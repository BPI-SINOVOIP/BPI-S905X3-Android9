From 247dd808650ec130a15f28263c24a705be428f0a Mon Sep 17 00:00:00 2001
From: Ajay Panicker <apanicke@google.com>
Date: Tue, 15 May 2018 14:51:02 -0700
Subject: [PATCH] Remove the old AVRCP code

Bug: 109883208
Test: Compile and sanity check AVRCP by connecting to headset
Change-Id: Iedaae7342032e9b3d42a59c3b3ec15c078ed0e5a
---

diff --git a/jni/Android.bp b/jni/Android.bp
index c0fdd80..cbbbe51 100644
--- a/jni/Android.bp
+++ b/jni/Android.bp
@@ -8,7 +8,6 @@
         "com_android_bluetooth_hfpclient.cpp",
         "com_android_bluetooth_a2dp.cpp",
         "com_android_bluetooth_a2dp_sink.cpp",
-        "com_android_bluetooth_avrcp.cpp",
         "com_android_bluetooth_avrcp_controller.cpp",
         "com_android_bluetooth_avrcp_target.cpp",
         "com_android_bluetooth_hid_host.cpp",
diff --git a/jni/com_android_bluetooth_avrcp.cpp b/jni/com_android_bluetooth_avrcp.cpp
deleted file mode 100644
index 1eb3553..0000000
--- a/jni/com_android_bluetooth_avrcp.cpp
+++ /dev/null
@@ -1,1529 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "BluetoothAvrcpServiceJni"
-
-#define LOG_NDEBUG 0
-
-#include "android_runtime/AndroidRuntime.h"
-#include "com_android_bluetooth.h"
-#include "hardware/bt_rc.h"
-#include "utils/Log.h"
-
-#include <inttypes.h>
-#include <string.h>
-
-namespace android {
-static jmethodID method_getRcFeatures;
-static jmethodID method_getPlayStatus;
-static jmethodID method_getElementAttr;
-static jmethodID method_registerNotification;
-static jmethodID method_volumeChangeCallback;
-static jmethodID method_handlePassthroughCmd;
-static jmethodID method_getFolderItemsCallback;
-static jmethodID method_setAddressedPlayerCallback;
-
-static jmethodID method_setBrowsedPlayerCallback;
-static jmethodID method_changePathCallback;
-static jmethodID method_searchCallback;
-static jmethodID method_playItemCallback;
-static jmethodID method_getItemAttrCallback;
-static jmethodID method_addToPlayListCallback;
-static jmethodID method_getTotalNumOfItemsCallback;
-
-static const btrc_interface_t* sBluetoothAvrcpInterface = NULL;
-static jobject mCallbacksObj = NULL;
-
-/* Function declarations */
-static bool copy_item_attributes(JNIEnv* env, jobject object,
-                                 btrc_folder_items_t* pitem,
-                                 jint* p_attributesIds,
-                                 jobjectArray attributesArray, int item_idx,
-                                 int attribCopiedIndex);
-
-static bool copy_jstring(uint8_t* str, int maxBytes, jstring jstr, JNIEnv* env);
-
-static void cleanup_items(btrc_folder_items_t* p_items, int numItems);
-
-static void btavrcp_remote_features_callback(const RawAddress& bd_addr,
-                                             btrc_remote_features_t features) {
-  CallbackEnv sCallbackEnv(__func__);
-  if (!sCallbackEnv.valid()) return;
-
-  if (!mCallbacksObj) {
-    ALOGE("%s: mCallbacksObj is null", __func__);
-    return;
-  }
-
-  ScopedLocalRef<jbyteArray> addr(
-      sCallbackEnv.get(), sCallbackEnv->NewByteArray(sizeof(RawAddress)));
-  if (!addr.get()) {
-    ALOGE("Unable to allocate byte array for bd_addr");
-    return;
-  }
-
-  sCallbackEnv->SetByteArrayRegion(addr.get(), 0, sizeof(RawAddress),
-                                   (jbyte*)bd_addr.address);
-  sCallbackEnv->CallVoidMethod(mCallbacksObj, method_getRcFeatures, addr.get(),
-                               (jint)features);
-}
-
-/** Callback for play status request */
-static void btavrcp_get_play_status_callback(const RawAddress& bd_addr) {
-  CallbackEnv sCallbackEnv(__func__);
-  if (!sCallbackEnv.valid()) return;
-
-  if (!mCallbacksObj) {
-    ALOGE("%s: mCallbacksObj is null", __func__);
-    return;
-  }
-
-  ScopedLocalRef<jbyteArray> addr(
-      sCallbackEnv.get(), sCallbackEnv->NewByteArray(sizeof(RawAddress)));
-  if (!addr.get()) {
-    ALOGE("Fail to new jbyteArray bd addr for get_play_status command");
-    return;
-  }
-
-  sCallbackEnv->SetByteArrayRegion(addr.get(), 0, sizeof(RawAddress),
-                                   (jbyte*)bd_addr.address);
-  sCallbackEnv->CallVoidMethod(mCallbacksObj, method_getPlayStatus, addr.get());
-}
-
-static void btavrcp_get_element_attr_callback(uint8_t num_attr,
-                                              btrc_media_attr_t* p_attrs,
-                                              const RawAddress& bd_addr) {
-  CallbackEnv sCallbackEnv(__func__);
-  if (!sCallbackEnv.valid()) return;
-
-  if (!mCallbacksObj) {
-    ALOGE("%s: mCallbacksObj is null", __func__);
-    return;
-  }
-
-  ScopedLocalRef<jbyteArray> addr(
-      sCallbackEnv.get(), sCallbackEnv->NewByteArray(sizeof(RawAddress)));
-  if (!addr.get()) {
-    ALOGE("Fail to new jbyteArray bd addr for get_element_attr command");
-    return;
-  }
-
-  ScopedLocalRef<jintArray> attrs(
-      sCallbackEnv.get(), (jintArray)sCallbackEnv->NewIntArray(num_attr));
-  if (!attrs.get()) {
-    ALOGE("Fail to new jintArray for attrs");
-    return;
-  }
-
-  sCallbackEnv->SetIntArrayRegion(attrs.get(), 0, num_attr, (jint*)p_attrs);
-
-  sCallbackEnv->SetByteArrayRegion(addr.get(), 0, sizeof(RawAddress),
-                                   (jbyte*)bd_addr.address);
-  sCallbackEnv->CallVoidMethod(mCallbacksObj, method_getElementAttr, addr.get(),
-                               (jbyte)num_attr, attrs.get());
-}
-
-static void btavrcp_register_notification_callback(btrc_event_id_t event_id,
-                                                   uint32_t param,
-                                                   const RawAddress& bd_addr) {
-  CallbackEnv sCallbackEnv(__func__);
-  if (!sCallbackEnv.valid()) return;
-
-  if (!mCallbacksObj) {
-    ALOGE("%s: mCallbacksObj is null", __func__);
-    return;
-  }
-
-  ScopedLocalRef<jbyteArray> addr(
-      sCallbackEnv.get(), sCallbackEnv->NewByteArray(sizeof(RawAddress)));
-  if (!addr.get()) {
-    ALOGE("Fail to new jbyteArray bd addr for register_notification command");
-    return;
-  }
-
-  sCallbackEnv->SetByteArrayRegion(addr.get(), 0, sizeof(RawAddress),
-                                   (jbyte*)bd_addr.address);
-  sCallbackEnv->CallVoidMethod(mCallbacksObj, method_registerNotification,
-                               addr.get(), (jint)event_id, (jint)param);
-}
-
-static void btavrcp_volume_change_callback(uint8_t volume, uint8_t ctype,
-                                           const RawAddress& bd_addr) {
-  CallbackEnv sCallbackEnv(__func__);
-  if (!sCallbackEnv.valid()) return;
-
-  if (!mCallbacksObj) {
-    ALOGE("%s: mCallbacksObj is null", __func__);
-    return;
-  }
-
-  ScopedLocalRef<jbyteArray> addr(
-      sCallbackEnv.get(), sCallbackEnv->NewByteArray(sizeof(RawAddress)));
-  if (!addr.get()) {
-    ALOGE("Fail to new jbyteArray bd addr for volume_change command");
-    return;
-  }
-
-  sCallbackEnv->SetByteArrayRegion(addr.get(), 0, sizeof(RawAddress),
-                                   (jbyte*)bd_addr.address);
-
-  sCallbackEnv->CallVoidMethod(mCallbacksObj, method_volumeChangeCallback,
-                               addr.get(), (jint)volume, (jint)ctype);
-}
-
-static void btavrcp_passthrough_command_callback(int id, int pressed,
-                                                 const RawAddress& bd_addr) {
-  CallbackEnv sCallbackEnv(__func__);
-  if (!sCallbackEnv.valid()) return;
-
-  if (!mCallbacksObj) {
-    ALOGE("%s: mCallbacksObj is null", __func__);
-    return;
-  }
-
-  ScopedLocalRef<jbyteArray> addr(
-      sCallbackEnv.get(), sCallbackEnv->NewByteArray(sizeof(RawAddress)));
-  if (!addr.get()) {
-    ALOGE("Fail to new jbyteArray bd addr for passthrough_command command");
-    return;
-  }
-  sCallbackEnv->SetByteArrayRegion(addr.get(), 0, sizeof(RawAddress),
-                                   (jbyte*)bd_addr.address);
-
-  sCallbackEnv->CallVoidMethod(mCallbacksObj, method_handlePassthroughCmd,
-                               addr.get(), (jint)id, (jint)pressed);
-}
-
-static void btavrcp_set_addressed_player_callback(uint16_t player_id,
-                                                  const RawAddress& bd_addr) {
-  CallbackEnv sCallbackEnv(__func__);
-  if (!sCallbackEnv.valid()) return;
-
-  if (!mCallbacksObj) {
-    ALOGE("%s: mCallbacksObj is null", __func__);
-    return;
-  }
-
-  ScopedLocalRef<jbyteArray> addr(
-      sCallbackEnv.get(), sCallbackEnv->NewByteArray(sizeof(RawAddress)));
-  if (!addr.get()) {
-    ALOGE("Fail to new jbyteArray bd addr for set_addressed_player command");
-    return;
-  }
-
-  sCallbackEnv->SetByteArrayRegion(addr.get(), 0, sizeof(RawAddress),
-                                   (jbyte*)bd_addr.address);
-  sCallbackEnv->CallVoidMethod(mCallbacksObj, method_setAddressedPlayerCallback,
-                               addr.get(), (jint)player_id);
-}
-
-static void btavrcp_set_browsed_player_callback(uint16_t player_id,
-                                                const RawAddress& bd_addr) {
-  CallbackEnv sCallbackEnv(__func__);
-  if (!sCallbackEnv.valid()) return;
-  if (!mCallbacksObj) {
-    ALOGE("%s: mCallbacksObj is null", __func__);
-    return;
-  }
-
-  ScopedLocalRef<jbyteArray> addr(
-      sCallbackEnv.get(), sCallbackEnv->NewByteArray(sizeof(RawAddress)));
-  if (!addr.get()) {
-    ALOGE("Fail to new jbyteArray bd addr for set_browsed_player command");
-    return;
-  }
-  sCallbackEnv->SetByteArrayRegion(addr.get(), 0, sizeof(RawAddress),
-                                   (jbyte*)bd_addr.address);
-
-  sCallbackEnv->CallVoidMethod(mCallbacksObj, method_setBrowsedPlayerCallback,
-                               addr.get(), (jint)player_id);
-}
-
-static void btavrcp_get_folder_items_callback(
-    uint8_t scope, uint32_t start_item, uint32_t end_item, uint8_t num_attr,
-    uint32_t* p_attr_ids, const RawAddress& bd_addr) {
-  CallbackEnv sCallbackEnv(__func__);
-  if (!sCallbackEnv.valid()) return;
-
-  if (!mCallbacksObj) {
-    ALOGE("%s: mCallbacksObj is null", __func__);
-    return;
-  }
-
-  ScopedLocalRef<jbyteArray> addr(
-      sCallbackEnv.get(), sCallbackEnv->NewByteArray(sizeof(RawAddress)));
-  if (!addr.get()) {
-    ALOGE("Fail to new jbyteArray bd addr for get_folder_items command");
-    return;
-  }
-
-  uint32_t* puiAttr = (uint32_t*)p_attr_ids;
-  ScopedLocalRef<jintArray> attr_ids(sCallbackEnv.get(), NULL);
-  sCallbackEnv->SetByteArrayRegion(addr.get(), 0, sizeof(RawAddress),
-                                   (jbyte*)bd_addr.address);
-
-  /* check number of attributes requested by remote device */
-  if ((num_attr != BTRC_NUM_ATTR_ALL) && (num_attr != BTRC_NUM_ATTR_NONE)) {
-    /* allocate memory for attr_ids only if some attributes passed from below
-     * layer */
-    attr_ids.reset((jintArray)sCallbackEnv->NewIntArray(num_attr));
-    if (!attr_ids.get()) {
-      ALOGE("Fail to allocate new jintArray for attrs");
-      return;
-    }
-    sCallbackEnv->SetIntArrayRegion(attr_ids.get(), 0, num_attr,
-                                    (jint*)puiAttr);
-  }
-
-  sCallbackEnv->CallVoidMethod(
-      mCallbacksObj, method_getFolderItemsCallback, addr.get(), (jbyte)scope,
-      (jlong)start_item, (jlong)end_item, (jbyte)num_attr, attr_ids.get());
-}
-
-static void btavrcp_change_path_callback(uint8_t direction, uint8_t* folder_uid,
-                                         const RawAddress& bd_addr) {
-  CallbackEnv sCallbackEnv(__func__);
-  if (!sCallbackEnv.valid()) return;
-
-  if (!mCallbacksObj) {
-    ALOGE("%s: mCallbacksObj is null", __func__);
-    return;
-  }
-
-  ScopedLocalRef<jbyteArray> attrs(sCallbackEnv.get(),
-                                   sCallbackEnv->NewByteArray(BTRC_UID_SIZE));
-  if (!attrs.get()) {
-    ALOGE("Fail to new jintArray for attrs");
-    return;
-  }
-
-  ScopedLocalRef<jbyteArray> addr(
-      sCallbackEnv.get(), sCallbackEnv->NewByteArray(sizeof(RawAddress)));
-  if (!addr.get()) {
-    ALOGE("Fail to new jbyteArray bd addr for change_path command");
-    return;
-  }
-
-  sCallbackEnv->SetByteArrayRegion(addr.get(), 0, sizeof(RawAddress),
-                                   (jbyte*)bd_addr.address);
-  sCallbackEnv->SetByteArrayRegion(
-      attrs.get(), 0, sizeof(uint8_t) * BTRC_UID_SIZE, (jbyte*)folder_uid);
-  sCallbackEnv->CallVoidMethod(mCallbacksObj, method_changePathCallback,
-                               addr.get(), (jbyte)direction, attrs.get());
-}
-
-static void btavrcp_get_item_attr_callback(uint8_t scope, uint8_t* uid,
-                                           uint16_t uid_counter,
-                                           uint8_t num_attr,
-                                           btrc_media_attr_t* p_attrs,
-                                           const RawAddress& bd_addr) {
-  CallbackEnv sCallbackEnv(__func__);
-  if (!sCallbackEnv.valid()) return;
-
-  if (!mCallbacksObj) {
-    ALOGE("%s: mCallbacksObj is null", __func__);
-    return;
-  }
-
-  ScopedLocalRef<jbyteArray> attr_uid(
-      sCallbackEnv.get(), sCallbackEnv->NewByteArray(BTRC_UID_SIZE));
-  if (!attr_uid.get()) {
-    ALOGE("Fail to new jintArray for attr_uid");
-    return;
-  }
-
-  ScopedLocalRef<jbyteArray> addr(
-      sCallbackEnv.get(), sCallbackEnv->NewByteArray(sizeof(RawAddress)));
-  if (!addr.get()) {
-    ALOGE("Fail to new jbyteArray bd addr for get_item_attr command");
-    return;
-  }
-
-  ScopedLocalRef<jintArray> attrs(
-      sCallbackEnv.get(), (jintArray)sCallbackEnv->NewIntArray(num_attr));
-  if (!attrs.get()) {
-    ALOGE("Fail to new jintArray for attrs");
-    return;
-  }
-
-  sCallbackEnv->SetByteArrayRegion(addr.get(), 0, sizeof(RawAddress),
-                                   (jbyte*)bd_addr.address);
-  sCallbackEnv->SetIntArrayRegion(attrs.get(), 0, num_attr, (jint*)p_attrs);
-  sCallbackEnv->SetByteArrayRegion(
-      attr_uid.get(), 0, sizeof(uint8_t) * BTRC_UID_SIZE, (jbyte*)uid);
-
-  sCallbackEnv->CallVoidMethod(mCallbacksObj, method_getItemAttrCallback,
-                               addr.get(), (jbyte)scope, attr_uid.get(),
-                               (jint)uid_counter, (jbyte)num_attr, attrs.get());
-}
-
-static void btavrcp_play_item_callback(uint8_t scope, uint16_t uid_counter,
-                                       uint8_t* uid,
-                                       const RawAddress& bd_addr) {
-  CallbackEnv sCallbackEnv(__func__);
-  if (!sCallbackEnv.valid()) return;
-  if (!mCallbacksObj) {
-    ALOGE("%s: mCallbacksObj is null", __func__);
-    return;
-  }
-
-  ScopedLocalRef<jbyteArray> attrs(sCallbackEnv.get(),
-                                   sCallbackEnv->NewByteArray(BTRC_UID_SIZE));
-  if (!attrs.get()) {
-    ALOGE("%s: Fail to new jByteArray attrs for play_item command", __func__);
-    return;
-  }
-
-  ScopedLocalRef<jbyteArray> addr(
-      sCallbackEnv.get(), sCallbackEnv->NewByteArray(sizeof(RawAddress)));
-  if (!addr.get()) {
-    ALOGE("Fail to new jbyteArray bd addr for play_item command");
-    return;
-  }
-
-  sCallbackEnv->SetByteArrayRegion(addr.get(), 0, sizeof(RawAddress),
-                                   (jbyte*)bd_addr.address);
-  sCallbackEnv->SetByteArrayRegion(
-      attrs.get(), 0, sizeof(uint8_t) * BTRC_UID_SIZE, (jbyte*)uid);
-  sCallbackEnv->CallVoidMethod(mCallbacksObj, method_playItemCallback,
-                               addr.get(), (jbyte)scope, (jint)uid_counter,
-                               attrs.get());
-}
-
-static void btavrcp_get_total_num_items_callback(uint8_t scope,
-                                                 const RawAddress& bd_addr) {
-  CallbackEnv sCallbackEnv(__func__);
-  if (!sCallbackEnv.valid()) return;
-  if (!mCallbacksObj) {
-    ALOGE("%s: mCallbacksObj is null", __func__);
-    return;
-  }
-
-  ScopedLocalRef<jbyteArray> addr(
-      sCallbackEnv.get(), sCallbackEnv->NewByteArray(sizeof(RawAddress)));
-  if (!addr.get()) {
-    ALOGE("Fail to new jbyteArray bd addr for get_total_num_items command");
-    return;
-  }
-
-  sCallbackEnv->SetByteArrayRegion(addr.get(), 0, sizeof(RawAddress),
-                                   (jbyte*)bd_addr.address);
-  sCallbackEnv->CallVoidMethod(mCallbacksObj, method_getTotalNumOfItemsCallback,
-                               addr.get(), (jbyte)scope);
-}
-
-static void btavrcp_search_callback(uint16_t charset_id, uint16_t str_len,
-                                    uint8_t* p_str, const RawAddress& bd_addr) {
-  CallbackEnv sCallbackEnv(__func__);
-  if (!sCallbackEnv.valid()) return;
-  if (!mCallbacksObj) {
-    ALOGE("%s: mCallbacksObj is null", __func__);
-    return;
-  }
-
-  ScopedLocalRef<jbyteArray> attrs(sCallbackEnv.get(),
-                                   sCallbackEnv->NewByteArray(str_len));
-  if (!attrs.get()) {
-    ALOGE("Fail to new jintArray for attrs");
-    return;
-  }
-
-  ScopedLocalRef<jbyteArray> addr(
-      sCallbackEnv.get(), sCallbackEnv->NewByteArray(sizeof(RawAddress)));
-  if (!addr.get()) {
-    ALOGE("Fail to new jbyteArray bd addr for search command");
-    return;
-  }
-
-  sCallbackEnv->SetByteArrayRegion(addr.get(), 0, sizeof(RawAddress),
-                                   (jbyte*)bd_addr.address);
-  sCallbackEnv->SetByteArrayRegion(attrs.get(), 0, str_len * sizeof(uint8_t),
-                                   (jbyte*)p_str);
-  sCallbackEnv->CallVoidMethod(mCallbacksObj, method_searchCallback, addr.get(),
-                               (jint)charset_id, attrs.get());
-}
-
-static void btavrcp_add_to_play_list_callback(uint8_t scope, uint8_t* uid,
-                                              uint16_t uid_counter,
-                                              const RawAddress& bd_addr) {
-  CallbackEnv sCallbackEnv(__func__);
-  if (!sCallbackEnv.valid()) return;
-  if (!mCallbacksObj) {
-    ALOGE("%s: mCallbacksObj is null", __func__);
-    return;
-  }
-
-  ScopedLocalRef<jbyteArray> addr(
-      sCallbackEnv.get(), sCallbackEnv->NewByteArray(sizeof(RawAddress)));
-  if (!addr.get()) {
-    ALOGE("Fail to new jbyteArray bd addr for add_to_play_list command");
-    return;
-  }
-
-  ScopedLocalRef<jbyteArray> attrs(sCallbackEnv.get(),
-                                   sCallbackEnv->NewByteArray(BTRC_UID_SIZE));
-  if (!attrs.get()) {
-    ALOGE("Fail to new jByteArray for attrs");
-    return;
-  }
-
-  sCallbackEnv->SetByteArrayRegion(addr.get(), 0, sizeof(RawAddress),
-                                   (jbyte*)bd_addr.address);
-  sCallbackEnv->SetByteArrayRegion(
-      attrs.get(), 0, sizeof(uint8_t) * BTRC_UID_SIZE, (jbyte*)uid);
-  sCallbackEnv->CallVoidMethod(mCallbacksObj, method_addToPlayListCallback,
-                               addr.get(), (jbyte)scope, attrs.get(),
-                               (jint)uid_counter);
-}
-
-static btrc_callbacks_t sBluetoothAvrcpCallbacks = {
-    sizeof(sBluetoothAvrcpCallbacks),
-    btavrcp_remote_features_callback,
-    btavrcp_get_play_status_callback,
-    NULL,
-    NULL,
-    NULL,
-    NULL,
-    NULL,
-    NULL,
-    btavrcp_get_element_attr_callback,
-    btavrcp_register_notification_callback,
-    btavrcp_volume_change_callback,
-    btavrcp_passthrough_command_callback,
-    btavrcp_set_addressed_player_callback,
-    btavrcp_set_browsed_player_callback,
-    btavrcp_get_folder_items_callback,
-    btavrcp_change_path_callback,
-    btavrcp_get_item_attr_callback,
-    btavrcp_play_item_callback,
-    btavrcp_get_total_num_items_callback,
-    btavrcp_search_callback,
-    btavrcp_add_to_play_list_callback,
-};
-
-static void classInitNative(JNIEnv* env, jclass clazz) {
-  method_getRcFeatures =
-      env->GetMethodID(clazz, "getRcFeaturesRequestFromNative", "([BI)V");
-  method_getPlayStatus =
-      env->GetMethodID(clazz, "getPlayStatusRequestFromNative", "([B)V");
-
-  method_getElementAttr =
-      env->GetMethodID(clazz, "getElementAttrRequestFromNative", "([BB[I)V");
-
-  method_registerNotification = env->GetMethodID(
-      clazz, "registerNotificationRequestFromNative", "([BII)V");
-
-  method_volumeChangeCallback =
-      env->GetMethodID(clazz, "volumeChangeRequestFromNative", "([BII)V");
-
-  method_handlePassthroughCmd = env->GetMethodID(
-      clazz, "handlePassthroughCmdRequestFromNative", "([BII)V");
-
-  method_setAddressedPlayerCallback =
-      env->GetMethodID(clazz, "setAddressedPlayerRequestFromNative", "([BI)V");
-
-  method_setBrowsedPlayerCallback =
-      env->GetMethodID(clazz, "setBrowsedPlayerRequestFromNative", "([BI)V");
-
-  method_getFolderItemsCallback =
-      env->GetMethodID(clazz, "getFolderItemsRequestFromNative", "([BBJJB[I)V");
-
-  method_changePathCallback =
-      env->GetMethodID(clazz, "changePathRequestFromNative", "([BB[B)V");
-
-  method_getItemAttrCallback =
-      env->GetMethodID(clazz, "getItemAttrRequestFromNative", "([BB[BIB[I)V");
-
-  method_playItemCallback =
-      env->GetMethodID(clazz, "playItemRequestFromNative", "([BBI[B)V");
-
-  method_getTotalNumOfItemsCallback =
-      env->GetMethodID(clazz, "getTotalNumOfItemsRequestFromNative", "([BB)V");
-
-  method_searchCallback =
-      env->GetMethodID(clazz, "searchRequestFromNative", "([BI[B)V");
-
-  method_addToPlayListCallback =
-      env->GetMethodID(clazz, "addToPlayListRequestFromNative", "([BB[BI)V");
-
-  ALOGI("%s: succeeds", __func__);
-}
-
-static void initNative(JNIEnv* env, jobject object) {
-  const bt_interface_t* btInf = getBluetoothInterface();
-  if (btInf == NULL) {
-    ALOGE("Bluetooth module is not loaded");
-    return;
-  }
-
-  if (sBluetoothAvrcpInterface != NULL) {
-    ALOGW("Cleaning up Avrcp Interface before initializing...");
-    sBluetoothAvrcpInterface->cleanup();
-    sBluetoothAvrcpInterface = NULL;
-  }
-
-  if (mCallbacksObj != NULL) {
-    ALOGW("Cleaning up Avrcp callback object");
-    env->DeleteGlobalRef(mCallbacksObj);
-    mCallbacksObj = NULL;
-  }
-
-  sBluetoothAvrcpInterface =
-      (btrc_interface_t*)btInf->get_profile_interface(BT_PROFILE_AV_RC_ID);
-  if (sBluetoothAvrcpInterface == NULL) {
-    ALOGE("Failed to get Bluetooth Avrcp Interface");
-    return;
-  }
-
-  bt_status_t status =
-      sBluetoothAvrcpInterface->init(&sBluetoothAvrcpCallbacks);
-  if (status != BT_STATUS_SUCCESS) {
-    ALOGE("Failed to initialize Bluetooth Avrcp, status: %d", status);
-    sBluetoothAvrcpInterface = NULL;
-    return;
-  }
-
-  mCallbacksObj = env->NewGlobalRef(object);
-}
-
-static void cleanupNative(JNIEnv* env, jobject object) {
-  const bt_interface_t* btInf = getBluetoothInterface();
-  if (btInf == NULL) {
-    ALOGE("Bluetooth module is not loaded");
-    return;
-  }
-
-  if (sBluetoothAvrcpInterface != NULL) {
-    sBluetoothAvrcpInterface->cleanup();
-    sBluetoothAvrcpInterface = NULL;
-  }
-
-  if (mCallbacksObj != NULL) {
-    env->DeleteGlobalRef(mCallbacksObj);
-    mCallbacksObj = NULL;
-  }
-}
-
-static jboolean getPlayStatusRspNative(JNIEnv* env, jobject object,
-                                       jbyteArray address, jint playStatus,
-                                       jint songLen, jint songPos) {
-  if (!sBluetoothAvrcpInterface) {
-    ALOGE("%s: sBluetoothAvrcpInterface is null", __func__);
-    return JNI_FALSE;
-  }
-
-  jbyte* addr = env->GetByteArrayElements(address, NULL);
-  if (!addr) {
-    jniThrowIOException(env, EINVAL);
-    return JNI_FALSE;
-  }
-  RawAddress rawAddress;
-  rawAddress.FromOctets((uint8_t*)addr);
-
-  bt_status_t status = sBluetoothAvrcpInterface->get_play_status_rsp(
-      rawAddress, (btrc_play_status_t)playStatus, songLen, songPos);
-  if (status != BT_STATUS_SUCCESS) {
-    ALOGE("Failed get_play_status_rsp, status: %d", status);
-  }
-  env->ReleaseByteArrayElements(address, addr, 0);
-  return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
-}
-
-static jboolean getElementAttrRspNative(JNIEnv* env, jobject object,
-                                        jbyteArray address, jbyte numAttr,
-                                        jintArray attrIds,
-                                        jobjectArray textArray) {
-  if (!sBluetoothAvrcpInterface) {
-    ALOGE("%s: sBluetoothAvrcpInterface is null", __func__);
-    return JNI_FALSE;
-  }
-
-  if (numAttr > BTRC_MAX_ELEM_ATTR_SIZE) {
-    ALOGE("get_element_attr_rsp: number of attributes exceed maximum");
-    return JNI_FALSE;
-  }
-
-  jbyte* addr = env->GetByteArrayElements(address, NULL);
-  if (!addr) {
-    jniThrowIOException(env, EINVAL);
-    return JNI_FALSE;
-  }
-
-  btrc_element_attr_val_t* pAttrs = new btrc_element_attr_val_t[numAttr];
-  if (!pAttrs) {
-    ALOGE("get_element_attr_rsp: not have enough memeory");
-    env->ReleaseByteArrayElements(address, addr, 0);
-    return JNI_FALSE;
-  }
-
-  jint* attr = env->GetIntArrayElements(attrIds, NULL);
-  if (!attr) {
-    delete[] pAttrs;
-    jniThrowIOException(env, EINVAL);
-    env->ReleaseByteArrayElements(address, addr, 0);
-    return JNI_FALSE;
-  }
-
-  int attr_cnt;
-  for (attr_cnt = 0; attr_cnt < numAttr; ++attr_cnt) {
-    pAttrs[attr_cnt].attr_id = attr[attr_cnt];
-    ScopedLocalRef<jstring> text(
-        env, (jstring)env->GetObjectArrayElement(textArray, attr_cnt));
-
-    if (!copy_jstring(pAttrs[attr_cnt].text, BTRC_MAX_ATTR_STR_LEN, text.get(),
-                      env)) {
-      break;
-    }
-  }
-
-  if (attr_cnt < numAttr) {
-    delete[] pAttrs;
-    env->ReleaseIntArrayElements(attrIds, attr, 0);
-    ALOGE("%s: Failed to copy attributes", __func__);
-    return JNI_FALSE;
-  }
-
-  RawAddress rawAddress;
-  rawAddress.FromOctets((uint8_t*)addr);
-  bt_status_t status = sBluetoothAvrcpInterface->get_element_attr_rsp(
-      rawAddress, numAttr, pAttrs);
-  if (status != BT_STATUS_SUCCESS) {
-    ALOGE("Failed get_element_attr_rsp, status: %d", status);
-  }
-
-  delete[] pAttrs;
-  env->ReleaseIntArrayElements(attrIds, attr, 0);
-  env->ReleaseByteArrayElements(address, addr, 0);
-  return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
-}
-
-static jboolean getItemAttrRspNative(JNIEnv* env, jobject object,
-                                     jbyteArray address, jint rspStatus,
-                                     jbyte numAttr, jintArray attrIds,
-                                     jobjectArray textArray) {
-  if (!sBluetoothAvrcpInterface) {
-    ALOGE("%s: sBluetoothAvrcpInterface is null", __func__);
-    return JNI_FALSE;
-  }
-
-  jbyte* addr = env->GetByteArrayElements(address, NULL);
-  if (!addr) {
-    jniThrowIOException(env, EINVAL);
-    return JNI_FALSE;
-  }
-
-  if (numAttr > BTRC_MAX_ELEM_ATTR_SIZE) {
-    ALOGE("get_element_attr_rsp: number of attributes exceed maximum");
-    return JNI_FALSE;
-  }
-
-  btrc_element_attr_val_t* pAttrs = new btrc_element_attr_val_t[numAttr];
-  if (!pAttrs) {
-    ALOGE("%s: not have enough memory", __func__);
-    env->ReleaseByteArrayElements(address, addr, 0);
-    return JNI_FALSE;
-  }
-
-  jint* attr = NULL;
-  if (attrIds != NULL) {
-    attr = env->GetIntArrayElements(attrIds, NULL);
-    if (!attr) {
-      delete[] pAttrs;
-      jniThrowIOException(env, EINVAL);
-      env->ReleaseByteArrayElements(address, addr, 0);
-      return JNI_FALSE;
-    }
-  }
-
-  for (int attr_cnt = 0; attr_cnt < numAttr; ++attr_cnt) {
-    pAttrs[attr_cnt].attr_id = attr[attr_cnt];
-    ScopedLocalRef<jstring> text(
-        env, (jstring)env->GetObjectArrayElement(textArray, attr_cnt));
-
-    if (!copy_jstring(pAttrs[attr_cnt].text, BTRC_MAX_ATTR_STR_LEN, text.get(),
-                      env)) {
-      rspStatus = BTRC_STS_INTERNAL_ERR;
-      ALOGE("%s: Failed to copy attributes", __func__);
-      break;
-    }
-  }
-  RawAddress rawAddress;
-  rawAddress.FromOctets((uint8_t*)addr);
-
-  bt_status_t status = sBluetoothAvrcpInterface->get_item_attr_rsp(
-      rawAddress, (btrc_status_t)rspStatus, numAttr, pAttrs);
-  if (status != BT_STATUS_SUCCESS)
-    ALOGE("Failed get_item_attr_rsp, status: %d", status);
-
-  if (pAttrs) delete[] pAttrs;
-  if (attr) env->ReleaseIntArrayElements(attrIds, attr, 0);
-  env->ReleaseByteArrayElements(address, addr, 0);
-
-  return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
-}
-
-static jboolean registerNotificationRspPlayStatusNative(JNIEnv* env,
-                                                        jobject object,
-                                                        jint type,
-                                                        jint playStatus) {
-  if (!sBluetoothAvrcpInterface) {
-    ALOGE("%s: sBluetoothAvrcpInterface is null", __func__);
-    return JNI_FALSE;
-  }
-
-  btrc_register_notification_t param;
-  param.play_status = (btrc_play_status_t)playStatus;
-
-  bt_status_t status = sBluetoothAvrcpInterface->register_notification_rsp(
-      BTRC_EVT_PLAY_STATUS_CHANGED, (btrc_notification_type_t)type, &param);
-  if (status != BT_STATUS_SUCCESS) {
-    ALOGE("Failed register_notification_rsp play status, status: %d", status);
-  }
-
-  return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
-}
-
-static jboolean registerNotificationRspTrackChangeNative(JNIEnv* env,
-                                                         jobject object,
-                                                         jint type,
-                                                         jbyteArray track) {
-  if (!sBluetoothAvrcpInterface) {
-    ALOGE("%s: sBluetoothAvrcpInterface is null", __func__);
-    return JNI_FALSE;
-  }
-
-  jbyte* trk = env->GetByteArrayElements(track, NULL);
-  if (!trk) {
-    jniThrowIOException(env, EINVAL);
-    return JNI_FALSE;
-  }
-
-  btrc_register_notification_t param;
-  uint64_t uid = 0;
-  for (int uid_idx = 0; uid_idx < BTRC_UID_SIZE; ++uid_idx) {
-    param.track[uid_idx] = trk[uid_idx];
-    uid = uid + (trk[uid_idx] << (BTRC_UID_SIZE - 1 - uid_idx));
-  }
-
-  ALOGV("%s: Sending track change notification: %d -> %" PRIu64, __func__, type,
-        uid);
-
-  bt_status_t status = sBluetoothAvrcpInterface->register_notification_rsp(
-      BTRC_EVT_TRACK_CHANGE, (btrc_notification_type_t)type, &param);
-  if (status != BT_STATUS_SUCCESS) {
-    ALOGE("Failed register_notification_rsp track change, status: %d", status);
-  }
-
-  env->ReleaseByteArrayElements(track, trk, 0);
-  return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
-}
-
-static jboolean registerNotificationRspPlayPosNative(JNIEnv* env,
-                                                     jobject object, jint type,
-                                                     jint playPos) {
-  if (!sBluetoothAvrcpInterface) {
-    ALOGE("%s: sBluetoothAvrcpInterface is null", __func__);
-    return JNI_FALSE;
-  }
-
-  btrc_register_notification_t param;
-  param.song_pos = (uint32_t)playPos;
-
-  bt_status_t status = sBluetoothAvrcpInterface->register_notification_rsp(
-      BTRC_EVT_PLAY_POS_CHANGED, (btrc_notification_type_t)type, &param);
-  if (status != BT_STATUS_SUCCESS) {
-    ALOGE("Failed register_notification_rsp play position, status: %d", status);
-  }
-
-  return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
-}
-
-static jboolean registerNotificationRspNowPlayingChangedNative(JNIEnv* env,
-                                                               jobject object,
-                                                               jint type) {
-  if (!sBluetoothAvrcpInterface) {
-    ALOGE("%s: sBluetoothAvrcpInterface is null", __func__);
-    return JNI_FALSE;
-  }
-
-  btrc_register_notification_t param;
-  bt_status_t status = sBluetoothAvrcpInterface->register_notification_rsp(
-      BTRC_EVT_NOW_PLAYING_CONTENT_CHANGED, (btrc_notification_type_t)type,
-      &param);
-  if (status != BT_STATUS_SUCCESS) {
-    ALOGE("Failed register_notification_rsp, nowPlaying Content status: %d",
-          status);
-  }
-  return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
-}
-
-static jboolean registerNotificationRspUIDsChangedNative(JNIEnv* env,
-                                                         jobject object,
-                                                         jint type,
-                                                         jint uidCounter) {
-  if (!sBluetoothAvrcpInterface) {
-    ALOGE("%s: sBluetoothAvrcpInterface is null", __func__);
-    return JNI_FALSE;
-  }
-
-  btrc_register_notification_t param;
-  param.uids_changed.uid_counter = (uint16_t)uidCounter;
-
-  bt_status_t status = sBluetoothAvrcpInterface->register_notification_rsp(
-      BTRC_EVT_UIDS_CHANGED, (btrc_notification_type_t)type, &param);
-  if (status != BT_STATUS_SUCCESS) {
-    ALOGE("Failed register_notification_rsp, uids changed status: %d", status);
-  }
-
-  return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
-}
-
-static jboolean registerNotificationRspAddrPlayerChangedNative(
-    JNIEnv* env, jobject object, jint type, jint playerId, jint uidCounter) {
-  if (!sBluetoothAvrcpInterface) {
-    ALOGE("%s: sBluetoothAvrcpInterface is null", __func__);
-    return JNI_FALSE;
-  }
-
-  btrc_register_notification_t param;
-  param.addr_player_changed.player_id = (uint16_t)playerId;
-  param.addr_player_changed.uid_counter = (uint16_t)uidCounter;
-
-  bt_status_t status = sBluetoothAvrcpInterface->register_notification_rsp(
-      BTRC_EVT_ADDR_PLAYER_CHANGE, (btrc_notification_type_t)type, &param);
-  if (status != BT_STATUS_SUCCESS) {
-    ALOGE("Failed register_notification_rsp address player changed status: %d",
-          status);
-  }
-
-  return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
-}
-
-static jboolean registerNotificationRspAvalPlayerChangedNative(JNIEnv* env,
-                                                               jobject object,
-                                                               jint type) {
-  if (!sBluetoothAvrcpInterface) {
-    ALOGE("%s: sBluetoothAvrcpInterface is null", __func__);
-    return JNI_FALSE;
-  }
-
-  btrc_register_notification_t param;
-  bt_status_t status = sBluetoothAvrcpInterface->register_notification_rsp(
-      BTRC_EVT_AVAL_PLAYER_CHANGE, (btrc_notification_type_t)type, &param);
-  if (status != BT_STATUS_SUCCESS) {
-    ALOGE(
-        "Failed register_notification_rsp available player changed status, "
-        "status: %d",
-        status);
-  }
-
-  return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
-}
-
-static jboolean setVolumeNative(JNIEnv* env, jobject object, jint volume) {
-  if (!sBluetoothAvrcpInterface) {
-    ALOGE("%s: sBluetoothAvrcpInterface is null", __func__);
-    return JNI_FALSE;
-  }
-
-  bt_status_t status = sBluetoothAvrcpInterface->set_volume((uint8_t)volume);
-  if (status != BT_STATUS_SUCCESS) {
-    ALOGE("Failed set_volume, status: %d", status);
-  }
-
-  return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
-}
-
-/* native response for scope as Media player */
-static jboolean mediaPlayerListRspNative(
-    JNIEnv* env, jobject object, jbyteArray address, jint rspStatus,
-    jint uidCounter, jbyte itemType, jint numItems, jintArray playerIds,
-    jbyteArray playerTypes, jintArray playerSubtypes,
-    jbyteArray playStatusValues, jshortArray featureBitmask,
-    jobjectArray textArray) {
-  if (!sBluetoothAvrcpInterface) {
-    ALOGE("%s: sBluetoothAvrcpInterface is null", __func__);
-    return JNI_FALSE;
-  }
-
-  jbyte* addr = env->GetByteArrayElements(address, NULL);
-  if (!addr) {
-    jniThrowIOException(env, EINVAL);
-    return JNI_FALSE;
-  }
-
-  jbyte *p_playerTypes = NULL, *p_PlayStatusValues = NULL;
-  jshort* p_FeatBitMaskValues = NULL;
-  jint *p_playerIds = NULL, *p_playerSubTypes = NULL;
-  btrc_folder_items_t* p_items = NULL;
-  if (rspStatus == BTRC_STS_NO_ERROR) {
-    /* allocate memory */
-    p_playerIds = env->GetIntArrayElements(playerIds, NULL);
-    p_playerTypes = env->GetByteArrayElements(playerTypes, NULL);
-    p_playerSubTypes = env->GetIntArrayElements(playerSubtypes, NULL);
-    p_PlayStatusValues = env->GetByteArrayElements(playStatusValues, NULL);
-    p_FeatBitMaskValues = env->GetShortArrayElements(featureBitmask, NULL);
-    p_items = new btrc_folder_items_t[numItems];
-    /* deallocate memory and return if allocation failed */
-    if (!p_playerIds || !p_playerTypes || !p_playerSubTypes ||
-        !p_PlayStatusValues || !p_FeatBitMaskValues || !p_items) {
-      if (p_playerIds) env->ReleaseIntArrayElements(playerIds, p_playerIds, 0);
-      if (p_playerTypes)
-        env->ReleaseByteArrayElements(playerTypes, p_playerTypes, 0);
-      if (p_playerSubTypes)
-        env->ReleaseIntArrayElements(playerSubtypes, p_playerSubTypes, 0);
-      if (p_PlayStatusValues)
-        env->ReleaseByteArrayElements(playStatusValues, p_PlayStatusValues, 0);
-      if (p_FeatBitMaskValues)
-        env->ReleaseShortArrayElements(featureBitmask, p_FeatBitMaskValues, 0);
-      if (p_items) delete[] p_items;
-
-      jniThrowIOException(env, EINVAL);
-      ALOGE("%s: not have enough memory", __func__);
-      return JNI_FALSE;
-    }
-
-    p_items->item_type = (uint8_t)itemType;
-
-    /* copy list of media players along with other parameters */
-    int itemIdx;
-    for (itemIdx = 0; itemIdx < numItems; ++itemIdx) {
-      p_items[itemIdx].player.player_id = p_playerIds[itemIdx];
-      p_items[itemIdx].player.major_type = p_playerTypes[itemIdx];
-      p_items[itemIdx].player.sub_type = p_playerSubTypes[itemIdx];
-      p_items[itemIdx].player.play_status = p_PlayStatusValues[itemIdx];
-      p_items[itemIdx].player.charset_id = BTRC_CHARSET_ID_UTF8;
-
-      ScopedLocalRef<jstring> text(
-          env, (jstring)env->GetObjectArrayElement(textArray, itemIdx));
-      /* copy player name */
-      if (!copy_jstring(p_items[itemIdx].player.name, BTRC_MAX_ATTR_STR_LEN,
-                        text.get(), env))
-        break;
-
-      /* Feature bit mask is 128-bit value each */
-      for (int InnCnt = 0; InnCnt < 16; InnCnt++) {
-        p_items[itemIdx].player.features[InnCnt] =
-            (uint8_t)p_FeatBitMaskValues[(itemIdx * 16) + InnCnt];
-      }
-    }
-
-    /* failed to copy list of media players */
-    if (itemIdx < numItems) {
-      rspStatus = BTRC_STS_INTERNAL_ERR;
-      ALOGE("%s: Failed to copy Media player attributes", __func__);
-    }
-  }
-
-  RawAddress* btAddr = (RawAddress*)addr;
-  bt_status_t status = sBluetoothAvrcpInterface->get_folder_items_list_rsp(
-      *btAddr, (btrc_status_t)rspStatus, uidCounter, numItems, p_items);
-  if (status != BT_STATUS_SUCCESS) {
-    ALOGE("Failed get_folder_items_list_rsp, status: %d", status);
-  }
-
-  /* release allocated memory */
-  if (p_items) delete[] p_items;
-  if (p_playerTypes)
-    env->ReleaseByteArrayElements(playerTypes, p_playerTypes, 0);
-  if (p_playerSubTypes)
-    env->ReleaseIntArrayElements(playerSubtypes, p_playerSubTypes, 0);
-  if (p_PlayStatusValues)
-    env->ReleaseByteArrayElements(playStatusValues, p_PlayStatusValues, 0);
-  if (p_FeatBitMaskValues) {
-    env->ReleaseShortArrayElements(featureBitmask, p_FeatBitMaskValues, 0);
-  }
-  env->ReleaseByteArrayElements(address, addr, 0);
-
-  return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
-}
-
-static jboolean getFolderItemsRspNative(
-    JNIEnv* env, jobject object, jbyteArray address, jint rspStatus,
-    jshort uidCounter, jbyte scope, jint numItems, jbyteArray folderType,
-    jbyteArray playable, jbyteArray itemType, jbyteArray itemUidArray,
-    jobjectArray displayNameArray, jintArray numAttrs, jintArray attributesIds,
-    jobjectArray attributesArray) {
-  if (!sBluetoothAvrcpInterface) {
-    ALOGE("%s: sBluetoothAvrcpInterface is null", __func__);
-    return JNI_FALSE;
-  }
-
-  jbyte* addr = env->GetByteArrayElements(address, NULL);
-  if (!addr) {
-    jniThrowIOException(env, EINVAL);
-    return JNI_FALSE;
-  }
-
-  jbyte *p_playable = NULL, *p_item_uid = NULL;
-  jbyte* p_item_types = NULL; /* Folder or Media Item */
-  jint* p_attributesIds = NULL;
-  jbyte* p_folder_types =
-      NULL; /* Folder properties like Album/Genre/Artists etc */
-  jint* p_num_attrs = NULL;
-  btrc_folder_items_t* p_items = NULL;
-  /* none of the parameters should be null when no error */
-  if (rspStatus == BTRC_STS_NO_ERROR) {
-    /* allocate memory to each rsp item */
-    if (folderType != NULL)
-      p_folder_types = env->GetByteArrayElements(folderType, NULL);
-    if (playable != NULL)
-      p_playable = env->GetByteArrayElements(playable, NULL);
-    if (itemType != NULL)
-      p_item_types = env->GetByteArrayElements(itemType, NULL);
-    if (NULL != numAttrs)
-      p_num_attrs = env->GetIntArrayElements(numAttrs, NULL);
-    if (NULL != attributesIds)
-      p_attributesIds = env->GetIntArrayElements(attributesIds, NULL);
-    if (itemUidArray != NULL)
-      p_item_uid = (jbyte*)env->GetByteArrayElements(itemUidArray, NULL);
-
-    p_items = new btrc_folder_items_t[numItems];
-
-    /* if memory alloc failed, release memory */
-    if (p_items && p_folder_types && p_playable && p_item_types && p_item_uid &&
-        /* attributes can be null if remote requests 0 attributes */
-        ((numAttrs != NULL && p_num_attrs) || (!numAttrs && !p_num_attrs)) &&
-        ((attributesIds != NULL && p_attributesIds) ||
-         (!attributesIds && !p_attributesIds))) {
-      memset(p_items, 0, sizeof(btrc_folder_items_t) * numItems);
-      if (scope == BTRC_SCOPE_FILE_SYSTEM || scope == BTRC_SCOPE_SEARCH ||
-          scope == BTRC_SCOPE_NOW_PLAYING) {
-        int attribCopiedIndex = 0;
-        for (int item_idx = 0; item_idx < numItems; item_idx++) {
-          if (BTRC_ITEM_FOLDER == p_item_types[item_idx]) {
-            btrc_folder_items_t* pitem = &p_items[item_idx];
-
-            memcpy(pitem->folder.uid, p_item_uid + item_idx * BTRC_UID_SIZE,
-                   BTRC_UID_SIZE);
-            pitem->item_type = (uint8_t)BTRC_ITEM_FOLDER;
-            pitem->folder.charset_id = BTRC_CHARSET_ID_UTF8;
-            pitem->folder.type = p_folder_types[item_idx];
-            pitem->folder.playable = p_playable[item_idx];
-
-            ScopedLocalRef<jstring> text(
-                env, (jstring)env->GetObjectArrayElement(displayNameArray,
-                                                         item_idx));
-            if (!copy_jstring(pitem->folder.name, BTRC_MAX_ATTR_STR_LEN,
-                              text.get(), env)) {
-              rspStatus = BTRC_STS_INTERNAL_ERR;
-              ALOGE("%s: failed to copy display name of folder item", __func__);
-              break;
-            }
-          } else if (BTRC_ITEM_MEDIA == p_item_types[item_idx]) {
-            btrc_folder_items_t* pitem = &p_items[item_idx];
-            memcpy(pitem->media.uid, p_item_uid + item_idx * BTRC_UID_SIZE,
-                   BTRC_UID_SIZE);
-
-            pitem->item_type = (uint8_t)BTRC_ITEM_MEDIA;
-            pitem->media.charset_id = BTRC_CHARSET_ID_UTF8;
-            pitem->media.type = BTRC_MEDIA_TYPE_AUDIO;
-            pitem->media.num_attrs =
-                (p_num_attrs != NULL) ? p_num_attrs[item_idx] : 0;
-
-            ScopedLocalRef<jstring> text(
-                env, (jstring)env->GetObjectArrayElement(displayNameArray,
-                                                         item_idx));
-            if (!copy_jstring(pitem->media.name, BTRC_MAX_ATTR_STR_LEN,
-                              text.get(), env)) {
-              rspStatus = BTRC_STS_INTERNAL_ERR;
-              ALOGE("%s: failed to copy display name of media item", __func__);
-              break;
-            }
-
-            /* copy item attributes */
-            if (!copy_item_attributes(env, object, pitem, p_attributesIds,
-                                      attributesArray, item_idx,
-                                      attribCopiedIndex)) {
-              ALOGE("%s: error in copying attributes of item = %s", __func__,
-                    pitem->media.name);
-              rspStatus = BTRC_STS_INTERNAL_ERR;
-              break;
-            }
-            attribCopiedIndex += pitem->media.num_attrs;
-          }
-        }
-      }
-    } else {
-      rspStatus = BTRC_STS_INTERNAL_ERR;
-      ALOGE("%s: unable to allocate memory", __func__);
-    }
-  }
-
-  RawAddress* btAddr = (RawAddress*)addr;
-  bt_status_t status = sBluetoothAvrcpInterface->get_folder_items_list_rsp(
-      *btAddr, (btrc_status_t)rspStatus, uidCounter, numItems, p_items);
-  if (status != BT_STATUS_SUCCESS)
-    ALOGE("Failed get_folder_items_list_rsp, status: %d", status);
-
-  /* Release allocated memory for all attributes in each media item */
-  if (p_items) cleanup_items(p_items, numItems);
-
-  /* Release allocated memory  */
-  if (p_folder_types)
-    env->ReleaseByteArrayElements(folderType, p_folder_types, 0);
-  if (p_playable) env->ReleaseByteArrayElements(playable, p_playable, 0);
-  if (p_item_types) env->ReleaseByteArrayElements(itemType, p_item_types, 0);
-  if (p_num_attrs) env->ReleaseIntArrayElements(numAttrs, p_num_attrs, 0);
-  if (p_attributesIds)
-    env->ReleaseIntArrayElements(attributesIds, p_attributesIds, 0);
-  if (p_item_uid) env->ReleaseByteArrayElements(itemUidArray, p_item_uid, 0);
-  if (p_items) delete[] p_items;
-  env->ReleaseByteArrayElements(address, addr, 0);
-
-  return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
-}
-
-static jboolean setAddressedPlayerRspNative(JNIEnv* env, jobject object,
-                                            jbyteArray address,
-                                            jint rspStatus) {
-  if (!sBluetoothAvrcpInterface) {
-    ALOGE("%s: sBluetoothAvrcpInterface is null", __func__);
-    return JNI_FALSE;
-  }
-
-  jbyte* addr = env->GetByteArrayElements(address, NULL);
-  if (!addr) {
-    jniThrowIOException(env, EINVAL);
-    return JNI_FALSE;
-  }
-
-  RawAddress* btAddr = (RawAddress*)addr;
-  bt_status_t status = sBluetoothAvrcpInterface->set_addressed_player_rsp(
-      *btAddr, (btrc_status_t)rspStatus);
-  if (status != BT_STATUS_SUCCESS) {
-    ALOGE("Failed set_addressed_player_rsp, status: %d", status);
-  }
-  env->ReleaseByteArrayElements(address, addr, 0);
-
-  return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
-}
-
-static jboolean setBrowsedPlayerRspNative(JNIEnv* env, jobject object,
-                                          jbyteArray address, jint rspStatus,
-                                          jbyte depth, jint numItems,
-                                          jobjectArray textArray) {
-  if (!sBluetoothAvrcpInterface) {
-    ALOGE("%s: sBluetoothAvrcpInterface is null", __func__);
-    return JNI_FALSE;
-  }
-
-  jbyte* addr = env->GetByteArrayElements(address, NULL);
-  if (!addr) {
-    jniThrowIOException(env, EINVAL);
-    return JNI_FALSE;
-  }
-
-  btrc_br_folder_name_t* p_folders = NULL;
-  if (rspStatus == BTRC_STS_NO_ERROR) {
-    if (depth > 0) {
-      p_folders = new btrc_br_folder_name_t[depth];
-    }
-
-    for (int folder_idx = 0; folder_idx < depth; folder_idx++) {
-      /* copy folder names */
-      ScopedLocalRef<jstring> text(
-          env, (jstring)env->GetObjectArrayElement(textArray, folder_idx));
-
-      if (!copy_jstring(p_folders[folder_idx].p_str, BTRC_MAX_ATTR_STR_LEN,
-                        text.get(), env)) {
-        rspStatus = BTRC_STS_INTERNAL_ERR;
-        delete[] p_folders;
-        env->ReleaseByteArrayElements(address, addr, 0);
-        ALOGE("%s: Failed to copy folder name", __func__);
-        return JNI_FALSE;
-      }
-
-      p_folders[folder_idx].str_len =
-          strlen((char*)p_folders[folder_idx].p_str);
-    }
-  }
-
-  uint8_t folder_depth =
-      depth; /* folder_depth is 0 if current folder is root */
-  uint16_t charset_id = BTRC_CHARSET_ID_UTF8;
-  RawAddress* btAddr = (RawAddress*)addr;
-  bt_status_t status = sBluetoothAvrcpInterface->set_browsed_player_rsp(
-      *btAddr, (btrc_status_t)rspStatus, numItems, charset_id, folder_depth,
-      p_folders);
-  if (status != BT_STATUS_SUCCESS) {
-    ALOGE("%s: Failed set_browsed_player_rsp, status: %d", __func__, status);
-  }
-
-  if (depth > 0) {
-    delete[] p_folders;
-  }
-
-  env->ReleaseByteArrayElements(address, addr, 0);
-  return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
-}
-
-static jboolean changePathRspNative(JNIEnv* env, jobject object,
-                                    jbyteArray address, jint rspStatus,
-                                    jint numItems) {
-  if (!sBluetoothAvrcpInterface) {
-    ALOGE("%s: sBluetoothAvrcpInterface is null", __func__);
-    return JNI_FALSE;
-  }
-
-  jbyte* addr = env->GetByteArrayElements(address, NULL);
-  if (!addr) {
-    jniThrowIOException(env, EINVAL);
-    return JNI_FALSE;
-  }
-
-  uint32_t nItems = (uint32_t)numItems;
-  RawAddress* btAddr = (RawAddress*)addr;
-  bt_status_t status = sBluetoothAvrcpInterface->change_path_rsp(
-      *btAddr, (btrc_status_t)rspStatus, (uint32_t)nItems);
-  if (status != BT_STATUS_SUCCESS) {
-    ALOGE("Failed change_path_rsp, status: %d", status);
-  }
-  env->ReleaseByteArrayElements(address, addr, 0);
-
-  return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
-}
-
-static jboolean searchRspNative(JNIEnv* env, jobject object, jbyteArray address,
-                                jint rspStatus, jint uidCounter,
-                                jint numItems) {
-  if (!sBluetoothAvrcpInterface) {
-    ALOGE("%s: sBluetoothAvrcpInterface is null", __func__);
-    return JNI_FALSE;
-  }
-
-  jbyte* addr = env->GetByteArrayElements(address, NULL);
-  if (!addr) {
-    jniThrowIOException(env, EINVAL);
-    return JNI_FALSE;
-  }
-
-  uint32_t nItems = (uint32_t)numItems;
-  RawAddress* btAddr = (RawAddress*)addr;
-  bt_status_t status = sBluetoothAvrcpInterface->search_rsp(
-      *btAddr, (btrc_status_t)rspStatus, (uint32_t)uidCounter,
-      (uint32_t)nItems);
-  if (status != BT_STATUS_SUCCESS) {
-    ALOGE("Failed search_rsp, status: %d", status);
-  }
-
-  env->ReleaseByteArrayElements(address, addr, 0);
-
-  return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
-}
-
-static jboolean playItemRspNative(JNIEnv* env, jobject object,
-                                  jbyteArray address, jint rspStatus) {
-  if (!sBluetoothAvrcpInterface) {
-    ALOGE("%s: sBluetoothAvrcpInterface is null", __func__);
-    return JNI_FALSE;
-  }
-
-  jbyte* addr = env->GetByteArrayElements(address, NULL);
-  if (!addr) {
-    jniThrowIOException(env, EINVAL);
-    return JNI_FALSE;
-  }
-
-  RawAddress* btAddr = (RawAddress*)addr;
-  bt_status_t status = sBluetoothAvrcpInterface->play_item_rsp(
-      *btAddr, (btrc_status_t)rspStatus);
-  if (status != BT_STATUS_SUCCESS) {
-    ALOGE("Failed play_item_rsp, status: %d", status);
-  }
-  env->ReleaseByteArrayElements(address, addr, 0);
-
-  return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
-}
-
-static jboolean getTotalNumOfItemsRspNative(JNIEnv* env, jobject object,
-                                            jbyteArray address, jint rspStatus,
-                                            jint uidCounter, jint numItems) {
-  if (!sBluetoothAvrcpInterface) {
-    ALOGE("%s: sBluetoothAvrcpInterface is null", __func__);
-    return JNI_FALSE;
-  }
-
-  jbyte* addr = env->GetByteArrayElements(address, NULL);
-  if (!addr) {
-    jniThrowIOException(env, EINVAL);
-    return JNI_FALSE;
-  }
-
-  uint32_t nItems = (uint32_t)numItems;
-  RawAddress* btAddr = (RawAddress*)addr;
-  bt_status_t status = sBluetoothAvrcpInterface->get_total_num_of_items_rsp(
-      *btAddr, (btrc_status_t)rspStatus, (uint32_t)uidCounter,
-      (uint32_t)nItems);
-  if (status != BT_STATUS_SUCCESS) {
-    ALOGE("Failed get_total_num_of_items_rsp, status: %d", status);
-  }
-  env->ReleaseByteArrayElements(address, addr, 0);
-
-  return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
-}
-
-static jboolean addToNowPlayingRspNative(JNIEnv* env, jobject object,
-                                         jbyteArray address, jint rspStatus) {
-  if (!sBluetoothAvrcpInterface) {
-    ALOGE("%s: sBluetoothAvrcpInterface is null", __func__);
-    return JNI_FALSE;
-  }
-
-  jbyte* addr = env->GetByteArrayElements(address, NULL);
-  if (!addr) {
-    jniThrowIOException(env, EINVAL);
-    return JNI_FALSE;
-  }
-
-  RawAddress* btAddr = (RawAddress*)addr;
-  bt_status_t status = sBluetoothAvrcpInterface->add_to_now_playing_rsp(
-      *btAddr, (btrc_status_t)rspStatus);
-  if (status != BT_STATUS_SUCCESS) {
-    ALOGE("Failed add_to_now_playing_rsp, status: %d", status);
-  }
-  env->ReleaseByteArrayElements(address, addr, 0);
-
-  return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
-}
-
-static JNINativeMethod sMethods[] = {
-    {"classInitNative", "()V", (void*)classInitNative},
-    {"initNative", "()V", (void*)initNative},
-    {"cleanupNative", "()V", (void*)cleanupNative},
-    {"getPlayStatusRspNative", "([BIII)Z", (void*)getPlayStatusRspNative},
-    {"getElementAttrRspNative", "([BB[I[Ljava/lang/String;)Z",
-     (void*)getElementAttrRspNative},
-    {"registerNotificationRspPlayStatusNative", "(II)Z",
-     (void*)registerNotificationRspPlayStatusNative},
-    {"registerNotificationRspTrackChangeNative", "(I[B)Z",
-     (void*)registerNotificationRspTrackChangeNative},
-    {"registerNotificationRspPlayPosNative", "(II)Z",
-     (void*)registerNotificationRspPlayPosNative},
-    {"setVolumeNative", "(I)Z", (void*)setVolumeNative},
-
-    {"setAddressedPlayerRspNative", "([BI)Z",
-     (void*)setAddressedPlayerRspNative},
-
-    {"setBrowsedPlayerRspNative", "([BIBI[Ljava/lang/String;)Z",
-     (void*)setBrowsedPlayerRspNative},
-
-    {"mediaPlayerListRspNative", "([BIIBI[I[B[I[B[S[Ljava/lang/String;)Z",
-     (void*)mediaPlayerListRspNative},
-
-    {"getFolderItemsRspNative",
-     "([BISBI[B[B[B[B[Ljava/lang/String;[I[I[Ljava/lang/String;)Z",
-     (void*)getFolderItemsRspNative},
-
-    {"changePathRspNative", "([BII)Z", (void*)changePathRspNative},
-
-    {"getItemAttrRspNative", "([BIB[I[Ljava/lang/String;)Z",
-     (void*)getItemAttrRspNative},
-
-    {"playItemRspNative", "([BI)Z", (void*)playItemRspNative},
-
-    {"getTotalNumOfItemsRspNative", "([BIII)Z",
-     (void*)getTotalNumOfItemsRspNative},
-
-    {"searchRspNative", "([BIII)Z", (void*)searchRspNative},
-
-    {"addToNowPlayingRspNative", "([BI)Z", (void*)addToNowPlayingRspNative},
-
-    {"registerNotificationRspAddrPlayerChangedNative", "(III)Z",
-     (void*)registerNotificationRspAddrPlayerChangedNative},
-
-    {"registerNotificationRspAvalPlayerChangedNative", "(I)Z",
-     (void*)registerNotificationRspAvalPlayerChangedNative},
-
-    {"registerNotificationRspUIDsChangedNative", "(II)Z",
-     (void*)registerNotificationRspUIDsChangedNative},
-
-    {"registerNotificationRspNowPlayingChangedNative", "(I)Z",
-     (void*)registerNotificationRspNowPlayingChangedNative}};
-
-int register_com_android_bluetooth_avrcp(JNIEnv* env) {
-  return jniRegisterNativeMethods(env, "com/android/bluetooth/avrcp/Avrcp",
-                                  sMethods, NELEM(sMethods));
-}
-
-/* Helper function to copy attributes of item.
- * Assumes that all items in response have same number of attributes
- *
- * returns true on succes, false otherwise.
-*/
-static bool copy_item_attributes(JNIEnv* env, jobject object,
-                                 btrc_folder_items_t* pitem,
-                                 jint* p_attributesIds,
-                                 jobjectArray attributesArray, int item_idx,
-                                 int attribCopiedIndex) {
-  bool success = true;
-
-  /* copy attributes of the item */
-  if (0 < pitem->media.num_attrs) {
-    int num_attrs = pitem->media.num_attrs;
-    ALOGI("%s num_attr = %d", __func__, num_attrs);
-    pitem->media.p_attrs = new btrc_element_attr_val_t[num_attrs];
-    if (!pitem->media.p_attrs) {
-      return false;
-    }
-
-    for (int tempAtrCount = 0; tempAtrCount < pitem->media.num_attrs;
-         ++tempAtrCount) {
-      pitem->media.p_attrs[tempAtrCount].attr_id =
-          p_attributesIds[attribCopiedIndex + tempAtrCount];
-
-      ScopedLocalRef<jstring> text(
-          env, (jstring)env->GetObjectArrayElement(
-                   attributesArray, attribCopiedIndex + tempAtrCount));
-
-      if (!copy_jstring(pitem->media.p_attrs[tempAtrCount].text,
-                        BTRC_MAX_ATTR_STR_LEN, text.get(), env)) {
-        success = false;
-        ALOGE("%s: failed to copy attributes", __func__);
-        break;
-      }
-    }
-  }
-  return success;
-}
-
-/* Helper function to copy String data from java to native
- *
- * returns true on succes, false otherwise
- */
-static bool copy_jstring(uint8_t* str, int maxBytes, jstring jstr,
-                         JNIEnv* env) {
-  if (str == NULL || jstr == NULL || env == NULL) return false;
-
-  memset(str, 0, maxBytes);
-  const char* p_str = env->GetStringUTFChars(jstr, NULL);
-  size_t len = strnlen(p_str, maxBytes - 1);
-  memcpy(str, p_str, len);
-
-  env->ReleaseStringUTFChars(jstr, p_str);
-  return true;
-}
-
-/* Helper function to cleanup items */
-static void cleanup_items(btrc_folder_items_t* p_items, int numItems) {
-  for (int item_idx = 0; item_idx < numItems; item_idx++) {
-    /* release memory for attributes in case item is media item */
-    if ((BTRC_ITEM_MEDIA == p_items[item_idx].item_type) &&
-        p_items[item_idx].media.p_attrs != NULL)
-      delete[] p_items[item_idx].media.p_attrs;
-  }
-}
-}
diff --git a/jni/com_android_bluetooth_btservice_AdapterService.cpp b/jni/com_android_bluetooth_btservice_AdapterService.cpp
index 976e388..2d0960c 100644
--- a/jni/com_android_bluetooth_btservice_AdapterService.cpp
+++ b/jni/com_android_bluetooth_btservice_AdapterService.cpp
@@ -1306,12 +1306,6 @@
     return JNI_ERR;
   }
 
-  status = android::register_com_android_bluetooth_avrcp(e);
-  if (status < 0) {
-    ALOGE("jni avrcp target registration failure: %d", status);
-    return JNI_ERR;
-  }
-
   status = android::register_com_android_bluetooth_avrcp_target(e);
   if (status < 0) {
     ALOGE("jni new avrcp target registration failure: %d", status);
diff --git a/src/com/android/bluetooth/a2dp/A2dpService.java b/src/com/android/bluetooth/a2dp/A2dpService.java
index 10a2f8b..0641c9f 100644
--- a/src/com/android/bluetooth/a2dp/A2dpService.java
+++ b/src/com/android/bluetooth/a2dp/A2dpService.java
@@ -37,7 +37,6 @@
 
 import com.android.bluetooth.BluetoothMetricsProto;
 import com.android.bluetooth.Utils;
-import com.android.bluetooth.avrcp.Avrcp;
 import com.android.bluetooth.avrcp.AvrcpTargetService;
 import com.android.bluetooth.btservice.AdapterService;
 import com.android.bluetooth.btservice.MetricsLogger;
@@ -63,7 +62,6 @@
     private BluetoothAdapter mAdapter;
     private AdapterService mAdapterService;
     private HandlerThread mStateMachinesThread;
-    private Avrcp mAvrcp;
 
     @VisibleForTesting
     A2dpNativeInterface mA2dpNativeInterface;
@@ -118,28 +116,25 @@
         mMaxConnectedAudioDevices = mAdapterService.getMaxConnectedAudioDevices();
         Log.i(TAG, "Max connected audio devices set to " + mMaxConnectedAudioDevices);
 
-        // Step 3: Setup AVRCP
-        mAvrcp = Avrcp.make(this);
-
-        // Step 4: Start handler thread for state machines
+        // Step 3: Start handler thread for state machines
         mStateMachines.clear();
         mStateMachinesThread = new HandlerThread("A2dpService.StateMachines");
         mStateMachinesThread.start();
 
-        // Step 5: Setup codec config
+        // Step 4: Setup codec config
         mA2dpCodecConfig = new A2dpCodecConfig(this, mA2dpNativeInterface);
 
-        // Step 6: Initialize native interface
+        // Step 5: Initialize native interface
         mA2dpNativeInterface.init(mMaxConnectedAudioDevices,
                                   mA2dpCodecConfig.codecConfigPriorities());
 
-        // Step 7: Check if A2DP is in offload mode
+        // Step 6: Check if A2DP is in offload mode
         mA2dpOffloadEnabled = mAdapterService.isA2dpOffloadEnabled();
         if (DBG) {
             Log.d(TAG, "A2DP offload flag set to " + mA2dpOffloadEnabled);
         }
 
-        // Step 8: Setup broadcast receivers
+        // Step 7: Setup broadcast receivers
         IntentFilter filter = new IntentFilter();
         filter.addAction(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
         mBondStateChangedReceiver = new BondStateChangedReceiver();
@@ -149,10 +144,10 @@
         mConnectionStateChangedReceiver = new ConnectionStateChangedReceiver();
         registerReceiver(mConnectionStateChangedReceiver, filter);
 
-        // Step 9: Mark service as started
+        // Step 8: Mark service as started
         setA2dpService(this);
 
-        // Step 10: Clear active device
+        // Step 9: Clear active device
         setActiveDevice(null);
 
         return true;
@@ -201,11 +196,6 @@
         mStateMachinesThread.quitSafely();
         mStateMachinesThread = null;
 
-        // Step 3: Cleanup AVRCP
-        mAvrcp.doQuit();
-        mAvrcp.cleanup();
-        mAvrcp = null;
-
         // Step 2: Reset maximum number of connected audio devices
         mMaxConnectedAudioDevices = 1;
 
@@ -580,11 +570,12 @@
         return priority;
     }
 
-    /* Absolute volume implementation */
     public boolean isAvrcpAbsoluteVolumeSupported() {
-        return mAvrcp.isAbsoluteVolumeSupported();
+        // TODO (apanicke): Add a hook here for the AvrcpTargetService.
+        return false;
     }
 
+
     public void setAvrcpAbsoluteVolume(int volume) {
         // TODO (apanicke): Instead of using A2DP as a middleman for volume changes, add a binder
         // service to the new AVRCP Profile and have the audio manager use that instead.
@@ -592,18 +583,6 @@
             AvrcpTargetService.get().sendVolumeChanged(volume);
             return;
         }
-
-        mAvrcp.setAbsoluteVolume(volume);
-    }
-
-    public void setAvrcpAudioState(int state) {
-        mAvrcp.setA2dpAudioState(state);
-    }
-
-    public void resetAvrcpBlacklist(BluetoothDevice device) {
-        if (mAvrcp != null) {
-            mAvrcp.resetBlackList(device.getAddress());
-        }
     }
 
     boolean isA2dpPlaying(BluetoothDevice device) {
@@ -1207,8 +1186,5 @@
         for (A2dpStateMachine sm : mStateMachines.values()) {
             sm.dump(sb);
         }
-        if (mAvrcp != null) {
-            mAvrcp.dump(sb);
-        }
     }
 }
diff --git a/src/com/android/bluetooth/a2dp/A2dpStateMachine.java b/src/com/android/bluetooth/a2dp/A2dpStateMachine.java
index 3ab26e1..8d41fff 100644
--- a/src/com/android/bluetooth/a2dp/A2dpStateMachine.java
+++ b/src/com/android/bluetooth/a2dp/A2dpStateMachine.java
@@ -130,7 +130,6 @@
             // Stop if auido is still playing
             log("doQuit: stopped playing " + mDevice);
             mIsPlaying = false;
-            mA2dpService.setAvrcpAudioState(BluetoothA2dp.STATE_NOT_PLAYING);
             broadcastAudioState(BluetoothA2dp.STATE_NOT_PLAYING,
                                 BluetoothA2dp.STATE_PLAYING);
         }
@@ -158,7 +157,6 @@
                 if (mIsPlaying) {
                     Log.i(TAG, "Disconnected: stopped playing: " + mDevice);
                     mIsPlaying = false;
-                    mA2dpService.setAvrcpAudioState(BluetoothA2dp.STATE_NOT_PLAYING);
                     broadcastAudioState(BluetoothA2dp.STATE_NOT_PLAYING,
                                         BluetoothA2dp.STATE_PLAYING);
                 }
@@ -559,7 +557,6 @@
                         if (!mIsPlaying) {
                             Log.i(TAG, "Connected: started playing: " + mDevice);
                             mIsPlaying = true;
-                            mA2dpService.setAvrcpAudioState(BluetoothA2dp.STATE_PLAYING);
                             broadcastAudioState(BluetoothA2dp.STATE_PLAYING,
                                                 BluetoothA2dp.STATE_NOT_PLAYING);
                         }
@@ -571,7 +568,6 @@
                         if (mIsPlaying) {
                             Log.i(TAG, "Connected: stopped playing: " + mDevice);
                             mIsPlaying = false;
-                            mA2dpService.setAvrcpAudioState(BluetoothA2dp.STATE_NOT_PLAYING);
                             broadcastAudioState(BluetoothA2dp.STATE_NOT_PLAYING,
                                                 BluetoothA2dp.STATE_PLAYING);
                         }
diff --git a/src/com/android/bluetooth/avrcp/AddressedMediaPlayer.java b/src/com/android/bluetooth/avrcp/AddressedMediaPlayer.java
deleted file mode 100644
index 1d4810a..0000000
--- a/src/com/android/bluetooth/avrcp/AddressedMediaPlayer.java
+++ /dev/null
@@ -1,601 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.bluetooth.avrcp;
-
-import android.annotation.NonNull;
-import android.annotation.Nullable;
-import android.media.MediaDescription;
-import android.media.MediaMetadata;
-import android.media.session.MediaSession;
-import android.media.session.MediaSession.QueueItem;
-import android.media.session.PlaybackState;
-import android.os.Bundle;
-import android.util.Log;
-
-import com.android.bluetooth.Utils;
-import com.android.bluetooth.btservice.ProfileService;
-
-import java.nio.ByteBuffer;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-/*************************************************************************************************
- * Provides functionality required for Addressed Media Player, like Now Playing List related
- * browsing commands, control commands to the current addressed player(playItem, play, pause, etc)
- * Acts as an Interface to communicate with media controller APIs for NowPlayingItems.
- ************************************************************************************************/
-
-public class AddressedMediaPlayer {
-    private static final String TAG = "AddressedMediaPlayer";
-    private static final Boolean DEBUG = false;
-
-    private static final long SINGLE_QID = 1;
-    private static final String UNKNOWN_TITLE = "(unknown)";
-
-    static private final String GPM_BUNDLE_METADATA_KEY =
-            "com.google.android.music.mediasession.music_metadata";
-
-    private AvrcpMediaRspInterface mMediaInterface;
-    @NonNull private List<MediaSession.QueueItem> mNowPlayingList;
-
-    private final List<MediaSession.QueueItem> mEmptyNowPlayingList;
-
-    private long mLastTrackIdSent;
-
-    public AddressedMediaPlayer(AvrcpMediaRspInterface mediaInterface) {
-        mEmptyNowPlayingList = new ArrayList<MediaSession.QueueItem>();
-        mNowPlayingList = mEmptyNowPlayingList;
-        mMediaInterface = mediaInterface;
-        mLastTrackIdSent = MediaSession.QueueItem.UNKNOWN_ID;
-    }
-
-    void cleanup() {
-        if (DEBUG) {
-            Log.v(TAG, "cleanup");
-        }
-        mNowPlayingList = mEmptyNowPlayingList;
-        mMediaInterface = null;
-        mLastTrackIdSent = MediaSession.QueueItem.UNKNOWN_ID;
-    }
-
-    /* get now playing list from addressed player */
-    void getFolderItemsNowPlaying(byte[] bdaddr, AvrcpCmd.FolderItemsCmd reqObj,
-            @Nullable MediaController mediaController) {
-        if (mediaController == null) {
-            // No players (if a player exists, we would have selected it)
-            Log.e(TAG, "mediaController = null, sending no available players response");
-            mMediaInterface.folderItemsRsp(bdaddr, AvrcpConstants.RSP_NO_AVBL_PLAY, null);
-            return;
-        }
-        List<MediaSession.QueueItem> items = updateNowPlayingList(mediaController);
-        getFolderItemsFilterAttr(bdaddr, reqObj, items, AvrcpConstants.BTRC_SCOPE_NOW_PLAYING,
-                reqObj.mStartItem, reqObj.mEndItem, mediaController);
-    }
-
-    /* get item attributes for item in now playing list */
-    void getItemAttr(byte[] bdaddr, AvrcpCmd.ItemAttrCmd itemAttr,
-            @Nullable MediaController mediaController) {
-        int status = AvrcpConstants.RSP_NO_ERROR;
-        long mediaId = ByteBuffer.wrap(itemAttr.mUid).getLong();
-        List<MediaSession.QueueItem> items = updateNowPlayingList(mediaController);
-
-        // NOTE: this is out-of-spec (AVRCP 1.6.1 sec 6.10.4.3, p90) but we answer it anyway
-        // because some CTs ask for it.
-        if (Arrays.equals(itemAttr.mUid, AvrcpConstants.TRACK_IS_SELECTED)) {
-            mediaId = getActiveQueueItemId(mediaController);
-            if (DEBUG) {
-                Log.d(TAG, "getItemAttr: Remote requests for now playing contents, sending UID: "
-                        + mediaId);
-            }
-        }
-
-        if (DEBUG) {
-            Log.d(TAG, "getItemAttr-UID: 0x" + Utils.byteArrayToString(itemAttr.mUid));
-        }
-        for (MediaSession.QueueItem item : items) {
-            if (item.getQueueId() == mediaId) {
-                getItemAttrFilterAttr(bdaddr, itemAttr, item, mediaController);
-                return;
-            }
-        }
-
-        // Couldn't find it, so the id is invalid
-        mMediaInterface.getItemAttrRsp(bdaddr, AvrcpConstants.RSP_INV_ITEM, null);
-    }
-
-    /* Refresh and get the queue of now playing.
-     */
-    @NonNull
-    List<MediaSession.QueueItem> updateNowPlayingList(@Nullable MediaController mediaController) {
-        if (mediaController == null) {
-            return mEmptyNowPlayingList;
-        }
-        List<MediaSession.QueueItem> items = mediaController.getQueue();
-        if (items == null) {
-            Log.i(TAG, "null queue from " + mediaController.getPackageName()
-                    + ", constructing single-item list");
-
-            // Because we are database-unaware, we can just number the item here whatever we want
-            // because they have to re-poll it every time.
-            MediaMetadata metadata = mediaController.getMetadata();
-            if (metadata == null) {
-                Log.w(TAG, "Controller has no metadata!? Making an empty one");
-                metadata = (new MediaMetadata.Builder()).build();
-            }
-
-            MediaDescription.Builder bob = new MediaDescription.Builder();
-            MediaDescription desc = metadata.getDescription();
-
-            // set the simple ones that MediaMetadata builds for us
-            bob.setMediaId(desc.getMediaId());
-            bob.setTitle(desc.getTitle());
-            bob.setSubtitle(desc.getSubtitle());
-            bob.setDescription(desc.getDescription());
-            // fill the ones that we use later
-            bob.setExtras(fillBundle(metadata, desc.getExtras()));
-
-            // build queue item with the new metadata
-            MediaSession.QueueItem current = new QueueItem(bob.build(), SINGLE_QID);
-
-            items = new ArrayList<MediaSession.QueueItem>();
-            items.add(current);
-        }
-
-        if (!items.equals(mNowPlayingList)) {
-            sendNowPlayingListChanged();
-        }
-        mNowPlayingList = items;
-
-        return mNowPlayingList;
-    }
-
-    private void sendNowPlayingListChanged() {
-        if (mMediaInterface == null) {
-            return;
-        }
-        if (DEBUG) {
-            Log.d(TAG, "sendNowPlayingListChanged()");
-        }
-        mMediaInterface.nowPlayingChangedRsp(AvrcpConstants.NOTIFICATION_TYPE_CHANGED);
-    }
-
-    private Bundle fillBundle(MediaMetadata metadata, Bundle currentExtras) {
-        if (metadata == null) {
-            Log.i(TAG, "fillBundle: metadata is null");
-            return currentExtras;
-        }
-
-        Bundle bundle = currentExtras;
-        if (bundle == null) {
-            bundle = new Bundle();
-        }
-
-        String[] stringKeys = {
-                MediaMetadata.METADATA_KEY_TITLE,
-                MediaMetadata.METADATA_KEY_ARTIST,
-                MediaMetadata.METADATA_KEY_ALBUM,
-                MediaMetadata.METADATA_KEY_GENRE
-        };
-        for (String key : stringKeys) {
-            String current = bundle.getString(key);
-            if (current == null) {
-                bundle.putString(key, metadata.getString(key));
-            }
-        }
-
-        String[] longKeys = {
-                MediaMetadata.METADATA_KEY_TRACK_NUMBER,
-                MediaMetadata.METADATA_KEY_NUM_TRACKS,
-                MediaMetadata.METADATA_KEY_DURATION
-        };
-        for (String key : longKeys) {
-            if (!bundle.containsKey(key)) {
-                bundle.putLong(key, metadata.getLong(key));
-            }
-        }
-        return bundle;
-    }
-
-    /* Instructs media player to play particular media item */
-    void playItem(byte[] bdaddr, byte[] uid, @Nullable MediaController mediaController) {
-        long qid = ByteBuffer.wrap(uid).getLong();
-        List<MediaSession.QueueItem> items = updateNowPlayingList(mediaController);
-
-        if (mediaController == null) {
-            Log.e(TAG, "No mediaController when PlayItem " + qid + " requested");
-            mMediaInterface.playItemRsp(bdaddr, AvrcpConstants.RSP_INTERNAL_ERR);
-            return;
-        }
-
-        MediaController.TransportControls mediaControllerCntrl =
-                mediaController.getTransportControls();
-
-        if (items == null) {
-            Log.w(TAG, "nowPlayingItems is null");
-            mMediaInterface.playItemRsp(bdaddr, AvrcpConstants.RSP_INTERNAL_ERR);
-            return;
-        }
-
-        for (MediaSession.QueueItem item : items) {
-            if (qid == item.getQueueId()) {
-                if (DEBUG) {
-                    Log.d(TAG, "Skipping to ID " + qid);
-                }
-                mediaControllerCntrl.skipToQueueItem(qid);
-                mMediaInterface.playItemRsp(bdaddr, AvrcpConstants.RSP_NO_ERROR);
-                return;
-            }
-        }
-
-        Log.w(TAG, "Invalid now playing Queue ID " + qid);
-        mMediaInterface.playItemRsp(bdaddr, AvrcpConstants.RSP_INV_ITEM);
-    }
-
-    void getTotalNumOfItems(byte[] bdaddr, @Nullable MediaController mediaController) {
-        List<MediaSession.QueueItem> items = updateNowPlayingList(mediaController);
-        if (DEBUG) {
-            Log.d(TAG, "getTotalNumOfItems: " + items.size() + " items.");
-        }
-        mMediaInterface.getTotalNumOfItemsRsp(bdaddr, AvrcpConstants.RSP_NO_ERROR, 0, items.size());
-    }
-
-    void sendTrackChangeWithId(int type, @Nullable MediaController mediaController) {
-        Log.d(TAG, "sendTrackChangeWithId (" + type + "): controller " + mediaController);
-        long qid = getActiveQueueItemId(mediaController);
-        byte[] track = ByteBuffer.allocate(AvrcpConstants.UID_SIZE).putLong(qid).array();
-        // The nowPlayingList changed: the new list has the full data for the current item
-        mMediaInterface.trackChangedRsp(type, track);
-        mLastTrackIdSent = qid;
-    }
-
-    /*
-     * helper method to check if startItem and endItem index is with range of
-     * MediaItem list. (Resultset containing all items in current path)
-     */
-    @Nullable
-    private List<MediaSession.QueueItem> getQueueSubset(@NonNull List<MediaSession.QueueItem> items,
-            long startItem, long endItem) {
-        if (endItem > items.size()) {
-            endItem = items.size() - 1;
-        }
-        if (startItem > Integer.MAX_VALUE) {
-            startItem = Integer.MAX_VALUE;
-        }
-        try {
-            List<MediaSession.QueueItem> selected =
-                    items.subList((int) startItem, (int) Math.min(items.size(), endItem + 1));
-            if (selected.isEmpty()) {
-                Log.i(TAG, "itemsSubList is empty.");
-                return null;
-            }
-            return selected;
-        } catch (IndexOutOfBoundsException ex) {
-            Log.i(TAG, "Range (" + startItem + ", " + endItem + ") invalid");
-        } catch (IllegalArgumentException ex) {
-            Log.i(TAG, "Range start " + startItem + " > size (" + items.size() + ")");
-        }
-        return null;
-    }
-
-    /*
-     * helper method to filter required attibutes before sending GetFolderItems
-     * response
-     */
-    private void getFolderItemsFilterAttr(byte[] bdaddr, AvrcpCmd.FolderItemsCmd folderItemsReqObj,
-            @NonNull List<MediaSession.QueueItem> items, byte scope, long startItem, long endItem,
-            @NonNull MediaController mediaController) {
-        if (DEBUG) {
-            Log.d(TAG,
-                    "getFolderItemsFilterAttr: startItem =" + startItem + ", endItem = " + endItem);
-        }
-
-        List<MediaSession.QueueItem> resultItems = getQueueSubset(items, startItem, endItem);
-        /* check for index out of bound errors */
-        if (resultItems == null) {
-            Log.w(TAG, "getFolderItemsFilterAttr: resultItems is empty");
-            mMediaInterface.folderItemsRsp(bdaddr, AvrcpConstants.RSP_INV_RANGE, null);
-            return;
-        }
-
-        FolderItemsData folderDataNative = new FolderItemsData(resultItems.size());
-
-        /* variables to accumulate attrs */
-        ArrayList<String> attrArray = new ArrayList<String>();
-        ArrayList<Integer> attrId = new ArrayList<Integer>();
-
-        for (int itemIndex = 0; itemIndex < resultItems.size(); itemIndex++) {
-            MediaSession.QueueItem item = resultItems.get(itemIndex);
-            // get the queue id
-            long qid = item.getQueueId();
-            byte[] uid = ByteBuffer.allocate(AvrcpConstants.UID_SIZE).putLong(qid).array();
-
-            // get the array of uid from 2d to array 1D array
-            for (int idx = 0; idx < AvrcpConstants.UID_SIZE; idx++) {
-                folderDataNative.mItemUid[itemIndex * AvrcpConstants.UID_SIZE + idx] = uid[idx];
-            }
-
-            /* Set display name for current item */
-            folderDataNative.mDisplayNames[itemIndex] =
-                    getAttrValue(AvrcpConstants.ATTRID_TITLE, item, mediaController);
-
-            int maxAttributesRequested = 0;
-            boolean isAllAttribRequested = false;
-            /* check if remote requested for attributes */
-            if (folderItemsReqObj.mNumAttr != AvrcpConstants.NUM_ATTR_NONE) {
-                int attrCnt = 0;
-
-                /* add requested attr ids to a temp array */
-                if (folderItemsReqObj.mNumAttr == AvrcpConstants.NUM_ATTR_ALL) {
-                    isAllAttribRequested = true;
-                    maxAttributesRequested = AvrcpConstants.MAX_NUM_ATTR;
-                } else {
-                    /* get only the requested attribute ids from the request */
-                    maxAttributesRequested = folderItemsReqObj.mNumAttr;
-                }
-
-                /* lookup and copy values of attributes for ids requested above */
-                for (int idx = 0; idx < maxAttributesRequested; idx++) {
-                    /* check if media player provided requested attributes */
-                    String value = null;
-
-                    int attribId =
-                            isAllAttribRequested ? (idx + 1) : folderItemsReqObj.mAttrIDs[idx];
-                    value = getAttrValue(attribId, item, mediaController);
-                    if (value != null) {
-                        attrArray.add(value);
-                        attrId.add(attribId);
-                        attrCnt++;
-                    }
-                }
-                /* add num attr actually received from media player for a particular item */
-                folderDataNative.mAttributesNum[itemIndex] = attrCnt;
-            }
-        }
-
-        /* copy filtered attr ids and attr values to response parameters */
-        if (folderItemsReqObj.mNumAttr != AvrcpConstants.NUM_ATTR_NONE) {
-            folderDataNative.mAttrIds = new int[attrId.size()];
-            for (int attrIndex = 0; attrIndex < attrId.size(); attrIndex++) {
-                folderDataNative.mAttrIds[attrIndex] = attrId.get(attrIndex);
-            }
-            folderDataNative.mAttrValues = attrArray.toArray(new String[attrArray.size()]);
-        }
-        for (int attrIndex = 0; attrIndex < folderDataNative.mAttributesNum.length; attrIndex++) {
-            if (DEBUG) {
-                Log.d(TAG, "folderDataNative.mAttributesNum"
-                        + folderDataNative.mAttributesNum[attrIndex] + " attrIndex " + attrIndex);
-            }
-        }
-
-        /* create rsp object and send response to remote device */
-        FolderItemsRsp rspObj =
-                new FolderItemsRsp(AvrcpConstants.RSP_NO_ERROR, Avrcp.sUIDCounter, scope,
-                        folderDataNative.mNumItems, folderDataNative.mFolderTypes,
-                        folderDataNative.mPlayable, folderDataNative.mItemTypes,
-                        folderDataNative.mItemUid, folderDataNative.mDisplayNames,
-                        folderDataNative.mAttributesNum, folderDataNative.mAttrIds,
-                        folderDataNative.mAttrValues);
-        mMediaInterface.folderItemsRsp(bdaddr, AvrcpConstants.RSP_NO_ERROR, rspObj);
-    }
-
-    private String getAttrValue(int attr, MediaSession.QueueItem item,
-            @Nullable MediaController mediaController) {
-        String attrValue = null;
-        if (item == null) {
-            if (DEBUG) {
-                Log.d(TAG, "getAttrValue received null item");
-            }
-            return null;
-        }
-        try {
-            MediaDescription desc = item.getDescription();
-            Bundle extras = desc.getExtras();
-            boolean isCurrentTrack = item.getQueueId() == getActiveQueueItemId(mediaController);
-            MediaMetadata data = null;
-            if (isCurrentTrack) {
-                if (DEBUG) {
-                    Log.d(TAG, "getAttrValue: item is active, using current data");
-                }
-                data = mediaController.getMetadata();
-                if (data == null) {
-                    Log.e(TAG, "getMetadata didn't give us any metadata for the current track");
-                }
-            }
-
-            if (data == null) {
-                // TODO: This code can be removed when b/63117921 is resolved
-                data = (MediaMetadata) extras.get(GPM_BUNDLE_METADATA_KEY);
-                extras = null; // We no longer need the data in here
-            }
-
-            extras = fillBundle(data, extras);
-
-            if (DEBUG) {
-                Log.d(TAG, "getAttrValue: item " + item + " : " + desc);
-            }
-            switch (attr) {
-                case AvrcpConstants.ATTRID_TITLE:
-                    /* Title is mandatory attribute */
-                    if (isCurrentTrack) {
-                        attrValue = extras.getString(MediaMetadata.METADATA_KEY_TITLE);
-                    } else {
-                        attrValue = desc.getTitle().toString();
-                    }
-                    break;
-
-                case AvrcpConstants.ATTRID_ARTIST:
-                    attrValue = extras.getString(MediaMetadata.METADATA_KEY_ARTIST);
-                    break;
-
-                case AvrcpConstants.ATTRID_ALBUM:
-                    attrValue = extras.getString(MediaMetadata.METADATA_KEY_ALBUM);
-                    break;
-
-                case AvrcpConstants.ATTRID_TRACK_NUM:
-                    attrValue =
-                            Long.toString(extras.getLong(MediaMetadata.METADATA_KEY_TRACK_NUMBER));
-                    break;
-
-                case AvrcpConstants.ATTRID_NUM_TRACKS:
-                    attrValue =
-                            Long.toString(extras.getLong(MediaMetadata.METADATA_KEY_NUM_TRACKS));
-                    break;
-
-                case AvrcpConstants.ATTRID_GENRE:
-                    attrValue = extras.getString(MediaMetadata.METADATA_KEY_GENRE);
-                    break;
-
-                case AvrcpConstants.ATTRID_PLAY_TIME:
-                    attrValue = Long.toString(extras.getLong(MediaMetadata.METADATA_KEY_DURATION));
-                    break;
-
-                case AvrcpConstants.ATTRID_COVER_ART:
-                    Log.e(TAG, "getAttrValue: Cover art attribute not supported");
-                    return null;
-
-                default:
-                    Log.e(TAG, "getAttrValue: Unknown attribute ID requested: " + attr);
-                    return null;
-            }
-        } catch (NullPointerException ex) {
-            Log.w(TAG, "getAttrValue: attr id not found in result");
-            /* checking if attribute is title, then it is mandatory and cannot send null */
-            if (attr == AvrcpConstants.ATTRID_TITLE) {
-                attrValue = "<Unknown Title>";
-            } else {
-                return null;
-            }
-        }
-        if (DEBUG) {
-            Log.d(TAG, "getAttrValue: attrvalue = " + attrValue + ", attr id:" + attr);
-        }
-        return attrValue;
-    }
-
-    private void getItemAttrFilterAttr(byte[] bdaddr, AvrcpCmd.ItemAttrCmd mItemAttrReqObj,
-            MediaSession.QueueItem mediaItem, @Nullable MediaController mediaController) {
-        /* Response parameters */
-        int[] attrIds = null; /* array of attr ids */
-        String[] attrValues = null; /* array of attr values */
-
-        /* variables to temperorily add attrs */
-        ArrayList<String> attrArray = new ArrayList<String>();
-        ArrayList<Integer> attrId = new ArrayList<Integer>();
-        ArrayList<Integer> attrTempId = new ArrayList<Integer>();
-
-        /* check if remote device has requested for attributes */
-        if (mItemAttrReqObj.mNumAttr != AvrcpConstants.NUM_ATTR_NONE) {
-            if (mItemAttrReqObj.mNumAttr == AvrcpConstants.NUM_ATTR_ALL) {
-                for (int idx = 1; idx < AvrcpConstants.MAX_NUM_ATTR; idx++) {
-                    attrTempId.add(idx); /* attr id 0x00 is unused */
-                }
-            } else {
-                /* get only the requested attribute ids from the request */
-                for (int idx = 0; idx < mItemAttrReqObj.mNumAttr; idx++) {
-                    if (DEBUG) {
-                        Log.d(TAG, "getItemAttrFilterAttr: attr id[" + idx + "] :"
-                                + mItemAttrReqObj.mAttrIDs[idx]);
-                    }
-                    attrTempId.add(mItemAttrReqObj.mAttrIDs[idx]);
-                }
-            }
-        }
-
-        if (DEBUG) {
-            Log.d(TAG, "getItemAttrFilterAttr: attr id list size:" + attrTempId.size());
-        }
-        /* lookup and copy values of attributes for ids requested above */
-        for (int idx = 0; idx < attrTempId.size(); idx++) {
-            /* check if media player provided requested attributes */
-            String value = getAttrValue(attrTempId.get(idx), mediaItem, mediaController);
-            if (value != null) {
-                attrArray.add(value);
-                attrId.add(attrTempId.get(idx));
-            }
-        }
-
-        /* copy filtered attr ids and attr values to response parameters */
-        if (mItemAttrReqObj.mNumAttr != AvrcpConstants.NUM_ATTR_NONE) {
-            attrIds = new int[attrId.size()];
-
-            for (int attrIndex = 0; attrIndex < attrId.size(); attrIndex++) {
-                attrIds[attrIndex] = attrId.get(attrIndex);
-            }
-
-            attrValues = attrArray.toArray(new String[attrId.size()]);
-
-            /* create rsp object and send response */
-            ItemAttrRsp rspObj = new ItemAttrRsp(AvrcpConstants.RSP_NO_ERROR, attrIds, attrValues);
-            mMediaInterface.getItemAttrRsp(bdaddr, AvrcpConstants.RSP_NO_ERROR, rspObj);
-            return;
-        }
-    }
-
-    private long getActiveQueueItemId(@Nullable MediaController controller) {
-        if (controller == null) {
-            return MediaSession.QueueItem.UNKNOWN_ID;
-        }
-        PlaybackState state = controller.getPlaybackState();
-        if (state == null || state.getState() == PlaybackState.STATE_BUFFERING
-                || state.getState() == PlaybackState.STATE_NONE) {
-            return MediaSession.QueueItem.UNKNOWN_ID;
-        }
-        long qid = state.getActiveQueueItemId();
-        if (qid != MediaSession.QueueItem.UNKNOWN_ID) {
-            return qid;
-        }
-        // Check if we're presenting a "one item queue"
-        if (controller.getMetadata() != null) {
-            return SINGLE_QID;
-        }
-        return MediaSession.QueueItem.UNKNOWN_ID;
-    }
-
-    String displayMediaItem(MediaSession.QueueItem item) {
-        StringBuilder sb = new StringBuilder();
-        sb.append("#");
-        sb.append(item.getQueueId());
-        sb.append(": ");
-        sb.append(Utils.ellipsize(getAttrValue(AvrcpConstants.ATTRID_TITLE, item, null)));
-        sb.append(" - ");
-        sb.append(Utils.ellipsize(getAttrValue(AvrcpConstants.ATTRID_ALBUM, item, null)));
-        sb.append(" by ");
-        sb.append(Utils.ellipsize(getAttrValue(AvrcpConstants.ATTRID_ARTIST, item, null)));
-        sb.append(" (");
-        sb.append(getAttrValue(AvrcpConstants.ATTRID_PLAY_TIME, item, null));
-        sb.append(" ");
-        sb.append(getAttrValue(AvrcpConstants.ATTRID_TRACK_NUM, item, null));
-        sb.append("/");
-        sb.append(getAttrValue(AvrcpConstants.ATTRID_NUM_TRACKS, item, null));
-        sb.append(") ");
-        sb.append(getAttrValue(AvrcpConstants.ATTRID_GENRE, item, null));
-        return sb.toString();
-    }
-
-    public void dump(StringBuilder sb, @Nullable MediaController mediaController) {
-        ProfileService.println(sb, "AddressedPlayer info:");
-        ProfileService.println(sb, "mLastTrackIdSent: " + mLastTrackIdSent);
-        ProfileService.println(sb, "mNowPlayingList: " + mNowPlayingList.size() + " elements");
-        long currentQueueId = getActiveQueueItemId(mediaController);
-        for (MediaSession.QueueItem item : mNowPlayingList) {
-            long itemId = item.getQueueId();
-            ProfileService.println(sb,
-                    (itemId == currentQueueId ? "*" : " ") + displayMediaItem(item));
-        }
-    }
-}
diff --git a/src/com/android/bluetooth/avrcp/Avrcp.java b/src/com/android/bluetooth/avrcp/Avrcp.java
deleted file mode 100644
index e30ad41..0000000
--- a/src/com/android/bluetooth/avrcp/Avrcp.java
+++ /dev/null
@@ -1,3123 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.bluetooth.avrcp;
-
-import android.annotation.NonNull;
-import android.annotation.Nullable;
-import android.bluetooth.BluetoothA2dp;
-import android.bluetooth.BluetoothAvrcp;
-import android.content.BroadcastReceiver;
-import android.content.ComponentName;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.content.SharedPreferences;
-import android.content.pm.ApplicationInfo;
-import android.content.pm.PackageManager;
-import android.content.pm.PackageManager.NameNotFoundException;
-import android.content.pm.ResolveInfo;
-import android.content.res.Resources;
-import android.media.AudioManager;
-import android.media.AudioPlaybackConfiguration;
-import android.media.MediaDescription;
-import android.media.MediaMetadata;
-import android.media.session.MediaSession;
-import android.media.session.MediaSessionManager;
-import android.media.session.PlaybackState;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.Looper;
-import android.os.Message;
-import android.os.SystemClock;
-import android.os.UserManager;
-import android.util.Log;
-import android.view.KeyEvent;
-
-import com.android.bluetooth.R;
-import com.android.bluetooth.Utils;
-import com.android.bluetooth.btservice.ProfileService;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.SortedMap;
-import java.util.TreeMap;
-
-/******************************************************************************
- * support Bluetooth AVRCP profile. support metadata, play status, event
- * notifications, address player selection and browse feature implementation.
- ******************************************************************************/
-
-public final class Avrcp {
-    private static final boolean DEBUG = false;
-    private static final String TAG = "Avrcp";
-    private static final String ABSOLUTE_VOLUME_BLACKLIST = "absolute_volume_blacklist";
-
-    private Context mContext;
-    private final AudioManager mAudioManager;
-    private volatile AvrcpMessageHandler mHandler;
-    private Handler mAudioManagerPlaybackHandler;
-    private AudioManagerPlaybackListener mAudioManagerPlaybackCb;
-    private MediaSessionManager mMediaSessionManager;
-    @Nullable private MediaController mMediaController;
-    private MediaControllerListener mMediaControllerCb;
-    private MediaAttributes mMediaAttributes;
-    private long mLastQueueId;
-    private PackageManager mPackageManager;
-    private int mTransportControlFlags;
-    @NonNull private PlaybackState mCurrentPlayState;
-    private int mA2dpState;
-    private boolean mAudioManagerIsPlaying;
-    private int mPlayStatusChangedNT;
-    private byte mReportedPlayStatus;
-    private int mTrackChangedNT;
-    private int mPlayPosChangedNT;
-    private int mAddrPlayerChangedNT;
-    private int mReportedPlayerID;
-    private int mNowPlayingListChangedNT;
-    private long mPlaybackIntervalMs;
-    private long mLastReportedPosition;
-    private long mNextPosMs;
-    private long mPrevPosMs;
-    private int mFeatures;
-    private int mRemoteVolume;
-    private int mLastRemoteVolume;
-    private int mInitialRemoteVolume;
-
-    /* Local volume in audio index 0-15 */
-    private int mLocalVolume;
-    private int mLastLocalVolume;
-    private int mAbsVolThreshold;
-
-    private String mAddress;
-    private HashMap<Integer, Integer> mVolumeMapping;
-
-    private int mLastDirection;
-    private final int mVolumeStep;
-    private final int mAudioStreamMax;
-    private boolean mVolCmdSetInProgress;
-    private int mAbsVolRetryTimes;
-
-    private static final int NO_PLAYER_ID = 0;
-
-    private int mCurrAddrPlayerID;
-    private int mCurrBrowsePlayerID;
-    private int mLastUsedPlayerID;
-    private AvrcpMediaRsp mAvrcpMediaRsp;
-
-    /* UID counter to be shared across different files. */
-    static short sUIDCounter = AvrcpConstants.DEFAULT_UID_COUNTER;
-
-    /* BTRC features */
-    public static final int BTRC_FEAT_METADATA = 0x01;
-    public static final int BTRC_FEAT_ABSOLUTE_VOLUME = 0x02;
-    public static final int BTRC_FEAT_BROWSE = 0x04;
-
-    /* AVRC response codes, from avrc_defs */
-    private static final int AVRC_RSP_NOT_IMPL = 8;
-    private static final int AVRC_RSP_ACCEPT = 9;
-    private static final int AVRC_RSP_REJ = 10;
-    private static final int AVRC_RSP_IN_TRANS = 11;
-    private static final int AVRC_RSP_IMPL_STBL = 12;
-    private static final int AVRC_RSP_CHANGED = 13;
-    private static final int AVRC_RSP_INTERIM = 15;
-
-    /* AVRC request commands from Native */
-    private static final int MSG_NATIVE_REQ_GET_RC_FEATURES = 1;
-    private static final int MSG_NATIVE_REQ_GET_PLAY_STATUS = 2;
-    private static final int MSG_NATIVE_REQ_GET_ELEM_ATTRS = 3;
-    private static final int MSG_NATIVE_REQ_REGISTER_NOTIFICATION = 4;
-    private static final int MSG_NATIVE_REQ_VOLUME_CHANGE = 5;
-    private static final int MSG_NATIVE_REQ_GET_FOLDER_ITEMS = 6;
-    private static final int MSG_NATIVE_REQ_SET_ADDR_PLAYER = 7;
-    private static final int MSG_NATIVE_REQ_SET_BR_PLAYER = 8;
-    private static final int MSG_NATIVE_REQ_CHANGE_PATH = 9;
-    private static final int MSG_NATIVE_REQ_PLAY_ITEM = 10;
-    private static final int MSG_NATIVE_REQ_GET_ITEM_ATTR = 11;
-    private static final int MSG_NATIVE_REQ_GET_TOTAL_NUM_OF_ITEMS = 12;
-    private static final int MSG_NATIVE_REQ_PASS_THROUGH = 13;
-
-    /* other AVRC messages */
-    private static final int MSG_PLAY_INTERVAL_TIMEOUT = 14;
-    private static final int MSG_SET_ABSOLUTE_VOLUME = 16;
-    private static final int MSG_ABS_VOL_TIMEOUT = 17;
-    private static final int MSG_SET_A2DP_AUDIO_STATE = 18;
-    private static final int MSG_NOW_PLAYING_CHANGED_RSP = 19;
-
-    private static final int CMD_TIMEOUT_DELAY = 2000;
-    private static final int MAX_ERROR_RETRY_TIMES = 6;
-    private static final int AVRCP_MAX_VOL = 127;
-    private static final int AVRCP_BASE_VOLUME_STEP = 1;
-
-    /* Communicates with MediaPlayer to fetch media content */
-    private BrowsedMediaPlayer mBrowsedMediaPlayer;
-
-    /* Addressed player handling */
-    private AddressedMediaPlayer mAddressedMediaPlayer;
-
-    /* List of Media player instances, useful for retrieving MediaPlayerList or MediaPlayerInfo */
-    private SortedMap<Integer, MediaPlayerInfo> mMediaPlayerInfoList;
-    private boolean mAvailablePlayerViewChanged;
-
-    /* List of media players which supports browse */
-    private List<BrowsePlayerInfo> mBrowsePlayerInfoList;
-
-    /* Manage browsed players */
-    private AvrcpBrowseManager mAvrcpBrowseManager;
-
-    /* Broadcast receiver for device connections intent broadcasts */
-    private final BroadcastReceiver mAvrcpReceiver = new AvrcpServiceBroadcastReceiver();
-    private final BroadcastReceiver mBootReceiver = new AvrcpServiceBootReceiver();
-
-    /* Recording passthrough key dispatches */
-    private static final int PASSTHROUGH_LOG_MAX_SIZE = DEBUG ? 50 : 10;
-    private EvictingQueue<MediaKeyLog> mPassthroughLogs; // Passthorugh keys dispatched
-    private List<MediaKeyLog> mPassthroughPending; // Passthrough keys sent not dispatched yet
-    private int mPassthroughDispatched; // Number of keys dispatched
-
-    private class MediaKeyLog {
-        private long mTimeSent;
-        private long mTimeProcessed;
-        private String mPackage;
-        private KeyEvent mEvent;
-
-        MediaKeyLog(long time, KeyEvent event) {
-            mEvent = event;
-            mTimeSent = time;
-        }
-
-        public boolean addDispatch(long time, KeyEvent event, String packageName) {
-            if (mPackage != null) {
-                return false;
-            }
-            if (event.getAction() != mEvent.getAction()) {
-                return false;
-            }
-            if (event.getKeyCode() != mEvent.getKeyCode()) {
-                return false;
-            }
-            mPackage = packageName;
-            mTimeProcessed = time;
-            return true;
-        }
-
-        @Override
-        public String toString() {
-            StringBuilder sb = new StringBuilder();
-            sb.append(android.text.format.DateFormat.format("MM-dd HH:mm:ss", mTimeSent));
-            sb.append(" " + mEvent.toString());
-            if (mPackage == null) {
-                sb.append(" (undispatched)");
-            } else {
-                sb.append(" to " + mPackage);
-                sb.append(" in " + (mTimeProcessed - mTimeSent) + "ms");
-            }
-            return sb.toString();
-        }
-    }
-
-    static {
-        classInitNative();
-    }
-
-    private Avrcp(Context context) {
-        mMediaAttributes = new MediaAttributes(null);
-        mLastQueueId = MediaSession.QueueItem.UNKNOWN_ID;
-        mCurrentPlayState =
-                new PlaybackState.Builder().setState(PlaybackState.STATE_NONE, -1L, 0.0f).build();
-        mReportedPlayStatus = PLAYSTATUS_ERROR;
-        mA2dpState = BluetoothA2dp.STATE_NOT_PLAYING;
-        mAudioManagerIsPlaying = false;
-        mPlayStatusChangedNT = AvrcpConstants.NOTIFICATION_TYPE_CHANGED;
-        mTrackChangedNT = AvrcpConstants.NOTIFICATION_TYPE_CHANGED;
-        mPlayPosChangedNT = AvrcpConstants.NOTIFICATION_TYPE_CHANGED;
-        mAddrPlayerChangedNT = AvrcpConstants.NOTIFICATION_TYPE_CHANGED;
-        mNowPlayingListChangedNT = AvrcpConstants.NOTIFICATION_TYPE_CHANGED;
-        mPlaybackIntervalMs = 0L;
-        mLastReportedPosition = -1;
-        mNextPosMs = -1;
-        mPrevPosMs = -1;
-        mFeatures = 0;
-        mRemoteVolume = -1;
-        mInitialRemoteVolume = -1;
-        mLastRemoteVolume = -1;
-        mLastDirection = 0;
-        mVolCmdSetInProgress = false;
-        mAbsVolRetryTimes = 0;
-        mLocalVolume = -1;
-        mLastLocalVolume = -1;
-        mAbsVolThreshold = 0;
-        mVolumeMapping = new HashMap<Integer, Integer>();
-        mCurrAddrPlayerID = NO_PLAYER_ID;
-        mReportedPlayerID = mCurrAddrPlayerID;
-        mCurrBrowsePlayerID = 0;
-        mContext = context;
-        mLastUsedPlayerID = 0;
-        mAddressedMediaPlayer = null;
-
-        initNative();
-
-        mMediaSessionManager =
-                (MediaSessionManager) context.getSystemService(Context.MEDIA_SESSION_SERVICE);
-        mAudioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);
-        mAudioStreamMax = mAudioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC);
-        mVolumeStep = Math.max(AVRCP_BASE_VOLUME_STEP, AVRCP_MAX_VOL / mAudioStreamMax);
-
-        Resources resources = context.getResources();
-        if (resources != null) {
-            mAbsVolThreshold =
-                    resources.getInteger(R.integer.a2dp_absolute_volume_initial_threshold);
-
-            // Update the threshold if the thresholdPercent is valid
-            int thresholdPercent =
-                    resources.getInteger(R.integer.a2dp_absolute_volume_initial_threshold_percent);
-            if (thresholdPercent >= 0 && thresholdPercent <= 100) {
-                mAbsVolThreshold = (thresholdPercent * mAudioStreamMax) / 100;
-            }
-        }
-
-        // Register for package removal intent broadcasts for media button receiver persistence
-        IntentFilter pkgFilter = new IntentFilter();
-        pkgFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);
-        pkgFilter.addAction(Intent.ACTION_PACKAGE_ADDED);
-        pkgFilter.addAction(Intent.ACTION_PACKAGE_CHANGED);
-        pkgFilter.addAction(Intent.ACTION_PACKAGE_DATA_CLEARED);
-        pkgFilter.addDataScheme("package");
-        context.registerReceiver(mAvrcpReceiver, pkgFilter);
-
-        IntentFilter bootFilter = new IntentFilter();
-        bootFilter.addAction(Intent.ACTION_USER_UNLOCKED);
-        context.registerReceiver(mBootReceiver, bootFilter);
-    }
-
-    private synchronized void start() {
-        HandlerThread thread = new HandlerThread("BluetoothAvrcpHandler");
-        thread.start();
-        Looper looper = thread.getLooper();
-        mHandler = new AvrcpMessageHandler(looper);
-        mAudioManagerPlaybackHandler = new Handler(looper);
-        mAudioManagerPlaybackCb = new AudioManagerPlaybackListener();
-        mMediaControllerCb = new MediaControllerListener();
-        mAvrcpMediaRsp = new AvrcpMediaRsp();
-        mMediaPlayerInfoList = new TreeMap<Integer, MediaPlayerInfo>();
-        mAvailablePlayerViewChanged = false;
-        mBrowsePlayerInfoList = Collections.synchronizedList(new ArrayList<BrowsePlayerInfo>());
-        mPassthroughDispatched = 0;
-        mPassthroughLogs = new EvictingQueue<MediaKeyLog>(PASSTHROUGH_LOG_MAX_SIZE);
-        mPassthroughPending = Collections.synchronizedList(new ArrayList<MediaKeyLog>());
-        if (mMediaSessionManager != null) {
-            mMediaSessionManager.addOnActiveSessionsChangedListener(mActiveSessionListener, null,
-                    mHandler);
-            mMediaSessionManager.setCallback(mButtonDispatchCallback, null);
-        }
-        mPackageManager = mContext.getApplicationContext().getPackageManager();
-
-        /* create object to communicate with addressed player */
-        mAddressedMediaPlayer = new AddressedMediaPlayer(mAvrcpMediaRsp);
-
-        /* initialize BrowseMananger which manages Browse commands and response */
-        mAvrcpBrowseManager = new AvrcpBrowseManager(mContext, mAvrcpMediaRsp);
-
-        initMediaPlayersList();
-
-        UserManager manager = UserManager.get(mContext);
-        if (manager == null || manager.isUserUnlocked()) {
-            if (DEBUG) {
-                Log.d(TAG, "User already unlocked, initializing player lists");
-            }
-            // initialize browsable player list and build media player list
-            buildBrowsablePlayerList();
-        }
-
-        mAudioManager.registerAudioPlaybackCallback(mAudioManagerPlaybackCb,
-                mAudioManagerPlaybackHandler);
-    }
-
-    public static Avrcp make(Context context) {
-        if (DEBUG) {
-            Log.v(TAG, "make");
-        }
-        Avrcp ar = new Avrcp(context);
-        ar.start();
-        return ar;
-    }
-
-    public synchronized void doQuit() {
-        if (DEBUG) {
-            Log.d(TAG, "doQuit");
-        }
-        if (mAudioManager != null) {
-            mAudioManager.unregisterAudioPlaybackCallback(mAudioManagerPlaybackCb);
-        }
-        if (mMediaController != null) {
-            mMediaController.unregisterCallback(mMediaControllerCb);
-        }
-        if (mMediaSessionManager != null) {
-            mMediaSessionManager.setCallback(null, null);
-            mMediaSessionManager.removeOnActiveSessionsChangedListener(mActiveSessionListener);
-        }
-
-        mAudioManagerPlaybackHandler.removeCallbacksAndMessages(null);
-        mHandler.removeCallbacksAndMessages(null);
-        Looper looper = mHandler.getLooper();
-        mHandler = null;
-        if (looper != null) {
-            looper.quitSafely();
-        }
-
-        mAudioManagerPlaybackHandler = null;
-        mContext.unregisterReceiver(mAvrcpReceiver);
-        mContext.unregisterReceiver(mBootReceiver);
-
-        mAddressedMediaPlayer.cleanup();
-        mAvrcpBrowseManager.cleanup();
-    }
-
-    public void cleanup() {
-        if (DEBUG) {
-            Log.d(TAG, "cleanup");
-        }
-        cleanupNative();
-        if (mVolumeMapping != null) {
-            mVolumeMapping.clear();
-        }
-    }
-
-    private class AudioManagerPlaybackListener extends AudioManager.AudioPlaybackCallback {
-        @Override
-        public void onPlaybackConfigChanged(List<AudioPlaybackConfiguration> configs) {
-            super.onPlaybackConfigChanged(configs);
-            boolean isPlaying = false;
-            for (AudioPlaybackConfiguration config : configs) {
-                if (DEBUG) {
-                    Log.d(TAG, "AudioManager Player: "
-                            + AudioPlaybackConfiguration.toLogFriendlyString(config));
-                }
-                if (config.getPlayerState() == AudioPlaybackConfiguration.PLAYER_STATE_STARTED) {
-                    isPlaying = true;
-                    break;
-                }
-            }
-            if (DEBUG) {
-                Log.d(TAG, "AudioManager isPlaying: " + isPlaying);
-            }
-            if (mAudioManagerIsPlaying != isPlaying) {
-                mAudioManagerIsPlaying = isPlaying;
-                updateCurrentMediaState();
-            }
-        }
-    }
-
-    private class MediaControllerListener extends MediaController.Callback {
-        @Override
-        public void onMetadataChanged(MediaMetadata metadata) {
-            if (DEBUG) {
-                Log.v(TAG, "onMetadataChanged");
-            }
-            updateCurrentMediaState();
-        }
-
-        @Override
-        public synchronized void onPlaybackStateChanged(PlaybackState state) {
-            if (DEBUG) {
-                Log.v(TAG, "onPlaybackStateChanged: state " + state.toString());
-            }
-
-            updateCurrentMediaState();
-        }
-
-        @Override
-        public void onSessionDestroyed() {
-            Log.v(TAG, "MediaController session destroyed");
-            synchronized (Avrcp.this) {
-                if (mMediaController != null) {
-                    removeMediaController(mMediaController.getWrappedInstance());
-                }
-            }
-        }
-
-        @Override
-        public void onQueueChanged(List<MediaSession.QueueItem> queue) {
-            if (queue == null) {
-                Log.v(TAG, "onQueueChanged: received null queue");
-                return;
-            }
-
-            final AvrcpMessageHandler handler = mHandler;
-            if (handler == null) {
-                if (DEBUG) Log.d(TAG, "onQueueChanged: mHandler is already null");
-                return;
-            }
-
-            Log.v(TAG, "onQueueChanged: NowPlaying list changed, Queue Size = "
-                    + queue.size());
-            handler.sendEmptyMessage(MSG_NOW_PLAYING_CHANGED_RSP);
-        }
-    }
-
-    /** Handles Avrcp messages. */
-    private final class AvrcpMessageHandler extends Handler {
-        private AvrcpMessageHandler(Looper looper) {
-            super(looper);
-        }
-
-        @Override
-        public void handleMessage(Message msg) {
-            switch (msg.what) {
-                case MSG_NATIVE_REQ_GET_RC_FEATURES: {
-                    String address = (String) msg.obj;
-                    mFeatures = msg.arg1;
-                    mFeatures = modifyRcFeatureFromBlacklist(mFeatures, address);
-                    if (DEBUG) {
-                        Log.v(TAG,
-                                "MSG_NATIVE_REQ_GET_RC_FEATURES: address=" + address + ", features="
-                                        + msg.arg1 + ", mFeatures=" + mFeatures);
-                    }
-                    mAudioManager.avrcpSupportsAbsoluteVolume(address, isAbsoluteVolumeSupported());
-                    mLastLocalVolume = -1;
-                    mRemoteVolume = -1;
-                    mLocalVolume = -1;
-                    mInitialRemoteVolume = -1;
-                    mAddress = address;
-                    if (mVolumeMapping != null) {
-                        mVolumeMapping.clear();
-                    }
-                    break;
-                }
-
-                case MSG_NATIVE_REQ_GET_PLAY_STATUS: {
-                    byte[] address = (byte[]) msg.obj;
-                    int btstate = getBluetoothPlayState(mCurrentPlayState);
-                    int length = (int) mMediaAttributes.getLength();
-                    int position = (int) getPlayPosition();
-                    if (DEBUG) {
-                        Log.v(TAG,
-                                "MSG_NATIVE_REQ_GET_PLAY_STATUS, responding with state " + btstate
-                                        + " len " + length + " pos " + position);
-                    }
-                    getPlayStatusRspNative(address, btstate, length, position);
-                    break;
-                }
-
-                case MSG_NATIVE_REQ_GET_ELEM_ATTRS: {
-                    String[] textArray;
-                    AvrcpCmd.ElementAttrCmd elem = (AvrcpCmd.ElementAttrCmd) msg.obj;
-                    byte numAttr = elem.mNumAttr;
-                    int[] attrIds = elem.mAttrIDs;
-                    if (DEBUG) {
-                        Log.v(TAG, "MSG_NATIVE_REQ_GET_ELEM_ATTRS:numAttr=" + numAttr);
-                    }
-                    textArray = new String[numAttr];
-                    StringBuilder responseDebug = new StringBuilder();
-                    responseDebug.append("getElementAttr response: ");
-                    for (int i = 0; i < numAttr; ++i) {
-                        textArray[i] = mMediaAttributes.getString(attrIds[i]);
-                        responseDebug.append("[" + attrIds[i] + "=");
-                        if (attrIds[i] == AvrcpConstants.ATTRID_TITLE
-                                || attrIds[i] == AvrcpConstants.ATTRID_ARTIST
-                                || attrIds[i] == AvrcpConstants.ATTRID_ALBUM) {
-                            responseDebug.append(Utils.ellipsize(textArray[i]) + "] ");
-                        } else {
-                            responseDebug.append(textArray[i] + "] ");
-                        }
-                    }
-                    Log.v(TAG, responseDebug.toString());
-                    byte[] bdaddr = elem.mAddress;
-                    getElementAttrRspNative(bdaddr, numAttr, attrIds, textArray);
-                    break;
-                }
-
-                case MSG_NATIVE_REQ_REGISTER_NOTIFICATION:
-                    if (DEBUG) {
-                        Log.v(TAG,
-                                "MSG_NATIVE_REQ_REGISTER_NOTIFICATION:event=" + msg.arg1 + " param="
-                                        + msg.arg2);
-                    }
-                    processRegisterNotification((byte[]) msg.obj, msg.arg1, msg.arg2);
-                    break;
-
-                case MSG_NOW_PLAYING_CHANGED_RSP:
-                    if (DEBUG) {
-                        Log.v(TAG, "MSG_NOW_PLAYING_CHANGED_RSP");
-                    }
-                    removeMessages(MSG_NOW_PLAYING_CHANGED_RSP);
-                    updateCurrentMediaState();
-                    break;
-
-                case MSG_PLAY_INTERVAL_TIMEOUT:
-                    sendPlayPosNotificationRsp(false);
-                    break;
-
-                case MSG_NATIVE_REQ_VOLUME_CHANGE:
-                    if (!isAbsoluteVolumeSupported()) {
-                        if (DEBUG) {
-                            Log.v(TAG, "MSG_NATIVE_REQ_VOLUME_CHANGE ignored, not supported");
-                        }
-                        break;
-                    }
-                    byte absVol = (byte) ((byte) msg.arg1 & 0x7f); // discard MSB as it is RFD
-                    if (DEBUG) {
-                        Log.v(TAG, "MSG_NATIVE_REQ_VOLUME_CHANGE: volume=" + absVol + " ctype="
-                                + msg.arg2);
-                    }
-
-                    if (msg.arg2 == AVRC_RSP_ACCEPT || msg.arg2 == AVRC_RSP_REJ) {
-                        if (!mVolCmdSetInProgress) {
-                            Log.e(TAG, "Unsolicited response, ignored");
-                            break;
-                        }
-                        removeMessages(MSG_ABS_VOL_TIMEOUT);
-
-                        mVolCmdSetInProgress = false;
-                        mAbsVolRetryTimes = 0;
-                    }
-
-                    // convert remote volume to local volume
-                    int volIndex = convertToAudioStreamVolume(absVol);
-                    if (mInitialRemoteVolume == -1) {
-                        mInitialRemoteVolume = absVol;
-                        if (mAbsVolThreshold > 0 && mAbsVolThreshold < mAudioStreamMax
-                                && volIndex > mAbsVolThreshold) {
-                            if (DEBUG) {
-                                Log.v(TAG, "remote inital volume too high " + volIndex + ">"
-                                        + mAbsVolThreshold);
-                            }
-                            Message msg1 = this.obtainMessage(MSG_SET_ABSOLUTE_VOLUME,
-                                    mAbsVolThreshold, 0);
-                            this.sendMessage(msg1);
-                            mRemoteVolume = absVol;
-                            mLocalVolume = volIndex;
-                            break;
-                        }
-                    }
-
-                    if (mLocalVolume != volIndex && (msg.arg2 == AVRC_RSP_ACCEPT
-                            || msg.arg2 == AVRC_RSP_CHANGED || msg.arg2 == AVRC_RSP_INTERIM)) {
-                    /* If the volume has successfully changed */
-                        mLocalVolume = volIndex;
-                        if (mLastLocalVolume != -1 && msg.arg2 == AVRC_RSP_ACCEPT) {
-                            if (mLastLocalVolume != volIndex) {
-                            /* remote volume changed more than requested due to
-                             * local and remote has different volume steps */
-                                if (DEBUG) {
-                                    Log.d(TAG,
-                                            "Remote returned volume does not match desired volume "
-                                                    + mLastLocalVolume + " vs " + volIndex);
-                                }
-                                mLastLocalVolume = mLocalVolume;
-                            }
-                        }
-
-                        notifyVolumeChanged(mLocalVolume);
-                        mRemoteVolume = absVol;
-                        long pecentVolChanged = ((long) absVol * 100) / 0x7f;
-                        Log.e(TAG, "percent volume changed: " + pecentVolChanged + "%");
-                    } else if (msg.arg2 == AVRC_RSP_REJ) {
-                        Log.e(TAG, "setAbsoluteVolume call rejected");
-                    }
-                    break;
-
-                case MSG_SET_ABSOLUTE_VOLUME:
-                    if (!isAbsoluteVolumeSupported()) {
-                        if (DEBUG) {
-                            Log.v(TAG, "ignore MSG_SET_ABSOLUTE_VOLUME");
-                        }
-                        break;
-                    }
-
-                    if (DEBUG) {
-                        Log.v(TAG, "MSG_SET_ABSOLUTE_VOLUME");
-                    }
-
-                    if (mVolCmdSetInProgress) {
-                        if (DEBUG) {
-                            Log.w(TAG, "There is already a volume command in progress.");
-                        }
-                        break;
-                    }
-
-                    // Remote device didn't set initial volume. Let's black list it
-                    if (mInitialRemoteVolume == -1) {
-                        if (DEBUG) {
-                            Log.d(TAG, "remote " + mAddress
-                                    + " never tell us initial volume, black list it.");
-                        }
-                        blackListCurrentDevice("MSG_SET_ABSOLUTE_VOLUME");
-                        break;
-                    }
-
-                    int avrcpVolume = convertToAvrcpVolume(msg.arg1);
-                    avrcpVolume = Math.min(AVRCP_MAX_VOL, Math.max(0, avrcpVolume));
-                    if (DEBUG) {
-                        Log.d(TAG, "Setting volume to " + msg.arg1 + "-" + avrcpVolume);
-                    }
-                    if (setVolumeNative(avrcpVolume)) {
-                        sendMessageDelayed(obtainMessage(MSG_ABS_VOL_TIMEOUT), CMD_TIMEOUT_DELAY);
-                        mVolCmdSetInProgress = true;
-                        mLastRemoteVolume = avrcpVolume;
-                        mLastLocalVolume = msg.arg1;
-                    } else {
-                        if (DEBUG) {
-                            Log.d(TAG, "setVolumeNative failed");
-                        }
-                    }
-                    break;
-
-                case MSG_ABS_VOL_TIMEOUT:
-                    if (DEBUG) {
-                        Log.v(TAG, "MSG_ABS_VOL_TIMEOUT: Volume change cmd timed out.");
-                    }
-                    mVolCmdSetInProgress = false;
-                    if (mAbsVolRetryTimes >= MAX_ERROR_RETRY_TIMES) {
-                        mAbsVolRetryTimes = 0;
-                    /* too many volume change failures, black list the device */
-                        blackListCurrentDevice("MSG_ABS_VOL_TIMEOUT");
-                    } else {
-                        mAbsVolRetryTimes += 1;
-                        if (setVolumeNative(mLastRemoteVolume)) {
-                            sendMessageDelayed(obtainMessage(MSG_ABS_VOL_TIMEOUT),
-                                    CMD_TIMEOUT_DELAY);
-                            mVolCmdSetInProgress = true;
-                        }
-                    }
-                    break;
-
-                case MSG_SET_A2DP_AUDIO_STATE:
-                    if (DEBUG) {
-                        Log.v(TAG, "MSG_SET_A2DP_AUDIO_STATE:" + msg.arg1);
-                    }
-                    mA2dpState = msg.arg1;
-                    updateCurrentMediaState();
-                    break;
-
-                case MSG_NATIVE_REQ_GET_FOLDER_ITEMS: {
-                    AvrcpCmd.FolderItemsCmd folderObj = (AvrcpCmd.FolderItemsCmd) msg.obj;
-                    if (DEBUG) {
-                        Log.v(TAG, "MSG_NATIVE_REQ_GET_FOLDER_ITEMS " + folderObj);
-                    }
-                    switch (folderObj.mScope) {
-                        case AvrcpConstants.BTRC_SCOPE_PLAYER_LIST:
-                            handleMediaPlayerListRsp(folderObj);
-                            break;
-                        case AvrcpConstants.BTRC_SCOPE_FILE_SYSTEM:
-                        case AvrcpConstants.BTRC_SCOPE_NOW_PLAYING:
-                            handleGetFolderItemBrowseResponse(folderObj, folderObj.mAddress);
-                            break;
-                        default:
-                            Log.e(TAG, "unknown scope for getfolderitems. scope = "
-                                    + folderObj.mScope);
-                            getFolderItemsRspNative(folderObj.mAddress,
-                                    AvrcpConstants.RSP_INV_SCOPE, (short) 0, (byte) 0, 0, null,
-                                    null, null, null, null, null, null, null);
-                    }
-                    break;
-                }
-
-                case MSG_NATIVE_REQ_SET_ADDR_PLAYER:
-                    // object is bdaddr, argument 1 is the selected player id
-                    if (DEBUG) {
-                        Log.v(TAG, "MSG_NATIVE_REQ_SET_ADDR_PLAYER id=" + msg.arg1);
-                    }
-                    setAddressedPlayer((byte[]) msg.obj, msg.arg1);
-                    break;
-
-                case MSG_NATIVE_REQ_GET_ITEM_ATTR:
-                    // msg object contains the item attribute object
-                    AvrcpCmd.ItemAttrCmd cmd = (AvrcpCmd.ItemAttrCmd) msg.obj;
-                    if (DEBUG) {
-                        Log.v(TAG, "MSG_NATIVE_REQ_GET_ITEM_ATTR " + cmd);
-                    }
-                    handleGetItemAttr(cmd);
-                    break;
-
-                case MSG_NATIVE_REQ_SET_BR_PLAYER:
-                    // argument 1 is the selected player id
-                    if (DEBUG) {
-                        Log.v(TAG, "MSG_NATIVE_REQ_SET_BR_PLAYER id=" + msg.arg1);
-                    }
-                    setBrowsedPlayer((byte[]) msg.obj, msg.arg1);
-                    break;
-
-                case MSG_NATIVE_REQ_CHANGE_PATH: {
-                    if (DEBUG) {
-                        Log.v(TAG, "MSG_NATIVE_REQ_CHANGE_PATH");
-                    }
-                    Bundle data = msg.getData();
-                    byte[] bdaddr = data.getByteArray("BdAddress");
-                    byte[] folderUid = data.getByteArray("folderUid");
-                    byte direction = data.getByte("direction");
-                    if (mAvrcpBrowseManager.getBrowsedMediaPlayer(bdaddr) != null) {
-                        mAvrcpBrowseManager.getBrowsedMediaPlayer(bdaddr)
-                                .changePath(folderUid, direction);
-                    } else {
-                        Log.e(TAG, "Remote requesting change path before setbrowsedplayer");
-                        changePathRspNative(bdaddr, AvrcpConstants.RSP_BAD_CMD, 0);
-                    }
-                    break;
-                }
-
-                case MSG_NATIVE_REQ_PLAY_ITEM: {
-                    Bundle data = msg.getData();
-                    byte[] bdaddr = data.getByteArray("BdAddress");
-                    byte[] uid = data.getByteArray("uid");
-                    byte scope = data.getByte("scope");
-                    if (DEBUG) {
-                        Log.v(TAG, "MSG_NATIVE_REQ_PLAY_ITEM scope=" + scope + " id="
-                                + Utils.byteArrayToString(uid));
-                    }
-                    handlePlayItemResponse(bdaddr, uid, scope);
-                    break;
-                }
-
-                case MSG_NATIVE_REQ_GET_TOTAL_NUM_OF_ITEMS:
-                    if (DEBUG) {
-                        Log.v(TAG, "MSG_NATIVE_REQ_GET_TOTAL_NUM_OF_ITEMS scope=" + msg.arg1);
-                    }
-                    // argument 1 is scope, object is bdaddr
-                    handleGetTotalNumOfItemsResponse((byte[]) msg.obj, (byte) msg.arg1);
-                    break;
-
-                case MSG_NATIVE_REQ_PASS_THROUGH:
-                    if (DEBUG) {
-                        Log.v(TAG,
-                                "MSG_NATIVE_REQ_PASS_THROUGH: id=" + msg.arg1 + " st=" + msg.arg2);
-                    }
-                    // argument 1 is id, argument 2 is keyState
-                    handlePassthroughCmd(msg.arg1, msg.arg2);
-                    break;
-
-                default:
-                    Log.e(TAG, "unknown message! msg.what=" + msg.what);
-                    break;
-            }
-        }
-    }
-
-    private PlaybackState updatePlaybackState() {
-        PlaybackState newState = new PlaybackState.Builder().setState(PlaybackState.STATE_NONE,
-                PlaybackState.PLAYBACK_POSITION_UNKNOWN, 0.0f).build();
-        synchronized (this) {
-            PlaybackState controllerState = null;
-            if (mMediaController != null) {
-                controllerState = mMediaController.getPlaybackState();
-            }
-
-            if (controllerState != null) {
-                newState = controllerState;
-            }
-            // Use the AudioManager to update the playback state.
-            // NOTE: We cannot use the
-            //    (mA2dpState == BluetoothA2dp.STATE_PLAYING)
-            // check, because after Pause, the A2DP state remains in
-            // STATE_PLAYING for 3 more seconds.
-            // As a result of that, if we pause the music, on carkits the
-            // Play status indicator will continue to display "Playing"
-            // for 3 more seconds which can be confusing.
-            if ((mAudioManagerIsPlaying && newState.getState() != PlaybackState.STATE_PLAYING) || (
-                    controllerState == null && mAudioManager != null
-                            && mAudioManager.isMusicActive())) {
-                // Use AudioManager playback state if we don't have the state
-                // from MediaControlller
-                PlaybackState.Builder builder = new PlaybackState.Builder();
-                if (mAudioManagerIsPlaying) {
-                    builder.setState(PlaybackState.STATE_PLAYING,
-                            PlaybackState.PLAYBACK_POSITION_UNKNOWN, 1.0f);
-                } else {
-                    builder.setState(PlaybackState.STATE_PAUSED,
-                            PlaybackState.PLAYBACK_POSITION_UNKNOWN, 0.0f);
-                }
-                newState = builder.build();
-            }
-        }
-
-        byte newPlayStatus = getBluetoothPlayState(newState);
-
-        /* update play status in global media player list */
-        MediaPlayerInfo player = getAddressedPlayerInfo();
-        if (player != null) {
-            player.setPlayStatus(newPlayStatus);
-        }
-
-        if (DEBUG) {
-            Log.v(TAG, "updatePlaybackState (" + mPlayStatusChangedNT + "): " + mReportedPlayStatus
-                    + "➡" + newPlayStatus + "(" + newState + ")");
-        }
-
-        if (newState != null) {
-            mCurrentPlayState = newState;
-        }
-
-        return mCurrentPlayState;
-    }
-
-    private void sendPlaybackStatus(int playStatusChangedNT, byte playbackState) {
-        registerNotificationRspPlayStatusNative(playStatusChangedNT, playbackState);
-        mPlayStatusChangedNT = playStatusChangedNT;
-        mReportedPlayStatus = playbackState;
-    }
-
-    private void updateTransportControls(int transportControlFlags) {
-        mTransportControlFlags = transportControlFlags;
-    }
-
-    class MediaAttributes {
-        private boolean mExists;
-        private String mTitle;
-        private String mArtistName;
-        private String mAlbumName;
-        private String mMediaNumber;
-        private String mMediaTotalNumber;
-        private String mGenre;
-        private long mPlayingTimeMs;
-
-        private static final int ATTR_TITLE = 1;
-        private static final int ATTR_ARTIST_NAME = 2;
-        private static final int ATTR_ALBUM_NAME = 3;
-        private static final int ATTR_MEDIA_NUMBER = 4;
-        private static final int ATTR_MEDIA_TOTAL_NUMBER = 5;
-        private static final int ATTR_GENRE = 6;
-        private static final int ATTR_PLAYING_TIME_MS = 7;
-
-
-        MediaAttributes(MediaMetadata data) {
-            mExists = data != null;
-            if (!mExists) {
-                return;
-            }
-
-            mArtistName = stringOrBlank(data.getString(MediaMetadata.METADATA_KEY_ARTIST));
-            mAlbumName = stringOrBlank(data.getString(MediaMetadata.METADATA_KEY_ALBUM));
-            mMediaNumber = longStringOrBlank(data.getLong(MediaMetadata.METADATA_KEY_TRACK_NUMBER));
-            mMediaTotalNumber =
-                    longStringOrBlank(data.getLong(MediaMetadata.METADATA_KEY_NUM_TRACKS));
-            mGenre = stringOrBlank(data.getString(MediaMetadata.METADATA_KEY_GENRE));
-            mPlayingTimeMs = data.getLong(MediaMetadata.METADATA_KEY_DURATION);
-
-            // Try harder for the title.
-            mTitle = data.getString(MediaMetadata.METADATA_KEY_TITLE);
-
-            if (mTitle == null) {
-                MediaDescription desc = data.getDescription();
-                if (desc != null) {
-                    CharSequence val = desc.getDescription();
-                    if (val != null) {
-                        mTitle = val.toString();
-                    }
-                }
-            }
-
-            if (mTitle == null) {
-                mTitle = new String();
-            }
-        }
-
-        public long getLength() {
-            if (!mExists) {
-                return 0L;
-            }
-            return mPlayingTimeMs;
-        }
-
-        public boolean equals(MediaAttributes other) {
-            if (other == null) {
-                return false;
-            }
-
-            if (mExists != other.mExists) {
-                return false;
-            }
-
-            if (!mExists) {
-                return true;
-            }
-
-            return (mTitle.equals(other.mTitle)) && (mArtistName.equals(other.mArtistName))
-                    && (mAlbumName.equals(other.mAlbumName)) && (mMediaNumber.equals(
-                    other.mMediaNumber)) && (mMediaTotalNumber.equals(other.mMediaTotalNumber))
-                    && (mGenre.equals(other.mGenre)) && (mPlayingTimeMs == other.mPlayingTimeMs);
-        }
-
-        public String getString(int attrId) {
-            if (!mExists) {
-                return new String();
-            }
-
-            switch (attrId) {
-                case ATTR_TITLE:
-                    return mTitle;
-                case ATTR_ARTIST_NAME:
-                    return mArtistName;
-                case ATTR_ALBUM_NAME:
-                    return mAlbumName;
-                case ATTR_MEDIA_NUMBER:
-                    return mMediaNumber;
-                case ATTR_MEDIA_TOTAL_NUMBER:
-                    return mMediaTotalNumber;
-                case ATTR_GENRE:
-                    return mGenre;
-                case ATTR_PLAYING_TIME_MS:
-                    return Long.toString(mPlayingTimeMs);
-                default:
-                    return new String();
-            }
-        }
-
-        private String stringOrBlank(String s) {
-            return s == null ? new String() : s;
-        }
-
-        private String longStringOrBlank(Long s) {
-            return s == null ? new String() : s.toString();
-        }
-
-        @Override
-        public String toString() {
-            if (!mExists) {
-                return "[MediaAttributes: none]";
-            }
-
-            return "[MediaAttributes: " + mTitle + " - " + mAlbumName + " by " + mArtistName + " ("
-                    + mPlayingTimeMs + " " + mMediaNumber + "/" + mMediaTotalNumber + ") " + mGenre
-                    + "]";
-        }
-
-        public String toRedactedString() {
-            if (!mExists) {
-                return "[MediaAttributes: none]";
-            }
-
-            return "[MediaAttributes: " + Utils.ellipsize(mTitle) + " - " + Utils.ellipsize(
-                    mAlbumName) + " by " + Utils.ellipsize(mArtistName) + " (" + mPlayingTimeMs
-                    + " " + mMediaNumber + "/" + mMediaTotalNumber + ") " + mGenre + "]";
-        }
-    }
-
-    private void updateCurrentMediaState() {
-        // Only do player updates when we aren't registering for track changes.
-        MediaAttributes currentAttributes;
-        PlaybackState newState = updatePlaybackState();
-
-        synchronized (this) {
-            if (mMediaController == null) {
-                currentAttributes = new MediaAttributes(null);
-            } else {
-                currentAttributes = new MediaAttributes(mMediaController.getMetadata());
-            }
-        }
-
-        byte newPlayStatus = getBluetoothPlayState(newState);
-
-        if (newState.getState() != PlaybackState.STATE_BUFFERING
-                && newState.getState() != PlaybackState.STATE_NONE) {
-            long newQueueId = MediaSession.QueueItem.UNKNOWN_ID;
-            if (newState != null) {
-                newQueueId = newState.getActiveQueueItemId();
-            }
-            if (DEBUG) {
-                Log.v(TAG,
-                        "Media update: id " + mLastQueueId + "➡" + newQueueId + "? " + currentAttributes
-                                .toRedactedString() + " : " + mMediaAttributes.toRedactedString());
-            }
-
-            if (mAvailablePlayerViewChanged) {
-                registerNotificationRspAvalPlayerChangedNative(
-                        AvrcpConstants.NOTIFICATION_TYPE_CHANGED);
-                mAvailablePlayerViewChanged = false;
-                return;
-            }
-
-            if (mAddrPlayerChangedNT == AvrcpConstants.NOTIFICATION_TYPE_INTERIM
-                    && mReportedPlayerID != mCurrAddrPlayerID) {
-                registerNotificationRspAvalPlayerChangedNative(
-                        AvrcpConstants.NOTIFICATION_TYPE_CHANGED);
-                registerNotificationRspAddrPlayerChangedNative(
-                        AvrcpConstants.NOTIFICATION_TYPE_CHANGED, mCurrAddrPlayerID, sUIDCounter);
-
-                mAvailablePlayerViewChanged = false;
-                mAddrPlayerChangedNT = AvrcpConstants.NOTIFICATION_TYPE_CHANGED;
-                mReportedPlayerID = mCurrAddrPlayerID;
-
-                // Update the now playing list without sending the notification
-                mNowPlayingListChangedNT = AvrcpConstants.NOTIFICATION_TYPE_CHANGED;
-                mAddressedMediaPlayer.updateNowPlayingList(mMediaController);
-                mNowPlayingListChangedNT = AvrcpConstants.NOTIFICATION_TYPE_INTERIM;
-            }
-
-            // Dont send now playing list changed if the player doesn't support browsing
-            MediaPlayerInfo info = getAddressedPlayerInfo();
-            if (info != null && info.isBrowseSupported()) {
-                if (DEBUG) {
-                    Log.v(TAG, "Check if NowPlayingList is updated");
-                }
-                mAddressedMediaPlayer.updateNowPlayingList(mMediaController);
-            }
-
-            // Notify track changed if:
-            //  - The CT is registered for the notification
-            //  - Queue ID is UNKNOWN and MediaMetadata is different
-            //  - Queue ID is valid and different from last Queue ID sent
-            if ((newQueueId == -1 || newQueueId != mLastQueueId)
-                    && mTrackChangedNT == AvrcpConstants.NOTIFICATION_TYPE_INTERIM
-                    && !currentAttributes.equals(mMediaAttributes)
-                    && newPlayStatus == PLAYSTATUS_PLAYING) {
-                Log.v(TAG, "Send track changed");
-                mMediaAttributes = currentAttributes;
-                mLastQueueId = newQueueId;
-                sendTrackChangedRsp(false);
-            }
-        } else {
-            Log.i(TAG, "Skipping update due to invalid playback state");
-        }
-
-        // still send the updated play state if the playback state is none or buffering
-        if (DEBUG) {
-            Log.v(TAG, "play status change " + mReportedPlayStatus + "➡" + newPlayStatus
-                    + " mPlayStatusChangedNT: " + mPlayStatusChangedNT);
-        }
-        if (mPlayStatusChangedNT == AvrcpConstants.NOTIFICATION_TYPE_INTERIM || (mReportedPlayStatus
-                != newPlayStatus)) {
-            sendPlaybackStatus(AvrcpConstants.NOTIFICATION_TYPE_CHANGED, newPlayStatus);
-        }
-
-        sendPlayPosNotificationRsp(false);
-    }
-
-    private void getRcFeaturesRequestFromNative(byte[] address, int features) {
-        final AvrcpMessageHandler handler = mHandler;
-        if (handler == null) {
-            if (DEBUG) Log.d(TAG, "getRcFeaturesRequestFromNative: mHandler is already null");
-            return;
-        }
-
-        Message msg = handler.obtainMessage(MSG_NATIVE_REQ_GET_RC_FEATURES, features, 0,
-                Utils.getAddressStringFromByte(address));
-        handler.sendMessage(msg);
-    }
-
-    private void getPlayStatusRequestFromNative(byte[] address) {
-        final AvrcpMessageHandler handler = mHandler;
-        if (handler == null) {
-            if (DEBUG) Log.d(TAG, "getPlayStatusRequestFromNative: mHandler is already null");
-            return;
-        }
-
-        Message msg = handler.obtainMessage(MSG_NATIVE_REQ_GET_PLAY_STATUS);
-        msg.obj = address;
-        handler.sendMessage(msg);
-    }
-
-    private void getElementAttrRequestFromNative(byte[] address, byte numAttr, int[] attrs) {
-        AvrcpCmd avrcpCmdobj = new AvrcpCmd();
-        AvrcpCmd.ElementAttrCmd elemAttr = avrcpCmdobj.new ElementAttrCmd(address, numAttr, attrs);
-        Message msg = mHandler.obtainMessage(MSG_NATIVE_REQ_GET_ELEM_ATTRS);
-        msg.obj = elemAttr;
-        mHandler.sendMessage(msg);
-    }
-
-    private void registerNotificationRequestFromNative(byte[] address, int eventId, int param) {
-        final AvrcpMessageHandler handler = mHandler;
-        if (handler == null) {
-            if (DEBUG) {
-                Log.d(TAG, "registerNotificationRequestFromNative: mHandler is already null");
-            }
-            return;
-        }
-        Message msg = handler.obtainMessage(MSG_NATIVE_REQ_REGISTER_NOTIFICATION, eventId, param);
-        msg.obj = address;
-        handler.sendMessage(msg);
-    }
-
-    private void processRegisterNotification(byte[] address, int eventId, int param) {
-        switch (eventId) {
-            case EVT_PLAY_STATUS_CHANGED:
-                mPlayStatusChangedNT = AvrcpConstants.NOTIFICATION_TYPE_CHANGED;
-                updatePlaybackState();
-                sendPlaybackStatus(AvrcpConstants.NOTIFICATION_TYPE_INTERIM, mReportedPlayStatus);
-                break;
-
-            case EVT_TRACK_CHANGED:
-                Log.v(TAG, "Track changed notification enabled");
-                mTrackChangedNT = AvrcpConstants.NOTIFICATION_TYPE_INTERIM;
-                sendTrackChangedRsp(true);
-                break;
-
-            case EVT_PLAY_POS_CHANGED:
-                mPlayPosChangedNT = AvrcpConstants.NOTIFICATION_TYPE_INTERIM;
-                mPlaybackIntervalMs = (long) param * 1000L;
-                sendPlayPosNotificationRsp(true);
-                break;
-
-            case EVT_AVBL_PLAYERS_CHANGED:
-                /* Notify remote available players changed */
-                if (DEBUG) {
-                    Log.d(TAG, "Available Players notification enabled");
-                }
-                registerNotificationRspAvalPlayerChangedNative(
-                        AvrcpConstants.NOTIFICATION_TYPE_INTERIM);
-                break;
-
-            case EVT_ADDR_PLAYER_CHANGED:
-                /* Notify remote addressed players changed */
-                if (DEBUG) {
-                    Log.d(TAG, "Addressed Player notification enabled");
-                }
-                registerNotificationRspAddrPlayerChangedNative(
-                        AvrcpConstants.NOTIFICATION_TYPE_INTERIM, mCurrAddrPlayerID, sUIDCounter);
-                mAddrPlayerChangedNT = AvrcpConstants.NOTIFICATION_TYPE_INTERIM;
-                mReportedPlayerID = mCurrAddrPlayerID;
-                break;
-
-            case EVENT_UIDS_CHANGED:
-                if (DEBUG) {
-                    Log.d(TAG, "UIDs changed notification enabled");
-                }
-                registerNotificationRspUIDsChangedNative(AvrcpConstants.NOTIFICATION_TYPE_INTERIM,
-                        sUIDCounter);
-                break;
-
-            case EVENT_NOW_PLAYING_CONTENT_CHANGED:
-                if (DEBUG) {
-                    Log.d(TAG, "Now Playing List changed notification enabled");
-                }
-                /* send interim response to remote device */
-                mNowPlayingListChangedNT = AvrcpConstants.NOTIFICATION_TYPE_INTERIM;
-                if (!registerNotificationRspNowPlayingChangedNative(
-                        AvrcpConstants.NOTIFICATION_TYPE_INTERIM)) {
-                    Log.e(TAG, "EVENT_NOW_PLAYING_CONTENT_CHANGED: "
-                            + "registerNotificationRspNowPlayingChangedNative for Interim rsp "
-                            + "failed!");
-                }
-                break;
-        }
-    }
-
-    private void handlePassthroughCmdRequestFromNative(byte[] address, int id, int keyState) {
-        final AvrcpMessageHandler handler = mHandler;
-        if (handler == null) {
-            if (DEBUG) {
-                Log.d(TAG, "handlePassthroughCmdRequestFromNative: mHandler is already null");
-            }
-            return;
-        }
-
-        Message msg = handler.obtainMessage(MSG_NATIVE_REQ_PASS_THROUGH, id, keyState);
-        handler.sendMessage(msg);
-    }
-
-    private void sendTrackChangedRsp(boolean registering) {
-        if (!registering && mTrackChangedNT != AvrcpConstants.NOTIFICATION_TYPE_INTERIM) {
-            if (DEBUG) {
-                Log.d(TAG, "sendTrackChangedRsp: Not registered or registering.");
-            }
-            return;
-        }
-
-        mTrackChangedNT = AvrcpConstants.NOTIFICATION_TYPE_CHANGED;
-        if (registering) {
-            mTrackChangedNT = AvrcpConstants.NOTIFICATION_TYPE_INTERIM;
-        }
-
-        MediaPlayerInfo info = getAddressedPlayerInfo();
-        // for non-browsable players or no player
-        if (info != null && !info.isBrowseSupported()) {
-            byte[] track = AvrcpConstants.TRACK_IS_SELECTED;
-            if (!mMediaAttributes.mExists) {
-                track = AvrcpConstants.NO_TRACK_SELECTED;
-            }
-            registerNotificationRspTrackChangeNative(mTrackChangedNT, track);
-            return;
-        }
-
-        mAddressedMediaPlayer.sendTrackChangeWithId(mTrackChangedNT, mMediaController);
-    }
-
-    private long getPlayPosition() {
-        if (mCurrentPlayState == null) {
-            return -1L;
-        }
-
-        if (mCurrentPlayState.getPosition() == PlaybackState.PLAYBACK_POSITION_UNKNOWN) {
-            return -1L;
-        }
-
-        if (isPlayingState(mCurrentPlayState)) {
-            long sinceUpdate =
-                    (SystemClock.elapsedRealtime() - mCurrentPlayState.getLastPositionUpdateTime());
-            return sinceUpdate + mCurrentPlayState.getPosition();
-        }
-
-        return mCurrentPlayState.getPosition();
-    }
-
-    private boolean isPlayingState(@Nullable PlaybackState state) {
-        if (state == null) {
-            return false;
-        }
-        return (state != null) && (state.getState() == PlaybackState.STATE_PLAYING);
-    }
-
-    /**
-     * Sends a play position notification, or schedules one to be
-     * sent later at an appropriate time. If |requested| is true,
-     * does both because this was called in reponse to a request from the
-     * TG.
-     */
-    private void sendPlayPosNotificationRsp(boolean requested) {
-        if (!requested && mPlayPosChangedNT != AvrcpConstants.NOTIFICATION_TYPE_INTERIM) {
-            if (DEBUG) {
-                Log.d(TAG, "sendPlayPosNotificationRsp: Not registered or requesting.");
-            }
-            return;
-        }
-
-        final AvrcpMessageHandler handler = mHandler;
-        if (handler == null) {
-            if (DEBUG) Log.d(TAG, "sendPlayPosNotificationRsp: handler is already null");
-            return;
-        }
-
-        long playPositionMs = getPlayPosition();
-        String debugLine = "sendPlayPosNotificationRsp: ";
-
-        // mNextPosMs is set to -1 when the previous position was invalid
-        // so this will be true if the new position is valid & old was invalid.
-        // mPlayPositionMs is set to -1 when the new position is invalid,
-        // and the old mPrevPosMs is >= 0 so this is true when the new is invalid
-        // and the old was valid.
-        if (DEBUG) {
-            debugLine += "(" + requested + ") " + mPrevPosMs + " <=? " + playPositionMs + " <=? "
-                    + mNextPosMs;
-            if (isPlayingState(mCurrentPlayState)) {
-                debugLine += " Playing";
-            }
-            debugLine += " State: " + mCurrentPlayState.getState();
-        }
-        if (requested || (
-                (mLastReportedPosition != playPositionMs) && (playPositionMs >= mNextPosMs) || (
-                        playPositionMs <= mPrevPosMs))) {
-            if (!requested) {
-                mPlayPosChangedNT = AvrcpConstants.NOTIFICATION_TYPE_CHANGED;
-            }
-            registerNotificationRspPlayPosNative(mPlayPosChangedNT, (int) playPositionMs);
-            mLastReportedPosition = playPositionMs;
-            if (playPositionMs != PlaybackState.PLAYBACK_POSITION_UNKNOWN) {
-                mNextPosMs = playPositionMs + mPlaybackIntervalMs;
-                mPrevPosMs = playPositionMs - mPlaybackIntervalMs;
-            } else {
-                mNextPosMs = -1;
-                mPrevPosMs = -1;
-            }
-        }
-
-        handler.removeMessages(MSG_PLAY_INTERVAL_TIMEOUT);
-        if (mPlayPosChangedNT == AvrcpConstants.NOTIFICATION_TYPE_INTERIM && isPlayingState(
-                mCurrentPlayState)) {
-            Message msg = handler.obtainMessage(MSG_PLAY_INTERVAL_TIMEOUT);
-            long delay = mPlaybackIntervalMs;
-            if (mNextPosMs != -1) {
-                delay = mNextPosMs - (playPositionMs > 0 ? playPositionMs : 0);
-            }
-            if (DEBUG) {
-                debugLine += " Timeout " + delay + "ms";
-            }
-            handler.sendMessageDelayed(msg, delay);
-        }
-        if (DEBUG) {
-            Log.d(TAG, debugLine);
-        }
-    }
-
-    /**
-     * This is called from AudioService. It will return whether this device supports abs volume.
-     * NOT USED AT THE MOMENT.
-     */
-    public boolean isAbsoluteVolumeSupported() {
-        return ((mFeatures & BTRC_FEAT_ABSOLUTE_VOLUME) != 0);
-    }
-
-    /**
-     * We get this call from AudioService. This will send a message to our handler object,
-     * requesting our handler to call setVolumeNative()
-     */
-    public void setAbsoluteVolume(int volume) {
-        if (volume == mLocalVolume) {
-            if (DEBUG) {
-                Log.v(TAG, "setAbsoluteVolume is setting same index, ignore " + volume);
-            }
-            return;
-        }
-
-        final AvrcpMessageHandler handler = mHandler;
-        if (handler == null) {
-            if (DEBUG) Log.d(TAG, "setAbsoluteVolume: mHandler is already null");
-            return;
-        }
-
-        Message msg = handler.obtainMessage(MSG_SET_ABSOLUTE_VOLUME, volume, 0);
-        handler.sendMessage(msg);
-    }
-
-    /* Called in the native layer as a btrc_callback to return the volume set on the carkit in the
-     * case when the volume is change locally on the carkit. This notification is not called when
-     * the volume is changed from the phone.
-     *
-     * This method will send a message to our handler to change the local stored volume and notify
-     * AudioService to update the UI
-     */
-    private void volumeChangeRequestFromNative(byte[] address, int volume, int ctype) {
-        final AvrcpMessageHandler handler = mHandler;
-        if (handler == null) {
-            if (DEBUG) Log.d(TAG, "volumeChangeRequestFromNative: mHandler is already null");
-            return;
-        }
-
-        Message msg = handler.obtainMessage(MSG_NATIVE_REQ_VOLUME_CHANGE, volume, ctype);
-        Bundle data = new Bundle();
-        data.putByteArray("BdAddress", address);
-        msg.setData(data);
-        handler.sendMessage(msg);
-    }
-
-    private void getFolderItemsRequestFromNative(byte[] address, byte scope, long startItem,
-            long endItem, byte numAttr, int[] attrIds) {
-        final AvrcpMessageHandler handler = mHandler;
-        if (handler == null) {
-            if (DEBUG) Log.d(TAG, "getFolderItemsRequestFromNative: mHandler is already null");
-            return;
-        }
-        AvrcpCmd avrcpCmdobj = new AvrcpCmd();
-        AvrcpCmd.FolderItemsCmd folderObj =
-                avrcpCmdobj.new FolderItemsCmd(address, scope, startItem, endItem, numAttr,
-                        attrIds);
-        Message msg = handler.obtainMessage(MSG_NATIVE_REQ_GET_FOLDER_ITEMS, 0, 0);
-        msg.obj = folderObj;
-        handler.sendMessage(msg);
-    }
-
-    private void setAddressedPlayerRequestFromNative(byte[] address, int playerId) {
-        final AvrcpMessageHandler handler = mHandler;
-        if (handler == null) {
-            if (DEBUG) Log.d(TAG, "setAddressedPlayerRequestFromNative: mHandler is already null");
-            return;
-        }
-
-        Message msg = handler.obtainMessage(MSG_NATIVE_REQ_SET_ADDR_PLAYER, playerId, 0);
-        msg.obj = address;
-        handler.sendMessage(msg);
-    }
-
-    private void setBrowsedPlayerRequestFromNative(byte[] address, int playerId) {
-        final AvrcpMessageHandler handler = mHandler;
-        if (handler == null) {
-            if (DEBUG) Log.d(TAG, "setBrowsedPlayerRequestFromNative: mHandler is already null");
-            return;
-        }
-
-        Message msg = handler.obtainMessage(MSG_NATIVE_REQ_SET_BR_PLAYER, playerId, 0);
-        msg.obj = address;
-        handler.sendMessage(msg);
-    }
-
-    private void changePathRequestFromNative(byte[] address, byte direction, byte[] folderUid) {
-        final AvrcpMessageHandler handler = mHandler;
-        if (handler == null) {
-            if (DEBUG) Log.d(TAG, "changePathRequestFromNative: mHandler is already null");
-            return;
-        }
-
-        Bundle data = new Bundle();
-        Message msg = handler.obtainMessage(MSG_NATIVE_REQ_CHANGE_PATH);
-        data.putByteArray("BdAddress", address);
-        data.putByteArray("folderUid", folderUid);
-        data.putByte("direction", direction);
-        msg.setData(data);
-        handler.sendMessage(msg);
-    }
-
-    private void getItemAttrRequestFromNative(byte[] address, byte scope, byte[] itemUid,
-            int uidCounter, byte numAttr, int[] attrs) {
-        final AvrcpMessageHandler handler = mHandler;
-        if (handler == null) {
-            if (DEBUG) Log.d(TAG, "getItemAttrRequestFromNative: mHandler is already null");
-            return;
-        }
-        AvrcpCmd avrcpCmdobj = new AvrcpCmd();
-        AvrcpCmd.ItemAttrCmd itemAttr =
-                avrcpCmdobj.new ItemAttrCmd(address, scope, itemUid, uidCounter, numAttr, attrs);
-        Message msg = handler.obtainMessage(MSG_NATIVE_REQ_GET_ITEM_ATTR);
-        msg.obj = itemAttr;
-        handler.sendMessage(msg);
-    }
-
-    private void searchRequestFromNative(byte[] address, int charsetId, byte[] searchStr) {
-        /* Search is not supported */
-        Log.w(TAG, "searchRequestFromNative: search is not supported");
-        searchRspNative(address, AvrcpConstants.RSP_SRCH_NOT_SPRTD, 0, 0);
-    }
-
-    private void playItemRequestFromNative(byte[] address, byte scope, int uidCounter, byte[] uid) {
-        final AvrcpMessageHandler handler = mHandler;
-        if (handler == null) {
-            if (DEBUG) Log.d(TAG, "playItemRequestFromNative: mHandler is already null");
-            return;
-        }
-
-        Bundle data = new Bundle();
-        Message msg = handler.obtainMessage(MSG_NATIVE_REQ_PLAY_ITEM);
-        data.putByteArray("BdAddress", address);
-        data.putByteArray("uid", uid);
-        data.putInt("uidCounter", uidCounter);
-        data.putByte("scope", scope);
-
-        msg.setData(data);
-        handler.sendMessage(msg);
-    }
-
-    private void addToPlayListRequestFromNative(byte[] address, byte scope, byte[] uid,
-            int uidCounter) {
-        /* add to NowPlaying not supported */
-        Log.w(TAG, "addToPlayListRequestFromNative: not supported! scope=" + scope);
-        addToNowPlayingRspNative(address, AvrcpConstants.RSP_INTERNAL_ERR);
-    }
-
-    private void getTotalNumOfItemsRequestFromNative(byte[] address, byte scope) {
-        final AvrcpMessageHandler handler = mHandler;
-        if (handler == null) {
-            if (DEBUG) Log.d(TAG, "getTotalNumOfItemsRequestFromNative: mHandler is already null");
-            return;
-        }
-
-        Bundle data = new Bundle();
-        Message msg = handler.obtainMessage(MSG_NATIVE_REQ_GET_TOTAL_NUM_OF_ITEMS);
-        msg.arg1 = scope;
-        msg.obj = address;
-        handler.sendMessage(msg);
-    }
-
-    private void notifyVolumeChanged(int volume) {
-        mAudioManager.setStreamVolume(AudioManager.STREAM_MUSIC, volume,
-                AudioManager.FLAG_SHOW_UI | AudioManager.FLAG_BLUETOOTH_ABS_VOLUME);
-    }
-
-    private int convertToAudioStreamVolume(int volume) {
-        // Rescale volume to match AudioSystem's volume
-        return (int) Math.floor((double) volume * mAudioStreamMax / AVRCP_MAX_VOL);
-    }
-
-    private int convertToAvrcpVolume(int volume) {
-        return (int) Math.ceil((double) volume * AVRCP_MAX_VOL / mAudioStreamMax);
-    }
-
-    private void blackListCurrentDevice(String reason) {
-        mFeatures &= ~BTRC_FEAT_ABSOLUTE_VOLUME;
-        mAudioManager.avrcpSupportsAbsoluteVolume(mAddress, isAbsoluteVolumeSupported());
-
-        SharedPreferences pref =
-                mContext.getSharedPreferences(ABSOLUTE_VOLUME_BLACKLIST, Context.MODE_PRIVATE);
-        SharedPreferences.Editor editor = pref.edit();
-
-        StringBuilder sb = new StringBuilder();
-        sb.append("Time: ");
-        sb.append(android.text.format.DateFormat.format("yyyy/MM/dd HH:mm:ss",
-                                                        System.currentTimeMillis()));
-        sb.append(" Reason: ");
-        sb.append(reason);
-        editor.putString(mAddress, sb.toString());
-        editor.apply();
-    }
-
-    private int modifyRcFeatureFromBlacklist(int feature, String address) {
-        SharedPreferences pref =
-                mContext.getSharedPreferences(ABSOLUTE_VOLUME_BLACKLIST, Context.MODE_PRIVATE);
-        if (!pref.contains(address)) {
-            return feature;
-        }
-        return feature & ~BTRC_FEAT_ABSOLUTE_VOLUME;
-    }
-
-    public void resetBlackList(String address) {
-        SharedPreferences pref =
-                mContext.getSharedPreferences(ABSOLUTE_VOLUME_BLACKLIST, Context.MODE_PRIVATE);
-        SharedPreferences.Editor editor = pref.edit();
-        editor.remove(address);
-        editor.apply();
-    }
-
-    /**
-     * This is called from A2dpStateMachine to set A2dp audio state.
-     */
-    public void setA2dpAudioState(int state) {
-        final AvrcpMessageHandler handler = mHandler;
-        if (handler == null) {
-            if (DEBUG) Log.d(TAG, "setA2dpAudioState: mHandler is already null");
-            return;
-        }
-
-        Message msg = handler.obtainMessage(MSG_SET_A2DP_AUDIO_STATE, state, 0);
-        handler.sendMessage(msg);
-    }
-
-    private class AvrcpServiceBootReceiver extends BroadcastReceiver {
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            String action = intent.getAction();
-            if (action.equals(Intent.ACTION_USER_UNLOCKED)) {
-                if (DEBUG) {
-                    Log.d(TAG, "User unlocked, initializing player lists");
-                }
-                /* initializing media player's list */
-                buildBrowsablePlayerList();
-            }
-        }
-    }
-
-    private class AvrcpServiceBroadcastReceiver extends BroadcastReceiver {
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            String action = intent.getAction();
-            if (DEBUG) {
-                Log.d(TAG, "AvrcpServiceBroadcastReceiver-> Action: " + action);
-            }
-
-            if (action.equals(Intent.ACTION_PACKAGE_REMOVED) || action.equals(
-                    Intent.ACTION_PACKAGE_DATA_CLEARED)) {
-                if (!intent.getBooleanExtra(Intent.EXTRA_REPLACING, false)) {
-                    // a package is being removed, not replaced
-                    String packageName = intent.getData().getSchemeSpecificPart();
-                    if (packageName != null) {
-                        handlePackageModified(packageName, true);
-                    }
-                }
-
-            } else if (action.equals(Intent.ACTION_PACKAGE_ADDED) || action.equals(
-                    Intent.ACTION_PACKAGE_CHANGED)) {
-                String packageName = intent.getData().getSchemeSpecificPart();
-                if (DEBUG) {
-                    Log.d(TAG, "AvrcpServiceBroadcastReceiver-> packageName: " + packageName);
-                }
-                if (packageName != null) {
-                    handlePackageModified(packageName, false);
-                }
-            }
-        }
-    }
-
-    private void handlePackageModified(String packageName, boolean removed) {
-        if (DEBUG) {
-            Log.d(TAG, "packageName: " + packageName + " removed: " + removed);
-        }
-
-        if (removed) {
-            removeMediaPlayerInfo(packageName);
-            // old package is removed, updating local browsable player's list
-            if (isBrowseSupported(packageName)) {
-                removePackageFromBrowseList(packageName);
-            }
-        } else {
-            // new package has been added.
-            if (isBrowsableListUpdated(packageName)) {
-                // Rebuilding browsable players list
-                buildBrowsablePlayerList();
-            }
-        }
-    }
-
-    private boolean isBrowsableListUpdated(String newPackageName) {
-        // getting the browsable media players list from package manager
-        Intent intent = new Intent("android.media.browse.MediaBrowserService");
-        List<ResolveInfo> resInfos =
-                mPackageManager.queryIntentServices(intent, PackageManager.MATCH_ALL);
-        for (ResolveInfo resolveInfo : resInfos) {
-            if (resolveInfo.serviceInfo.packageName.equals(newPackageName)) {
-                if (DEBUG) {
-                    Log.d(TAG,
-                            "isBrowsableListUpdated: package includes MediaBrowserService, true");
-                }
-                return true;
-            }
-        }
-
-        // if list has different size
-        if (resInfos.size() != mBrowsePlayerInfoList.size()) {
-            if (DEBUG) {
-                Log.d(TAG, "isBrowsableListUpdated: browsable list size mismatch, true");
-            }
-            return true;
-        }
-
-        Log.d(TAG, "isBrowsableListUpdated: false");
-        return false;
-    }
-
-    private void removePackageFromBrowseList(String packageName) {
-        if (DEBUG) {
-            Log.d(TAG, "removePackageFromBrowseList: " + packageName);
-        }
-        synchronized (mBrowsePlayerInfoList) {
-            int browseInfoID = getBrowseId(packageName);
-            if (browseInfoID != -1) {
-                mBrowsePlayerInfoList.remove(browseInfoID);
-            }
-        }
-    }
-
-    /*
-     * utility function to get the browse player index from global browsable
-     * list. It may return -1 if specified package name is not in the list.
-     */
-    private int getBrowseId(String packageName) {
-        boolean response = false;
-        int browseInfoID = 0;
-        synchronized (mBrowsePlayerInfoList) {
-            for (BrowsePlayerInfo info : mBrowsePlayerInfoList) {
-                if (info.packageName.equals(packageName)) {
-                    response = true;
-                    break;
-                }
-                browseInfoID++;
-            }
-        }
-
-        if (!response) {
-            browseInfoID = -1;
-        }
-
-        if (DEBUG) {
-            Log.d(TAG, "getBrowseId for packageName: " + packageName + " , browseInfoID: "
-                    + browseInfoID);
-        }
-        return browseInfoID;
-    }
-
-    private void setAddressedPlayer(byte[] bdaddr, int selectedId) {
-        String functionTag = "setAddressedPlayer(" + selectedId + "): ";
-
-        synchronized (mMediaPlayerInfoList) {
-            if (mMediaPlayerInfoList.isEmpty()) {
-                Log.w(TAG, functionTag + "no players, send no available players");
-                setAddressedPlayerRspNative(bdaddr, AvrcpConstants.RSP_NO_AVBL_PLAY);
-                return;
-            }
-            if (!mMediaPlayerInfoList.containsKey(selectedId)) {
-                Log.w(TAG, functionTag + "invalid id, sending response back ");
-                setAddressedPlayerRspNative(bdaddr, AvrcpConstants.RSP_INV_PLAYER);
-                return;
-            }
-
-            if (isPlayerAlreadyAddressed(selectedId)) {
-                MediaPlayerInfo info = getAddressedPlayerInfo();
-                Log.i(TAG, functionTag + "player already addressed: " + info);
-                setAddressedPlayerRspNative(bdaddr, AvrcpConstants.RSP_NO_ERROR);
-                return;
-            }
-            // register new Media Controller Callback and update the current IDs
-            if (!updateCurrentController(selectedId, mCurrBrowsePlayerID)) {
-                Log.e(TAG, functionTag + "updateCurrentController failed!");
-                setAddressedPlayerRspNative(bdaddr, AvrcpConstants.RSP_INTERNAL_ERR);
-                return;
-            }
-            // If we don't have a controller, try to launch the player
-            MediaPlayerInfo info = getAddressedPlayerInfo();
-            if (info.getMediaController() == null) {
-                Intent launch = mPackageManager.getLaunchIntentForPackage(info.getPackageName());
-                Log.i(TAG, functionTag + "launching player " + launch);
-                mContext.startActivity(launch);
-            }
-        }
-        setAddressedPlayerRspNative(bdaddr, AvrcpConstants.RSP_NO_ERROR);
-    }
-
-    private void setBrowsedPlayer(byte[] bdaddr, int selectedId) {
-        int status = AvrcpConstants.RSP_NO_ERROR;
-
-        // checking for error cases
-        if (mMediaPlayerInfoList.isEmpty()) {
-            status = AvrcpConstants.RSP_NO_AVBL_PLAY;
-            Log.w(TAG, "setBrowsedPlayer: No available players! ");
-        } else {
-            // Workaround for broken controllers selecting ID 0
-            // Seen at least on Ford, Chevrolet MyLink
-            if (selectedId == 0) {
-                Log.w(TAG, "setBrowsedPlayer: workaround invalid id 0");
-                selectedId = mCurrAddrPlayerID;
-            }
-
-            // update current browse player id and start browsing service
-            updateNewIds(mCurrAddrPlayerID, selectedId);
-            String browsedPackage = getPackageName(selectedId);
-
-            if (!isPackageNameValid(browsedPackage)) {
-                Log.w(TAG, " Invalid package for id:" + mCurrBrowsePlayerID);
-                status = AvrcpConstants.RSP_INV_PLAYER;
-            } else if (!isBrowseSupported(browsedPackage)) {
-                Log.w(TAG, "Browse unsupported for id:" + mCurrBrowsePlayerID + ", packagename : "
-                        + browsedPackage);
-                status = AvrcpConstants.RSP_PLAY_NOT_BROW;
-            } else if (!startBrowseService(bdaddr, browsedPackage)) {
-                Log.e(TAG, "service cannot be started for browse player id:" + mCurrBrowsePlayerID
-                        + ", packagename : " + browsedPackage);
-                status = AvrcpConstants.RSP_INTERNAL_ERR;
-            }
-        }
-
-        if (status != AvrcpConstants.RSP_NO_ERROR) {
-            setBrowsedPlayerRspNative(bdaddr, status, (byte) 0x00, 0, null);
-        }
-
-        if (DEBUG) {
-            Log.d(TAG, "setBrowsedPlayer for selectedId: " + selectedId + " , status: " + status);
-        }
-    }
-
-    private MediaSessionManager.OnActiveSessionsChangedListener mActiveSessionListener =
-            new MediaSessionManager.OnActiveSessionsChangedListener() {
-
-                @Override
-                public void onActiveSessionsChanged(
-                        List<android.media.session.MediaController> newControllers) {
-                    Set<String> updatedPackages = new HashSet<String>();
-                    // Update the current players
-                    for (android.media.session.MediaController controller : newControllers) {
-                        String packageName = controller.getPackageName();
-                        if (DEBUG) {
-                            Log.v(TAG, "ActiveSession: " + MediaControllerFactory.wrap(controller));
-                        }
-                        // Only use the first (highest priority) controller from each package
-                        if (updatedPackages.contains(packageName)) {
-                            continue;
-                        }
-                        addMediaPlayerController(controller);
-                        updatedPackages.add(packageName);
-                    }
-
-                    if (newControllers.size() > 0 && getAddressedPlayerInfo() == null) {
-                        if (DEBUG) {
-                            Log.v(TAG, "No addressed player but active sessions, taking first.");
-                        }
-                        setAddressedMediaSessionPackage(newControllers.get(0).getPackageName());
-                    }
-                    updateCurrentMediaState();
-                }
-            };
-
-    private void setAddressedMediaSessionPackage(@Nullable String packageName) {
-        if (packageName == null) {
-            // Should only happen when there's no media players, reset to no available player.
-            updateCurrentController(0, mCurrBrowsePlayerID);
-            return;
-        }
-        if (packageName.equals("com.android.server.telecom")) {
-            Log.d(TAG, "Ignore addressed media session change to telecom");
-            return;
-        }
-        // No change.
-        if (getPackageName(mCurrAddrPlayerID).equals(packageName)) {
-            return;
-        }
-        if (DEBUG) {
-            Log.v(TAG, "Changing addressed media session to " + packageName);
-        }
-        // If the player doesn't exist, we need to add it.
-        if (getMediaPlayerInfo(packageName) == null) {
-            addMediaPlayerPackage(packageName);
-            updateCurrentMediaState();
-        }
-        synchronized (mMediaPlayerInfoList) {
-            for (Map.Entry<Integer, MediaPlayerInfo> entry : mMediaPlayerInfoList.entrySet()) {
-                if (entry.getValue().getPackageName().equals(packageName)) {
-                    int newAddrID = entry.getKey();
-                    if (DEBUG) {
-                        Log.v(TAG, "Set addressed #" + newAddrID + " " + entry.getValue());
-                    }
-                    updateCurrentController(newAddrID, mCurrBrowsePlayerID);
-                    updateCurrentMediaState();
-                    return;
-                }
-            }
-        }
-        // We shouldn't ever get here.
-        Log.e(TAG, "Player info for " + packageName + " doesn't exist!");
-    }
-
-    private void setActiveMediaSession(MediaSession.Token token) {
-        android.media.session.MediaController activeController =
-                new android.media.session.MediaController(mContext, token);
-        if (activeController.getPackageName().equals("com.android.server.telecom")) {
-            Log.d(TAG, "Ignore active media session change to telecom");
-            return;
-        }
-        if (DEBUG) {
-            Log.v(TAG, "Set active media session " + activeController.getPackageName());
-        }
-        addMediaPlayerController(activeController);
-        setAddressedMediaSessionPackage(activeController.getPackageName());
-    }
-
-    private boolean startBrowseService(byte[] bdaddr, String packageName) {
-        boolean status = true;
-
-        /* creating new instance for Browse Media Player */
-        String browseService = getBrowseServiceName(packageName);
-        if (!browseService.isEmpty()) {
-            mAvrcpBrowseManager.getBrowsedMediaPlayer(bdaddr)
-                    .setBrowsed(packageName, browseService);
-        } else {
-            Log.w(TAG, "No Browser service available for " + packageName);
-            status = false;
-        }
-
-        if (DEBUG) {
-            Log.d(TAG,
-                    "startBrowseService for packageName: " + packageName + ", status = " + status);
-        }
-        return status;
-    }
-
-    private String getBrowseServiceName(String packageName) {
-        String browseServiceName = "";
-
-        // getting the browse service name from browse player info
-        synchronized (mBrowsePlayerInfoList) {
-            int browseInfoID = getBrowseId(packageName);
-            if (browseInfoID != -1) {
-                browseServiceName = mBrowsePlayerInfoList.get(browseInfoID).serviceClass;
-            }
-        }
-
-        if (DEBUG) {
-            Log.d(TAG, "getBrowseServiceName for packageName: " + packageName
-                    + ", browseServiceName = " + browseServiceName);
-        }
-        return browseServiceName;
-    }
-
-    void buildBrowsablePlayerList() {
-        synchronized (mBrowsePlayerInfoList) {
-            mBrowsePlayerInfoList.clear();
-            Intent intent = new Intent(android.service.media.MediaBrowserService.SERVICE_INTERFACE);
-            List<ResolveInfo> playerList =
-                    mPackageManager.queryIntentServices(intent, PackageManager.MATCH_ALL);
-
-            for (ResolveInfo info : playerList) {
-                String displayableName = info.loadLabel(mPackageManager).toString();
-                String serviceName = info.serviceInfo.name;
-                String packageName = info.serviceInfo.packageName;
-
-                if (DEBUG) {
-                    Log.d(TAG, "Adding " + serviceName + " to list of browsable players");
-                }
-                BrowsePlayerInfo currentPlayer =
-                        new BrowsePlayerInfo(packageName, displayableName, serviceName);
-                mBrowsePlayerInfoList.add(currentPlayer);
-                MediaPlayerInfo playerInfo = getMediaPlayerInfo(packageName);
-                MediaController controller =
-                        (playerInfo == null) ? null : playerInfo.getMediaController();
-                // Refresh the media player entry so it notices we can browse
-                if (controller != null) {
-                    addMediaPlayerController(controller.getWrappedInstance());
-                } else {
-                    addMediaPlayerPackage(packageName);
-                }
-            }
-            updateCurrentMediaState();
-        }
-    }
-
-    /* Initializes list of media players identified from session manager active sessions */
-    private void initMediaPlayersList() {
-        synchronized (mMediaPlayerInfoList) {
-            // Clearing old browsable player's list
-            mMediaPlayerInfoList.clear();
-
-            if (mMediaSessionManager == null) {
-                if (DEBUG) {
-                    Log.w(TAG, "initMediaPlayersList: no media session manager!");
-                }
-                return;
-            }
-
-            List<android.media.session.MediaController> controllers =
-                    mMediaSessionManager.getActiveSessions(null);
-            if (DEBUG) {
-                Log.v(TAG, "initMediaPlayerInfoList: " + controllers.size() + " controllers");
-            }
-            /* Initializing all media players */
-            for (android.media.session.MediaController controller : controllers) {
-                addMediaPlayerController(controller);
-            }
-
-            updateCurrentMediaState();
-
-            if (mMediaPlayerInfoList.size() > 0) {
-                // Set the first one as the Addressed Player
-                updateCurrentController(mMediaPlayerInfoList.firstKey(), -1);
-            }
-        }
-    }
-
-    private List<android.media.session.MediaController> getMediaControllers() {
-        List<android.media.session.MediaController> controllers =
-                new ArrayList<android.media.session.MediaController>();
-        synchronized (mMediaPlayerInfoList) {
-            for (MediaPlayerInfo info : mMediaPlayerInfoList.values()) {
-                MediaController controller = info.getMediaController();
-                if (controller != null) {
-                    controllers.add(controller.getWrappedInstance());
-                }
-            }
-        }
-        return controllers;
-    }
-
-    /** Add (or update) a player to the media player list without a controller */
-    private boolean addMediaPlayerPackage(String packageName) {
-        MediaPlayerInfo info = new MediaPlayerInfo(null, AvrcpConstants.PLAYER_TYPE_AUDIO,
-                AvrcpConstants.PLAYER_SUBTYPE_NONE, PLAYSTATUS_STOPPED,
-                getFeatureBitMask(packageName), packageName, getAppLabel(packageName));
-        return addMediaPlayerInfo(info);
-    }
-
-    /** Add (or update) a player to the media player list given an active controller */
-    private boolean addMediaPlayerController(android.media.session.MediaController controller) {
-        String packageName = controller.getPackageName();
-        MediaPlayerInfo info = new MediaPlayerInfo(MediaControllerFactory.wrap(controller),
-                AvrcpConstants.PLAYER_TYPE_AUDIO, AvrcpConstants.PLAYER_SUBTYPE_NONE,
-                getBluetoothPlayState(controller.getPlaybackState()),
-                getFeatureBitMask(packageName), controller.getPackageName(),
-                getAppLabel(packageName));
-        return addMediaPlayerInfo(info);
-    }
-
-    /** Add or update a player to the media player list given the MediaPlayerInfo object.
-     *  @return true if an item was updated, false if it was added instead
-     */
-    private boolean addMediaPlayerInfo(MediaPlayerInfo info) {
-        int updateId = -1;
-        boolean updated = false;
-        boolean currentRemoved = false;
-        if (info.getPackageName().equals("com.android.server.telecom")) {
-            Log.d(TAG, "Skip adding telecom to the media player info list");
-            return updated;
-        }
-        synchronized (mMediaPlayerInfoList) {
-            for (Map.Entry<Integer, MediaPlayerInfo> entry : mMediaPlayerInfoList.entrySet()) {
-                MediaPlayerInfo current = entry.getValue();
-                int id = entry.getKey();
-                if (info.getPackageName().equals(current.getPackageName())) {
-                    if (!current.equalView(info)) {
-                        // If we would present a different player, make it a new player
-                        // so that controllers know whether a player is browsable or not.
-                        mMediaPlayerInfoList.remove(id);
-                        currentRemoved = (mCurrAddrPlayerID == id);
-                        break;
-                    }
-                    updateId = id;
-                    updated = true;
-                    break;
-                }
-            }
-            if (updateId == -1) {
-                // New player
-                mLastUsedPlayerID++;
-                updateId = mLastUsedPlayerID;
-                mAvailablePlayerViewChanged = true;
-            }
-            mMediaPlayerInfoList.put(updateId, info);
-        }
-        if (DEBUG) {
-            Log.d(TAG, (updated ? "update #" : "add #") + updateId + ":" + info.toString());
-        }
-        if (currentRemoved || updateId == mCurrAddrPlayerID) {
-            updateCurrentController(updateId, mCurrBrowsePlayerID);
-        }
-        return updated;
-    }
-
-    /** Remove all players related to |packageName| from the media player info list */
-    private MediaPlayerInfo removeMediaPlayerInfo(String packageName) {
-        synchronized (mMediaPlayerInfoList) {
-            int removeKey = -1;
-            for (Map.Entry<Integer, MediaPlayerInfo> entry : mMediaPlayerInfoList.entrySet()) {
-                if (entry.getValue().getPackageName().equals(packageName)) {
-                    removeKey = entry.getKey();
-                    break;
-                }
-            }
-            if (removeKey != -1) {
-                if (DEBUG) {
-                    Log.d(TAG, "remove #" + removeKey + ":" + mMediaPlayerInfoList.get(removeKey));
-                }
-                mAvailablePlayerViewChanged = true;
-                return mMediaPlayerInfoList.remove(removeKey);
-            }
-
-            return null;
-        }
-    }
-
-    /** Remove the controller referenced by |controller| from any player in the list */
-    private void removeMediaController(@Nullable android.media.session.MediaController controller) {
-        if (controller == null) {
-            return;
-        }
-        synchronized (mMediaPlayerInfoList) {
-            for (Map.Entry<Integer, MediaPlayerInfo> entry : mMediaPlayerInfoList.entrySet()) {
-                MediaPlayerInfo info = entry.getValue();
-                MediaController c = info.getMediaController();
-                if (c != null && c.equals(controller)) {
-                    info.setMediaController(null);
-                    if (entry.getKey() == mCurrAddrPlayerID) {
-                        updateCurrentController(mCurrAddrPlayerID, mCurrBrowsePlayerID);
-                    }
-                }
-            }
-        }
-    }
-
-    /*
-     * utility function to get the playback state of any media player through
-     * media controller APIs.
-     */
-    private byte getBluetoothPlayState(PlaybackState pbState) {
-        if (pbState == null) {
-            Log.w(TAG, "playState object null, sending STOPPED");
-            return PLAYSTATUS_STOPPED;
-        }
-
-        switch (pbState.getState()) {
-            case PlaybackState.STATE_PLAYING:
-                return PLAYSTATUS_PLAYING;
-
-            case PlaybackState.STATE_BUFFERING:
-            case PlaybackState.STATE_STOPPED:
-            case PlaybackState.STATE_NONE:
-            case PlaybackState.STATE_CONNECTING:
-                return PLAYSTATUS_STOPPED;
-
-            case PlaybackState.STATE_PAUSED:
-                return PLAYSTATUS_PAUSED;
-
-            case PlaybackState.STATE_FAST_FORWARDING:
-            case PlaybackState.STATE_SKIPPING_TO_NEXT:
-            case PlaybackState.STATE_SKIPPING_TO_QUEUE_ITEM:
-                return PLAYSTATUS_FWD_SEEK;
-
-            case PlaybackState.STATE_REWINDING:
-            case PlaybackState.STATE_SKIPPING_TO_PREVIOUS:
-                return PLAYSTATUS_REV_SEEK;
-
-            case PlaybackState.STATE_ERROR:
-            default:
-                return PLAYSTATUS_ERROR;
-        }
-    }
-
-    /*
-     * utility function to get the feature bit mask of any media player through
-     * package name
-     */
-    private short[] getFeatureBitMask(String packageName) {
-
-        ArrayList<Short> featureBitsList = new ArrayList<Short>();
-
-        /* adding default feature bits */
-        featureBitsList.add(AvrcpConstants.AVRC_PF_PLAY_BIT_NO);
-        featureBitsList.add(AvrcpConstants.AVRC_PF_STOP_BIT_NO);
-        featureBitsList.add(AvrcpConstants.AVRC_PF_PAUSE_BIT_NO);
-        featureBitsList.add(AvrcpConstants.AVRC_PF_REWIND_BIT_NO);
-        featureBitsList.add(AvrcpConstants.AVRC_PF_FAST_FWD_BIT_NO);
-        featureBitsList.add(AvrcpConstants.AVRC_PF_FORWARD_BIT_NO);
-        featureBitsList.add(AvrcpConstants.AVRC_PF_BACKWARD_BIT_NO);
-        featureBitsList.add(AvrcpConstants.AVRC_PF_ADV_CTRL_BIT_NO);
-
-        /* Add/Modify browse player supported features. */
-        if (isBrowseSupported(packageName)) {
-            featureBitsList.add(AvrcpConstants.AVRC_PF_BROWSE_BIT_NO);
-            featureBitsList.add(AvrcpConstants.AVRC_PF_UID_UNIQUE_BIT_NO);
-            featureBitsList.add(AvrcpConstants.AVRC_PF_NOW_PLAY_BIT_NO);
-            featureBitsList.add(AvrcpConstants.AVRC_PF_GET_NUM_OF_ITEMS_BIT_NO);
-        }
-
-        // converting arraylist to array for response
-        short[] featureBitsArray = new short[featureBitsList.size()];
-
-        for (int i = 0; i < featureBitsList.size(); i++) {
-            featureBitsArray[i] = featureBitsList.get(i).shortValue();
-        }
-
-        return featureBitsArray;
-    }
-
-    /**
-     * Checks the Package name if it supports Browsing or not.
-     *
-     * @param packageName - name of the package to get the Id.
-     * @return true if it supports browsing, else false.
-     */
-    private boolean isBrowseSupported(String packageName) {
-        synchronized (mBrowsePlayerInfoList) {
-            /* check if Browsable Player's list contains this package name */
-            for (BrowsePlayerInfo info : mBrowsePlayerInfoList) {
-                if (info.packageName.equals(packageName)) {
-                    if (DEBUG) {
-                        Log.v(TAG, "isBrowseSupported for " + packageName + ": true");
-                    }
-                    return true;
-                }
-            }
-        }
-
-        if (DEBUG) {
-            Log.v(TAG, "isBrowseSupported for " + packageName + ": false");
-        }
-        return false;
-    }
-
-    private String getPackageName(int id) {
-        MediaPlayerInfo player = null;
-        synchronized (mMediaPlayerInfoList) {
-            player = mMediaPlayerInfoList.getOrDefault(id, null);
-        }
-
-        if (player == null) {
-            Log.w(TAG, "No package name for player (" + id + " not valid)");
-            return "";
-        }
-
-        String packageName = player.getPackageName();
-        if (DEBUG) {
-            Log.v(TAG, "Player " + id + " package: " + packageName);
-        }
-        return packageName;
-    }
-
-    /* from the global object, getting the current browsed player's package name */
-    private String getCurrentBrowsedPlayer(byte[] bdaddr) {
-        String browsedPlayerPackage = "";
-
-        Map<String, BrowsedMediaPlayer> connList = mAvrcpBrowseManager.getConnList();
-        String bdaddrStr = new String(bdaddr);
-        if (connList.containsKey(bdaddrStr)) {
-            browsedPlayerPackage = connList.get(bdaddrStr).getPackageName();
-        }
-        if (DEBUG) {
-            Log.v(TAG, "getCurrentBrowsedPlayerPackage: " + browsedPlayerPackage);
-        }
-        return browsedPlayerPackage;
-    }
-
-    /* Returns the MediaPlayerInfo for the currently addressed media player */
-    private MediaPlayerInfo getAddressedPlayerInfo() {
-        synchronized (mMediaPlayerInfoList) {
-            return mMediaPlayerInfoList.getOrDefault(mCurrAddrPlayerID, null);
-        }
-    }
-
-    /*
-     * Utility function to get the Media player info from package name returns
-     * null if package name not found in media players list
-     */
-    private MediaPlayerInfo getMediaPlayerInfo(String packageName) {
-        synchronized (mMediaPlayerInfoList) {
-            if (mMediaPlayerInfoList.isEmpty()) {
-                if (DEBUG) {
-                    Log.v(TAG, "getMediaPlayerInfo: Media players list empty");
-                }
-                return null;
-            }
-
-            for (MediaPlayerInfo info : mMediaPlayerInfoList.values()) {
-                if (packageName.equals(info.getPackageName())) {
-                    if (DEBUG) {
-                        Log.v(TAG, "getMediaPlayerInfo: Found " + packageName);
-                    }
-                    return info;
-                }
-            }
-            if (DEBUG) {
-                Log.w(TAG, "getMediaPlayerInfo: " + packageName + " not found");
-            }
-            return null;
-        }
-    }
-
-    /* prepare media list & return the media player list response object */
-    private MediaPlayerListRsp prepareMediaPlayerRspObj() {
-        synchronized (mMediaPlayerInfoList) {
-            // TODO(apanicke): This hack will go away as soon as a developer
-            // option to enable or disable player selection is created. Right
-            // now this is needed to fix BMW i3 carkits and any other carkits
-            // that might try to connect to a player that isnt the current
-            // player based on this list
-            int numPlayers = 1;
-
-            int[] playerIds = new int[numPlayers];
-            byte[] playerTypes = new byte[numPlayers];
-            int[] playerSubTypes = new int[numPlayers];
-            String[] displayableNameArray = new String[numPlayers];
-            byte[] playStatusValues = new byte[numPlayers];
-            short[] featureBitMaskValues =
-                    new short[numPlayers * AvrcpConstants.AVRC_FEATURE_MASK_SIZE];
-
-            // Reserve the first spot for the currently addressed player if
-            // we have one
-            int players = mMediaPlayerInfoList.containsKey(mCurrAddrPlayerID) ? 1 : 0;
-            for (Map.Entry<Integer, MediaPlayerInfo> entry : mMediaPlayerInfoList.entrySet()) {
-                int idx = players;
-                if (entry.getKey() == mCurrAddrPlayerID) {
-                    idx = 0;
-                } else {
-                    continue; // TODO(apanicke): Remove, see above note
-                }
-                MediaPlayerInfo info = entry.getValue();
-                playerIds[idx] = entry.getKey();
-                playerTypes[idx] = info.getMajorType();
-                playerSubTypes[idx] = info.getSubType();
-                displayableNameArray[idx] = info.getDisplayableName();
-                playStatusValues[idx] = info.getPlayStatus();
-
-                short[] featureBits = info.getFeatureBitMask();
-                for (int numBit = 0; numBit < featureBits.length; numBit++) {
-                    /* gives which octet this belongs to */
-                    byte octet = (byte) (featureBits[numBit] / 8);
-                    /* gives the bit position within the octet */
-                    byte bit = (byte) (featureBits[numBit] % 8);
-                    featureBitMaskValues[(idx * AvrcpConstants.AVRC_FEATURE_MASK_SIZE) + octet] |=
-                            (1 << bit);
-                }
-
-                /* printLogs */
-                if (DEBUG) {
-                    Log.d(TAG, "Player " + playerIds[idx] + ": " + displayableNameArray[idx]
-                            + " type: " + playerTypes[idx] + ", " + playerSubTypes[idx]
-                            + " status: " + playStatusValues[idx]);
-                }
-
-                if (idx != 0) {
-                    players++;
-                }
-            }
-
-            if (DEBUG) {
-                Log.d(TAG, "prepareMediaPlayerRspObj: numPlayers = " + numPlayers);
-            }
-
-            return new MediaPlayerListRsp(AvrcpConstants.RSP_NO_ERROR, sUIDCounter, numPlayers,
-                    AvrcpConstants.BTRC_ITEM_PLAYER, playerIds, playerTypes, playerSubTypes,
-                    playStatusValues, featureBitMaskValues, displayableNameArray);
-        }
-    }
-
-    /* build media player list and send it to remote. */
-    private void handleMediaPlayerListRsp(AvrcpCmd.FolderItemsCmd folderObj) {
-        MediaPlayerListRsp rspObj = null;
-        synchronized (mMediaPlayerInfoList) {
-            int numPlayers = mMediaPlayerInfoList.size();
-            if (numPlayers == 0) {
-                mediaPlayerListRspNative(folderObj.mAddress, AvrcpConstants.RSP_NO_AVBL_PLAY,
-                        (short) 0, (byte) 0, 0, null, null, null, null, null, null);
-                return;
-            }
-            if (folderObj.mStartItem >= numPlayers) {
-                Log.i(TAG, "handleMediaPlayerListRsp: start = " + folderObj.mStartItem
-                        + " > num of items = " + numPlayers);
-                mediaPlayerListRspNative(folderObj.mAddress, AvrcpConstants.RSP_INV_RANGE,
-                        (short) 0, (byte) 0, 0, null, null, null, null, null, null);
-                return;
-            }
-            rspObj = prepareMediaPlayerRspObj();
-        }
-        if (DEBUG) {
-            Log.d(TAG, "handleMediaPlayerListRsp: sending " + rspObj.mNumItems + " players");
-        }
-        mediaPlayerListRspNative(folderObj.mAddress, rspObj.mStatus, rspObj.mUIDCounter,
-                rspObj.mItemType, rspObj.mNumItems, rspObj.mPlayerIds, rspObj.mPlayerTypes,
-                rspObj.mPlayerSubTypes, rspObj.mPlayStatusValues, rspObj.mFeatureBitMaskValues,
-                rspObj.mPlayerNameList);
-    }
-
-    /* unregister to the old controller, update new IDs and register to the new controller */
-    private boolean updateCurrentController(int addrId, int browseId) {
-        boolean registerRsp = true;
-
-        updateNewIds(addrId, browseId);
-
-        MediaController newController = null;
-        MediaPlayerInfo info = getAddressedPlayerInfo();
-        if (info != null) {
-            newController = info.getMediaController();
-        }
-
-        if (DEBUG) {
-            Log.d(TAG, "updateCurrentController: " + mMediaController + " to " + newController);
-        }
-        synchronized (this) {
-            if (mMediaController == null || (!mMediaController.equals(newController))) {
-                if (mMediaController != null) {
-                    mMediaController.unregisterCallback(mMediaControllerCb);
-                }
-                mMediaController = newController;
-                if (mMediaController != null) {
-                    mMediaController.registerCallback(mMediaControllerCb, mHandler);
-                } else {
-                    registerRsp = false;
-                }
-            }
-        }
-        updateCurrentMediaState();
-        return registerRsp;
-    }
-
-    /* Handle getfolderitems for scope = VFS, Search, NowPlayingList */
-    private void handleGetFolderItemBrowseResponse(AvrcpCmd.FolderItemsCmd folderObj,
-            byte[] bdaddr) {
-        int status = AvrcpConstants.RSP_NO_ERROR;
-
-        /* Browsed player is already set */
-        if (folderObj.mScope == AvrcpConstants.BTRC_SCOPE_FILE_SYSTEM) {
-            if (mAvrcpBrowseManager.getBrowsedMediaPlayer(bdaddr) == null) {
-                Log.e(TAG, "handleGetFolderItemBrowseResponse: no browsed player set for "
-                        + Utils.getAddressStringFromByte(bdaddr));
-                getFolderItemsRspNative(bdaddr, AvrcpConstants.RSP_INTERNAL_ERR, (short) 0,
-                        (byte) 0x00, 0, null, null, null, null, null, null, null, null);
-                return;
-            }
-            mAvrcpBrowseManager.getBrowsedMediaPlayer(bdaddr).getFolderItemsVFS(folderObj);
-            return;
-        }
-        if (folderObj.mScope == AvrcpConstants.BTRC_SCOPE_NOW_PLAYING) {
-            mAddressedMediaPlayer.getFolderItemsNowPlaying(bdaddr, folderObj, mMediaController);
-            return;
-        }
-
-        /* invalid scope */
-        Log.e(TAG, "handleGetFolderItemBrowseResponse: unknown scope " + folderObj.mScope);
-        getFolderItemsRspNative(bdaddr, AvrcpConstants.RSP_INV_SCOPE, (short) 0, (byte) 0x00, 0,
-                null, null, null, null, null, null, null, null);
-    }
-
-    /* utility function to update the global values of current Addressed and browsed player */
-    private void updateNewIds(int addrId, int browseId) {
-        if (DEBUG) {
-            Log.v(TAG,
-                    "updateNewIds: Addressed:" + mCurrAddrPlayerID + " to " + addrId + ", Browse:"
-                            + mCurrBrowsePlayerID + " to " + browseId);
-        }
-        mCurrAddrPlayerID = addrId;
-        mCurrBrowsePlayerID = browseId;
-    }
-
-    /* Getting the application's displayable name from package name */
-    private String getAppLabel(String packageName) {
-        ApplicationInfo appInfo = null;
-        try {
-            appInfo = mPackageManager.getApplicationInfo(packageName, 0);
-        } catch (NameNotFoundException e) {
-            e.printStackTrace();
-        }
-
-        return (String) (appInfo != null ? mPackageManager.getApplicationLabel(appInfo)
-                : "Unknown");
-    }
-
-    private void handlePlayItemResponse(byte[] bdaddr, byte[] uid, byte scope) {
-        if (scope == AvrcpConstants.BTRC_SCOPE_NOW_PLAYING) {
-            mAddressedMediaPlayer.playItem(bdaddr, uid, mMediaController);
-        } else {
-            if (!isAddrPlayerSameAsBrowsed(bdaddr)) {
-                Log.w(TAG, "Remote requesting play item on uid which may not be recognized by"
-                        + "current addressed player");
-                playItemRspNative(bdaddr, AvrcpConstants.RSP_INV_ITEM);
-            }
-
-            if (mAvrcpBrowseManager.getBrowsedMediaPlayer(bdaddr) != null) {
-                mAvrcpBrowseManager.getBrowsedMediaPlayer(bdaddr).playItem(uid, scope);
-            } else {
-                Log.e(TAG, "handlePlayItemResponse: Remote requested playitem "
-                        + "before setbrowsedplayer");
-                playItemRspNative(bdaddr, AvrcpConstants.RSP_INTERNAL_ERR);
-            }
-        }
-    }
-
-    private void handleGetItemAttr(AvrcpCmd.ItemAttrCmd itemAttr) {
-        if (itemAttr.mUidCounter != sUIDCounter) {
-            Log.e(TAG, "handleGetItemAttr: invaild uid counter.");
-            getItemAttrRspNative(itemAttr.mAddress, AvrcpConstants.RSP_UID_CHANGED, (byte) 0, null,
-                    null);
-            return;
-        }
-        if (itemAttr.mScope == AvrcpConstants.BTRC_SCOPE_NOW_PLAYING) {
-            if (mCurrAddrPlayerID == NO_PLAYER_ID) {
-                getItemAttrRspNative(itemAttr.mAddress, AvrcpConstants.RSP_NO_AVBL_PLAY, (byte) 0,
-                        null, null);
-                return;
-            }
-            mAddressedMediaPlayer.getItemAttr(itemAttr.mAddress, itemAttr, mMediaController);
-            return;
-        }
-        // All other scopes use browsed player
-        if (mAvrcpBrowseManager.getBrowsedMediaPlayer(itemAttr.mAddress) != null) {
-            mAvrcpBrowseManager.getBrowsedMediaPlayer(itemAttr.mAddress).getItemAttr(itemAttr);
-        } else {
-            Log.e(TAG, "Could not get attributes. mBrowsedMediaPlayer is null");
-            getItemAttrRspNative(itemAttr.mAddress, AvrcpConstants.RSP_INTERNAL_ERR, (byte) 0, null,
-                    null);
-        }
-    }
-
-    private void handleGetTotalNumOfItemsResponse(byte[] bdaddr, byte scope) {
-        // for scope as media player list
-        if (scope == AvrcpConstants.BTRC_SCOPE_PLAYER_LIST) {
-            int numPlayers = 0;
-            synchronized (mMediaPlayerInfoList) {
-                numPlayers = mMediaPlayerInfoList.size();
-            }
-            if (DEBUG) {
-                Log.d(TAG, "handleGetTotalNumOfItemsResponse: " + numPlayers + " players.");
-            }
-            getTotalNumOfItemsRspNative(bdaddr, AvrcpConstants.RSP_NO_ERROR, 0, numPlayers);
-        } else if (scope == AvrcpConstants.BTRC_SCOPE_NOW_PLAYING) {
-            mAddressedMediaPlayer.getTotalNumOfItems(bdaddr, mMediaController);
-        } else {
-            // for FileSystem browsing scopes as VFS, Now Playing
-            if (mAvrcpBrowseManager.getBrowsedMediaPlayer(bdaddr) != null) {
-                mAvrcpBrowseManager.getBrowsedMediaPlayer(bdaddr).getTotalNumOfItems(scope);
-            } else {
-                Log.e(TAG, "Could not get Total NumOfItems. mBrowsedMediaPlayer is null");
-                getTotalNumOfItemsRspNative(bdaddr, AvrcpConstants.RSP_INTERNAL_ERR, 0, 0);
-            }
-        }
-
-    }
-
-    /* check if browsed player and addressed player are same */
-    private boolean isAddrPlayerSameAsBrowsed(byte[] bdaddr) {
-        String browsedPlayer = getCurrentBrowsedPlayer(bdaddr);
-
-        if (!isPackageNameValid(browsedPlayer)) {
-            Log.w(TAG, "Browsed player name empty");
-            return false;
-        }
-
-        MediaPlayerInfo info = getAddressedPlayerInfo();
-        String packageName = (info == null) ? "<none>" : info.getPackageName();
-        if (info == null || !packageName.equals(browsedPlayer)) {
-            if (DEBUG) {
-                Log.d(TAG, browsedPlayer + " is not addressed player " + packageName);
-            }
-            return false;
-        }
-        return true;
-    }
-
-    /* checks if package name is not null or empty */
-    private boolean isPackageNameValid(String browsedPackage) {
-        boolean isValid = (browsedPackage != null && browsedPackage.length() > 0);
-        if (DEBUG) {
-            Log.d(TAG, "isPackageNameValid: browsedPackage = " + browsedPackage + "isValid = "
-                    + isValid);
-        }
-        return isValid;
-    }
-
-    /* checks if selected addressed player is already addressed */
-    private boolean isPlayerAlreadyAddressed(int selectedId) {
-        // checking if selected ID is same as the current addressed player id
-        boolean isAddressed = (mCurrAddrPlayerID == selectedId);
-        if (DEBUG) {
-            Log.d(TAG, "isPlayerAlreadyAddressed: isAddressed = " + isAddressed);
-        }
-        return isAddressed;
-    }
-
-    public void dump(StringBuilder sb) {
-        sb.append("AVRCP:\n");
-        ProfileService.println(sb, "mMediaAttributes: " + mMediaAttributes.toRedactedString());
-        ProfileService.println(sb, "mTransportControlFlags: " + mTransportControlFlags);
-        ProfileService.println(sb, "mCurrentPlayState: " + mCurrentPlayState);
-        ProfileService.println(sb, "mPlayStatusChangedNT: " + mPlayStatusChangedNT);
-        ProfileService.println(sb, "mTrackChangedNT: " + mTrackChangedNT);
-        ProfileService.println(sb, "mPlaybackIntervalMs: " + mPlaybackIntervalMs);
-        ProfileService.println(sb, "mPlayPosChangedNT: " + mPlayPosChangedNT);
-        ProfileService.println(sb, "mNextPosMs: " + mNextPosMs);
-        ProfileService.println(sb, "mPrevPosMs: " + mPrevPosMs);
-        ProfileService.println(sb, "mFeatures: " + mFeatures);
-        ProfileService.println(sb, "mRemoteVolume: " + mRemoteVolume);
-        ProfileService.println(sb, "mLastRemoteVolume: " + mLastRemoteVolume);
-        ProfileService.println(sb, "mLastDirection: " + mLastDirection);
-        ProfileService.println(sb, "mVolumeStep: " + mVolumeStep);
-        ProfileService.println(sb, "mAudioStreamMax: " + mAudioStreamMax);
-        ProfileService.println(sb, "mVolCmdSetInProgress: " + mVolCmdSetInProgress);
-        ProfileService.println(sb, "mAbsVolRetryTimes: " + mAbsVolRetryTimes);
-        ProfileService.println(sb, "mVolumeMapping: " + mVolumeMapping.toString());
-        synchronized (this) {
-            if (mMediaController != null) {
-                ProfileService.println(sb,
-                        "mMediaController: " + mMediaController.getWrappedInstance() + " pkg "
-                                + mMediaController.getPackageName());
-            }
-        }
-        ProfileService.println(sb, "");
-        ProfileService.println(sb, "Media Players:");
-        synchronized (mMediaPlayerInfoList) {
-            for (Map.Entry<Integer, MediaPlayerInfo> entry : mMediaPlayerInfoList.entrySet()) {
-                int key = entry.getKey();
-                ProfileService.println(sb,
-                        ((mCurrAddrPlayerID == key) ? " *#" : "  #") + entry.getKey() + ": " + entry
-                                .getValue());
-            }
-        }
-
-        ProfileService.println(sb, "");
-        mAddressedMediaPlayer.dump(sb, mMediaController);
-
-        ProfileService.println(sb, "");
-        ProfileService.println(sb, mPassthroughDispatched + " passthrough operations: ");
-        if (mPassthroughDispatched > mPassthroughLogs.size()) {
-            ProfileService.println(sb, "  (last " + mPassthroughLogs.size() + ")");
-        }
-        synchronized (mPassthroughLogs) {
-            for (MediaKeyLog log : mPassthroughLogs) {
-                ProfileService.println(sb, "  " + log);
-            }
-        }
-        synchronized (mPassthroughPending) {
-            for (MediaKeyLog log : mPassthroughPending) {
-                ProfileService.println(sb, "  " + log);
-            }
-        }
-
-        // Print the blacklisted devices (for absolute volume control)
-        SharedPreferences pref =
-                mContext.getSharedPreferences(ABSOLUTE_VOLUME_BLACKLIST, Context.MODE_PRIVATE);
-        Map<String, ?> allKeys = pref.getAll();
-        ProfileService.println(sb, "");
-        ProfileService.println(sb, "Runtime Blacklisted Devices (absolute volume):");
-        if (allKeys.isEmpty()) {
-            ProfileService.println(sb, "  None");
-        } else {
-            for (Map.Entry<String, ?> entry : allKeys.entrySet()) {
-                String key = entry.getKey();
-                Object value = entry.getValue();
-                if (value instanceof String) {
-                    ProfileService.println(sb, "  " + key + " " + value);
-                } else {
-                    ProfileService.println(sb, "  " + key + " Reason: Unknown");
-                }
-            }
-        }
-    }
-
-    public class AvrcpBrowseManager {
-        public Map<String, BrowsedMediaPlayer> connList = new HashMap<String, BrowsedMediaPlayer>();
-        private AvrcpMediaRspInterface mMediaInterface;
-        private Context mContext;
-
-        public AvrcpBrowseManager(Context context, AvrcpMediaRspInterface mediaInterface) {
-            mContext = context;
-            mMediaInterface = mediaInterface;
-        }
-
-        public void cleanup() {
-            Iterator entries = connList.entrySet().iterator();
-            while (entries.hasNext()) {
-                Map.Entry entry = (Map.Entry) entries.next();
-                BrowsedMediaPlayer browsedMediaPlayer = (BrowsedMediaPlayer) entry.getValue();
-                if (browsedMediaPlayer != null) {
-                    browsedMediaPlayer.cleanup();
-                }
-            }
-            // clean up the map
-            connList.clear();
-        }
-
-        // get the a free media player interface based on the passed bd address
-        // if the no items is found for the passed media player then it assignes a
-        // available media player interface
-        public BrowsedMediaPlayer getBrowsedMediaPlayer(byte[] bdaddr) {
-            BrowsedMediaPlayer mediaPlayer;
-            String bdaddrStr = new String(bdaddr);
-            if (connList.containsKey(bdaddrStr)) {
-                mediaPlayer = connList.get(bdaddrStr);
-            } else {
-                mediaPlayer = new BrowsedMediaPlayer(bdaddr, mContext, mMediaInterface);
-                connList.put(bdaddrStr, mediaPlayer);
-            }
-            return mediaPlayer;
-        }
-
-        // clears the details pertaining to passed bdaddres
-        public boolean clearBrowsedMediaPlayer(byte[] bdaddr) {
-            String bdaddrStr = new String(bdaddr);
-            if (connList.containsKey(bdaddrStr)) {
-                connList.remove(bdaddrStr);
-                return true;
-            }
-            return false;
-        }
-
-        public Map<String, BrowsedMediaPlayer> getConnList() {
-            return connList;
-        }
-
-        /* Helper function to convert colon separated bdaddr to byte string */
-        private byte[] hexStringToByteArray(String s) {
-            int len = s.length();
-            byte[] data = new byte[len / 2];
-            for (int i = 0; i < len; i += 2) {
-                data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4) + Character.digit(
-                        s.charAt(i + 1), 16));
-            }
-            return data;
-        }
-    }
-
-    /*
-     * private class which handles responses from AvrcpMediaManager. Maps responses to native
-     * responses. This class implements the AvrcpMediaRspInterface interface.
-     */
-    private class AvrcpMediaRsp implements AvrcpMediaRspInterface {
-        private static final String TAG = "AvrcpMediaRsp";
-
-        @Override
-        public void setAddrPlayerRsp(byte[] address, int rspStatus) {
-            if (!setAddressedPlayerRspNative(address, rspStatus)) {
-                Log.e(TAG, "setAddrPlayerRsp failed!");
-            }
-        }
-
-        @Override
-        public void setBrowsedPlayerRsp(byte[] address, int rspStatus, byte depth, int numItems,
-                String[] textArray) {
-            if (!setBrowsedPlayerRspNative(address, rspStatus, depth, numItems, textArray)) {
-                Log.e(TAG, "setBrowsedPlayerRsp failed!");
-            }
-        }
-
-        @Override
-        public void mediaPlayerListRsp(byte[] address, int rspStatus, MediaPlayerListRsp rspObj) {
-            if (rspObj != null && rspStatus == AvrcpConstants.RSP_NO_ERROR) {
-                if (!mediaPlayerListRspNative(address, rspStatus, sUIDCounter, rspObj.mItemType,
-                        rspObj.mNumItems, rspObj.mPlayerIds, rspObj.mPlayerTypes,
-                        rspObj.mPlayerSubTypes, rspObj.mPlayStatusValues,
-                        rspObj.mFeatureBitMaskValues, rspObj.mPlayerNameList)) {
-                    Log.e(TAG, "mediaPlayerListRsp failed!");
-                }
-            } else {
-                Log.e(TAG, "mediaPlayerListRsp: rspObj is null");
-                if (!mediaPlayerListRspNative(address, rspStatus, sUIDCounter, (byte) 0x00, 0, null,
-                        null, null, null, null, null)) {
-                    Log.e(TAG, "mediaPlayerListRsp failed!");
-                }
-            }
-        }
-
-        @Override
-        public void folderItemsRsp(byte[] address, int rspStatus, FolderItemsRsp rspObj) {
-            if (rspObj != null && rspStatus == AvrcpConstants.RSP_NO_ERROR) {
-                if (!getFolderItemsRspNative(address, rspStatus, sUIDCounter, rspObj.mScope,
-                        rspObj.mNumItems, rspObj.mFolderTypes, rspObj.mPlayable, rspObj.mItemTypes,
-                        rspObj.mItemUid, rspObj.mDisplayNames, rspObj.mAttributesNum,
-                        rspObj.mAttrIds, rspObj.mAttrValues)) {
-                    Log.e(TAG, "getFolderItemsRspNative failed!");
-                }
-            } else {
-                Log.e(TAG, "folderItemsRsp: rspObj is null or rspStatus is error:" + rspStatus);
-                if (!getFolderItemsRspNative(address, rspStatus, sUIDCounter, (byte) 0x00, 0, null,
-                        null, null, null, null, null, null, null)) {
-                    Log.e(TAG, "getFolderItemsRspNative failed!");
-                }
-            }
-
-        }
-
-        @Override
-        public void changePathRsp(byte[] address, int rspStatus, int numItems) {
-            if (!changePathRspNative(address, rspStatus, numItems)) {
-                Log.e(TAG, "changePathRspNative failed!");
-            }
-        }
-
-        @Override
-        public void getItemAttrRsp(byte[] address, int rspStatus, ItemAttrRsp rspObj) {
-            if (rspObj != null && rspStatus == AvrcpConstants.RSP_NO_ERROR) {
-                if (!getItemAttrRspNative(address, rspStatus, rspObj.mNumAttr,
-                        rspObj.mAttributesIds, rspObj.mAttributesArray)) {
-                    Log.e(TAG, "getItemAttrRspNative failed!");
-                }
-            } else {
-                Log.e(TAG, "getItemAttrRsp: rspObj is null or rspStatus is error:" + rspStatus);
-                if (!getItemAttrRspNative(address, rspStatus, (byte) 0x00, null, null)) {
-                    Log.e(TAG, "getItemAttrRspNative failed!");
-                }
-            }
-        }
-
-        @Override
-        public void playItemRsp(byte[] address, int rspStatus) {
-            if (!playItemRspNative(address, rspStatus)) {
-                Log.e(TAG, "playItemRspNative failed!");
-            }
-        }
-
-        @Override
-        public void getTotalNumOfItemsRsp(byte[] address, int rspStatus, int uidCounter,
-                int numItems) {
-            if (!getTotalNumOfItemsRspNative(address, rspStatus, sUIDCounter, numItems)) {
-                Log.e(TAG, "getTotalNumOfItemsRspNative failed!");
-            }
-        }
-
-        @Override
-        public void addrPlayerChangedRsp(int type, int playerId, int uidCounter) {
-            if (!registerNotificationRspAddrPlayerChangedNative(type, playerId, sUIDCounter)) {
-                Log.e(TAG, "registerNotificationRspAddrPlayerChangedNative failed!");
-            }
-        }
-
-        @Override
-        public void avalPlayerChangedRsp(byte[] address, int type) {
-            if (!registerNotificationRspAvalPlayerChangedNative(type)) {
-                Log.e(TAG, "registerNotificationRspAvalPlayerChangedNative failed!");
-            }
-        }
-
-        @Override
-        public void uidsChangedRsp(int type) {
-            if (!registerNotificationRspUIDsChangedNative(type, sUIDCounter)) {
-                Log.e(TAG, "registerNotificationRspUIDsChangedNative failed!");
-            }
-        }
-
-        @Override
-        public void nowPlayingChangedRsp(int type) {
-            if (mNowPlayingListChangedNT != AvrcpConstants.NOTIFICATION_TYPE_INTERIM) {
-                if (DEBUG) {
-                    Log.d(TAG, "NowPlayingListChanged: Not registered or requesting.");
-                }
-                return;
-            }
-
-            if (!registerNotificationRspNowPlayingChangedNative(type)) {
-                Log.e(TAG, "registerNotificationRspNowPlayingChangedNative failed!");
-            }
-            mNowPlayingListChangedNT = AvrcpConstants.NOTIFICATION_TYPE_CHANGED;
-        }
-
-        @Override
-        public void trackChangedRsp(int type, byte[] uid) {
-            if (!registerNotificationRspTrackChangeNative(type, uid)) {
-                Log.e(TAG, "registerNotificationRspTrackChangeNative failed!");
-            }
-        }
-    }
-
-    /* getters for some private variables */
-    public AvrcpBrowseManager getAvrcpBrowseManager() {
-        return mAvrcpBrowseManager;
-    }
-
-    /* PASSTHROUGH COMMAND MANAGEMENT */
-
-    void handlePassthroughCmd(int op, int state) {
-        int code = avrcpPassthroughToKeyCode(op);
-        if (code == KeyEvent.KEYCODE_UNKNOWN) {
-            Log.w(TAG, "Ignoring passthrough of unknown key " + op + " state " + state);
-            return;
-        }
-        int action = KeyEvent.ACTION_DOWN;
-        if (state == AvrcpConstants.KEY_STATE_RELEASE) {
-            action = KeyEvent.ACTION_UP;
-        }
-        KeyEvent event = new KeyEvent(action, code);
-        if (!KeyEvent.isMediaKey(code)) {
-            Log.w(TAG, "Passthrough non-media key " + op + " (code " + code + ") state " + state);
-        }
-
-        mMediaSessionManager.dispatchMediaKeyEvent(event);
-        addKeyPending(event);
-    }
-
-    private int avrcpPassthroughToKeyCode(int operation) {
-        switch (operation) {
-            case BluetoothAvrcp.PASSTHROUGH_ID_UP:
-                return KeyEvent.KEYCODE_DPAD_UP;
-            case BluetoothAvrcp.PASSTHROUGH_ID_DOWN:
-                return KeyEvent.KEYCODE_DPAD_DOWN;
-            case BluetoothAvrcp.PASSTHROUGH_ID_LEFT:
-                return KeyEvent.KEYCODE_DPAD_LEFT;
-            case BluetoothAvrcp.PASSTHROUGH_ID_RIGHT:
-                return KeyEvent.KEYCODE_DPAD_RIGHT;
-            case BluetoothAvrcp.PASSTHROUGH_ID_RIGHT_UP:
-                return KeyEvent.KEYCODE_DPAD_UP_RIGHT;
-            case BluetoothAvrcp.PASSTHROUGH_ID_RIGHT_DOWN:
-                return KeyEvent.KEYCODE_DPAD_DOWN_RIGHT;
-            case BluetoothAvrcp.PASSTHROUGH_ID_LEFT_UP:
-                return KeyEvent.KEYCODE_DPAD_UP_LEFT;
-            case BluetoothAvrcp.PASSTHROUGH_ID_LEFT_DOWN:
-                return KeyEvent.KEYCODE_DPAD_DOWN_LEFT;
-            case BluetoothAvrcp.PASSTHROUGH_ID_0:
-                return KeyEvent.KEYCODE_NUMPAD_0;
-            case BluetoothAvrcp.PASSTHROUGH_ID_1:
-                return KeyEvent.KEYCODE_NUMPAD_1;
-            case BluetoothAvrcp.PASSTHROUGH_ID_2:
-                return KeyEvent.KEYCODE_NUMPAD_2;
-            case BluetoothAvrcp.PASSTHROUGH_ID_3:
-                return KeyEvent.KEYCODE_NUMPAD_3;
-            case BluetoothAvrcp.PASSTHROUGH_ID_4:
-                return KeyEvent.KEYCODE_NUMPAD_4;
-            case BluetoothAvrcp.PASSTHROUGH_ID_5:
-                return KeyEvent.KEYCODE_NUMPAD_5;
-            case BluetoothAvrcp.PASSTHROUGH_ID_6:
-                return KeyEvent.KEYCODE_NUMPAD_6;
-            case BluetoothAvrcp.PASSTHROUGH_ID_7:
-                return KeyEvent.KEYCODE_NUMPAD_7;
-            case BluetoothAvrcp.PASSTHROUGH_ID_8:
-                return KeyEvent.KEYCODE_NUMPAD_8;
-            case BluetoothAvrcp.PASSTHROUGH_ID_9:
-                return KeyEvent.KEYCODE_NUMPAD_9;
-            case BluetoothAvrcp.PASSTHROUGH_ID_DOT:
-                return KeyEvent.KEYCODE_NUMPAD_DOT;
-            case BluetoothAvrcp.PASSTHROUGH_ID_ENTER:
-                return KeyEvent.KEYCODE_NUMPAD_ENTER;
-            case BluetoothAvrcp.PASSTHROUGH_ID_CLEAR:
-                return KeyEvent.KEYCODE_CLEAR;
-            case BluetoothAvrcp.PASSTHROUGH_ID_CHAN_UP:
-                return KeyEvent.KEYCODE_CHANNEL_UP;
-            case BluetoothAvrcp.PASSTHROUGH_ID_CHAN_DOWN:
-                return KeyEvent.KEYCODE_CHANNEL_DOWN;
-            case BluetoothAvrcp.PASSTHROUGH_ID_PREV_CHAN:
-                return KeyEvent.KEYCODE_LAST_CHANNEL;
-            case BluetoothAvrcp.PASSTHROUGH_ID_INPUT_SEL:
-                return KeyEvent.KEYCODE_TV_INPUT;
-            case BluetoothAvrcp.PASSTHROUGH_ID_DISP_INFO:
-                return KeyEvent.KEYCODE_INFO;
-            case BluetoothAvrcp.PASSTHROUGH_ID_HELP:
-                return KeyEvent.KEYCODE_HELP;
-            case BluetoothAvrcp.PASSTHROUGH_ID_PAGE_UP:
-                return KeyEvent.KEYCODE_PAGE_UP;
-            case BluetoothAvrcp.PASSTHROUGH_ID_PAGE_DOWN:
-                return KeyEvent.KEYCODE_PAGE_DOWN;
-            case BluetoothAvrcp.PASSTHROUGH_ID_POWER:
-                return KeyEvent.KEYCODE_POWER;
-            case BluetoothAvrcp.PASSTHROUGH_ID_VOL_UP:
-                return KeyEvent.KEYCODE_VOLUME_UP;
-            case BluetoothAvrcp.PASSTHROUGH_ID_VOL_DOWN:
-                return KeyEvent.KEYCODE_VOLUME_DOWN;
-            case BluetoothAvrcp.PASSTHROUGH_ID_MUTE:
-                return KeyEvent.KEYCODE_MUTE;
-            case BluetoothAvrcp.PASSTHROUGH_ID_PLAY:
-                return KeyEvent.KEYCODE_MEDIA_PLAY;
-            case BluetoothAvrcp.PASSTHROUGH_ID_STOP:
-                return KeyEvent.KEYCODE_MEDIA_STOP;
-            case BluetoothAvrcp.PASSTHROUGH_ID_PAUSE:
-                return KeyEvent.KEYCODE_MEDIA_PAUSE;
-            case BluetoothAvrcp.PASSTHROUGH_ID_RECORD:
-                return KeyEvent.KEYCODE_MEDIA_RECORD;
-            case BluetoothAvrcp.PASSTHROUGH_ID_REWIND:
-                return KeyEvent.KEYCODE_MEDIA_REWIND;
-            case BluetoothAvrcp.PASSTHROUGH_ID_FAST_FOR:
-                return KeyEvent.KEYCODE_MEDIA_FAST_FORWARD;
-            case BluetoothAvrcp.PASSTHROUGH_ID_EJECT:
-                return KeyEvent.KEYCODE_MEDIA_EJECT;
-            case BluetoothAvrcp.PASSTHROUGH_ID_FORWARD:
-                return KeyEvent.KEYCODE_MEDIA_NEXT;
-            case BluetoothAvrcp.PASSTHROUGH_ID_BACKWARD:
-                return KeyEvent.KEYCODE_MEDIA_PREVIOUS;
-            case BluetoothAvrcp.PASSTHROUGH_ID_F1:
-                return KeyEvent.KEYCODE_F1;
-            case BluetoothAvrcp.PASSTHROUGH_ID_F2:
-                return KeyEvent.KEYCODE_F2;
-            case BluetoothAvrcp.PASSTHROUGH_ID_F3:
-                return KeyEvent.KEYCODE_F3;
-            case BluetoothAvrcp.PASSTHROUGH_ID_F4:
-                return KeyEvent.KEYCODE_F4;
-            case BluetoothAvrcp.PASSTHROUGH_ID_F5:
-                return KeyEvent.KEYCODE_F5;
-            // Fallthrough for all unknown key mappings
-            case BluetoothAvrcp.PASSTHROUGH_ID_SELECT:
-            case BluetoothAvrcp.PASSTHROUGH_ID_ROOT_MENU:
-            case BluetoothAvrcp.PASSTHROUGH_ID_SETUP_MENU:
-            case BluetoothAvrcp.PASSTHROUGH_ID_CONT_MENU:
-            case BluetoothAvrcp.PASSTHROUGH_ID_FAV_MENU:
-            case BluetoothAvrcp.PASSTHROUGH_ID_EXIT:
-            case BluetoothAvrcp.PASSTHROUGH_ID_SOUND_SEL:
-            case BluetoothAvrcp.PASSTHROUGH_ID_ANGLE:
-            case BluetoothAvrcp.PASSTHROUGH_ID_SUBPICT:
-            case BluetoothAvrcp.PASSTHROUGH_ID_VENDOR:
-            default:
-                return KeyEvent.KEYCODE_UNKNOWN;
-        }
-    }
-
-    private void addKeyPending(KeyEvent event) {
-        mPassthroughPending.add(new MediaKeyLog(System.currentTimeMillis(), event));
-    }
-
-    private void recordKeyDispatched(KeyEvent event, String packageName) {
-        long time = System.currentTimeMillis();
-        Log.v(TAG, "recordKeyDispatched: " + event + " dispatched to " + packageName);
-        setAddressedMediaSessionPackage(packageName);
-        synchronized (mPassthroughPending) {
-            Iterator<MediaKeyLog> pending = mPassthroughPending.iterator();
-            while (pending.hasNext()) {
-                MediaKeyLog log = pending.next();
-                if (log.addDispatch(time, event, packageName)) {
-                    mPassthroughDispatched++;
-                    mPassthroughLogs.add(log);
-                    pending.remove();
-                    return;
-                }
-            }
-            Log.w(TAG, "recordKeyDispatch: can't find matching log!");
-        }
-    }
-
-    private final MediaSessionManager.Callback mButtonDispatchCallback =
-            new MediaSessionManager.Callback() {
-                @Override
-                public void onMediaKeyEventDispatched(KeyEvent event, MediaSession.Token token) {
-                    // Get the package name
-                    android.media.session.MediaController controller =
-                            new android.media.session.MediaController(mContext, token);
-                    String targetPackage = controller.getPackageName();
-                    recordKeyDispatched(event, targetPackage);
-                }
-
-                @Override
-                public void onMediaKeyEventDispatched(KeyEvent event, ComponentName receiver) {
-                    recordKeyDispatched(event, receiver.getPackageName());
-                }
-
-                @Override
-                public void onAddressedPlayerChanged(MediaSession.Token token) {
-                    setActiveMediaSession(token);
-                }
-
-                @Override
-                public void onAddressedPlayerChanged(ComponentName receiver) {
-                    if (receiver == null) {
-                        // No active sessions, and no session to revive, give up.
-                        setAddressedMediaSessionPackage(null);
-                        return;
-                    }
-                    // We can still get a passthrough which will revive this player.
-                    setAddressedMediaSessionPackage(receiver.getPackageName());
-                }
-            };
-
-    // Do not modify without updating the HAL bt_rc.h files.
-
-    // match up with btrc_play_status_t enum of bt_rc.h
-    static final byte PLAYSTATUS_STOPPED = 0;
-    static final byte PLAYSTATUS_PLAYING = 1;
-    static final byte PLAYSTATUS_PAUSED = 2;
-    static final byte PLAYSTATUS_FWD_SEEK = 3;
-    static final byte PLAYSTATUS_REV_SEEK = 4;
-    static final byte PLAYSTATUS_ERROR = (byte) 255;
-
-    // match up with btrc_media_attr_t enum of bt_rc.h
-    static final int MEDIA_ATTR_TITLE = 1;
-    static final int MEDIA_ATTR_ARTIST = 2;
-    static final int MEDIA_ATTR_ALBUM = 3;
-    static final int MEDIA_ATTR_TRACK_NUM = 4;
-    static final int MEDIA_ATTR_NUM_TRACKS = 5;
-    static final int MEDIA_ATTR_GENRE = 6;
-    static final int MEDIA_ATTR_PLAYING_TIME = 7;
-
-    // match up with btrc_event_id_t enum of bt_rc.h
-    static final int EVT_PLAY_STATUS_CHANGED = 1;
-    static final int EVT_TRACK_CHANGED = 2;
-    static final int EVT_TRACK_REACHED_END = 3;
-    static final int EVT_TRACK_REACHED_START = 4;
-    static final int EVT_PLAY_POS_CHANGED = 5;
-    static final int EVT_BATT_STATUS_CHANGED = 6;
-    static final int EVT_SYSTEM_STATUS_CHANGED = 7;
-    static final int EVT_APP_SETTINGS_CHANGED = 8;
-    static final int EVENT_NOW_PLAYING_CONTENT_CHANGED = 9;
-    static final int EVT_AVBL_PLAYERS_CHANGED = 0xa;
-    static final int EVT_ADDR_PLAYER_CHANGED = 0xb;
-    static final int EVENT_UIDS_CHANGED = 0x0c;
-
-    private static native void classInitNative();
-
-    private native void initNative();
-
-    private native void cleanupNative();
-
-    private native boolean getPlayStatusRspNative(byte[] address, int playStatus, int songLen,
-            int songPos);
-
-    private native boolean getElementAttrRspNative(byte[] address, byte numAttr, int[] attrIds,
-            String[] textArray);
-
-    private native boolean registerNotificationRspPlayStatusNative(int type, int playStatus);
-
-    private native boolean registerNotificationRspTrackChangeNative(int type, byte[] track);
-
-    private native boolean registerNotificationRspPlayPosNative(int type, int playPos);
-
-    private native boolean setVolumeNative(int volume);
-
-    private native boolean sendPassThroughCommandNative(int keyCode, int keyState);
-
-    private native boolean setAddressedPlayerRspNative(byte[] address, int rspStatus);
-
-    private native boolean setBrowsedPlayerRspNative(byte[] address, int rspStatus, byte depth,
-            int numItems, String[] textArray);
-
-    private native boolean mediaPlayerListRspNative(byte[] address, int rsStatus, int uidCounter,
-            byte itemType, int numItems, int[] playerIds, byte[] playerTypes, int[] playerSubTypes,
-            byte[] playStatusValues, short[] featureBitMaskValues, String[] textArray);
-
-    private native boolean getFolderItemsRspNative(byte[] address, int rspStatus, short uidCounter,
-            byte scope, int numItems, byte[] folderTypes, byte[] playable, byte[] itemTypes,
-            byte[] itemUidArray, String[] textArray, int[] attributesNum, int[] attributesIds,
-            String[] attributesArray);
-
-    private native boolean changePathRspNative(byte[] address, int rspStatus, int numItems);
-
-    private native boolean getItemAttrRspNative(byte[] address, int rspStatus, byte numAttr,
-            int[] attrIds, String[] textArray);
-
-    private native boolean playItemRspNative(byte[] address, int rspStatus);
-
-    private native boolean getTotalNumOfItemsRspNative(byte[] address, int rspStatus,
-            int uidCounter, int numItems);
-
-    private native boolean searchRspNative(byte[] address, int rspStatus, int uidCounter,
-            int numItems);
-
-    private native boolean addToNowPlayingRspNative(byte[] address, int rspStatus);
-
-    private native boolean registerNotificationRspAddrPlayerChangedNative(int type, int playerId,
-            int uidCounter);
-
-    private native boolean registerNotificationRspAvalPlayerChangedNative(int type);
-
-    private native boolean registerNotificationRspUIDsChangedNative(int type, int uidCounter);
-
-    private native boolean registerNotificationRspNowPlayingChangedNative(int type);
-
-}
diff --git a/src/com/android/bluetooth/avrcp/AvrcpConstants.java b/src/com/android/bluetooth/avrcp/AvrcpConstants.java
deleted file mode 100644
index 50a2eeb..0000000
--- a/src/com/android/bluetooth/avrcp/AvrcpConstants.java
+++ /dev/null
@@ -1,165 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.bluetooth.avrcp;
-
-/*************************************************************************************************
- * Grouped all HAL constants into a file to be consistent with the stack.
- * Moved the constants used in Avrcp to this new file to be used across multiple files.
- * Helps in easier modifications and future enhancements in the constants.
- ************************************************************************************************/
-
-/*
- * @hide
- */
-final class AvrcpConstants {
-
-    /* Do not modify without upating the HAL bt_rc.h file */
-    /** Response Error codes **/
-    static final byte RSP_BAD_CMD = 0x00; /* Invalid command */
-    static final byte RSP_BAD_PARAM = 0x01; /* Invalid parameter */
-    static final byte RSP_NOT_FOUND = 0x02; /* Specified parameter is
-                                                              * wrong or not found */
-    static final byte RSP_INTERNAL_ERR = 0x03; /* Internal Error */
-    static final byte RSP_NO_ERROR = 0x04; /* Operation Success */
-    static final byte RSP_UID_CHANGED = 0x05; /* UIDs changed */
-    static final byte RSP_RESERVED = 0x06; /* Reserved */
-    static final byte RSP_INV_DIRN = 0x07; /* Invalid direction */
-    static final byte RSP_INV_DIRECTORY = 0x08; /* Invalid directory */
-    static final byte RSP_INV_ITEM = 0x09; /* Invalid Item */
-    static final byte RSP_INV_SCOPE = 0x0a; /* Invalid scope */
-    static final byte RSP_INV_RANGE = 0x0b; /* Invalid range */
-    static final byte RSP_DIRECTORY = 0x0c; /* UID is a directory */
-    static final byte RSP_MEDIA_IN_USE = 0x0d; /* Media in use */
-    static final byte RSP_PLAY_LIST_FULL = 0x0e; /* Playing list full */
-    static final byte RSP_SRCH_NOT_SPRTD = 0x0f; /* Search not supported */
-    static final byte RSP_SRCH_IN_PROG = 0x10; /* Search in progress */
-    static final byte RSP_INV_PLAYER = 0x11; /* Invalid player */
-    static final byte RSP_PLAY_NOT_BROW = 0x12; /* Player not browsable */
-    static final byte RSP_PLAY_NOT_ADDR = 0x13; /* Player not addressed */
-    static final byte RSP_INV_RESULTS = 0x14; /* Invalid results */
-    static final byte RSP_NO_AVBL_PLAY = 0x15; /* No available players */
-    static final byte RSP_ADDR_PLAY_CHGD = 0x16; /* Addressed player changed */
-
-    /* valid scopes for get_folder_items */
-    static final byte BTRC_SCOPE_PLAYER_LIST = 0x00; /* Media Player List */
-    static final byte BTRC_SCOPE_FILE_SYSTEM = 0x01; /* Virtual File System */
-    static final byte BTRC_SCOPE_SEARCH = 0x02; /* Search */
-    static final byte BTRC_SCOPE_NOW_PLAYING = 0x03; /* Now Playing */
-
-    /* valid directions for change path */
-    static final byte DIR_UP = 0x00;
-    static final byte DIR_DOWN = 0x01;
-
-    /* item type to browse */
-    static final byte BTRC_ITEM_PLAYER = 0x01;
-    static final byte BTRC_ITEM_FOLDER = 0x02;
-    static final byte BTRC_ITEM_MEDIA = 0x03;
-
-    /* valid folder types */
-    static final byte FOLDER_TYPE_MIXED = 0x00;
-    static final byte FOLDER_TYPE_TITLES = 0x01;
-    static final byte FOLDER_TYPE_ALBUMS = 0x02;
-    static final byte FOLDER_TYPE_ARTISTS = 0x03;
-    static final byte FOLDER_TYPE_GENRES = 0x04;
-    static final byte FOLDER_TYPE_PLAYLISTS = 0x05;
-    static final byte FOLDER_TYPE_YEARS = 0x06;
-
-    /* valid playable flags */
-    static final byte ITEM_NOT_PLAYABLE = 0x00;
-    static final byte ITEM_PLAYABLE = 0x01;
-
-    /* valid Attribute ids for media elements */
-    static final int ATTRID_TITLE = 0x01;
-    static final int ATTRID_ARTIST = 0x02;
-    static final int ATTRID_ALBUM = 0x03;
-    static final int ATTRID_TRACK_NUM = 0x04;
-    static final int ATTRID_NUM_TRACKS = 0x05;
-    static final int ATTRID_GENRE = 0x06;
-    static final int ATTRID_PLAY_TIME = 0x07;
-    static final int ATTRID_COVER_ART = 0x08;
-
-    /* constants to send in Track change response */
-    static final byte[] NO_TRACK_SELECTED = {
-            (byte) 0xFF,
-            (byte) 0xFF,
-            (byte) 0xFF,
-            (byte) 0xFF,
-            (byte) 0xFF,
-            (byte) 0xFF,
-            (byte) 0xFF,
-            (byte) 0xFF
-    };
-    static final byte[] TRACK_IS_SELECTED = {
-            (byte) 0x00,
-            (byte) 0x00,
-            (byte) 0x00,
-            (byte) 0x00,
-            (byte) 0x00,
-            (byte) 0x00,
-            (byte) 0x00,
-            (byte) 0x00
-    };
-
-    /* UID size */
-    static final int UID_SIZE = 8;
-
-    static final short DEFAULT_UID_COUNTER = 0x0000;
-
-    /* Bitmask size for Media Players */
-    static final int AVRC_FEATURE_MASK_SIZE = 16;
-
-    /* Maximum attributes for media item */
-    static final int MAX_NUM_ATTR = 8;
-
-    /* notification types for remote device */
-    static final int NOTIFICATION_TYPE_INTERIM = 0;
-    static final int NOTIFICATION_TYPE_CHANGED = 1;
-
-    static final int TRACK_ID_SIZE = 8;
-
-    /* player feature bit mask constants */
-    static final short AVRC_PF_PLAY_BIT_NO = 40;
-    static final short AVRC_PF_STOP_BIT_NO = 41;
-    static final short AVRC_PF_PAUSE_BIT_NO = 42;
-    static final short AVRC_PF_REWIND_BIT_NO = 44;
-    static final short AVRC_PF_FAST_FWD_BIT_NO = 45;
-    static final short AVRC_PF_FORWARD_BIT_NO = 47;
-    static final short AVRC_PF_BACKWARD_BIT_NO = 48;
-    static final short AVRC_PF_ADV_CTRL_BIT_NO = 58;
-    static final short AVRC_PF_BROWSE_BIT_NO = 59;
-    static final short AVRC_PF_ADD2NOWPLAY_BIT_NO = 61;
-    static final short AVRC_PF_UID_UNIQUE_BIT_NO = 62;
-    static final short AVRC_PF_NOW_PLAY_BIT_NO = 65;
-    static final short AVRC_PF_GET_NUM_OF_ITEMS_BIT_NO = 67;
-
-    static final byte PLAYER_TYPE_AUDIO = 1;
-    static final int PLAYER_SUBTYPE_NONE = 0;
-
-    // match up with btrc_play_status_t enum of bt_rc.h
-    static final int PLAYSTATUS_STOPPED = 0;
-    static final int PLAYSTATUS_PLAYING = 1;
-    static final int PLAYSTATUS_PAUSED = 2;
-    static final int PLAYSTATUS_FWD_SEEK = 3;
-    static final int PLAYSTATUS_REV_SEEK = 4;
-    static final int PLAYSTATUS_ERROR = 255;
-
-    static final byte NUM_ATTR_ALL = (byte) 0x00;
-    static final byte NUM_ATTR_NONE = (byte) 0xFF;
-
-    static final int KEY_STATE_PRESS = 1;
-    static final int KEY_STATE_RELEASE = 0;
-}
diff --git a/src/com/android/bluetooth/avrcp/AvrcpHelperClasses.java b/src/com/android/bluetooth/avrcp/AvrcpHelperClasses.java
deleted file mode 100644
index ea6d7b8..0000000
--- a/src/com/android/bluetooth/avrcp/AvrcpHelperClasses.java
+++ /dev/null
@@ -1,451 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.bluetooth.avrcp;
-
-import android.annotation.NonNull;
-import android.annotation.Nullable;
-
-import com.android.bluetooth.Utils;
-
-import java.util.ArrayDeque;
-import java.util.Arrays;
-import java.util.Collection;
-
-/*************************************************************************************************
- * Helper classes used for callback/response of browsing commands:-
- *     1) To bundle parameters for  native callbacks/response.
- *     2) Stores information of Addressed and Browsed Media Players.
- ************************************************************************************************/
-
-class AvrcpCmd {
-
-    AvrcpCmd() {}
-
-    /* Helper classes to pass parameters from callbacks to Avrcp handler */
-    class FolderItemsCmd {
-        byte mScope;
-        long mStartItem;
-        long mEndItem;
-        byte mNumAttr;
-        int[] mAttrIDs;
-        public byte[] mAddress;
-
-        FolderItemsCmd(byte[] address, byte scope, long startItem, long endItem, byte numAttr,
-                int[] attrIds) {
-            mAddress = address;
-            this.mScope = scope;
-            this.mStartItem = startItem;
-            this.mEndItem = endItem;
-            this.mNumAttr = numAttr;
-            this.mAttrIDs = attrIds;
-        }
-
-        @Override
-        public String toString() {
-            StringBuilder sb = new StringBuilder();
-            sb.append("[FolderItemCmd: scope " + mScope);
-            sb.append(" start " + mStartItem);
-            sb.append(" end " + mEndItem);
-            sb.append(" numAttr " + mNumAttr);
-            sb.append(" attrs: ");
-            for (int i = 0; i < mNumAttr; i++) {
-                sb.append(mAttrIDs[i] + " ");
-            }
-            return sb.toString();
-        }
-    }
-
-    class ItemAttrCmd {
-        byte mScope;
-        byte[] mUid;
-        int mUidCounter;
-        byte mNumAttr;
-        int[] mAttrIDs;
-        public byte[] mAddress;
-
-        ItemAttrCmd(byte[] address, byte scope, byte[] uid, int uidCounter, byte numAttr,
-                int[] attrIDs) {
-            mAddress = address;
-            mScope = scope;
-            mUid = uid;
-            mUidCounter = uidCounter;
-            mNumAttr = numAttr;
-            mAttrIDs = attrIDs;
-        }
-
-        @Override
-        public String toString() {
-            StringBuilder sb = new StringBuilder();
-            sb.append("[ItemAttrCmd: scope " + mScope);
-            sb.append(" uid " + Utils.byteArrayToString(mUid));
-            sb.append(" numAttr " + mNumAttr);
-            sb.append(" attrs: ");
-            for (int i = 0; i < mNumAttr; i++) {
-                sb.append(mAttrIDs[i] + " ");
-            }
-            return sb.toString();
-        }
-    }
-
-    class ElementAttrCmd {
-        byte mNumAttr;
-        int[] mAttrIDs;
-        public byte[] mAddress;
-
-        ElementAttrCmd(byte[] address, byte numAttr, int[] attrIDs) {
-            mAddress = address;
-            mNumAttr = numAttr;
-            mAttrIDs = attrIDs;
-        }
-    }
-}
-
-/* Helper classes to pass parameters to native response */
-class MediaPlayerListRsp {
-    byte mStatus;
-    short mUIDCounter;
-    byte mItemType;
-    int[] mPlayerIds;
-    byte[] mPlayerTypes;
-    int[] mPlayerSubTypes;
-    byte[] mPlayStatusValues;
-    short[] mFeatureBitMaskValues;
-    String[] mPlayerNameList;
-    int mNumItems;
-
-    MediaPlayerListRsp(byte status, short uidCounter, int numItems, byte itemType, int[] playerIds,
-            byte[] playerTypes, int[] playerSubTypes, byte[] playStatusValues,
-            short[] featureBitMaskValues, String[] playerNameList) {
-        this.mStatus = status;
-        this.mUIDCounter = uidCounter;
-        this.mNumItems = numItems;
-        this.mItemType = itemType;
-        this.mPlayerIds = playerIds;
-        this.mPlayerTypes = playerTypes;
-        this.mPlayerSubTypes = new int[numItems];
-        this.mPlayerSubTypes = playerSubTypes;
-        this.mPlayStatusValues = new byte[numItems];
-        this.mPlayStatusValues = playStatusValues;
-        int bitMaskSize = AvrcpConstants.AVRC_FEATURE_MASK_SIZE;
-        this.mFeatureBitMaskValues = new short[numItems * bitMaskSize];
-        for (int bitMaskIndex = 0; bitMaskIndex < (numItems * bitMaskSize); bitMaskIndex++) {
-            this.mFeatureBitMaskValues[bitMaskIndex] = featureBitMaskValues[bitMaskIndex];
-        }
-        this.mPlayerNameList = playerNameList;
-    }
-}
-
-class FolderItemsRsp {
-    byte mStatus;
-    short mUIDCounter;
-    byte mScope;
-    int mNumItems;
-    byte[] mFolderTypes;
-    byte[] mPlayable;
-    byte[] mItemTypes;
-    byte[] mItemUid;
-    String[] mDisplayNames; /* display name of the item. Eg: Folder name or song name */
-    int[] mAttributesNum;
-    int[] mAttrIds;
-    String[] mAttrValues;
-
-    FolderItemsRsp(byte status, short uidCounter, byte scope, int numItems, byte[] folderTypes,
-            byte[] playable, byte[] itemTypes, byte[] itemsUid, String[] displayNameArray,
-            int[] attributesNum, int[] attrIds, String[] attrValues) {
-        this.mStatus = status;
-        this.mUIDCounter = uidCounter;
-        this.mScope = scope;
-        this.mNumItems = numItems;
-        this.mFolderTypes = folderTypes;
-        this.mPlayable = playable;
-        this.mItemTypes = itemTypes;
-        this.mItemUid = itemsUid;
-        this.mDisplayNames = displayNameArray;
-        this.mAttributesNum = attributesNum;
-        this.mAttrIds = attrIds;
-        this.mAttrValues = attrValues;
-    }
-}
-
-class ItemAttrRsp {
-    byte mStatus;
-    byte mNumAttr;
-    int[] mAttributesIds;
-    String[] mAttributesArray;
-
-    ItemAttrRsp(byte status, int[] attributesIds, String[] attributesArray) {
-        mStatus = status;
-        mNumAttr = (byte) attributesIds.length;
-        mAttributesIds = attributesIds;
-        mAttributesArray = attributesArray;
-    }
-}
-
-/* stores information of Media Players in the system */
-class MediaPlayerInfo {
-
-    private byte mMajorType;
-    private int mSubType;
-    private byte mPlayStatus;
-    private short[] mFeatureBitMask;
-    @NonNull private String mPackageName;
-    @NonNull private String mDisplayableName;
-    @Nullable private MediaController mMediaController;
-
-    MediaPlayerInfo(@Nullable MediaController controller, byte majorType, int subType,
-            byte playStatus, short[] featureBitMask, @NonNull String packageName,
-            @Nullable String displayableName) {
-        this.setMajorType(majorType);
-        this.setSubType(subType);
-        this.mPlayStatus = playStatus;
-        // store a copy the FeatureBitMask array
-        this.mFeatureBitMask = Arrays.copyOf(featureBitMask, featureBitMask.length);
-        Arrays.sort(this.mFeatureBitMask);
-        this.setPackageName(packageName);
-        this.setDisplayableName(displayableName);
-        this.setMediaController(controller);
-    }
-
-    /* getters and setters */
-    byte getPlayStatus() {
-        return mPlayStatus;
-    }
-
-    void setPlayStatus(byte playStatus) {
-        this.mPlayStatus = playStatus;
-    }
-
-    MediaController getMediaController() {
-        return mMediaController;
-    }
-
-    void setMediaController(MediaController mediaController) {
-        if (mediaController != null) {
-            this.mPackageName = mediaController.getPackageName();
-        }
-        this.mMediaController = mediaController;
-    }
-
-    void setPackageName(@NonNull String name) {
-        // Controller determines package name when it is set.
-        if (mMediaController != null) {
-            return;
-        }
-        this.mPackageName = name;
-    }
-
-    String getPackageName() {
-        if (mMediaController != null) {
-            return mMediaController.getPackageName();
-        } else if (mPackageName != null) {
-            return mPackageName;
-        }
-        return null;
-    }
-
-    byte getMajorType() {
-        return mMajorType;
-    }
-
-    void setMajorType(byte majorType) {
-        this.mMajorType = majorType;
-    }
-
-    int getSubType() {
-        return mSubType;
-    }
-
-    void setSubType(int subType) {
-        this.mSubType = subType;
-    }
-
-    String getDisplayableName() {
-        return mDisplayableName;
-    }
-
-    void setDisplayableName(@Nullable String displayableName) {
-        if (displayableName == null) {
-            displayableName = "";
-        }
-        this.mDisplayableName = displayableName;
-    }
-
-    short[] getFeatureBitMask() {
-        return mFeatureBitMask;
-    }
-
-    void setFeatureBitMask(short[] featureBitMask) {
-        synchronized (this) {
-            this.mFeatureBitMask = Arrays.copyOf(featureBitMask, featureBitMask.length);
-            Arrays.sort(this.mFeatureBitMask);
-        }
-    }
-
-    boolean isBrowseSupported() {
-        synchronized (this) {
-            if (this.mFeatureBitMask == null) {
-                return false;
-            }
-            for (short bit : this.mFeatureBitMask) {
-                if (bit == AvrcpConstants.AVRC_PF_BROWSE_BIT_NO) {
-                    return true;
-                }
-            }
-        }
-        return false;
-    }
-
-    /** Tests if the view of this player presented to the controller is different enough to
-     *  justify sending an Available Players Changed update */
-    public boolean equalView(MediaPlayerInfo other) {
-        return (this.mMajorType == other.getMajorType()) && (this.mSubType == other.getSubType())
-                && Arrays.equals(this.mFeatureBitMask, other.getFeatureBitMask())
-                && this.mDisplayableName.equals(other.getDisplayableName());
-    }
-
-    @Override
-    public String toString() {
-        StringBuilder sb = new StringBuilder();
-        sb.append("MediaPlayerInfo ");
-        sb.append(getPackageName());
-        sb.append(" (as '" + getDisplayableName() + "')");
-        sb.append(" Type = " + getMajorType());
-        sb.append(", SubType = " + getSubType());
-        sb.append(", Status = " + mPlayStatus);
-        sb.append(" Feature Bits [");
-        short[] bits = getFeatureBitMask();
-        for (int i = 0; i < bits.length; i++) {
-            if (i != 0) {
-                sb.append(" ");
-            }
-            sb.append(bits[i]);
-        }
-        sb.append("] Controller: ");
-        sb.append(getMediaController());
-        return sb.toString();
-    }
-}
-
-/* stores information for browsable Media Players available in the system */
-class BrowsePlayerInfo {
-    public String packageName;
-    public String displayableName;
-    public String serviceClass;
-
-    BrowsePlayerInfo(String packageName, String displayableName, String serviceClass) {
-        this.packageName = packageName;
-        this.displayableName = displayableName;
-        this.serviceClass = serviceClass;
-    }
-
-    @Override
-    public String toString() {
-        StringBuilder sb = new StringBuilder();
-        sb.append("BrowsePlayerInfo ");
-        sb.append(packageName);
-        sb.append(" ( as '" + displayableName + "')");
-        sb.append(" service " + serviceClass);
-        return sb.toString();
-    }
-}
-
-class FolderItemsData {
-    /* initialize sizes for rsp parameters */ int mNumItems;
-    int[] mAttributesNum;
-    byte[] mFolderTypes;
-    byte[] mItemTypes;
-    byte[] mPlayable;
-    byte[] mItemUid;
-    String[] mDisplayNames;
-    int[] mAttrIds;
-    String[] mAttrValues;
-    int mAttrCounter;
-
-    FolderItemsData(int size) {
-        mNumItems = size;
-        mAttributesNum = new int[size];
-
-        mFolderTypes = new byte[size]; /* folderTypes */
-        mItemTypes = new byte[size]; /* folder or media item */
-        mPlayable = new byte[size];
-        Arrays.fill(mFolderTypes, AvrcpConstants.FOLDER_TYPE_MIXED);
-        Arrays.fill(mItemTypes, AvrcpConstants.BTRC_ITEM_MEDIA);
-        Arrays.fill(mPlayable, AvrcpConstants.ITEM_PLAYABLE);
-
-        mItemUid = new byte[size * AvrcpConstants.UID_SIZE];
-        mDisplayNames = new String[size];
-
-        mAttrIds = null; /* array of attr ids */
-        mAttrValues = null; /* array of attr values */
-    }
-}
-
-/** A queue that evicts the first element when you add an element to the end when it reaches a
- * maximum size.
- * This is useful for keeping a FIFO queue of items where the items drop off the front, i.e. a log
- * with a maximum size.
- */
-class EvictingQueue<E> extends ArrayDeque<E> {
-    private int mMaxSize;
-
-    EvictingQueue(int maxSize) {
-        super();
-        mMaxSize = maxSize;
-    }
-
-    EvictingQueue(int maxSize, int initialElements) {
-        super(initialElements);
-        mMaxSize = maxSize;
-    }
-
-    EvictingQueue(int maxSize, Collection<? extends E> c) {
-        super(c);
-        mMaxSize = maxSize;
-    }
-
-    @Override
-    public void addFirst(E e) {
-        if (super.size() == mMaxSize) {
-            return;
-        }
-        super.addFirst(e);
-    }
-
-    @Override
-    public void addLast(E e) {
-        if (super.size() == mMaxSize) {
-            super.remove();
-        }
-        super.addLast(e);
-    }
-
-    @Override
-    public boolean offerFirst(E e) {
-        if (super.size() == mMaxSize) {
-            return false;
-        }
-        return super.offerFirst(e);
-    }
-
-    @Override
-    public boolean offerLast(E e) {
-        if (super.size() == mMaxSize) {
-            super.remove();
-        }
-        return super.offerLast(e);
-    }
-}
diff --git a/src/com/android/bluetooth/avrcp/AvrcpMediaRspInterface.java b/src/com/android/bluetooth/avrcp/AvrcpMediaRspInterface.java
deleted file mode 100644
index 8cab68e..0000000
--- a/src/com/android/bluetooth/avrcp/AvrcpMediaRspInterface.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.bluetooth.avrcp;
-
-
-/*************************************************************************************************
- * Interface for classes which handle callbacks from AvrcpMediaManager.
- * These callbacks should map to native responses and used to communicate with the native layer.
- ************************************************************************************************/
-
-public interface AvrcpMediaRspInterface {
-    void setAddrPlayerRsp(byte[] address, int rspStatus);
-
-    void setBrowsedPlayerRsp(byte[] address, int rspStatus, byte depth, int numItems,
-            String[] textArray);
-
-    void mediaPlayerListRsp(byte[] address, int rspStatus, MediaPlayerListRsp rspObj);
-
-    void folderItemsRsp(byte[] address, int rspStatus, FolderItemsRsp rspObj);
-
-    void changePathRsp(byte[] address, int rspStatus, int numItems);
-
-    void getItemAttrRsp(byte[] address, int rspStatus, ItemAttrRsp rspObj);
-
-    void playItemRsp(byte[] address, int rspStatus);
-
-    void getTotalNumOfItemsRsp(byte[] address, int rspStatus, int uidCounter, int numItems);
-
-    void addrPlayerChangedRsp(int type, int playerId, int uidCounter);
-
-    void avalPlayerChangedRsp(byte[] address, int type);
-
-    void uidsChangedRsp(int type);
-
-    void nowPlayingChangedRsp(int type);
-
-    void trackChangedRsp(int type, byte[] uid);
-}
-
diff --git a/src/com/android/bluetooth/avrcp/BrowsedMediaPlayer.java b/src/com/android/bluetooth/avrcp/BrowsedMediaPlayer.java
deleted file mode 100644
index 0889d90..0000000
--- a/src/com/android/bluetooth/avrcp/BrowsedMediaPlayer.java
+++ /dev/null
@@ -1,842 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.bluetooth.avrcp;
-
-import android.annotation.NonNull;
-import android.content.ComponentName;
-import android.content.Context;
-import android.media.MediaDescription;
-import android.media.MediaMetadata;
-import android.media.browse.MediaBrowser;
-import android.media.browse.MediaBrowser.MediaItem;
-import android.media.session.MediaSession;
-import android.os.Bundle;
-import android.util.Log;
-
-import java.math.BigInteger;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Stack;
-
-/*************************************************************************************************
- * Provides functionality required for Browsed Media Player like browsing Virtual File System, get
- * Item Attributes, play item from the file system, etc.
- * Acts as an Interface to communicate with Media Browsing APIs for browsing FileSystem.
- ************************************************************************************************/
-
-class BrowsedMediaPlayer {
-    private static final boolean DEBUG = false;
-    private static final String TAG = "BrowsedMediaPlayer";
-
-    /* connection state with MediaBrowseService */
-    private static final int DISCONNECTED = 0;
-    private static final int CONNECTED = 1;
-    private static final int SUSPENDED = 2;
-
-    private static final String[] ROOT_FOLDER = {"root"};
-
-    /*  package and service name of target Media Player which is set for browsing */
-    private String mPackageName;
-    private String mConnectingPackageName;
-    private String mClassName;
-    private Context mContext;
-    private AvrcpMediaRspInterface mMediaInterface;
-    private byte[] mBDAddr;
-
-    /* Object used to connect to MediaBrowseService of Media Player */
-    private MediaBrowser mMediaBrowser = null;
-    private MediaController mMediaController = null;
-
-    /* The mediaId to be used for subscribing for children using the MediaBrowser */
-    private String mMediaId = null;
-    private String mRootFolderUid = null;
-    private int mConnState = DISCONNECTED;
-
-    /* stores the path trail during changePath */
-    private Stack<String> mPathStack = null;
-
-    /* Number of items in current folder */
-    private int mCurrFolderNumItems = 0;
-
-    /* store mapping between uid(Avrcp) and mediaId(Media Player). */
-    private HashMap<Integer, String> mHmap = new HashMap<Integer, String>();
-
-    /* command objects from avrcp handler */
-    private AvrcpCmd.FolderItemsCmd mFolderItemsReqObj;
-
-    /* store result of getfolderitems with scope="vfs" */
-    private List<MediaBrowser.MediaItem> mFolderItems = null;
-
-    /* Connection state callback handler */
-    class MediaConnectionCallback extends MediaBrowser.ConnectionCallback {
-        private String mCallbackPackageName;
-        private MediaBrowser mBrowser;
-
-        MediaConnectionCallback(String packageName) {
-            this.mCallbackPackageName = packageName;
-        }
-
-        public void setBrowser(MediaBrowser b) {
-            mBrowser = b;
-        }
-
-        @Override
-        public void onConnected() {
-            mConnState = CONNECTED;
-            if (DEBUG) {
-                Log.d(TAG, "mediaBrowser CONNECTED to " + mPackageName);
-            }
-            /* perform init tasks and set player as browsed player on successful connection */
-            onBrowseConnect(mCallbackPackageName, mBrowser);
-
-            // Remove what could be a circular dependency causing GC to never happen on this object
-            mBrowser = null;
-        }
-
-        @Override
-        public void onConnectionFailed() {
-            mConnState = DISCONNECTED;
-            // Remove what could be a circular dependency causing GC to never happen on this object
-            mBrowser = null;
-            Log.e(TAG, "mediaBrowser Connection failed with " + mPackageName
-                    + ", Sending fail response!");
-            mMediaInterface.setBrowsedPlayerRsp(mBDAddr, AvrcpConstants.RSP_INTERNAL_ERR,
-                    (byte) 0x00, 0, null);
-        }
-
-        @Override
-        public void onConnectionSuspended() {
-            mBrowser = null;
-            mConnState = SUSPENDED;
-            Log.e(TAG, "mediaBrowser SUSPENDED connection with " + mPackageName);
-        }
-    }
-
-    /* Subscription callback handler. Subscribe to a folder to get its contents */
-    private MediaBrowser.SubscriptionCallback mFolderItemsCb =
-            new MediaBrowser.SubscriptionCallback() {
-
-                @Override
-                public void onChildrenLoaded(String parentId,
-                        List<MediaBrowser.MediaItem> children) {
-                    if (DEBUG) {
-                        Log.d(TAG, "OnChildren Loaded folder items: childrens= " + children.size());
-                    }
-
-            /*
-             * cache current folder items and send as rsp when remote requests
-             * get_folder_items (scope = vfs)
-             */
-                    if (mFolderItems == null) {
-                        if (DEBUG) {
-                            Log.d(TAG, "sending setbrowsed player rsp");
-                        }
-                        mFolderItems = children;
-                        mMediaInterface.setBrowsedPlayerRsp(mBDAddr, AvrcpConstants.RSP_NO_ERROR,
-                                (byte) 0x00, children.size(), ROOT_FOLDER);
-                    } else {
-                        mFolderItems = children;
-                        mCurrFolderNumItems = mFolderItems.size();
-                        mMediaInterface.changePathRsp(mBDAddr, AvrcpConstants.RSP_NO_ERROR,
-                                mCurrFolderNumItems);
-                    }
-                    mMediaBrowser.unsubscribe(parentId);
-                }
-
-                /* UID is invalid */
-                @Override
-                public void onError(String id) {
-                    Log.e(TAG, "set browsed player rsp. Could not get root folder items");
-                    mMediaInterface.setBrowsedPlayerRsp(mBDAddr, AvrcpConstants.RSP_INTERNAL_ERR,
-                            (byte) 0x00, 0, null);
-                }
-            };
-
-    /* callback from media player in response to getitemAttr request */
-    private class ItemAttribSubscriber extends MediaBrowser.SubscriptionCallback {
-        private String mMediaId;
-        private AvrcpCmd.ItemAttrCmd mAttrReq;
-
-        ItemAttribSubscriber(@NonNull AvrcpCmd.ItemAttrCmd attrReq, @NonNull String mediaId) {
-            mAttrReq = attrReq;
-            mMediaId = mediaId;
-        }
-
-        @Override
-        public void onChildrenLoaded(String parentId, List<MediaBrowser.MediaItem> children) {
-            String logprefix = "ItemAttribSubscriber(" + mMediaId + "): ";
-            if (DEBUG) {
-                Log.d(TAG, logprefix + "OnChildren Loaded");
-            }
-            int status = AvrcpConstants.RSP_INV_ITEM;
-
-            if (children == null) {
-                Log.w(TAG, logprefix + "children list is null parentId: " + parentId);
-            } else {
-                /* find the item in the folder */
-                for (MediaBrowser.MediaItem item : children) {
-                    if (item.getMediaId().equals(mMediaId)) {
-                        if (DEBUG) {
-                            Log.d(TAG, logprefix + "found item");
-                        }
-                        getItemAttrFilterAttr(item);
-                        status = AvrcpConstants.RSP_NO_ERROR;
-                        break;
-                    }
-                }
-            }
-            /* Send only error from here, in case of success, getItemAttrFilterAttr sends */
-            if (status != AvrcpConstants.RSP_NO_ERROR) {
-                Log.e(TAG, logprefix + "not able to find item from " + parentId);
-                mMediaInterface.getItemAttrRsp(mBDAddr, status, null);
-            }
-            mMediaBrowser.unsubscribe(parentId);
-        }
-
-        @Override
-        public void onError(String id) {
-            Log.e(TAG, "Could not get attributes from media player id: " + id);
-            mMediaInterface.getItemAttrRsp(mBDAddr, AvrcpConstants.RSP_INTERNAL_ERR, null);
-        }
-
-        /* helper method to filter required attibuteand send GetItemAttr response */
-        private void getItemAttrFilterAttr(@NonNull MediaBrowser.MediaItem mediaItem) {
-            /* Response parameters */
-            int[] attrIds = null; /* array of attr ids */
-            String[] attrValues = null; /* array of attr values */
-
-            /* variables to temperorily add attrs */
-            ArrayList<Integer> attrIdArray = new ArrayList<Integer>();
-            ArrayList<String> attrValueArray = new ArrayList<String>();
-            ArrayList<Integer> attrReqIds = new ArrayList<Integer>();
-
-            if (mAttrReq.mNumAttr == AvrcpConstants.NUM_ATTR_NONE) {
-                // Note(jamuraa): the stack should never send this, remove?
-                Log.i(TAG, "getItemAttrFilterAttr: No attributes requested");
-                mMediaInterface.getItemAttrRsp(mBDAddr, AvrcpConstants.RSP_BAD_PARAM, null);
-                return;
-            }
-
-            /* check if remote device has requested all attributes */
-            if (mAttrReq.mNumAttr == AvrcpConstants.NUM_ATTR_ALL
-                    || mAttrReq.mNumAttr == AvrcpConstants.MAX_NUM_ATTR) {
-                for (int idx = 1; idx <= AvrcpConstants.MAX_NUM_ATTR; idx++) {
-                    attrReqIds.add(idx); /* attr id 0x00 is unused */
-                }
-            } else {
-                /* get only the requested attribute ids from the request */
-                for (int idx = 0; idx < mAttrReq.mNumAttr; idx++) {
-                    attrReqIds.add(mAttrReq.mAttrIDs[idx]);
-                }
-            }
-
-            /* lookup and copy values of attributes for ids requested above */
-            for (int attrId : attrReqIds) {
-                /* check if media player provided requested attributes */
-                String value = getAttrValue(attrId, mediaItem);
-                if (value != null) {
-                    attrIdArray.add(attrId);
-                    attrValueArray.add(value);
-                }
-            }
-
-            /* copy filtered attr ids and attr values to response parameters */
-            attrIds = new int[attrIdArray.size()];
-            for (int i = 0; i < attrIdArray.size(); i++) {
-                attrIds[i] = attrIdArray.get(i);
-            }
-
-            attrValues = attrValueArray.toArray(new String[attrIdArray.size()]);
-
-            /* create rsp object and send response */
-            ItemAttrRsp rspObj = new ItemAttrRsp(AvrcpConstants.RSP_NO_ERROR, attrIds, attrValues);
-            mMediaInterface.getItemAttrRsp(mBDAddr, AvrcpConstants.RSP_NO_ERROR, rspObj);
-        }
-    }
-
-    /* Constructor */
-    BrowsedMediaPlayer(byte[] address, Context context,
-            AvrcpMediaRspInterface mAvrcpMediaRspInterface) {
-        mContext = context;
-        mMediaInterface = mAvrcpMediaRspInterface;
-        mBDAddr = address;
-    }
-
-    /* initialize mediacontroller in order to communicate with media player. */
-    private void onBrowseConnect(String connectedPackage, MediaBrowser browser) {
-        if (!connectedPackage.equals(mConnectingPackageName)) {
-            Log.w(TAG, "onBrowseConnect: recieved callback for package we aren't connecting to "
-                    + connectedPackage);
-            return;
-        }
-        mConnectingPackageName = null;
-
-        if (browser == null) {
-            Log.e(TAG, "onBrowseConnect: received a null browser for " + connectedPackage);
-            mMediaInterface.setBrowsedPlayerRsp(mBDAddr, AvrcpConstants.RSP_INTERNAL_ERR,
-                    (byte) 0x00, 0, null);
-            return;
-        }
-
-        MediaSession.Token token = null;
-        try {
-            if (!browser.isConnected()) {
-                Log.e(TAG, "setBrowsedPlayer: " + mPackageName + "not connected");
-            } else if ((token = browser.getSessionToken()) == null) {
-                Log.e(TAG, "setBrowsedPlayer: " + mPackageName + "no Session token");
-            } else {
-                /* update to the new MediaBrowser */
-                if (mMediaBrowser != null) {
-                    mMediaBrowser.disconnect();
-                }
-                mMediaBrowser = browser;
-                mPackageName = connectedPackage;
-
-                /* get rootfolder uid from media player */
-                if (mMediaId == null) {
-                    mMediaId = mMediaBrowser.getRoot();
-                    /*
-                     * assuming that root folder uid will not change on uids changed
-                     */
-                    mRootFolderUid = mMediaId;
-                    /* store root folder uid to stack */
-                    mPathStack.push(mMediaId);
-                }
-
-                mMediaController = MediaControllerFactory.make(mContext, token);
-                /* get root folder items */
-                mMediaBrowser.subscribe(mRootFolderUid, mFolderItemsCb);
-                return;
-            }
-        } catch (NullPointerException ex) {
-            Log.e(TAG, "setBrowsedPlayer : Null pointer during init");
-            ex.printStackTrace();
-        }
-
-        mMediaInterface.setBrowsedPlayerRsp(mBDAddr, AvrcpConstants.RSP_INTERNAL_ERR, (byte) 0x00,
-                0, null);
-    }
-
-    public void setBrowsed(String packageName, String cls) {
-        mConnectingPackageName = packageName;
-        mClassName = cls;
-        /* cleanup variables from previous browsed calls */
-        mFolderItems = null;
-        mMediaId = null;
-        mRootFolderUid = null;
-        /*
-         * create stack to store the navigation trail (current folder ID). This
-         * will be required while navigating up the folder
-         */
-        mPathStack = new Stack<String>();
-
-        /* Bind to MediaBrowseService of MediaPlayer */
-        MediaConnectionCallback callback = new MediaConnectionCallback(packageName);
-        MediaBrowser tempBrowser =
-                new MediaBrowser(mContext, new ComponentName(packageName, mClassName), callback,
-                        null);
-        callback.setBrowser(tempBrowser);
-
-        tempBrowser.connect();
-    }
-
-    /* called when connection to media player is closed */
-    public void cleanup() {
-        if (DEBUG) {
-            Log.d(TAG, "cleanup");
-        }
-
-        if (mConnState != DISCONNECTED) {
-            mMediaBrowser.disconnect();
-        }
-
-        mHmap = null;
-        mMediaController = null;
-        mMediaBrowser = null;
-        mPathStack = null;
-    }
-
-    public boolean isPlayerConnected() {
-        if (mMediaBrowser == null) {
-            if (DEBUG) {
-                Log.d(TAG, "isPlayerConnected: mMediaBrowser = null!");
-            }
-            return false;
-        }
-
-        return mMediaBrowser.isConnected();
-    }
-
-    /* returns number of items in new path as reponse */
-    public void changePath(byte[] folderUid, byte direction) {
-        if (DEBUG) {
-            Log.d(TAG, "changePath.direction = " + direction);
-        }
-        String newPath = "";
-
-        if (!isPlayerConnected()) {
-            Log.w(TAG, "changePath: disconnected from player service, sending internal error");
-            mMediaInterface.changePathRsp(mBDAddr, AvrcpConstants.RSP_INTERNAL_ERR, 0);
-            return;
-        }
-
-        if (mMediaBrowser == null) {
-            Log.e(TAG, "Media browser is null, sending internal error");
-            mMediaInterface.changePathRsp(mBDAddr, AvrcpConstants.RSP_INTERNAL_ERR, 0);
-            return;
-        }
-
-        /* check direction and change the path */
-        if (direction == AvrcpConstants.DIR_DOWN) { /* move down */
-            if ((newPath = byteToString(folderUid)) == null) {
-                Log.e(TAG, "Could not get media item from folder Uid, sending err response");
-                mMediaInterface.changePathRsp(mBDAddr, AvrcpConstants.RSP_INV_ITEM, 0);
-            } else if (!isBrowsableFolderDn(newPath)) {
-                /* new path is not browsable */
-                Log.e(TAG, "ItemUid received from changePath cmd is not browsable");
-                mMediaInterface.changePathRsp(mBDAddr, AvrcpConstants.RSP_INV_DIRECTORY, 0);
-            } else if (mPathStack.peek().equals(newPath)) {
-                /* new_folder is same as current folder */
-                Log.e(TAG, "new_folder is same as current folder, Invalid direction!");
-                mMediaInterface.changePathRsp(mBDAddr, AvrcpConstants.RSP_INV_DIRN, 0);
-            } else {
-                mMediaBrowser.subscribe(newPath, mFolderItemsCb);
-                /* assume that call is success and update stack with new folder path */
-                mPathStack.push(newPath);
-            }
-        } else if (direction == AvrcpConstants.DIR_UP) { /* move up */
-            if (!isBrowsableFolderUp()) {
-                /* Already on the root, cannot allow up: PTS: test case TC_TG_MCN_CB_BI_02_C
-                 * This is required, otherwise some CT will keep on sending change path up
-                 * until they receive error */
-                Log.w(TAG, "Cannot go up from now, already in the root, Invalid direction!");
-                mMediaInterface.changePathRsp(mBDAddr, AvrcpConstants.RSP_INV_DIRN, 0);
-            } else {
-                /* move folder up */
-                mPathStack.pop();
-                newPath = mPathStack.peek();
-                mMediaBrowser.subscribe(newPath, mFolderItemsCb);
-            }
-        } else { /* invalid direction */
-            Log.w(TAG, "changePath : Invalid direction " + direction);
-            mMediaInterface.changePathRsp(mBDAddr, AvrcpConstants.RSP_INV_DIRN, 0);
-        }
-    }
-
-    public void getItemAttr(AvrcpCmd.ItemAttrCmd itemAttr) {
-        String mediaID;
-        if (DEBUG) {
-            Log.d(TAG, "getItemAttr");
-        }
-
-        /* check if uid is valid by doing a lookup in hashmap */
-        mediaID = byteToString(itemAttr.mUid);
-        if (mediaID == null) {
-            Log.e(TAG, "uid is invalid");
-            mMediaInterface.getItemAttrRsp(mBDAddr, AvrcpConstants.RSP_INV_ITEM, null);
-            return;
-        }
-
-        /* check scope */
-        if (itemAttr.mScope != AvrcpConstants.BTRC_SCOPE_FILE_SYSTEM) {
-            Log.e(TAG, "invalid scope");
-            mMediaInterface.getItemAttrRsp(mBDAddr, AvrcpConstants.RSP_INV_SCOPE, null);
-            return;
-        }
-
-        if (mMediaBrowser == null) {
-            Log.e(TAG, "mMediaBrowser is null");
-            mMediaInterface.getItemAttrRsp(mBDAddr, AvrcpConstants.RSP_INTERNAL_ERR, null);
-            return;
-        }
-
-        /* Subscribe to the parent to list items and retrieve the right one */
-        mMediaBrowser.subscribe(mPathStack.peek(), new ItemAttribSubscriber(itemAttr, mediaID));
-    }
-
-    public void getTotalNumOfItems(byte scope) {
-        if (DEBUG) {
-            Log.d(TAG, "getTotalNumOfItems scope = " + scope);
-        }
-        if (scope != AvrcpConstants.BTRC_SCOPE_FILE_SYSTEM) {
-            Log.e(TAG, "getTotalNumOfItems error" + scope);
-            mMediaInterface.getTotalNumOfItemsRsp(mBDAddr, AvrcpConstants.RSP_INV_SCOPE, 0, 0);
-            return;
-        }
-
-        if (mFolderItems == null) {
-            Log.e(TAG, "mFolderItems is null, sending internal error");
-            /* folderitems were not fetched during change path */
-            mMediaInterface.getTotalNumOfItemsRsp(mBDAddr, AvrcpConstants.RSP_INTERNAL_ERR, 0, 0);
-            return;
-        }
-
-        /* find num items using size of already cached folder items */
-        mMediaInterface.getTotalNumOfItemsRsp(mBDAddr, AvrcpConstants.RSP_NO_ERROR, 0,
-                mFolderItems.size());
-    }
-
-    public void getFolderItemsVFS(AvrcpCmd.FolderItemsCmd reqObj) {
-        if (!isPlayerConnected()) {
-            Log.e(TAG, "unable to connect to media player, sending internal error");
-            /* unable to connect to media player. Send error response to remote device */
-            mMediaInterface.folderItemsRsp(mBDAddr, AvrcpConstants.RSP_INTERNAL_ERR, null);
-            return;
-        }
-
-        if (DEBUG) {
-            Log.d(TAG, "getFolderItemsVFS");
-        }
-        mFolderItemsReqObj = reqObj;
-
-        if (mFolderItems == null) {
-            /* Failed to fetch folder items from media player. Send error to remote device */
-            Log.e(TAG, "Failed to fetch folder items during getFolderItemsVFS");
-            mMediaInterface.folderItemsRsp(mBDAddr, AvrcpConstants.RSP_INTERNAL_ERR, null);
-            return;
-        }
-
-        /* Filter attributes based on the request and send response to remote device */
-        getFolderItemsFilterAttr(mBDAddr, reqObj, mFolderItems,
-                AvrcpConstants.BTRC_SCOPE_FILE_SYSTEM, mFolderItemsReqObj.mStartItem,
-                mFolderItemsReqObj.mEndItem);
-    }
-
-    /* Instructs media player to play particular media item */
-    public void playItem(byte[] uid, byte scope) {
-        String folderUid;
-
-        if (isPlayerConnected()) {
-            /* check if uid is valid */
-            if ((folderUid = byteToString(uid)) == null) {
-                Log.e(TAG, "uid is invalid!");
-                mMediaInterface.playItemRsp(mBDAddr, AvrcpConstants.RSP_INV_ITEM);
-                return;
-            }
-
-            if (mMediaController != null) {
-                MediaController.TransportControls mediaControllerCntrl =
-                        mMediaController.getTransportControls();
-                if (DEBUG) {
-                    Log.d(TAG, "Sending playID: " + folderUid);
-                }
-
-                if (scope == AvrcpConstants.BTRC_SCOPE_FILE_SYSTEM) {
-                    mediaControllerCntrl.playFromMediaId(folderUid, null);
-                    mMediaInterface.playItemRsp(mBDAddr, AvrcpConstants.RSP_NO_ERROR);
-                } else {
-                    Log.e(TAG, "playItem received for invalid scope!");
-                    mMediaInterface.playItemRsp(mBDAddr, AvrcpConstants.RSP_INV_SCOPE);
-                }
-            } else {
-                Log.e(TAG, "mediaController is null");
-                mMediaInterface.playItemRsp(mBDAddr, AvrcpConstants.RSP_INTERNAL_ERR);
-            }
-        } else {
-            Log.e(TAG, "playItem: Not connected to media player");
-            mMediaInterface.playItemRsp(mBDAddr, AvrcpConstants.RSP_INTERNAL_ERR);
-        }
-    }
-
-    /*
-     * helper method to check if startItem and endItem index is with range of
-     * MediaItem list. (Resultset containing all items in current path)
-     */
-    private List<MediaBrowser.MediaItem> checkIndexOutofBounds(byte[] bdaddr,
-            List<MediaBrowser.MediaItem> children, long startItem, long endItem) {
-        if (endItem >= children.size()) {
-            endItem = children.size() - 1;
-        }
-        if (startItem >= Integer.MAX_VALUE) {
-            startItem = Integer.MAX_VALUE;
-        }
-        try {
-            List<MediaBrowser.MediaItem> childrenSubList =
-                    children.subList((int) startItem, (int) endItem + 1);
-            if (childrenSubList.isEmpty()) {
-                Log.i(TAG, "childrenSubList is empty.");
-                throw new IndexOutOfBoundsException();
-            }
-            return childrenSubList;
-        } catch (IndexOutOfBoundsException ex) {
-            Log.w(TAG, "Index out of bounds start item =" + startItem + " end item = " + Math.min(
-                    children.size(), endItem + 1));
-            return null;
-        } catch (IllegalArgumentException ex) {
-            Log.i(TAG, "Index out of bounds start item =" + startItem + " > size");
-            return null;
-        }
-    }
-
-
-    /*
-     * helper method to filter required attibutes before sending GetFolderItems response
-     */
-    public void getFolderItemsFilterAttr(byte[] bdaddr, AvrcpCmd.FolderItemsCmd mFolderItemsReqObj,
-            List<MediaBrowser.MediaItem> children, byte scope, long startItem, long endItem) {
-        if (DEBUG) {
-            Log.d(TAG,
-                    "getFolderItemsFilterAttr: startItem =" + startItem + ", endItem = " + endItem);
-        }
-
-        List<MediaBrowser.MediaItem> resultItems = new ArrayList<MediaBrowser.MediaItem>();
-
-        if (children == null) {
-            Log.e(TAG, "Error: children are null in getFolderItemsFilterAttr");
-            mMediaInterface.folderItemsRsp(bdaddr, AvrcpConstants.RSP_INV_RANGE, null);
-            return;
-        }
-
-        /* check for index out of bound errors */
-        resultItems = checkIndexOutofBounds(bdaddr, children, startItem, endItem);
-        if (resultItems == null) {
-            Log.w(TAG, "resultItems is null.");
-            mMediaInterface.folderItemsRsp(bdaddr, AvrcpConstants.RSP_INV_RANGE, null);
-            return;
-        }
-        FolderItemsData folderDataNative = new FolderItemsData(resultItems.size());
-
-        /* variables to temperorily add attrs */
-        ArrayList<String> attrArray = new ArrayList<String>();
-        ArrayList<Integer> attrId = new ArrayList<Integer>();
-
-        for (int itemIndex = 0; itemIndex < resultItems.size(); itemIndex++) {
-            /* item type. Needs to be set by media player */
-            MediaBrowser.MediaItem item = resultItems.get(itemIndex);
-            int flags = item.getFlags();
-            if ((flags & MediaBrowser.MediaItem.FLAG_BROWSABLE) != 0) {
-                folderDataNative.mItemTypes[itemIndex] = AvrcpConstants.BTRC_ITEM_FOLDER;
-            } else {
-                folderDataNative.mItemTypes[itemIndex] = AvrcpConstants.BTRC_ITEM_MEDIA;
-            }
-
-            /* set playable */
-            if ((flags & MediaBrowser.MediaItem.FLAG_PLAYABLE) != 0) {
-                folderDataNative.mPlayable[itemIndex] = AvrcpConstants.ITEM_PLAYABLE;
-            } else {
-                folderDataNative.mPlayable[itemIndex] = AvrcpConstants.ITEM_NOT_PLAYABLE;
-            }
-            /* set uid for current item */
-            byte[] uid = stringToByte(item.getDescription().getMediaId());
-            for (int idx = 0; idx < AvrcpConstants.UID_SIZE; idx++) {
-                folderDataNative.mItemUid[itemIndex * AvrcpConstants.UID_SIZE + idx] = uid[idx];
-            }
-
-            /* Set display name for current item */
-            folderDataNative.mDisplayNames[itemIndex] =
-                    getAttrValue(AvrcpConstants.ATTRID_TITLE, item);
-
-            int maxAttributesRequested = 0;
-            boolean isAllAttribRequested = false;
-            /* check if remote requested for attributes */
-            if (mFolderItemsReqObj.mNumAttr != AvrcpConstants.NUM_ATTR_NONE) {
-                int attrCnt = 0;
-
-                /* add requested attr ids to a temp array */
-                if (mFolderItemsReqObj.mNumAttr == AvrcpConstants.NUM_ATTR_ALL) {
-                    isAllAttribRequested = true;
-                    maxAttributesRequested = AvrcpConstants.MAX_NUM_ATTR;
-                } else {
-                    /* get only the requested attribute ids from the request */
-                    maxAttributesRequested = mFolderItemsReqObj.mNumAttr;
-                }
-
-                /* lookup and copy values of attributes for ids requested above */
-                for (int idx = 0; idx < maxAttributesRequested; idx++) {
-                    /* check if media player provided requested attributes */
-                    String value = null;
-
-                    int attribId =
-                            isAllAttribRequested ? (idx + 1) : mFolderItemsReqObj.mAttrIDs[idx];
-                    value = getAttrValue(attribId, resultItems.get(itemIndex));
-                    if (value != null) {
-                        attrArray.add(value);
-                        attrId.add(attribId);
-                        attrCnt++;
-                    }
-                }
-                /* add num attr actually received from media player for a particular item */
-                folderDataNative.mAttributesNum[itemIndex] = attrCnt;
-            }
-        }
-
-        /* copy filtered attr ids and attr values to response parameters */
-        if (attrId.size() > 0) {
-            folderDataNative.mAttrIds = new int[attrId.size()];
-            for (int attrIndex = 0; attrIndex < attrId.size(); attrIndex++) {
-                folderDataNative.mAttrIds[attrIndex] = attrId.get(attrIndex);
-            }
-            folderDataNative.mAttrValues = attrArray.toArray(new String[attrArray.size()]);
-        }
-
-        /* create rsp object and send response to remote device */
-        FolderItemsRsp rspObj =
-                new FolderItemsRsp(AvrcpConstants.RSP_NO_ERROR, Avrcp.sUIDCounter, scope,
-                        folderDataNative.mNumItems, folderDataNative.mFolderTypes,
-                        folderDataNative.mPlayable, folderDataNative.mItemTypes,
-                        folderDataNative.mItemUid, folderDataNative.mDisplayNames,
-                        folderDataNative.mAttributesNum, folderDataNative.mAttrIds,
-                        folderDataNative.mAttrValues);
-        mMediaInterface.folderItemsRsp(bdaddr, AvrcpConstants.RSP_NO_ERROR, rspObj);
-    }
-
-    public static String getAttrValue(int attr, MediaBrowser.MediaItem item) {
-        String attrValue = null;
-        try {
-            MediaDescription desc = item.getDescription();
-            Bundle extras = desc.getExtras();
-            switch (attr) {
-                /* Title is mandatory attribute */
-                case AvrcpConstants.ATTRID_TITLE:
-                    attrValue = desc.getTitle().toString();
-                    break;
-
-                case AvrcpConstants.ATTRID_ARTIST:
-                    attrValue = extras.getString(MediaMetadata.METADATA_KEY_ARTIST);
-                    break;
-
-                case AvrcpConstants.ATTRID_ALBUM:
-                    attrValue = extras.getString(MediaMetadata.METADATA_KEY_ALBUM);
-                    break;
-
-                case AvrcpConstants.ATTRID_TRACK_NUM:
-                    attrValue = extras.getString(MediaMetadata.METADATA_KEY_TRACK_NUMBER);
-                    break;
-
-                case AvrcpConstants.ATTRID_NUM_TRACKS:
-                    attrValue = extras.getString(MediaMetadata.METADATA_KEY_NUM_TRACKS);
-                    break;
-
-                case AvrcpConstants.ATTRID_GENRE:
-                    attrValue = extras.getString(MediaMetadata.METADATA_KEY_GENRE);
-                    break;
-
-                case AvrcpConstants.ATTRID_PLAY_TIME:
-                    attrValue = extras.getString(MediaMetadata.METADATA_KEY_DURATION);
-                    break;
-
-                case AvrcpConstants.ATTRID_COVER_ART:
-                    Log.e(TAG, "getAttrValue: Cover art attribute not supported");
-                    return null;
-
-                default:
-                    Log.e(TAG, "getAttrValue: Unknown attribute ID requested: " + attr);
-                    return null;
-            }
-        } catch (NullPointerException ex) {
-            Log.w(TAG, "getAttrValue: attr id not found in result");
-            /* checking if attribute is title, then it is mandatory and cannot send null */
-            if (attr == AvrcpConstants.ATTRID_TITLE) {
-                attrValue = "<Unknown Title>";
-            } else {
-                return null;
-            }
-        }
-        if (DEBUG) {
-            Log.d(TAG, "getAttrValue: attrvalue = " + attrValue + "attr id:" + attr);
-        }
-        return attrValue;
-    }
-
-
-    public String getPackageName() {
-        return mPackageName;
-    }
-
-    /* Helper methods */
-
-    /* check if item is browsable Down*/
-    private boolean isBrowsableFolderDn(String uid) {
-        for (MediaBrowser.MediaItem item : mFolderItems) {
-            if (item.getMediaId().equals(uid) && (
-                    (item.getFlags() & MediaBrowser.MediaItem.FLAG_BROWSABLE)
-                            == MediaBrowser.MediaItem.FLAG_BROWSABLE)) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /* check if browsable Up*/
-    private boolean isBrowsableFolderUp() {
-        if (mPathStack.peek().equals(mRootFolderUid)) {
-            /* Already on the root, cannot go up */
-            return false;
-        }
-        return true;
-    }
-
-    /* convert uid to mediaId */
-    private String byteToString(byte[] byteArray) {
-        int uid = new BigInteger(byteArray).intValue();
-        String mediaId = mHmap.get(uid);
-        return mediaId;
-    }
-
-    /* convert mediaId to uid */
-    private byte[] stringToByte(String mediaId) {
-        /* check if this mediaId already exists in hashmap */
-        if (!mHmap.containsValue(mediaId)) { /* add to hashmap */
-            // Offset by one as uid 0 is reserved
-            int uid = mHmap.size() + 1;
-            mHmap.put(uid, mediaId);
-            return intToByteArray(uid);
-        } else { /* search key for give mediaId */
-            for (int uid : mHmap.keySet()) {
-                if (mHmap.get(uid).equals(mediaId)) {
-                    return intToByteArray(uid);
-                }
-            }
-        }
-        return null;
-    }
-
-    /* converts queue item received from getQueue call, to MediaItem used by FilterAttr method */
-    private List<MediaBrowser.MediaItem> queueItem2MediaItem(
-            List<MediaSession.QueueItem> tempItems) {
-
-        List<MediaBrowser.MediaItem> tempMedia = new ArrayList<MediaBrowser.MediaItem>();
-        for (int itemCount = 0; itemCount < tempItems.size(); itemCount++) {
-            MediaDescription.Builder build = new MediaDescription.Builder();
-            build.setMediaId(Long.toString(tempItems.get(itemCount).getQueueId()));
-            build.setTitle(tempItems.get(itemCount).getDescription().getTitle());
-            build.setExtras(tempItems.get(itemCount).getDescription().getExtras());
-            MediaDescription des = build.build();
-            MediaItem item = new MediaItem((des), MediaItem.FLAG_PLAYABLE);
-            tempMedia.add(item);
-        }
-        return tempMedia;
-    }
-
-    /* convert integer to byte array of size 8 bytes */
-    public byte[] intToByteArray(int value) {
-        int index = 0;
-        byte[] encodedValue = new byte[AvrcpConstants.UID_SIZE];
-
-        encodedValue[index++] = (byte) 0x00;
-        encodedValue[index++] = (byte) 0x00;
-        encodedValue[index++] = (byte) 0x00;
-        encodedValue[index++] = (byte) 0x00;
-        encodedValue[index++] = (byte) (value >> 24);
-        encodedValue[index++] = (byte) (value >> 16);
-        encodedValue[index++] = (byte) (value >> 8);
-        encodedValue[index++] = (byte) value;
-
-        return encodedValue;
-    }
-}
diff --git a/src/com/android/bluetooth/avrcp/mockable/MediaBrowser.java b/src/com/android/bluetooth/avrcp/mockable/MediaBrowser.java
deleted file mode 100644
index d6e846d..0000000
--- a/src/com/android/bluetooth/avrcp/mockable/MediaBrowser.java
+++ /dev/null
@@ -1,165 +0,0 @@
-/*
- * Copyright 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.bluetooth.avrcp;
-
-import android.content.ComponentName;
-import android.content.Context;
-import android.media.session.MediaSession;
-import android.os.Bundle;
-import android.util.Log;
-
-import com.android.internal.annotations.VisibleForTesting;
-
-/**
- * Provide a mockable interface in order to test classes that use MediaBrowser.
- * We need this class due to the fact that the MediaController class is marked as final and
- * there is no way to currently mock final classes in Android. Once this is possible this class
- * can be deleted.
- */
-public class MediaBrowser {
-    android.media.browse.MediaBrowser mDelegate;
-
-    /**
-     * Wrap a real MediaBrowser object
-     */
-    public MediaBrowser(android.media.browse.MediaBrowser delegate) {
-        mDelegate = delegate;
-    }
-
-    /**
-     * Create a real MediaBrowser object and wrap it
-     */
-    public MediaBrowser(Context context, ComponentName serviceComponent,
-            ConnectionCallback callback, Bundle rootHints) {
-        mDelegate = new android.media.browse.MediaBrowser(context, serviceComponent, callback,
-                rootHints);
-    }
-
-    /**
-     * Wrapper for MediaBrowser.ConnectionCallback
-     */
-    public abstract static class ConnectionCallback extends
-            android.media.browse.MediaBrowser.ConnectionCallback {}
-
-    /**
-     * Wrapper for MediaBrowser.ItemCallback
-     */
-    public abstract static class ItemCallback extends
-            android.media.browse.MediaBrowser.ItemCallback {}
-
-    /**
-     * Wrapper for MediaBrowser.SubscriptionCallback
-     */
-    public abstract static class SubscriptionCallback extends
-            android.media.browse.MediaBrowser.SubscriptionCallback {}
-
-    /**
-     * Wrapper for MediaBrowser.connect()
-     */
-    public void connect() {
-        mDelegate.connect();
-    }
-
-    /**
-     * Wrapper for MediaBrowser.disconnect()
-     */
-    public void disconnect() {
-        mDelegate.disconnect();
-    }
-
-    /**
-     * Wrapper for MediaBrowser.getExtras()
-     */
-    public Bundle getExtras() {
-        return mDelegate.getExtras();
-    }
-
-    /**
-     * Wrapper for MediaBrowser.getItem(String mediaId, ItemCallback callback)
-     */
-    public void getItem(String mediaId, ItemCallback callback) {
-        mDelegate.getItem(mediaId, callback);
-    }
-
-    /**
-     * Wrapper for MediaBrowser.getRoot()
-     */
-    public String getRoot() {
-        return mDelegate.getRoot();
-    }
-
-    /**
-     * Wrapper for MediaBrowser.getServiceComponent()
-     */
-    public ComponentName getServiceComponent() {
-        return mDelegate.getServiceComponent();
-    }
-
-    /**
-     * Wrapper for MediaBrowser.getSessionToken()
-     */
-    public MediaSession.Token getSessionToken() {
-        return mDelegate.getSessionToken();
-    }
-    /**
-     * Wrapper for MediaBrowser.isConnected()
-     */
-    public boolean isConnected() {
-        return mDelegate.isConnected();
-    }
-
-    /**
-     * Wrapper for MediaBrowser.subscribe(String parentId, Bundle options,
-     * SubscriptionCallback callback)
-     */
-    public void subscribe(String parentId, Bundle options, SubscriptionCallback callback) {
-        mDelegate.subscribe(parentId, options, callback);
-    }
-
-    /**
-     * Wrapper for MediaBrowser.subscribe(String parentId, SubscriptionCallback callback)
-     */
-    public void subscribe(String parentId, SubscriptionCallback callback) {
-        mDelegate.subscribe(parentId, callback);
-    }
-
-    /**
-     * Wrapper for MediaBrowser.unsubscribe(String parentId)
-     */
-    public void unsubscribe(String parentId) {
-        mDelegate.unsubscribe(parentId);
-    }
-
-
-    /**
-     * Wrapper for MediaBrowser.unsubscribe(String parentId, SubscriptionCallback callback)
-     */
-    public void unsubscribe(String parentId, SubscriptionCallback callback) {
-        mDelegate.unsubscribe(parentId, callback);
-    }
-
-    /**
-     * A function that allows Mockito to capture the constructor arguments when using
-     * MediaBrowserFactory.make()
-     */
-    @VisibleForTesting
-    public void testInit(Context context, ComponentName serviceComponent,
-            ConnectionCallback callback, Bundle rootHints) {
-        // This is only used by Mockito to capture the constructor arguments on creation
-        Log.wtfStack("AvrcpMockMediaBrowser", "This function should never be called");
-    }
-}
diff --git a/src/com/android/bluetooth/avrcp/mockable/MediaBrowserFactory.java b/src/com/android/bluetooth/avrcp/mockable/MediaBrowserFactory.java
deleted file mode 100644
index eb8c092..0000000
--- a/src/com/android/bluetooth/avrcp/mockable/MediaBrowserFactory.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.bluetooth.avrcp;
-
-import android.content.ComponentName;
-import android.content.Context;
-import android.os.Bundle;
-
-import com.android.internal.annotations.VisibleForTesting;
-
-/**
- * Provide a method to inject custom MediaBrowser objects for testing. By using the factory
- * methods instead of calling the constructor of MediaBrowser directly, we can inject a custom
- * MediaBrowser that can be used with JUnit and Mockito to set expectations and validate
- * behaviour in tests.
- */
-public final class MediaBrowserFactory {
-    private static MediaBrowser sInjectedBrowser;
-
-    static MediaBrowser wrap(android.media.browse.MediaBrowser delegate) {
-        if (sInjectedBrowser != null) return sInjectedBrowser;
-        return (delegate != null) ? new MediaBrowser(delegate) : null;
-    }
-
-    static MediaBrowser make(Context context, ComponentName serviceComponent,
-            MediaBrowser.ConnectionCallback callback, Bundle rootHints) {
-        if (sInjectedBrowser != null) {
-            sInjectedBrowser.testInit(context, serviceComponent, callback, rootHints);
-            return sInjectedBrowser;
-        }
-        return new MediaBrowser(context, serviceComponent, callback, rootHints);
-    }
-
-    @VisibleForTesting
-    static void inject(MediaBrowser browser) {
-        sInjectedBrowser = browser;
-    }
-}
diff --git a/src/com/android/bluetooth/avrcp/mockable/MediaController.java b/src/com/android/bluetooth/avrcp/mockable/MediaController.java
deleted file mode 100644
index 934a454..0000000
--- a/src/com/android/bluetooth/avrcp/mockable/MediaController.java
+++ /dev/null
@@ -1,264 +0,0 @@
-/*
- * Copyright 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.bluetooth.avrcp;
-
-import android.annotation.NonNull;
-import android.annotation.Nullable;
-import android.app.PendingIntent;
-import android.content.Context;
-import android.media.MediaDescription;
-import android.media.MediaMetadata;
-import android.media.Rating;
-import android.media.session.MediaSession;
-import android.media.session.PlaybackState;
-import android.net.Uri;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.ResultReceiver;
-import android.view.KeyEvent;
-
-import java.util.List;
-
-/**
- * Provide a mockable interface in order to test classes that use MediaController.
- * We need this class due to the fact that the MediaController class is marked as final and
- * there is no way to currently mock final classes in Android. Once this is possible this class
- * can be deleted.
- */
-public class MediaController {
-    @NonNull public android.media.session.MediaController mDelegate;
-    public android.media.session.MediaController.TransportControls mTransportDelegate;
-    public TransportControls mTransportControls;
-
-    public MediaController(@NonNull android.media.session.MediaController delegate) {
-        mDelegate = delegate;
-        mTransportDelegate = delegate.getTransportControls();
-        mTransportControls = new TransportControls();
-    }
-
-    public MediaController(Context context, MediaSession.Token token) {
-        mDelegate = new android.media.session.MediaController(context, token);
-        mTransportDelegate = mDelegate.getTransportControls();
-        mTransportControls = new TransportControls();
-    }
-
-    public android.media.session.MediaController getWrappedInstance() {
-        return mDelegate;
-    }
-
-    @NonNull
-    public TransportControls getTransportControls() {
-        return mTransportControls;
-    }
-
-    public boolean dispatchMediaButtonEvent(@NonNull KeyEvent keyEvent) {
-        return mDelegate.dispatchMediaButtonEvent(keyEvent);
-    }
-
-    @Nullable
-    public PlaybackState getPlaybackState() {
-        return mDelegate.getPlaybackState();
-    }
-
-    @Nullable
-    public MediaMetadata getMetadata() {
-        return mDelegate.getMetadata();
-    }
-
-    @Nullable
-    public List<MediaSession.QueueItem> getQueue() {
-        return mDelegate.getQueue();
-    }
-
-    @Nullable
-    public CharSequence getQueueTitle() {
-        return mDelegate.getQueueTitle();
-    }
-
-    @Nullable
-    public Bundle getExtras() {
-        return mDelegate.getExtras();
-    }
-
-    public int getRatingType() {
-        return mDelegate.getRatingType();
-    }
-
-    public long getFlags() {
-        return mDelegate.getFlags();
-    }
-
-    @Nullable
-    public android.media.session.MediaController.PlaybackInfo getPlaybackInfo() {
-        return mDelegate.getPlaybackInfo();
-    }
-
-    @Nullable
-    public PendingIntent getSessionActivity() {
-        return mDelegate.getSessionActivity();
-    }
-
-    @NonNull
-    public MediaSession.Token getSessionToken() {
-        return mDelegate.getSessionToken();
-    }
-
-    public void setVolumeTo(int value, int flags) {
-        mDelegate.setVolumeTo(value, flags);
-    }
-
-    public void adjustVolume(int direction, int flags) {
-        mDelegate.adjustVolume(direction, flags);
-    }
-
-    public void registerCallback(@NonNull Callback callback) {
-        //TODO(apanicke): Add custom callback struct to be able to analyze and
-        // delegate callbacks
-        mDelegate.registerCallback(callback);
-    }
-
-    public void registerCallback(@NonNull Callback callback, @Nullable Handler handler) {
-        mDelegate.registerCallback(callback, handler);
-    }
-
-    public void unregisterCallback(@NonNull Callback callback) {
-        mDelegate.unregisterCallback(callback);
-    }
-
-    public void sendCommand(@NonNull String command, @Nullable Bundle args,
-            @Nullable ResultReceiver cb) {
-        mDelegate.sendCommand(command, args, cb);
-    }
-
-    public String getPackageName() {
-        return mDelegate.getPackageName();
-    }
-
-    public String getTag() {
-        return mDelegate.getTag();
-    }
-
-    public boolean controlsSameSession(MediaController other) {
-        return mDelegate.controlsSameSession(other.getWrappedInstance());
-    }
-
-    public boolean controlsSameSession(android.media.session.MediaController other) {
-        return mDelegate.controlsSameSession(other);
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (o instanceof android.media.session.MediaController) {
-            return mDelegate.equals(o);
-        } else if (o instanceof MediaController) {
-            MediaController other = (MediaController) o;
-            return mDelegate.equals(other.mDelegate);
-        }
-        return false;
-    }
-
-    @Override
-    public String toString() {
-        MediaMetadata data = getMetadata();
-        MediaDescription desc = (data == null) ? null : data.getDescription();
-        return "MediaController (" + getPackageName() + "@" + Integer.toHexString(
-                mDelegate.hashCode()) + ") " + desc;
-    }
-
-    public abstract static class Callback extends android.media.session.MediaController.Callback {}
-
-    public class TransportControls {
-
-        public void prepare() {
-            mTransportDelegate.prepare();
-        }
-
-        public void prepareFromMediaId(String mediaId, Bundle extras) {
-            mTransportDelegate.prepareFromMediaId(mediaId, extras);
-        }
-
-        public void prepareFromSearch(String query, Bundle extras) {
-            mTransportDelegate.prepareFromSearch(query, extras);
-        }
-
-        public void prepareFromUri(Uri uri, Bundle extras) {
-            mTransportDelegate.prepareFromUri(uri, extras);
-        }
-
-        public void play() {
-            mTransportDelegate.play();
-        }
-
-        public void playFromMediaId(String mediaId, Bundle extras) {
-            mTransportDelegate.playFromMediaId(mediaId, extras);
-        }
-
-        public void playFromSearch(String query, Bundle extras) {
-            mTransportDelegate.playFromSearch(query, extras);
-        }
-
-        public void playFromUri(Uri uri, Bundle extras) {
-            mTransportDelegate.playFromUri(uri, extras);
-        }
-
-        public void skipToQueueItem(long id) {
-            mTransportDelegate.skipToQueueItem(id);
-        }
-
-        public void pause() {
-            mTransportDelegate.pause();
-        }
-
-        public void stop() {
-            mTransportDelegate.stop();
-        }
-
-        public void seekTo(long pos) {
-            mTransportDelegate.seekTo(pos);
-        }
-
-        public void fastForward() {
-            mTransportDelegate.fastForward();
-        }
-
-        public void skipToNext() {
-            mTransportDelegate.skipToNext();
-        }
-
-        public void rewind() {
-            mTransportDelegate.rewind();
-        }
-
-        public void skipToPrevious() {
-            mTransportDelegate.skipToPrevious();
-        }
-
-        public void setRating(Rating rating) {
-            mTransportDelegate.setRating(rating);
-        }
-
-        public void sendCustomAction(@NonNull PlaybackState.CustomAction customAction,
-                @Nullable Bundle args) {
-            mTransportDelegate.sendCustomAction(customAction, args);
-        }
-
-        public void sendCustomAction(@NonNull String action, @Nullable Bundle args) {
-            mTransportDelegate.sendCustomAction(action, args);
-        }
-    }
-}
-
diff --git a/src/com/android/bluetooth/avrcp/mockable/MediaControllerFactory.java b/src/com/android/bluetooth/avrcp/mockable/MediaControllerFactory.java
deleted file mode 100644
index 8b2a80d..0000000
--- a/src/com/android/bluetooth/avrcp/mockable/MediaControllerFactory.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright 2018 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.bluetooth.avrcp;
-
-import android.content.Context;
-import android.media.session.MediaSession;
-
-import com.android.internal.annotations.VisibleForTesting;
-
-/**
- * Provide a method to inject custom MediaController objects for testing. By using the factory
- * methods instead of calling the constructor of MediaController directly, we can inject a custom
- * MediaController that can be used with JUnit and Mockito to set expectations and validate
- * behaviour in tests.
- */
-public final class MediaControllerFactory {
-    private static MediaController sInjectedController;
-
-    static MediaController wrap(android.media.session.MediaController delegate) {
-        if (sInjectedController != null) return sInjectedController;
-        return (delegate != null) ? new MediaController(delegate) : null;
-    }
-
-    static MediaController make(Context context, MediaSession.Token token) {
-        if (sInjectedController != null) return sInjectedController;
-        return new MediaController(context, token);
-    }
-
-    @VisibleForTesting
-    static void inject(MediaController controller) {
-        sInjectedController = controller;
-    }
-}
diff --git a/src/com/android/bluetooth/btservice/BondStateMachine.java b/src/com/android/bluetooth/btservice/BondStateMachine.java
index 13ef2ad..04488b3 100644
--- a/src/com/android/bluetooth/btservice/BondStateMachine.java
+++ b/src/com/android/bluetooth/btservice/BondStateMachine.java
@@ -473,11 +473,6 @@
         if (pbapClientService != null) {
             pbapClientService.setPriority(device, BluetoothProfile.PRIORITY_UNDEFINED);
         }
-
-        // Clear Absolute Volume black list
-        if (a2dpService != null) {
-            a2dpService.resetAvrcpBlacklist(device);
-        }
     }
 
     private String state2str(int state) {
diff --git a/src/com/android/bluetooth/newavrcp/mockable/MediaBrowser.java b/src/com/android/bluetooth/newavrcp/mockable/MediaBrowser.java
new file mode 100644
index 0000000..d6e846d
--- /dev/null
+++ b/src/com/android/bluetooth/newavrcp/mockable/MediaBrowser.java
@@ -0,0 +1,165 @@
+/*
+ * Copyright 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.bluetooth.avrcp;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.media.session.MediaSession;
+import android.os.Bundle;
+import android.util.Log;
+
+import com.android.internal.annotations.VisibleForTesting;
+
+/**
+ * Provide a mockable interface in order to test classes that use MediaBrowser.
+ * We need this class due to the fact that the MediaController class is marked as final and
+ * there is no way to currently mock final classes in Android. Once this is possible this class
+ * can be deleted.
+ */
+public class MediaBrowser {
+    android.media.browse.MediaBrowser mDelegate;
+
+    /**
+     * Wrap a real MediaBrowser object
+     */
+    public MediaBrowser(android.media.browse.MediaBrowser delegate) {
+        mDelegate = delegate;
+    }
+
+    /**
+     * Create a real MediaBrowser object and wrap it
+     */
+    public MediaBrowser(Context context, ComponentName serviceComponent,
+            ConnectionCallback callback, Bundle rootHints) {
+        mDelegate = new android.media.browse.MediaBrowser(context, serviceComponent, callback,
+                rootHints);
+    }
+
+    /**
+     * Wrapper for MediaBrowser.ConnectionCallback
+     */
+    public abstract static class ConnectionCallback extends
+            android.media.browse.MediaBrowser.ConnectionCallback {}
+
+    /**
+     * Wrapper for MediaBrowser.ItemCallback
+     */
+    public abstract static class ItemCallback extends
+            android.media.browse.MediaBrowser.ItemCallback {}
+
+    /**
+     * Wrapper for MediaBrowser.SubscriptionCallback
+     */
+    public abstract static class SubscriptionCallback extends
+            android.media.browse.MediaBrowser.SubscriptionCallback {}
+
+    /**
+     * Wrapper for MediaBrowser.connect()
+     */
+    public void connect() {
+        mDelegate.connect();
+    }
+
+    /**
+     * Wrapper for MediaBrowser.disconnect()
+     */
+    public void disconnect() {
+        mDelegate.disconnect();
+    }
+
+    /**
+     * Wrapper for MediaBrowser.getExtras()
+     */
+    public Bundle getExtras() {
+        return mDelegate.getExtras();
+    }
+
+    /**
+     * Wrapper for MediaBrowser.getItem(String mediaId, ItemCallback callback)
+     */
+    public void getItem(String mediaId, ItemCallback callback) {
+        mDelegate.getItem(mediaId, callback);
+    }
+
+    /**
+     * Wrapper for MediaBrowser.getRoot()
+     */
+    public String getRoot() {
+        return mDelegate.getRoot();
+    }
+
+    /**
+     * Wrapper for MediaBrowser.getServiceComponent()
+     */
+    public ComponentName getServiceComponent() {
+        return mDelegate.getServiceComponent();
+    }
+
+    /**
+     * Wrapper for MediaBrowser.getSessionToken()
+     */
+    public MediaSession.Token getSessionToken() {
+        return mDelegate.getSessionToken();
+    }
+    /**
+     * Wrapper for MediaBrowser.isConnected()
+     */
+    public boolean isConnected() {
+        return mDelegate.isConnected();
+    }
+
+    /**
+     * Wrapper for MediaBrowser.subscribe(String parentId, Bundle options,
+     * SubscriptionCallback callback)
+     */
+    public void subscribe(String parentId, Bundle options, SubscriptionCallback callback) {
+        mDelegate.subscribe(parentId, options, callback);
+    }
+
+    /**
+     * Wrapper for MediaBrowser.subscribe(String parentId, SubscriptionCallback callback)
+     */
+    public void subscribe(String parentId, SubscriptionCallback callback) {
+        mDelegate.subscribe(parentId, callback);
+    }
+
+    /**
+     * Wrapper for MediaBrowser.unsubscribe(String parentId)
+     */
+    public void unsubscribe(String parentId) {
+        mDelegate.unsubscribe(parentId);
+    }
+
+
+    /**
+     * Wrapper for MediaBrowser.unsubscribe(String parentId, SubscriptionCallback callback)
+     */
+    public void unsubscribe(String parentId, SubscriptionCallback callback) {
+        mDelegate.unsubscribe(parentId, callback);
+    }
+
+    /**
+     * A function that allows Mockito to capture the constructor arguments when using
+     * MediaBrowserFactory.make()
+     */
+    @VisibleForTesting
+    public void testInit(Context context, ComponentName serviceComponent,
+            ConnectionCallback callback, Bundle rootHints) {
+        // This is only used by Mockito to capture the constructor arguments on creation
+        Log.wtfStack("AvrcpMockMediaBrowser", "This function should never be called");
+    }
+}
diff --git a/src/com/android/bluetooth/newavrcp/mockable/MediaBrowserFactory.java b/src/com/android/bluetooth/newavrcp/mockable/MediaBrowserFactory.java
new file mode 100644
index 0000000..eb8c092
--- /dev/null
+++ b/src/com/android/bluetooth/newavrcp/mockable/MediaBrowserFactory.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.bluetooth.avrcp;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.os.Bundle;
+
+import com.android.internal.annotations.VisibleForTesting;
+
+/**
+ * Provide a method to inject custom MediaBrowser objects for testing. By using the factory
+ * methods instead of calling the constructor of MediaBrowser directly, we can inject a custom
+ * MediaBrowser that can be used with JUnit and Mockito to set expectations and validate
+ * behaviour in tests.
+ */
+public final class MediaBrowserFactory {
+    private static MediaBrowser sInjectedBrowser;
+
+    static MediaBrowser wrap(android.media.browse.MediaBrowser delegate) {
+        if (sInjectedBrowser != null) return sInjectedBrowser;
+        return (delegate != null) ? new MediaBrowser(delegate) : null;
+    }
+
+    static MediaBrowser make(Context context, ComponentName serviceComponent,
+            MediaBrowser.ConnectionCallback callback, Bundle rootHints) {
+        if (sInjectedBrowser != null) {
+            sInjectedBrowser.testInit(context, serviceComponent, callback, rootHints);
+            return sInjectedBrowser;
+        }
+        return new MediaBrowser(context, serviceComponent, callback, rootHints);
+    }
+
+    @VisibleForTesting
+    static void inject(MediaBrowser browser) {
+        sInjectedBrowser = browser;
+    }
+}
diff --git a/src/com/android/bluetooth/newavrcp/mockable/MediaController.java b/src/com/android/bluetooth/newavrcp/mockable/MediaController.java
new file mode 100644
index 0000000..5c7b73f
--- /dev/null
+++ b/src/com/android/bluetooth/newavrcp/mockable/MediaController.java
@@ -0,0 +1,398 @@
+/*
+ * Copyright 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.bluetooth.avrcp;
+
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.app.PendingIntent;
+import android.content.Context;
+import android.media.MediaDescription;
+import android.media.MediaMetadata;
+import android.media.Rating;
+import android.media.session.MediaSession;
+import android.media.session.PlaybackState;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.ResultReceiver;
+import android.view.KeyEvent;
+
+import java.util.List;
+
+/**
+ * Provide a mockable interface in order to test classes that use MediaController.
+ * We need this class due to the fact that the MediaController class is marked as final and
+ * there is no way to currently mock final classes in Android. Once this is possible this class
+ * can be deleted.
+ */
+public class MediaController {
+    @NonNull public android.media.session.MediaController mDelegate;
+    public android.media.session.MediaController.TransportControls mTransportDelegate;
+    public TransportControls mTransportControls;
+
+    MediaController(@NonNull android.media.session.MediaController delegate) {
+        mDelegate = delegate;
+        mTransportDelegate = delegate.getTransportControls();
+        mTransportControls = new TransportControls();
+    }
+
+    MediaController(Context context, MediaSession.Token token) {
+        mDelegate = new android.media.session.MediaController(context, token);
+        mTransportDelegate = mDelegate.getTransportControls();
+        mTransportControls = new TransportControls();
+    }
+
+    public android.media.session.MediaController getWrappedInstance() {
+        return mDelegate;
+    }
+
+    @NonNull
+    public TransportControls getTransportControls() {
+        return mTransportControls;
+    }
+
+    /**
+     * Wrapper for MediaController.dispatchMediaButtonEvent(KeyEvent keyEvent)
+     */
+    public boolean dispatchMediaButtonEvent(@NonNull KeyEvent keyEvent) {
+        return mDelegate.dispatchMediaButtonEvent(keyEvent);
+    }
+
+    /**
+     * Wrapper for MediaController.getPlaybackState()
+     */
+    @Nullable
+    public PlaybackState getPlaybackState() {
+        return mDelegate.getPlaybackState();
+    }
+
+
+    /**
+     * Wrapper for MediaController.getMetadata()
+     */
+    @Nullable
+    public MediaMetadata getMetadata() {
+        return mDelegate.getMetadata();
+    }
+
+    /**
+     * Wrapper for MediaController.getQueue()
+     */
+    @Nullable
+    public List<MediaSession.QueueItem> getQueue() {
+        return mDelegate.getQueue();
+    }
+
+    /**
+     * Wrapper for MediaController.getQueueTitle()
+     */
+    @Nullable
+    public CharSequence getQueueTitle() {
+        return mDelegate.getQueueTitle();
+    }
+
+    /**
+     * Wrapper for MediaController.getExtras()
+     */
+    @Nullable
+    public Bundle getExtras() {
+        return mDelegate.getExtras();
+    }
+
+    /**
+     * Wrapper for MediaController.getRatingType()
+     */
+    public int getRatingType() {
+        return mDelegate.getRatingType();
+    }
+
+    /**
+     * Wrapper for MediaController.getFlags()
+     */
+    public long getFlags() {
+        return mDelegate.getFlags();
+    }
+
+    /**
+     * Wrapper for MediaController.getPlaybackInfo()
+     */
+    @Nullable
+    public android.media.session.MediaController.PlaybackInfo getPlaybackInfo() {
+        return mDelegate.getPlaybackInfo();
+    }
+
+
+    /**
+     * Wrapper for MediaController.getSessionActivity()
+     */
+    @Nullable
+    public PendingIntent getSessionActivity() {
+        return mDelegate.getSessionActivity();
+    }
+
+    /**
+     * Wrapper for MediaController.getSessionToken()
+     */
+    @NonNull
+    public MediaSession.Token getSessionToken() {
+        return mDelegate.getSessionToken();
+    }
+
+    /**
+     * Wrapper for MediaController.setVolumeTo(int value, int flags)
+     */
+    public void setVolumeTo(int value, int flags) {
+        mDelegate.setVolumeTo(value, flags);
+    }
+
+    /**
+     * Wrapper for MediaController.adjustVolume(int direction, int flags)
+     */
+    public void adjustVolume(int direction, int flags) {
+        mDelegate.adjustVolume(direction, flags);
+    }
+
+    /**
+     * Wrapper for MediaController.registerCallback(Callback callback)
+     */
+    public void registerCallback(@NonNull Callback callback) {
+        //TODO(apanicke): Add custom callback struct to be able to analyze and
+        // delegate callbacks
+        mDelegate.registerCallback(callback);
+    }
+
+    /**
+     * Wrapper for MediaController.registerCallback(Callback callback, Handler handler)
+     */
+    public void registerCallback(@NonNull Callback callback, @Nullable Handler handler) {
+        mDelegate.registerCallback(callback, handler);
+    }
+
+    /**
+     * Wrapper for MediaController.unregisterCallback(Callback callback)
+     */
+    public void unregisterCallback(@NonNull Callback callback) {
+        mDelegate.unregisterCallback(callback);
+    }
+
+    /**
+     * Wrapper for MediaController.sendCommand(String command, Bundle args, ResultReceiver cb)
+     */
+    public void sendCommand(@NonNull String command, @Nullable Bundle args,
+            @Nullable ResultReceiver cb) {
+        mDelegate.sendCommand(command, args, cb);
+    }
+
+    /**
+     * Wrapper for MediaController.getPackageName()
+     */
+    public String getPackageName() {
+        return mDelegate.getPackageName();
+    }
+
+    /**
+     * Wrapper for MediaController.getTag()
+     */
+    public String getTag() {
+        return mDelegate.getTag();
+    }
+
+    /**
+     * Wrapper for MediaController.controlsSameSession(MediaController other)
+     */
+    public boolean controlsSameSession(MediaController other) {
+        return mDelegate.controlsSameSession(other.getWrappedInstance());
+    }
+
+    /**
+     * Wrapper for MediaController.controlsSameSession(MediaController other)
+     */
+    public boolean controlsSameSession(android.media.session.MediaController other) {
+        return mDelegate.controlsSameSession(other);
+    }
+
+    /**
+     * Wrapper for MediaController.equals(Object other)
+     */
+    @Override
+    public boolean equals(Object o) {
+        if (o instanceof android.media.session.MediaController) {
+            return mDelegate.equals(o);
+        } else if (o instanceof MediaController) {
+            MediaController other = (MediaController) o;
+            return mDelegate.equals(other.mDelegate);
+        }
+        return false;
+    }
+
+    /**
+     * Wrapper for MediaController.toString()
+     */
+    @Override
+    public String toString() {
+        MediaMetadata data = getMetadata();
+        MediaDescription desc = (data == null) ? null : data.getDescription();
+        return "MediaController (" + getPackageName() + "@" + Integer.toHexString(
+                mDelegate.hashCode()) + ") " + desc;
+    }
+
+    /**
+     * Wrapper for MediaController.Callback
+     */
+    public abstract static class Callback extends android.media.session.MediaController.Callback {}
+
+    /**
+     * Wrapper for MediaController.TransportControls
+     */
+    public class TransportControls {
+
+        /**
+         * Wrapper for MediaController.TransportControls.prepare()
+         */
+        public void prepare() {
+            mTransportDelegate.prepare();
+        }
+
+        /**
+         * Wrapper for MediaController.TransportControls.prepareFromMediaId()
+         */
+        public void prepareFromMediaId(String mediaId, Bundle extras) {
+            mTransportDelegate.prepareFromMediaId(mediaId, extras);
+        }
+
+        /**
+         * Wrapper for MediaController.TransportControls.prepareFromSearch()
+         */
+        public void prepareFromSearch(String query, Bundle extras) {
+            mTransportDelegate.prepareFromSearch(query, extras);
+        }
+
+        /**
+         * Wrapper for MediaController.TransportControls.prepareFromUri()
+         */
+        public void prepareFromUri(Uri uri, Bundle extras) {
+            mTransportDelegate.prepareFromUri(uri, extras);
+        }
+
+        /**
+         * Wrapper for MediaController.TransportControls.play()
+         */
+        public void play() {
+            mTransportDelegate.play();
+        }
+
+        /**
+         * Wrapper for MediaController.TransportControls.playFromMediaId()
+         */
+        public void playFromMediaId(String mediaId, Bundle extras) {
+            mTransportDelegate.playFromMediaId(mediaId, extras);
+        }
+
+        /**
+         * Wrapper for MediaController.TransportControls.playFromSearch()
+         */
+        public void playFromSearch(String query, Bundle extras) {
+            mTransportDelegate.playFromSearch(query, extras);
+        }
+
+        /**
+         * Wrapper for MediaController.TransportControls.playFromUri()
+         */
+        public void playFromUri(Uri uri, Bundle extras) {
+            mTransportDelegate.playFromUri(uri, extras);
+        }
+
+        /**
+         * Wrapper for MediaController.TransportControls.skipToQueueItem()
+         */
+        public void skipToQueueItem(long id) {
+            mTransportDelegate.skipToQueueItem(id);
+        }
+
+        /**
+         * Wrapper for MediaController.TransportControls.pause()
+         */
+        public void pause() {
+            mTransportDelegate.pause();
+        }
+
+        /**
+         * Wrapper for MediaController.TransportControls.stop()
+         */
+        public void stop() {
+            mTransportDelegate.stop();
+        }
+
+        /**
+         * Wrapper for MediaController.TransportControls.seekTo()
+         */
+        public void seekTo(long pos) {
+            mTransportDelegate.seekTo(pos);
+        }
+
+        /**
+         * Wrapper for MediaController.TransportControls.fastForward()
+         */
+        public void fastForward() {
+            mTransportDelegate.fastForward();
+        }
+
+        /**
+         * Wrapper for MediaController.TransportControls.skipToNext()
+         */
+        public void skipToNext() {
+            mTransportDelegate.skipToNext();
+        }
+
+        /**
+         * Wrapper for MediaController.TransportControls.rewind()
+         */
+        public void rewind() {
+            mTransportDelegate.rewind();
+        }
+
+        /**
+         * Wrapper for MediaController.TransportControls.skipToPrevious()
+         */
+        public void skipToPrevious() {
+            mTransportDelegate.skipToPrevious();
+        }
+
+        /**
+         * Wrapper for MediaController.TransportControls.setRating()
+         */
+        public void setRating(Rating rating) {
+            mTransportDelegate.setRating(rating);
+        }
+
+        /**
+         * Wrapper for MediaController.TransportControls.sendCustomAction()
+         */
+        public void sendCustomAction(@NonNull PlaybackState.CustomAction customAction,
+                @Nullable Bundle args) {
+            mTransportDelegate.sendCustomAction(customAction, args);
+        }
+
+        /**
+         * Wrapper for MediaController.TransportControls.sendCustomAction()
+         */
+        public void sendCustomAction(@NonNull String action, @Nullable Bundle args) {
+            mTransportDelegate.sendCustomAction(action, args);
+        }
+    }
+}
+
diff --git a/src/com/android/bluetooth/newavrcp/mockable/MediaControllerFactory.java b/src/com/android/bluetooth/newavrcp/mockable/MediaControllerFactory.java
new file mode 100644
index 0000000..8b2a80d
--- /dev/null
+++ b/src/com/android/bluetooth/newavrcp/mockable/MediaControllerFactory.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.bluetooth.avrcp;
+
+import android.content.Context;
+import android.media.session.MediaSession;
+
+import com.android.internal.annotations.VisibleForTesting;
+
+/**
+ * Provide a method to inject custom MediaController objects for testing. By using the factory
+ * methods instead of calling the constructor of MediaController directly, we can inject a custom
+ * MediaController that can be used with JUnit and Mockito to set expectations and validate
+ * behaviour in tests.
+ */
+public final class MediaControllerFactory {
+    private static MediaController sInjectedController;
+
+    static MediaController wrap(android.media.session.MediaController delegate) {
+        if (sInjectedController != null) return sInjectedController;
+        return (delegate != null) ? new MediaController(delegate) : null;
+    }
+
+    static MediaController make(Context context, MediaSession.Token token) {
+        if (sInjectedController != null) return sInjectedController;
+        return new MediaController(context, token);
+    }
+
+    @VisibleForTesting
+    static void inject(MediaController controller) {
+        sInjectedController = controller;
+    }
+}
diff --git a/tests/unit/src/com/android/bluetooth/avrcp/AvrcpTest.java b/tests/unit/src/com/android/bluetooth/avrcp/AvrcpTest.java
deleted file mode 100644
index 5af45e1..0000000
--- a/tests/unit/src/com/android/bluetooth/avrcp/AvrcpTest.java
+++ /dev/null
@@ -1,83 +0,0 @@
-package com.android.bluetooth.avrcp;
-
-import static org.mockito.Mockito.*;
-
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.PackageManager;
-import android.content.pm.ResolveInfo;
-import android.content.pm.ServiceInfo;
-import android.media.AudioManager;
-import android.os.Looper;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.filters.MediumTest;
-import android.support.test.runner.AndroidJUnit4;
-
-import org.junit.Assert;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import java.util.ArrayList;
-import java.util.List;
-
-
-/**
- * Unit tests for {@link Avrcp}
- */
-@MediumTest
-@RunWith(AndroidJUnit4.class)
-public class AvrcpTest {
-    @Test
-    public void testCanStart() {
-        if (Looper.myLooper() == null) {
-            Looper.prepare();
-        }
-
-        Avrcp a = Avrcp.make(InstrumentationRegistry.getTargetContext());
-    }
-
-    @Test
-    public void testFailedBrowseStart() {
-        if (Looper.myLooper() == null) {
-            Looper.prepare();
-        }
-
-        Context mockContext = mock(Context.class);
-        AudioManager mockAudioManager = mock(AudioManager.class);
-        PackageManager mockPackageManager = mock(PackageManager.class);
-
-        when(mockAudioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC)).thenReturn(100);
-
-        when(mockContext.getSystemService(Context.AUDIO_SERVICE)).thenReturn(mockAudioManager);
-
-        when(mockContext.getApplicationContext()).thenReturn(mockContext);
-        when(mockContext.getPackageManager()).thenReturn(mockPackageManager);
-
-
-        // Call to get the BrowsableMediaPlayers
-        // We must return at least one to try to startService
-        List<ResolveInfo> resInfos = new ArrayList<ResolveInfo>();
-
-        ServiceInfo fakeService = new ServiceInfo();
-        fakeService.name = ".browse.MediaBrowserService";
-        fakeService.packageName = "com.test.android.fake";
-
-        ResolveInfo fakePackage = new ResolveInfo();
-        fakePackage.serviceInfo = fakeService;
-        fakePackage.nonLocalizedLabel = "Fake Package";
-        resInfos.add(fakePackage);
-        when(mockPackageManager.queryIntentServices(isA(Intent.class), anyInt())).thenReturn(
-                resInfos);
-
-        when(mockContext.startService(isA(Intent.class))).thenThrow(new SecurityException("test"));
-
-        // Make calls start() which calls buildMediaPlayersList() which should
-        // try to start the service?
-        try {
-            Avrcp a = Avrcp.make(mockContext);
-        } catch (SecurityException e) {
-            Assert.fail(
-                    "Threw SecurityException instead of protecting against it: " + e.toString());
-        }
-    }
-}
diff --git a/tests/unit/src/com/android/bluetooth/avrcp/EvictingQueueTest.java b/tests/unit/src/com/android/bluetooth/avrcp/EvictingQueueTest.java
deleted file mode 100644
index ff44f06..0000000
--- a/tests/unit/src/com/android/bluetooth/avrcp/EvictingQueueTest.java
+++ /dev/null
@@ -1,58 +0,0 @@
-package com.android.bluetooth.avrcp;
-
-import android.support.test.filters.MediumTest;
-import android.support.test.runner.AndroidJUnit4;
-
-import org.junit.Assert;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-/**
- *  Unit tests for {@link EvictingQueue}.
- */
-@MediumTest
-@RunWith(AndroidJUnit4.class)
-public class EvictingQueueTest {
-    @Test
-    public void testEvictingQueue_canAddItems() {
-        EvictingQueue<Integer> e = new EvictingQueue<Integer>(10);
-
-        e.add(1);
-
-        Assert.assertEquals((long) e.size(), (long) 1);
-    }
-
-    @Test
-    public void testEvictingQueue_maxItems() {
-        EvictingQueue<Integer> e = new EvictingQueue<Integer>(5);
-
-        e.add(1);
-        e.add(2);
-        e.add(3);
-        e.add(4);
-        e.add(5);
-        e.add(6);
-
-        Assert.assertEquals((long) e.size(), (long) 5);
-        // Items drop off the front
-        Assert.assertEquals((long) e.peek(), (long) 2);
-    }
-
-    @Test
-    public void testEvictingQueue_frontDrop() {
-        EvictingQueue<Integer> e = new EvictingQueue<Integer>(5);
-
-        e.add(1);
-        e.add(2);
-        e.add(3);
-        e.add(4);
-        e.add(5);
-
-        Assert.assertEquals((long) e.size(), (long) 5);
-
-        e.addFirst(6);
-
-        Assert.assertEquals((long) e.size(), (long) 5);
-        Assert.assertEquals((long) e.peek(), (long) 1);
-    }
-}
