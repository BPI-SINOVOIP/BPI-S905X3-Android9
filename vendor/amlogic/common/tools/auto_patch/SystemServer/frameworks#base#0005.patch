From 75617acc4e1258f6e627fb43d7c93abcab3d9ddb Mon Sep 17 00:00:00 2001
From: xi an <an.xi@amlogic.com>
Date: Fri, 19 Apr 2019 15:58:09 +0800
Subject: [PATCH] SystemServer: fix vmreboot for null ptr of ActivityDisplay
 [1/1]

PD#SWPL-6852

Problem:
vmboot would be caused if the ActivityStack were used after removed.

Sulotion:
add null ptr protection

Verify:
verify by p321

Change-Id: Ic4942d56b5ce99acd7d129f7c7c6244a1b326ac5
Signed-off-by: xi an <an.xi@amlogic.com>
---
 .../java/com/android/server/am/ActivityStack.java  | 68 ++++++++++++++--------
 1 file changed, 45 insertions(+), 23 deletions(-)
 mode change 100644 => 100755 services/core/java/com/android/server/am/ActivityStack.java

diff --git a/services/core/java/com/android/server/am/ActivityStack.java b/services/core/java/com/android/server/am/ActivityStack.java
old mode 100644
new mode 100755
index aea29ac..4bdadcf
--- a/services/core/java/com/android/server/am/ActivityStack.java
+++ b/services/core/java/com/android/server/am/ActivityStack.java
@@ -522,22 +522,22 @@ class ActivityStack<T extends StackWindowController> extends ConfigurationContai
         final int currentMode = getWindowingMode();
         final ActivityDisplay display = getDisplay();
         final TaskRecord topTask = topTask();
-        final ActivityStack splitScreenStack = display.getSplitScreenPrimaryStack();
+        final ActivityStack splitScreenStack = display != null ? display.getSplitScreenPrimaryStack() : null;
         mTmpOptions.setLaunchWindowingMode(preferredWindowingMode);
 
         // Need to make sure windowing mode is supported. If we in the process of creating the stack
         // no need to resolve the windowing mode again as it is already resolved to the right mode.
         int windowingMode = creating
                 ? preferredWindowingMode
-                : display.resolveWindowingMode(
-                        null /* ActivityRecord */, mTmpOptions, topTask, getActivityType());
+                : (display != null ? display.resolveWindowingMode(
+                        null /* ActivityRecord */, mTmpOptions, topTask, getActivityType()) : WINDOWING_MODE_UNDEFINED);
         if (splitScreenStack == this && windowingMode == WINDOWING_MODE_SPLIT_SCREEN_SECONDARY) {
             // Resolution to split-screen secondary for the primary split-screen stack means we want
             // to go fullscreen.
             windowingMode = WINDOWING_MODE_FULLSCREEN;
         }
 
-        final boolean alreadyInSplitScreenMode = display.hasSplitScreenPrimaryStack();
+        final boolean alreadyInSplitScreenMode = display != null ? display.hasSplitScreenPrimaryStack() : false;
 
         // Don't send non-resizeable notifications if the windowing mode changed was a side effect
         // of us entering split-screen mode.
@@ -553,9 +553,11 @@ class ActivityStack<T extends StackWindowController> extends ConfigurationContai
                 // doesn't support split-screen mode, go ahead an dismiss split-screen and display a
                 // warning toast about it.
                 mService.mTaskChangeNotificationController.notifyActivityDismissingDockedStack();
-                display.getSplitScreenPrimaryStack().setWindowingMode(WINDOWING_MODE_FULLSCREEN,
-                        false /* animate */, false /* showRecents */,
-                        false /* enteringSplitScreenMode */, true /* deferEnsuringVisibility */);
+                if (display != null) {
+                    display.getSplitScreenPrimaryStack().setWindowingMode(WINDOWING_MODE_FULLSCREEN,
+                            false /* animate */, false /* showRecents */,
+                            false /* enteringSplitScreenMode */, true /* deferEnsuringVisibility */);
+                }
             }
         }
 
@@ -639,10 +641,12 @@ class ActivityStack<T extends StackWindowController> extends ConfigurationContai
                 // TODO (b/78247419): Check if launcher and overview are same then move home stack
                 // instead of recents stack. Then fix the rotation animation from fullscreen to
                 // minimized mode
-                final ActivityStack recentStack = display.getOrCreateStack(
+                final ActivityStack recentStack = display != null ? display.getOrCreateStack(
                         WINDOWING_MODE_SPLIT_SCREEN_SECONDARY, ACTIVITY_TYPE_RECENTS,
-                        true /* onTop */);
-                recentStack.moveToFront("setWindowingMode");
+                        true /* onTop */) : null;
+                if (recentStack != null) {
+                    recentStack.moveToFront("setWindowingMode");
+                }
                 // If task moved to docked stack - show recents if needed.
                 mService.mWindowManager.showRecentApps();
             }
@@ -1022,14 +1026,14 @@ class ActivityStack<T extends StackWindowController> extends ConfigurationContai
 
         final ActivityDisplay display = getDisplay();
 
-        if (inSplitScreenSecondaryWindowingMode()) {
+        if (inSplitScreenSecondaryWindowingMode() && display != null) {
             // If the stack is in split-screen seconardy mode, we need to make sure we move the
             // primary split-screen stack forward in the case it is currently behind a fullscreen
             // stack so both halves of the split-screen appear on-top and the fullscreen stack isn't
             // cutting between them.
             // TODO(b/70677280): This is a workaround until we can fix as part of b/70677280.
             final ActivityStack topFullScreenStack =
-                    display.getTopStackInWindowingMode(WINDOWING_MODE_FULLSCREEN);
+                            display.getTopStackInWindowingMode(WINDOWING_MODE_FULLSCREEN);
             if (topFullScreenStack != null) {
                 final ActivityStack primarySplitScreenStack = display.getSplitScreenPrimaryStack();
                 if (display.getIndexOf(topFullScreenStack)
@@ -1045,7 +1049,9 @@ class ActivityStack<T extends StackWindowController> extends ConfigurationContai
             mStackSupervisor.moveHomeStackToFront(reason + " returnToHome");
         }
 
-        display.positionChildAtTop(this);
+        if (display != null) {
+            display.positionChildAtTop(this);
+        }
         mStackSupervisor.setFocusStackUnchecked(reason, this);
         if (task != null) {
             insertTaskAtTop(task, null);
@@ -1070,8 +1076,12 @@ class ActivityStack<T extends StackWindowController> extends ConfigurationContai
             setWindowingMode(WINDOWING_MODE_FULLSCREEN);
         }
 
-        getDisplay().positionChildAtBottom(this);
-        mStackSupervisor.setFocusStackUnchecked(reason, getDisplay().getTopStack());
+        final ActivityDisplay display = getDisplay();
+        if (display != null) {
+            display.positionChildAtBottom(this);
+            mStackSupervisor.setFocusStackUnchecked(reason, display.getTopStack());
+        }
+
         if (task != null) {
             insertTaskAtBottom(task);
             return;
@@ -1642,8 +1652,9 @@ class ActivityStack<T extends StackWindowController> extends ConfigurationContai
         // Notify when the task stack has changed, but only if visibilities changed (not just
         // focus). Also if there is an active pinned stack - we always want to notify it about
         // task stack changes, because its positioning may depend on it.
+        final ActivityDisplay display = getDisplay();
         if (mStackSupervisor.mAppVisibilitiesChangedSinceLastPause
-                || getDisplay().hasPinnedStack()) {
+                || (display != null && display.hasPinnedStack())) {
             mService.mTaskChangeNotificationController.notifyTaskStackChanged();
             mStackSupervisor.mAppVisibilitiesChangedSinceLastPause = false;
         }
@@ -1715,7 +1726,8 @@ class ActivityStack<T extends StackWindowController> extends ConfigurationContai
     }
 
     boolean isTopStackOnDisplay() {
-        return getDisplay().isTopStack(this);
+        final ActivityDisplay display = getDisplay();
+        return display != null && display.isTopStack(this);
     }
 
     boolean isTopActivityVisible() {
@@ -1744,6 +1756,9 @@ class ActivityStack<T extends StackWindowController> extends ConfigurationContai
         }
 
         final ActivityDisplay display = getDisplay();
+        if (display == null) {
+            return false;
+        }
         boolean gotSplitScreenStack = false;
         boolean gotOpaqueSplitScreenPrimary = false;
         boolean gotOpaqueSplitScreenSecondary = false;
@@ -1866,8 +1881,9 @@ class ActivityStack<T extends StackWindowController> extends ConfigurationContai
             boolean behindFullscreenActivity = !stackShouldBeVisible;
             boolean resumeNextActivity = mStackSupervisor.isFocusedStack(this)
                     && (isInStackLocked(starting) == null);
+            final ActivityDisplay display = getDisplay();
             final boolean isTopNotPinnedStack =
-                    isAttached() && getDisplay().isTopNotPinnedStack(this);
+                    isAttached() && display != null && display.isTopNotPinnedStack(this);
             for (int taskNdx = mTaskHistory.size() - 1; taskNdx >= 0; --taskNdx) {
                 final TaskRecord task = mTaskHistory.get(taskNdx);
                 final ArrayList<ActivityRecord> activities = task.mActivities;
@@ -4560,7 +4576,8 @@ class ActivityStack<T extends StackWindowController> extends ConfigurationContai
             AppTimeTracker timeTracker, String reason) {
         if (DEBUG_SWITCH) Slog.v(TAG_SWITCH, "moveTaskToFront: " + tr);
 
-        final ActivityStack topStack = getDisplay().getTopStack();
+        final ActivityDisplay display = getDisplay();
+        final ActivityStack topStack = display != null ? display.getTopStack() : null;
         final ActivityRecord topActivity = topStack != null ? topStack.getTopActivity() : null;
         final int numTasks = mTaskHistory.size();
         final int index = mTaskHistory.indexOf(tr);
@@ -4585,7 +4602,9 @@ class ActivityStack<T extends StackWindowController> extends ConfigurationContai
             // Defer updating the IME target since the new IME target will try to get computed
             // before updating all closing and opening apps, which can cause the ime target to
             // get calculated incorrectly.
-            getDisplay().deferUpdateImeTarget();
+            if (display != null) {
+                display.deferUpdateImeTarget();
+            }
 
             // Shift all activities with this task up to the top
             // of the stack, keeping them in the same internal order.
@@ -4631,7 +4650,9 @@ class ActivityStack<T extends StackWindowController> extends ConfigurationContai
 
             mService.mTaskChangeNotificationController.notifyTaskMovedToFront(tr.taskId);
         } finally {
-            getDisplay().continueUpdateImeTarget();
+            if (display != null) {
+                display.continueUpdateImeTarget();
+            }
         }
     }
 
@@ -5147,8 +5168,9 @@ class ActivityStack<T extends StackWindowController> extends ConfigurationContai
                     mStackSupervisor.moveHomeStackToFront(myReason);
                 }
             }
-            if (isAttached()) {
-                getDisplay().positionChildAtBottom(this);
+            final ActivityDisplay display = getDisplay();
+            if (isAttached() && display != null) {
+                display.positionChildAtBottom(this);
             }
             if (!isActivityTypeHome()) {
                 remove();
-- 
1.9.1

