<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->
<!-- on Tue May 19 17:01:55 PDT 2009 -->

<api
  xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
  xsi:noNamespaceSchemaLocation='api.xsd'
  name="2.0"
  jdversion="1.1.1">

<!--  Command line arguments =  -doclet jdiff.JDiff -docletpath /Applications/bin/jdiff-1.1.1/jdiff.jar:/Applications/bin/jdiff-1.1.1/xerces.jar -d /Users/jessewilson/Guice/guice-everything/api-diffs -classpath /usr/share/ant/lib/ant-launcher.jar:/usr/share/ant/lib/ant-jai.jar:/usr/share/ant/lib/ant-jmf.jar:/usr/share/ant/lib/ant-junit.jar:/usr/share/ant/lib/ant-nodeps.jar:/usr/share/ant/lib/ant-swing.jar:/usr/share/ant/lib/ant-testutil.jar:/usr/share/ant/lib/ant-trax.jar:/usr/share/ant/lib/ant.jar:/usr/share/ant/lib/junit.jar:/usr/share/ant/lib/xercesImpl.jar:/usr/share/ant/lib/xml-apis.jar -sourcepath /Users/jessewilson/Guice/google-guice/src:/Users/jessewilson/Guice/google-guice/extensions/jmx/src:/Users/jessewilson/Guice/google-guice/extensions/jndi/src:/Users/jessewilson/Guice/google-guice/extensions/assistedinject/src:/Users/jessewilson/Guice/google-guice/extensions/multibindings/src:/Users/jessewilson/Guice/google-guice/extensions/throwingproviders/src:/Users/jessewilson/Guice/google-guice/servlet/src:/Users/jessewilson/Guice/google-guice/spring/src:/Users/jessewilson/Guice/google-guice/struts2/plugin/src -apiname 2.0 -baseURI http://www.w3.org -apidir /Users/jessewilson/Guice/guice-everything/api-diffs -source 1.5 -->
<package name="com.google.inject">
  <!-- start class com.google.inject.AbstractModule -->
  <class name="AbstractModule" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Module"/>
    <constructor name="AbstractModule"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="com.google.inject.Binder"/>
    </method>
    <method name="configure"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Configures a {@link Binder} via the exposed methods.]]>
      </doc>
    </method>
    <method name="binder" return="com.google.inject.Binder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets direct access to the underlying {@code Binder}.]]>
      </doc>
    </method>
    <method name="bindScope"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="scopeAnnotation" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <param name="scope" type="com.google.inject.Scope"/>
      <doc>
      <![CDATA[@see Binder#bindScope(Class, Scope)]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.LinkedBindingBuilder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#bind(Key)]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.AnnotatedBindingBuilder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#bind(TypeLiteral)]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.AnnotatedBindingBuilder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#bind(Class)]]>
      </doc>
    </method>
    <method name="bindConstant" return="com.google.inject.binder.AnnotatedConstantBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see Binder#bindConstant()]]>
      </doc>
    </method>
    <method name="install"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="module" type="com.google.inject.Module"/>
      <doc>
      <![CDATA[@see Binder#install(Module)]]>
      </doc>
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <param name="arguments" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[@see Binder#addError(String, Object[])]]>
      </doc>
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[@see Binder#addError(Throwable)]]>
      </doc>
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="message" type="com.google.inject.spi.Message"/>
      <doc>
      <![CDATA[@see Binder#addError(Message)
 @since 2.0]]>
      </doc>
    </method>
    <method name="requestInjection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="instance" type="java.lang.Object"/>
      <doc>
      <![CDATA[@see Binder#requestInjection(Object)
 @since 2.0]]>
      </doc>
    </method>
    <method name="requestStaticInjection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="types" type="java.lang.Class[]"/>
      <doc>
      <![CDATA[@see Binder#requestStaticInjection(Class[])]]>
      </doc>
    </method>
    <method name="bindInterceptor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="classMatcher" type="com.google.inject.matcher.Matcher&lt;? super java.lang.Class&lt;?&gt;&gt;"/>
      <param name="methodMatcher" type="com.google.inject.matcher.Matcher&lt;? super java.lang.reflect.Method&gt;"/>
      <param name="interceptors" type="org.aopalliance.intercept.MethodInterceptor[]"/>
      <doc>
      <![CDATA[@see Binder#bindInterceptor(com.google.inject.matcher.Matcher,
  com.google.inject.matcher.Matcher,
  org.aopalliance.intercept.MethodInterceptor[])]]>
      </doc>
    </method>
    <method name="requireBinding"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;?&gt;"/>
      <doc>
      <![CDATA[Adds a dependency from this module to {@code key}. When the injector is
 created, Guice will report an error if {@code key} cannot be injected.
 Note that this requirement may be satisfied by implicit binding, such as
 a public no-arguments constructor.

 @since 2.0]]>
      </doc>
    </method>
    <method name="requireBinding"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Adds a dependency from this module to {@code type}. When the injector is
 created, Guice will report an error if {@code type} cannot be injected.
 Note that this requirement may be satisfied by implicit binding, such as
 a public no-arguments constructor.

 @since 2.0]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#getProvider(Key)
 @since 2.0]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#getProvider(Class)
 @since 2.0]]>
      </doc>
    </method>
    <method name="convertToTypes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="typeMatcher" type="com.google.inject.matcher.Matcher&lt;? super com.google.inject.TypeLiteral&lt;?&gt;&gt;"/>
      <param name="converter" type="com.google.inject.spi.TypeConverter"/>
      <doc>
      <![CDATA[@see Binder#convertToTypes
 @since 2.0]]>
      </doc>
    </method>
    <method name="currentStage" return="com.google.inject.Stage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see Binder#currentStage() 
 @since 2.0]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#getMembersInjector(Class)
 @since 2.0]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#getMembersInjector(TypeLiteral)
 @since 2.0]]>
      </doc>
    </method>
    <method name="bindListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="typeMatcher" type="com.google.inject.matcher.Matcher&lt;? super com.google.inject.TypeLiteral&lt;?&gt;&gt;"/>
      <param name="listener" type="com.google.inject.spi.TypeListener"/>
      <doc>
      <![CDATA[@see Binder#bindListener(com.google.inject.matcher.Matcher,
  com.google.inject.spi.TypeListener)
 @since 2.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A support class for {@link Module}s which reduces repetition and results in
 a more readable configuration. Simply extend this class, implement {@link
 #configure()}, and call the inherited methods which mirror those found in
 {@link Binder}. For example:

 <pre>
 public class MyModule extends AbstractModule {
   protected void configure() {
     bind(Service.class).to(ServiceImpl.class).in(Singleton.class);
     bind(CreditCardPaymentService.class);
     bind(PaymentService.class).to(CreditCardPaymentService.class);
     bindConstant().annotatedWith(Names.named("port")).to(8080);
   }
 }
 </pre>

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.AbstractModule -->
  <!-- start interface com.google.inject.Binder -->
  <interface name="Binder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="bindInterceptor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classMatcher" type="com.google.inject.matcher.Matcher&lt;? super java.lang.Class&lt;?&gt;&gt;"/>
      <param name="methodMatcher" type="com.google.inject.matcher.Matcher&lt;? super java.lang.reflect.Method&gt;"/>
      <param name="interceptors" type="org.aopalliance.intercept.MethodInterceptor[]"/>
      <doc>
      <![CDATA[Binds method interceptor[s] to methods matched by class and method matchers. A method is
 eligible for interception if:

 <ul>
  <li>Guice created the instance the method is on</li>
  <li>Neither the enclosing type nor the method is final</li>
  <li>And the method is package-private, protected, or public</li>
 </ul>

 @param classMatcher matches classes the interceptor should apply to. For
     example: {@code only(Runnable.class)}.
 @param methodMatcher matches methods the interceptor should apply to. For
     example: {@code annotatedWith(Transactional.class)}.
 @param interceptors to bind]]>
      </doc>
    </method>
    <method name="bindScope"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <param name="scope" type="com.google.inject.Scope"/>
      <doc>
      <![CDATA[Binds a scope to an annotation.]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.LinkedBindingBuilder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link Binder}.]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.AnnotatedBindingBuilder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link Binder}.]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.AnnotatedBindingBuilder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link Binder}.]]>
      </doc>
    </method>
    <method name="bindConstant" return="com.google.inject.binder.AnnotatedConstantBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See the EDSL examples at {@link Binder}.]]>
      </doc>
    </method>
    <method name="requestInjection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <param name="instance" type="T"/>
      <doc>
      <![CDATA[Upon successful creation, the {@link Injector} will inject instance fields
 and methods of the given object.

 @param type of instance
 @param instance for which members will be injected
 @since 2.0]]>
      </doc>
    </method>
    <method name="requestInjection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="java.lang.Object"/>
      <doc>
      <![CDATA[Upon successful creation, the {@link Injector} will inject instance fields
 and methods of the given object.

 @param instance for which members will be injected
 @since 2.0]]>
      </doc>
    </method>
    <method name="requestStaticInjection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="types" type="java.lang.Class[]"/>
      <doc>
      <![CDATA[Upon successful creation, the {@link Injector} will inject static fields
 and methods in the given classes.

 @param types for which static members will be injected]]>
      </doc>
    </method>
    <method name="install"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="module" type="com.google.inject.Module"/>
      <doc>
      <![CDATA[Uses the given module to configure more bindings.]]>
      </doc>
    </method>
    <method name="currentStage" return="com.google.inject.Stage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current stage.]]>
      </doc>
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <param name="arguments" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Records an error message which will be presented to the user at a later
 time. Unlike throwing an exception, this enable us to continue
 configuring the Injector and discover more errors. Uses {@link
 String#format(String, Object[])} to insert the arguments into the
 message.]]>
      </doc>
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Records an exception, the full details of which will be logged, and the
 message of which will be presented to the user at a later
 time. If your Module calls something that you worry may fail, you should
 catch the exception and pass it into this.]]>
      </doc>
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="com.google.inject.spi.Message"/>
      <doc>
      <![CDATA[Records an error message to be presented to the user at a later time.

 @since 2.0]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the provider used to obtain instances for the given injection key.
 The returned will not be valid until the {@link Injector} has been
 created. The provider will throw an {@code IllegalStateException} if you
 try to use it beforehand.

 @since 2.0]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the provider used to obtain instances for the given injection type.
 The returned provider will not be valid until the {@link Injector} has been
 created. The provider will throw an {@code IllegalStateException} if you
 try to use it beforehand.

 @since 2.0]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the members injector used to inject dependencies into methods and fields on instances
 of the given type {@code T}. The returned members injector will not be valid until the main
 {@link Injector} has been created. The members injector will throw an {@code
 IllegalStateException} if you try to use it beforehand.

 @param typeLiteral type to get members injector for
 @since 2.0]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the members injector used to inject dependencies into methods and fields on instances
 of the given type {@code T}. The returned members injector will not be valid until the main
 {@link Injector} has been created. The members injector will throw an {@code
 IllegalStateException} if you try to use it beforehand.

 @param type type to get members injector for
 @since 2.0]]>
      </doc>
    </method>
    <method name="convertToTypes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeMatcher" type="com.google.inject.matcher.Matcher&lt;? super com.google.inject.TypeLiteral&lt;?&gt;&gt;"/>
      <param name="converter" type="com.google.inject.spi.TypeConverter"/>
      <doc>
      <![CDATA[Binds a type converter. The injector will use the given converter to
 convert string constants to matching types as needed.

 @param typeMatcher matches types the converter can handle
 @param converter converts values
 @since 2.0]]>
      </doc>
    </method>
    <method name="bindListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeMatcher" type="com.google.inject.matcher.Matcher&lt;? super com.google.inject.TypeLiteral&lt;?&gt;&gt;"/>
      <param name="listener" type="com.google.inject.spi.TypeListener"/>
      <doc>
      <![CDATA[Registers a listener for injectable types. Guice will notify the listener when it encounters
 injectable types matched by the given type matcher.

 @param typeMatcher that matches injectable types the listener should be notified of
 @param listener for injectable types matched by typeMatcher
 @since 2.0]]>
      </doc>
    </method>
    <method name="withSource" return="com.google.inject.Binder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns a binder that uses {@code source} as the reference location for
 configuration errors. This is typically a {@link StackTraceElement}
 for {@code .java} source but it could any binding source, such as the
 path to a {@code .properties} file.

 @param source any object representing the source location and has a
     concise {@link Object#toString() toString()} value
 @return a binder that shares its configuration with this binder
 @since 2.0]]>
      </doc>
    </method>
    <method name="skipSources" return="com.google.inject.Binder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classesToSkip" type="java.lang.Class[]"/>
      <doc>
      <![CDATA[Returns a binder that skips {@code classesToSkip} when identify the
 calling code. The caller's {@link StackTraceElement} is used to locate
 the source of configuration errors.

 @param classesToSkip library classes that create bindings on behalf of
      their clients.
 @return a binder that shares its configuration with this binder.
 @since 2.0]]>
      </doc>
    </method>
    <method name="newPrivateBinder" return="com.google.inject.PrivateBinder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new private child environment for bindings and other configuration. The returned
 binder can be used to add and configuration information in this environment. See {@link
 PrivateModule} for details.

 @return a binder that inherits configuration from this binder. Only exposed configuration on
      the returned binder will be visible to this binder.
 @since 2.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Collects configuration information (primarily <i>bindings</i>) which will be
 used to create an {@link Injector}. Guice provides this object to your
 application's {@link Module} implementors so they may each contribute
 their own bindings and other registrations.

 <h3>The Guice Binding EDSL</h3>

 Guice uses an <i>embedded domain-specific language</i>, or EDSL, to help you
 create bindings simply and readably.  This approach is great for overall
 usability, but it does come with a small cost: <b>it is difficult to
 learn how to use the Binding EDSL by reading
 method-level javadocs</b>.  Instead, you should consult the series of
 examples below.  To save space, these examples omit the opening
 {@code binder}, just as you will if your module extends
 {@link AbstractModule}.

 <pre>
     bind(ServiceImpl.class);</pre>

 This statement does essentially nothing; it "binds the {@code ServiceImpl}
 class to itself" and does not change Guice's default behavior.  You may still
 want to use this if you prefer your {@link Module} class to serve as an
 explicit <i>manifest</i> for the services it provides.  Also, in rare cases,
 Guice may be unable to validate a binding at injector creation time unless it
 is given explicitly.

 <pre>
     bind(Service.class).to(ServiceImpl.class);</pre>

 Specifies that a request for a {@code Service} instance with no binding
 annotations should be treated as if it were a request for a
 {@code ServiceImpl} instance. This <i>overrides</i> the function of any
 {@link ImplementedBy @ImplementedBy} or {@link ProvidedBy @ProvidedBy}
 annotations found on {@code Service}, since Guice will have already
 "moved on" to {@code ServiceImpl} before it reaches the point when it starts
 looking for these annotations.

 <pre>
     bind(Service.class).toProvider(ServiceProvider.class);</pre>

 In this example, {@code ServiceProvider} must extend or implement
 {@code Provider<Service>}. This binding specifies that Guice should resolve
 an unannotated injection request for {@code Service} by first resolving an
 instance of {@code ServiceProvider} in the regular way, then calling
 {@link Provider#get get()} on the resulting Provider instance to obtain the
 {@code Service} instance.

 <p>The {@link Provider} you use here does not have to be a "factory"; that
 is, a provider which always <i>creates</i> each instance it provides.
 However, this is generally a good practice to follow.  You can then use
 Guice's concept of {@link Scope scopes} to guide when creation should happen
 -- "letting Guice work for you".

 <pre>
     bind(Service.class).annotatedWith(Red.class).to(ServiceImpl.class);</pre>

 Like the previous example, but only applies to injection requests that use
 the binding annotation {@code @Red}.  If your module also includes bindings
 for particular <i>values</i> of the {@code @Red} annotation (see below),
 then this binding will serve as a "catch-all" for any values of {@code @Red}
 that have no exact match in the bindings.
 
 <pre>
     bind(ServiceImpl.class).in(Singleton.class);
     // or, alternatively
     bind(ServiceImpl.class).in(Scopes.SINGLETON);</pre>

 Either of these statements places the {@code ServiceImpl} class into
 singleton scope.  Guice will create only one instance of {@code ServiceImpl}
 and will reuse it for all injection requests of this type.  Note that it is
 still possible to bind another instance of {@code ServiceImpl} if the second
 binding is qualified by an annotation as in the previous example.  Guice is
 not overly concerned with <i>preventing</i> you from creating multiple
 instances of your "singletons", only with <i>enabling</i> your application to
 share only one instance if that's all you tell Guice you need.

 <p><b>Note:</b> a scope specified in this way <i>overrides</i> any scope that
 was specified with an annotation on the {@code ServiceImpl} class.
 
 <p>Besides {@link Singleton}/{@link Scopes#SINGLETON}, there are
 servlet-specific scopes available in
 {@code com.google.inject.servlet.ServletScopes}, and your Modules can
 contribute their own custom scopes for use here as well.

 <pre>
     bind(new TypeLiteral&lt;PaymentService&lt;CreditCard>>() {})
         .to(CreditCardPaymentService.class);</pre>

 This admittedly odd construct is the way to bind a parameterized type. It
 tells Guice how to honor an injection request for an element of type
 {@code PaymentService<CreditCard>}. The class
 {@code CreditCardPaymentService} must implement the
 {@code PaymentService<CreditCard>} interface.  Guice cannot currently bind or
 inject a generic type, such as {@code Set<E>}; all type parameters must be
 fully specified.

 <pre>
     bind(Service.class).toInstance(new ServiceImpl());
     // or, alternatively
     bind(Service.class).toInstance(SomeLegacyRegistry.getService());</pre>

 In this example, your module itself, <i>not Guice</i>, takes responsibility
 for obtaining a {@code ServiceImpl} instance, then asks Guice to always use
 this single instance to fulfill all {@code Service} injection requests.  When
 the {@link Injector} is created, it will automatically perform field
 and method injection for this instance, but any injectable constructor on
 {@code ServiceImpl} is simply ignored.  Note that using this approach results
 in "eager loading" behavior that you can't control.

 <pre>
     bindConstant().annotatedWith(ServerHost.class).to(args[0]);</pre>

 Sets up a constant binding. Constant injections must always be annotated.
 When a constant binding's value is a string, it is eligile for conversion to
 all primitive types, to {@link Enum#valueOf(Class, String) all enums}, and to
 {@link Class#forName class literals}. Conversions for other types can be
 configured using {@link #convertToTypes(Matcher, TypeConverter)
 convertToTypes()}.

 <pre>
   {@literal @}Color("red") Color red; // A member variable (field)
    . . .
     red = MyModule.class.getDeclaredField("red").getAnnotation(Color.class);
     bind(Service.class).annotatedWith(red).to(RedService.class);</pre>

 If your binding annotation has parameters you can apply different bindings to
 different specific values of your annotation.  Getting your hands on the
 right instance of the annotation is a bit of a pain -- one approach, shown
 above, is to apply a prototype annotation to a field in your module class, so
 that you can read this annotation instance and give it to Guice.

 <pre>
     bind(Service.class)
         .annotatedWith(Names.named("blue"))
         .to(BlueService.class);</pre>

 Differentiating by names is a common enough use case that we provided a
 standard annotation, {@link com.google.inject.name.Named @Named}.  Because of
 Guice's library support, binding by name is quite easier than in the
 arbitrary binding annotation case we just saw.  However, remember that these
 names will live in a single flat namespace with all the other names used in
 your application.

 <p>The above list of examples is far from exhaustive.  If you can think of
 how the concepts of one example might coexist with the concepts from another,
 you can most likely weave the two together.  If the two concepts make no
 sense with each other, you most likely won't be able to do it.  In a few
 cases Guice will let something bogus slip by, and will then inform you of
 the problems at runtime, as soon as you try to create your Injector.

 <p>The other methods of Binder such as {@link #bindScope},
 {@link #bindInterceptor}, {@link #install}, {@link #requestStaticInjection},
 {@link #addError} and {@link #currentStage} are not part of the Binding EDSL;
 you can learn how to use these in the usual way, from the method
 documentation.

 @author crazybob@google.com (Bob Lee)
 @author jessewilson@google.com (Jesse Wilson)
 @author kevinb@google.com (Kevin Bourrillion)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.Binder -->
  <!-- start interface com.google.inject.Binding -->
  <interface name="Binding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <method name="getKey" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the key for this binding.]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the scoped provider guice uses to fulfill requests for this
 binding.

 @throws UnsupportedOperationException when invoked on a {@link Binding}
      created via {@link com.google.inject.spi.Elements#getElements}. This
      method is only supported on {@link Binding}s returned from an injector.]]>
      </doc>
    </method>
    <method name="acceptTargetVisitor" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.BindingTargetVisitor&lt;? super T, V&gt;"/>
      <doc>
      <![CDATA[Accepts a target visitor. Invokes the visitor method specific to this binding's target.

 @param visitor to call back on
 @since 2.0]]>
      </doc>
    </method>
    <method name="acceptScopingVisitor" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.BindingScopingVisitor&lt;V&gt;"/>
      <doc>
      <![CDATA[Accepts a scoping visitor. Invokes the visitor method specific to this binding's scoping.

 @param visitor to call back on
 @since 2.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A mapping from a key (type and optional annotation) to the strategy for getting instances of the
 type. This interface is part of the introspection API and is intended primarily for use by 
 tools.

 <p>Bindings are created in several ways:
 <ul>
     <li>Explicitly in a module, via {@code bind()} and {@code bindConstant()}
         statements:
 <pre>
     bind(Service.class).annotatedWith(Red.class).to(ServiceImpl.class);
     bindConstant().annotatedWith(ServerHost.class).to(args[0]);</pre></li>
     <li>Implicitly by the Injector by following a type's {@link ImplementedBy
         pointer} {@link ProvidedBy annotations} or by using its {@link Inject annotated} or
         default constructor.</li>
     <li>By converting a bound instance to a different type.</li>
     <li>For {@link Provider providers}, by delegating to the binding for the provided type.</li>
 </ul>


 <p>They exist on both modules and on injectors, and their behaviour is different for each:
 <ul>
     <li><strong>Module bindings</strong> are incomplete and cannot be used to provide instances.
         This is because the applicable scopes and interceptors may not be known until an injector
         is created. From a tool's perspective, module bindings are like the injector's source
         code. They can be inspected or rewritten, but this analysis must be done statically.</li>
     <li><strong>Injector bindings</strong> are complete and valid and can be used to provide
         instances. From a tools' perspective, injector bindings are like reflection for an
         injector. They have full runtime information, including the complete graph of injections
         necessary to satisfy a binding.</li>
 </ul>

 @param <T> the bound type. The injected is always assignable to this type.

 @author crazybob@google.com (Bob Lee)
 @author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.Binding -->
  <!-- start class com.google.inject.BindingAnnotation -->
  <class name="BindingAnnotation"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotates annotations which are used for binding. Only one such annotation
 may apply to a single injection point. You must also annotate binder
 annotations with {@code @Retention(RUNTIME)}. For example:

 <pre>
   {@code @}Retention(RUNTIME)
   {@code @}Target({ FIELD, PARAMETER, METHOD })
   {@code @}BindingAnnotation
   public {@code @}interface Transactional {}
 </pre>

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.BindingAnnotation -->
  <!-- start class com.google.inject.ConfigurationException -->
  <class name="ConfigurationException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ConfigurationException" type="java.lang.Iterable&lt;com.google.inject.spi.Message&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a ConfigurationException containing {@code messages}.]]>
      </doc>
    </constructor>
    <method name="withPartialValue" return="com.google.inject.ConfigurationException"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="partialValue" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns a copy of this configuration exception with the specified partial value.]]>
      </doc>
    </method>
    <method name="getErrorMessages" return="java.util.Collection&lt;com.google.inject.spi.Message&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns messages for the errors that caused this exception.]]>
      </doc>
    </method>
    <method name="getPartialValue" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a value that was only partially computed due to this exception. The caller can use
 this while collecting additional configuration problems.

 @return the partial value, or {@code null} if none was set. The type of the partial value is
      specified by the throwing method.]]>
      </doc>
    </method>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Thrown when a programming error such as a misplaced annotation, illegal binding, or unsupported
 scope is found. Clients should catch this exception, log it, and stop execution.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.ConfigurationException -->
  <!-- start class com.google.inject.CreationException -->
  <class name="CreationException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CreationException" type="java.util.Collection&lt;com.google.inject.spi.Message&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a CreationException containing {@code messages}.]]>
      </doc>
    </constructor>
    <method name="getErrorMessages" return="java.util.Collection&lt;com.google.inject.spi.Message&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns messages for the errors that caused this exception.]]>
      </doc>
    </method>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Thrown when errors occur while creating a {@link Injector}. Includes a list of encountered
 errors. Clients should catch this exception, log it, and stop execution.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.CreationException -->
  <!-- start class com.google.inject.Exposed -->
  <class name="Exposed"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Acccompanies a {@literal @}{@link com.google.inject.Provides Provides} method annotation in a
 private module to indicate that the provided binding is exposed.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.Exposed -->
  <!-- start class com.google.inject.Guice -->
  <class name="Guice" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="createInjector" return="com.google.inject.Injector"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="com.google.inject.Module[]"/>
      <doc>
      <![CDATA[Creates an injector for the given set of modules.

 @throws CreationException if one or more errors occur during Injector
     construction]]>
      </doc>
    </method>
    <method name="createInjector" return="com.google.inject.Injector"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Iterable&lt;? extends com.google.inject.Module&gt;"/>
      <doc>
      <![CDATA[Creates an injector for the given set of modules.

 @throws CreationException if one or more errors occur during Injector
     creation]]>
      </doc>
    </method>
    <method name="createInjector" return="com.google.inject.Injector"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stage" type="com.google.inject.Stage"/>
      <param name="modules" type="com.google.inject.Module[]"/>
      <doc>
      <![CDATA[Creates an injector for the given set of modules, in a given development
 stage.

 @throws CreationException if one or more errors occur during Injector
     creation]]>
      </doc>
    </method>
    <method name="createInjector" return="com.google.inject.Injector"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stage" type="com.google.inject.Stage"/>
      <param name="modules" type="java.lang.Iterable&lt;? extends com.google.inject.Module&gt;"/>
      <doc>
      <![CDATA[Creates an injector for the given set of modules, in a given development
 stage.

 @throws CreationException if one or more errors occur during Injector
     construction]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The entry point to the Guice framework. Creates {@link Injector}s from
 {@link Module}s.

 <p>Guice supports a model of development that draws clear boundaries between
 APIs, Implementations of these APIs, Modules which configure these
 implementations, and finally Applications which consist of a collection of
 Modules. It is the Application, which typically defines your {@code main()}
 method, that bootstraps the Guice Injector using the {@code Guice} class, as
 in this example:
 <pre>
     public class FooApplication {
       public static void main(String[] args) {
         Injector injector = Guice.createInjector(
             new ModuleA(),
             new ModuleB(),
             . . .
             new FooApplicationFlagsModule(args)
         );

         // Now just bootstrap the application and you're done
         FooStarter starter = injector.getInstance(FooStarter.class);
         starter.runApplication();
       }
     }
 </pre>]]>
    </doc>
  </class>
  <!-- end class com.google.inject.Guice -->
  <!-- start class com.google.inject.ImplementedBy -->
  <class name="ImplementedBy"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[A pointer to the default implementation of a type.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.ImplementedBy -->
  <!-- start class com.google.inject.Inject -->
  <class name="Inject"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotates members of your implementation class (constructors, methods
 and fields) into which the {@link Injector} should inject values.
 The Injector fulfills injection requests for:

 <ul>
 <li>Every instance it constructs. The class being constructed must have
 exactly one of its constructors marked with {@code @Inject} or must have a
 constructor taking no parameters. The Injector then proceeds to perform
 method and field injections.
 
 <li>Pre-constructed instances passed to {@link Injector#injectMembers},
 {@link com.google.inject.binder.LinkedBindingBuilder#toInstance(Object)} and
 {@link com.google.inject.binder.LinkedBindingBuilder#toProvider(Provider)}.
 In this case all constructors are, of course, ignored.

 <li>Static fields and methods of classes which any {@link Module} has
 specifically requested static injection for, using
 {@link Binder#requestStaticInjection}.
 </ul>

 In all cases, a member can be injected regardless of its Java access
 specifier (private, default, protected, public).

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.Inject -->
  <!-- start interface com.google.inject.Injector -->
  <interface name="Injector"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="injectMembers"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="java.lang.Object"/>
      <doc>
      <![CDATA[Injects dependencies into the fields and methods of {@code instance}. Ignores the presence or
 absence of an injectable constructor.

 <p>Whenever Guice creates an instance, it performs this injection automatically (after first
 performing constructor injection), so if you're able to let Guice create all your objects for
 you, you'll never need to use this method.

 @param instance to inject members on

 @see Binder#getMembersInjector(Class) for a preferred alternative that supports checks before
  run time]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the members injector used to inject dependencies into methods and fields on instances
 of the given type {@code T}.

 @param typeLiteral type to get members injector for
 @see Binder#getMembersInjector(TypeLiteral) for an alternative that offers up front error
  detection
 @since 2.0]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the members injector used to inject dependencies into methods and fields on instances
 of the given type {@code T}. When feasible, use {@link Binder#getMembersInjector(TypeLiteral)}
 instead to get increased up front error detection.

 @param type type to get members injector for
 @see Binder#getMembersInjector(Class) for an alternative that offers up front error
  detection
 @since 2.0]]>
      </doc>
    </method>
    <method name="getBindings" return="java.util.Map&lt;com.google.inject.Key&lt;?&gt;, com.google.inject.Binding&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns all explicit bindings.

 <p>The returned map does not include bindings inherited from a {@link #getParent() parent
 injector}, should one exist. The returned map is guaranteed to iterate (for example, with
 its {@link java.util.Map#entrySet()} iterator) in the order of insertion. In other words,
 the order in which bindings appear in user Modules.

 <p>This method is part of the Guice SPI and is intended for use by tools and extensions.]]>
      </doc>
    </method>
    <method name="getBinding" return="com.google.inject.Binding&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the binding for the given injection key. This will be an explicit bindings if the key
 was bound explicitly by a module, or an implicit binding otherwise. The implicit binding will
 be created if necessary.

 <p>This method is part of the Guice SPI and is intended for use by tools and extensions.

 @throws ConfigurationException if this injector cannot find or create the binding.]]>
      </doc>
    </method>
    <method name="getBinding" return="com.google.inject.Binding&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the binding for the given type. This will be an explicit bindings if the injection key
 was bound explicitly by a module, or an implicit binding otherwise. The implicit binding will
 be created if necessary.

 <p>This method is part of the Guice SPI and is intended for use by tools and extensions.

 @throws ConfigurationException if this injector cannot find or create the binding.
 @since 2.0]]>
      </doc>
    </method>
    <method name="findBindingsByType" return="java.util.List&lt;com.google.inject.Binding&lt;T&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns all explicit bindings for {@code type}.

 <p>This method is part of the Guice SPI and is intended for use by tools and extensions.]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the provider used to obtain instances for the given injection key. When feasible, avoid
 using this method, in favor of having Guice inject your dependencies ahead of time.

 @throws ConfigurationException if this injector cannot find or create the provider.
 @see Binder#getProvider(Key) for an alternative that offers up front error detection]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the provider used to obtain instances for the given type. When feasible, avoid
 using this method, in favor of having Guice inject your dependencies ahead of time.

 @throws ConfigurationException if this injector cannot find or create the provider.
 @see Binder#getProvider(Class) for an alternative that offers up front error detection]]>
      </doc>
    </method>
    <method name="getInstance" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the appropriate instance for the given injection key; equivalent to {@code
 getProvider(key).get()}. When feasible, avoid using this method, in favor of having Guice
 inject your dependencies ahead of time.

 @throws ConfigurationException if this injector cannot find or create the provider.
 @throws ProvisionException if there was a runtime failure while providing an instance.]]>
      </doc>
    </method>
    <method name="getInstance" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the appropriate instance for the given injection type; equivalent to {@code
 getProvider(type).get()}. When feasible, avoid using this method, in favor of having Guice
 inject your dependencies ahead of time.

 @throws ConfigurationException if this injector cannot find or create the provider.
 @throws ProvisionException if there was a runtime failure while providing an instance.]]>
      </doc>
    </method>
    <method name="getParent" return="com.google.inject.Injector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns this injector's parent, or {@code null} if this is a top-level injector.

 @since 2.0]]>
      </doc>
    </method>
    <method name="createChildInjector" return="com.google.inject.Injector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Iterable&lt;? extends com.google.inject.Module&gt;"/>
      <doc>
      <![CDATA[Returns a new injector that inherits all state from this injector. All bindings, scopes,
 interceptors and type converters are inherited -- they are visible to the child injector.
 Elements of the child injector are not visible to its parent.

 <p>Just-in-time bindings created for child injectors will be created in an ancestor injector
 whenever possible. This allows for scoped instances to be shared between injectors. Use
 explicit bindings to prevent bindings from being shared with the parent injector.

 <p>No key may be bound by both an injector and one of its ancestors. This includes just-in-time
 bindings. The lone exception is the key for {@code Injector.class}, which is bound by each
 injector to itself.

 @since 2.0]]>
      </doc>
    </method>
    <method name="createChildInjector" return="com.google.inject.Injector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="com.google.inject.Module[]"/>
      <doc>
      <![CDATA[Returns a new injector that inherits all state from this injector. All bindings, scopes,
 interceptors and type converters are inherited -- they are visible to the child injector.
 Elements of the child injector are not visible to its parent.

 <p>Just-in-time bindings created for child injectors will be created in an ancestor injector
 whenever possible. This allows for scoped instances to be shared between injectors. Use
 explicit bindings to prevent bindings from being shared with the parent injector.

 <p>No key may be bound by both an injector and one of its ancestors. This includes just-in-time
 bindings. The lone exception is the key for {@code Injector.class}, which is bound by each
 injector to itself.

 @since 2.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Builds the graphs of objects that make up your application. The injector tracks the dependencies
 for each type and uses bindings to inject them. This is the core of Guice, although you rarely
 interact with it directly. This "behind-the-scenes" operation is what distinguishes dependency
 injection from its cousin, the service locator pattern.

 <p>Contains several default bindings:

 <ul>
 <li>This {@link Injector} instance itself
 <li>A {@code Provider<T>} for each binding of type {@code T}
 <li>The {@link java.util.logging.Logger} for the class being injected
 <li>The {@link Stage} in which the Injector was created
 </ul>

 Injectors are created using the facade class {@link Guice}.

 <p>An injector can also {@link #injectMembers(Object) inject the dependencies} of
 already-constructed instances. This can be used to interoperate with objects created by other
 frameworks or services.

 <p>Injectors can be {@link #createChildInjector(Iterable) hierarchical}. Child injectors inherit
 the configuration of their parent injectors, but the converse does not hold.

 <p>The injector's {@link #getBindings() internal bindings} are available for introspection. This
 enables tools and extensions to operate on an injector reflectively.

 @author crazybob@google.com (Bob Lee)
 @author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.Injector -->
  <!-- start class com.google.inject.Key -->
  <class name="Key" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Key" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new key. Derives the type from this class's type parameter.

 <p>Clients create an empty anonymous subclass. Doing so embeds the type
 parameter in the anonymous class's type hierarchy so we can reconstitute it
 at runtime despite erasure.

 <p>Example usage for a binding of type {@code Foo} annotated with
 {@code @Bar}:

 <p>{@code new Key<Foo>(Bar.class) {}}.]]>
      </doc>
    </constructor>
    <constructor name="Key" type="java.lang.annotation.Annotation"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new key. Derives the type from this class's type parameter.

 <p>Clients create an empty anonymous subclass. Doing so embeds the type
 parameter in the anonymous class's type hierarchy so we can reconstitute it
 at runtime despite erasure.

 <p>Example usage for a binding of type {@code Foo} annotated with
 {@code @Bar}:

 <p>{@code new Key<Foo>(new Bar()) {}}.]]>
      </doc>
    </constructor>
    <constructor name="Key"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new key. Derives the type from this class's type parameter.

 <p>Clients create an empty anonymous subclass. Doing so embeds the type
 parameter in the anonymous class's type hierarchy so we can reconstitute it
 at runtime despite erasure.

 <p>Example usage for a binding of type {@code Foo}:

 <p>{@code new Key<Foo>() {}}.]]>
      </doc>
    </constructor>
    <method name="getTypeLiteral" return="com.google.inject.TypeLiteral&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the key type.]]>
      </doc>
    </method>
    <method name="getAnnotationType" return="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the annotation type.]]>
      </doc>
    </method>
    <method name="getAnnotation" return="java.lang.annotation.Annotation"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the annotation.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Gets a key for an injection type.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[Gets a key for an injection type and an annotation type.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Gets a key for an injection type and an annotation.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.Key&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Gets a key for an injection type.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.Key&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[Gets a key for an injection type and an annotation type.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.Key&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Gets a key for an injection type and an annotation.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[Gets a key for an injection type.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[Gets a key for an injection type and an annotation type.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Gets a key for an injection type and an annotation.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Binding key consisting of an injection type and an optional annotation.
 Matches the type and annotation at a point of injection.

 <p>For example, {@code Key.get(Service.class, Transactional.class)} will
 match:

 <pre>
   {@literal @}Inject
   public void setService({@literal @}Transactional Service service) {
     ...
   }
 </pre>

 <p>{@code Key} supports generic types via subclassing just like {@link
 TypeLiteral}.

 <p>Keys do not differentiate between primitive types (int, char, etc.) and
 their correpsonding wrapper types (Integer, Character, etc.). Primitive
 types will be replaced with their wrapper types when keys are created.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.Key -->
  <!-- start interface com.google.inject.MembersInjector -->
  <interface name="MembersInjector"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="injectMembers"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="T"/>
      <doc>
      <![CDATA[Injects dependencies into the fields and methods of {@code instance}. Ignores the presence or
 absence of an injectable constructor.

 <p>Whenever Guice creates an instance, it performs this injection automatically (after first
 performing constructor injection), so if you're able to let Guice create all your objects for
 you, you'll never need to use this method.

 @param instance to inject members on. May be {@code null}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Injects dependencies into the fields and methods on instances of type {@code T}. Ignores the
 presence or absence of an injectable constructor.

 @param <T> type to inject members of

 @author crazybob@google.com (Bob Lee)
 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.MembersInjector -->
  <!-- start interface com.google.inject.Module -->
  <interface name="Module"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <doc>
      <![CDATA[Contributes bindings and other configurations for this module to {@code binder}.

 <p><strong>Do not invoke this method directly</strong> to install submodules. Instead use
 {@link Binder#install(Module)}, which ensures that {@link Provides provider methods} are
 discovered.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A module contributes configuration information, typically interface
 bindings, which will be used to create an {@link Injector}. A Guice-based
 application is ultimately composed of little more than a set of
 {@code Module}s and some bootstrapping code.

 <p>Your Module classes can use a more streamlined syntax by extending
 {@link AbstractModule} rather than implementing this interface directly.

 <p>In addition to the bindings configured via {@link #configure}, bindings
 will be created for all methods annotated with {@literal @}{@link Provides}.
 Use scope and binding annotations on these methods to configure the
 bindings.]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.Module -->
  <!-- start class com.google.inject.OutOfScopeException -->
  <class name="OutOfScopeException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="OutOfScopeException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="OutOfScopeException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="OutOfScopeException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Thrown from {@link Provider#get} when an attempt is made to access a scoped
 object while the scope in question is not currently active.

 @author kevinb@google.com (Kevin Bourrillion)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.OutOfScopeException -->
  <!-- start interface com.google.inject.PrivateBinder -->
  <interface name="PrivateBinder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binder"/>
    <method name="expose"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;?&gt;"/>
      <doc>
      <![CDATA[Makes the binding for {@code key} available to the enclosing environment]]>
      </doc>
    </method>
    <method name="expose" return="com.google.inject.binder.AnnotatedElementBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Makes a binding for {@code type} available to the enclosing environment. Use {@link
 com.google.inject.binder.AnnotatedElementBuilder#annotatedWith(Class) annotatedWith()} to expose {@code type} with a
 binding annotation.]]>
      </doc>
    </method>
    <method name="expose" return="com.google.inject.binder.AnnotatedElementBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral&lt;?&gt;"/>
      <doc>
      <![CDATA[Makes a binding for {@code type} available to the enclosing environment. Use {@link
 AnnotatedElementBuilder#annotatedWith(Class) annotatedWith()} to expose {@code type} with a
 binding annotation.]]>
      </doc>
    </method>
    <method name="withSource" return="com.google.inject.PrivateBinder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.Object"/>
    </method>
    <method name="skipSources" return="com.google.inject.PrivateBinder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classesToSkip" type="java.lang.Class[]"/>
    </method>
    <doc>
    <![CDATA[Returns a binder whose configuration information is hidden from its environment by default. See
 {@link com.google.inject.PrivateModule PrivateModule} for details.
 
 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.PrivateBinder -->
  <!-- start class com.google.inject.PrivateModule -->
  <class name="PrivateModule" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Module"/>
    <constructor name="PrivateModule"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="configure"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates bindings and other configurations private to this module. Use {@link #expose(Class)
 expose()} to make the bindings in this module available externally.]]>
      </doc>
    </method>
    <method name="expose"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[Makes the binding for {@code key} available to other modules and the injector.]]>
      </doc>
    </method>
    <method name="expose" return="com.google.inject.binder.AnnotatedElementBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Makes a binding for {@code type} available to other modules and the injector. Use {@link
 AnnotatedElementBuilder#annotatedWith(Class) annotatedWith()} to expose {@code type} with a
 binding annotation.]]>
      </doc>
    </method>
    <method name="expose" return="com.google.inject.binder.AnnotatedElementBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral&lt;?&gt;"/>
      <doc>
      <![CDATA[Makes a binding for {@code type} available to other modules and the injector. Use {@link
 AnnotatedElementBuilder#annotatedWith(Class) annotatedWith()} to expose {@code type} with a
 binding annotation.]]>
      </doc>
    </method>
    <method name="binder" return="com.google.inject.PrivateBinder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the current binder.]]>
      </doc>
    </method>
    <method name="bindScope"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="scopeAnnotation" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <param name="scope" type="com.google.inject.Scope"/>
      <doc>
      <![CDATA[@see Binder#bindScope(Class, Scope)]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.LinkedBindingBuilder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#bind(Key)]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.AnnotatedBindingBuilder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#bind(TypeLiteral)]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.AnnotatedBindingBuilder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#bind(Class)]]>
      </doc>
    </method>
    <method name="bindConstant" return="com.google.inject.binder.AnnotatedConstantBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see Binder#bindConstant()]]>
      </doc>
    </method>
    <method name="install"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="module" type="com.google.inject.Module"/>
      <doc>
      <![CDATA[@see Binder#install(Module)]]>
      </doc>
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <param name="arguments" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[@see Binder#addError(String, Object[])]]>
      </doc>
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[@see Binder#addError(Throwable)]]>
      </doc>
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="message" type="com.google.inject.spi.Message"/>
      <doc>
      <![CDATA[@see Binder#addError(Message)]]>
      </doc>
    </method>
    <method name="requestInjection"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="instance" type="java.lang.Object"/>
      <doc>
      <![CDATA[@see Binder#requestInjection(Object)]]>
      </doc>
    </method>
    <method name="requestStaticInjection"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="types" type="java.lang.Class[]"/>
      <doc>
      <![CDATA[@see Binder#requestStaticInjection(Class[])]]>
      </doc>
    </method>
    <method name="bindInterceptor"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="classMatcher" type="com.google.inject.matcher.Matcher&lt;? super java.lang.Class&lt;?&gt;&gt;"/>
      <param name="methodMatcher" type="com.google.inject.matcher.Matcher&lt;? super java.lang.reflect.Method&gt;"/>
      <param name="interceptors" type="org.aopalliance.intercept.MethodInterceptor[]"/>
      <doc>
      <![CDATA[@see Binder#bindInterceptor(com.google.inject.matcher.Matcher, com.google.inject.matcher.Matcher, org.aopalliance.intercept.MethodInterceptor[])]]>
      </doc>
    </method>
    <method name="requireBinding"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;?&gt;"/>
      <doc>
      <![CDATA[Instructs Guice to require a binding to the given key.]]>
      </doc>
    </method>
    <method name="requireBinding"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Instructs Guice to require a binding to the given type.]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#getProvider(Key)]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#getProvider(Class)]]>
      </doc>
    </method>
    <method name="convertToTypes"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="typeMatcher" type="com.google.inject.matcher.Matcher&lt;? super com.google.inject.TypeLiteral&lt;?&gt;&gt;"/>
      <param name="converter" type="com.google.inject.spi.TypeConverter"/>
      <doc>
      <![CDATA[@see Binder#convertToTypes(com.google.inject.matcher.Matcher, com.google.inject.spi.TypeConverter)]]>
      </doc>
    </method>
    <method name="currentStage" return="com.google.inject.Stage"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see Binder#currentStage()]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#getMembersInjector(Class)]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#getMembersInjector(TypeLiteral)]]>
      </doc>
    </method>
    <method name="bindListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="typeMatcher" type="com.google.inject.matcher.Matcher&lt;? super com.google.inject.TypeLiteral&lt;?&gt;&gt;"/>
      <param name="listener" type="com.google.inject.spi.TypeListener"/>
      <doc>
      <![CDATA[@see Binder#bindListener(com.google.inject.matcher.Matcher, com.google.inject.spi.TypeListener)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A module whose configuration information is hidden from its environment by default. Only bindings
 that are explicitly exposed will be available to other modules and to the users of the injector.
 This module may expose the bindings it creates and the bindings of the modules it installs.

 <p>A private module can be nested within a regular module or within another private module using
 {@link Binder#install install()}.  Its bindings live in a new environment that inherits bindings,
 type converters, scopes, and interceptors from the surrounding ("parent") environment.  When you
 nest multiple private modules, the result is a tree of environments where the injector's
 environment is the root.

 <p>Guice EDSL bindings can be exposed with {@link #expose(Class) expose()}. {@literal @}{@link
 com.google.inject.Provides Provides} bindings can be exposed with the {@literal @}{@link
 Exposed} annotation:

 <pre>
 public class FooBarBazModule extends PrivateModule {
   protected void configure() {
     bind(Foo.class).to(RealFoo.class);
     expose(Foo.class);

     install(new TransactionalBarModule());
     expose(Bar.class).annotatedWith(Transactional.class);

     bind(SomeImplementationDetail.class);
     install(new MoreImplementationDetailsModule());
   }

   {@literal @}Provides {@literal @}Exposed
   public Baz provideBaz() {
     return new SuperBaz();
   }
 }
 </pre>

 <p>Private modules are implemented using {@link Injector#createChildInjector(Module[]) parent
 injectors}. When it can satisfy their dependencies, just-in-time bindings will be created in the
 root environment. Such bindings are shared among all environments in the tree.
 
 <p>The scope of a binding is constrained to its environment. A singleton bound in a private
 module will be unique to its environment. But a binding for the same type in a different private
 module will yield a different instance.

 <p>A shared binding that injects the {@code Injector} gets the root injector, which only has
 access to bindings in the root environment. An explicit binding that injects the {@code Injector}
 gets access to all bindings in the child environment.

 <p>To promote a just-in-time binding to an explicit binding, bind it:
 <pre>
   bind(FooImpl.class);
 </pre>

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.PrivateModule -->
  <!-- start class com.google.inject.ProvidedBy -->
  <class name="ProvidedBy"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[A pointer to the default provider type for a type.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.ProvidedBy -->
  <!-- start interface com.google.inject.Provider -->
  <interface name="Provider"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Provides an instance of {@code T}. Must never return {@code null}.

 @throws OutOfScopeException when an attempt is made to access a scoped object while the scope
     in question is not currently active
 @throws ProvisionException if an instance cannot be provided. Such exceptions include messages
     and throwables to describe why provision failed.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object capable of providing instances of type {@code T}. Providers are used in numerous ways
 by Guice:

 <ul>
 <li>When the default means for obtaining instances (an injectable or parameterless constructor)
 is insufficient for a particular binding, the module can specify a custom {@code Provider}
 instead, to control exactly how Guice creates or obtains instances for the binding.

 <li>An implementation class may always choose to have a {@code Provider<T>} instance injected,
 rather than having a {@code T} injected directly.  This may give you access to multiple
 instances, instances you wish to safely mutate and discard, instances which are out of scope
 (e.g. using a {@code @RequestScoped} object from within a {@code @SessionScoped} object), or
 instances that will be initialized lazily.

 <li>A custom {@link Scope} is implemented as a decorator of {@code Provider<T>}, which decides
 when to delegate to the backing provider and when to provide the instance some other way.

 <li>The {@link Injector} offers access to the {@code Provider<T>} it uses to fulfill requests
 for a given key, via the {@link Injector#getProvider} methods.
 </ul>

 @param <T> the type of object this provides

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.Provider -->
  <!-- start class com.google.inject.Provides -->
  <class name="Provides"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotates methods of a {@link Module} to create a provider method binding. The method's return
 type is bound to it's returned value. Guice will pass dependencies to the method as parameters.

 @author crazybob@google.com (Bob Lee)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.Provides -->
  <!-- start class com.google.inject.ProvisionException -->
  <class name="ProvisionException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ProvisionException" type="java.lang.Iterable&lt;com.google.inject.spi.Message&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a ConfigurationException containing {@code messages}.]]>
      </doc>
    </constructor>
    <constructor name="ProvisionException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ProvisionException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getErrorMessages" return="java.util.Collection&lt;com.google.inject.spi.Message&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns messages for the errors that caused this exception.]]>
      </doc>
    </method>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Indicates that there was a runtime failure while providing an instance.

 @author kevinb@google.com (Kevin Bourrillion)
 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.ProvisionException -->
  <!-- start interface com.google.inject.Scope -->
  <interface name="Scope"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="scope" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <param name="unscoped" type="com.google.inject.Provider&lt;T&gt;"/>
      <doc>
      <![CDATA[Scopes a provider. The returned provider returns objects from this scope.
 If an object does not exist in this scope, the provider can use the given
 unscoped provider to retrieve one.

 <p>Scope implementations are strongly encouraged to override
 {@link Object#toString} in the returned provider and include the backing
 provider's {@code toString()} output.

 @param key binding key
 @param unscoped locates an instance when one doesn't already exist in this
  scope.
 @return a new provider which only delegates to the given unscoped provider
  when an instance of the requested object doesn't already exist in this
  scope]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A short but useful description of this scope.  For comparison, the standard
 scopes that ship with guice use the descriptions
 {@code "Scopes.SINGLETON"}, {@code "ServletScopes.SESSION"} and
 {@code "ServletScopes.REQUEST"}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A scope is a level of visibility that instances provided by Guice may have.
 By default, an instance created by the {@link Injector} has <i>no scope</i>,
 meaning it has no state from the framework's perspective -- the
 {@code Injector} creates it, injects it once into the class that required it,
 and then immediately forgets it. Associating a scope with a particular
 binding allows the created instance to be "remembered" and possibly used
 again for other injections.

 <p>An example of a scope is {@link Scopes#SINGLETON}.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.Scope -->
  <!-- start class com.google.inject.ScopeAnnotation -->
  <class name="ScopeAnnotation"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotates annotations which are used for scoping. Only one such annotation
 may apply to a single implementation class. You must also annotate scope
 annotations with {@code @Retention(RUNTIME)}. For example:

 <pre>
   {@code @}Retention(RUNTIME)
   {@code @}Target(TYPE)
   {@code @}ScopeAnnotation
   public {@code @}interface SessionScoped {}
 </pre>

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.ScopeAnnotation -->
  <!-- start class com.google.inject.Scopes -->
  <class name="Scopes" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <field name="SINGLETON" type="com.google.inject.Scope"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[One instance per {@link Injector}. Also see {@code @}{@link Singleton}.]]>
      </doc>
    </field>
    <field name="NO_SCOPE" type="com.google.inject.Scope"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[No scope; the same as not applying any scope at all.  Each time the
 Injector obtains an instance of an object with "no scope", it injects this
 instance then immediately forgets it.  When the next request for the same
 binding arrives it will need to obtain the instance over again.

 <p>This exists only in case a class has been annotated with a scope
 annotation such as {@link Singleton @Singleton}, and you need to override
 this to "no scope" in your binding.

 @since 2.0]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Built-in scope implementations.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.Scopes -->
  <!-- start class com.google.inject.Singleton -->
  <class name="Singleton"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Apply this to implementation classes when you want only one instance
 (per {@link Injector}) to be reused for all injections for that binding.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.Singleton -->
  <!-- start class com.google.inject.Stage -->
  <class name="Stage" extends="java.lang.Enum&lt;com.google.inject.Stage&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.inject.Stage[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.inject.Stage"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[The stage we're running in.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.Stage -->
  <!-- start class com.google.inject.TypeLiteral -->
  <class name="TypeLiteral" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="TypeLiteral"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new type literal. Derives represented class from type
 parameter.

 <p>Clients create an empty anonymous subclass. Doing so embeds the type
 parameter in the anonymous class's type hierarchy so we can reconstitute it
 at runtime despite erasure.]]>
      </doc>
    </constructor>
    <method name="getRawType" return="java.lang.Class&lt;? super T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the raw (non-generic) type for this type.
 
 @since 2.0]]>
      </doc>
    </method>
    <method name="getType" return="java.lang.reflect.Type"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets underlying {@code Type} instance.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="com.google.inject.TypeLiteral&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Gets type literal for the given {@code Type} instance.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.TypeLiteral&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Gets type literal for the given {@code Class} instance.]]>
      </doc>
    </method>
    <method name="getSupertype" return="com.google.inject.TypeLiteral&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="supertype" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns the generic form of {@code supertype}. For example, if this is {@code
 ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code
 Iterable.class}.

 @param supertype a superclass of, or interface implemented by, this.
 @since 2.0]]>
      </doc>
    </method>
    <method name="getFieldType" return="com.google.inject.TypeLiteral&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field" type="java.lang.reflect.Field"/>
      <doc>
      <![CDATA[Returns the resolved generic type of {@code field}.

 @param field a field defined by this or any superclass.
 @since 2.0]]>
      </doc>
    </method>
    <method name="getParameterTypes" return="java.util.List&lt;com.google.inject.TypeLiteral&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="methodOrConstructor" type="java.lang.reflect.Member"/>
      <doc>
      <![CDATA[Returns the resolved generic parameter types of {@code methodOrConstructor}.

 @param methodOrConstructor a method or constructor defined by this or any supertype.
 @since 2.0]]>
      </doc>
    </method>
    <method name="getExceptionTypes" return="java.util.List&lt;com.google.inject.TypeLiteral&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="methodOrConstructor" type="java.lang.reflect.Member"/>
      <doc>
      <![CDATA[Returns the resolved generic exception types thrown by {@code constructor}.

 @param methodOrConstructor a method or constructor defined by this or any supertype.
 @since 2.0]]>
      </doc>
    </method>
    <method name="getReturnType" return="com.google.inject.TypeLiteral&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="method" type="java.lang.reflect.Method"/>
      <doc>
      <![CDATA[Returns the resolved generic return type of {@code method}.

 @param method a method defined by this or any supertype.
 @since 2.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a generic type {@code T}. Java doesn't yet provide a way to
 represent generic types, so this class does. Forces clients to create a
 subclass of this class which enables retrieval the type information even at
 runtime.

 <p>For example, to create a type literal for {@code List<String>}, you can
 create an empty anonymous inner class:

 <p>
 {@code TypeLiteral<List<String>> list = new TypeLiteral<List<String>>() {};}

 <p>This syntax cannot be used to create type literals that have wildcard
 parameters, such as {@code Class<?>} or {@code List<? extends CharSequence>}.
 Such type literals must be constructed programatically, either by {@link
 Method#getGenericReturnType extracting types from members} or by using the
 {@link Types} factory class.

 <p>Along with modeling generic types, this class can resolve type parameters.
 For example, to figure out what type {@code keySet()} returns on a {@code
 Map<Integer, String>}, use this code:<pre>   {@code

   TypeLiteral<Map<Integer, String>> mapType
       = new TypeLiteral<Map<Integer, String>>() {};
   TypeLiteral<?> keySetType
       = mapType.getReturnType(Map.class.getMethod("keySet"));
   System.out.println(keySetType); // prints "Set<Integer>"}</pre>

 @author crazybob@google.com (Bob Lee)
 @author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.TypeLiteral -->
</package>
<package name="com.google.inject.assistedinject">
  <!-- start class com.google.inject.assistedinject.Assisted -->
  <class name="Assisted"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotates an injected parameter or field whose value comes from an argument to a factory method.

 @author jmourits@google.com (Jerome Mourits)
 @author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.assistedinject.Assisted -->
  <!-- start class com.google.inject.assistedinject.AssistedInject -->
  <class name="AssistedInject"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="{@link FactoryProvider} now works better with the standard {@literal @Inject}
     annotation. When using that annotation, parameters are matched by name and type rather than
     by position. In addition, values that use the standard {@literal @Inject} constructor
     annotation are eligible for method interception.">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[<p>Constructors annotated with {@code @AssistedInject} indicate that they can be instantiated by
 the {@link FactoryProvider}. Each constructor must exactly match one corresponding factory method
 within the factory interface.
 
 <p>Constructor parameters must be either supplied by the factory interface and marked with
 <code>@Assisted</code>, or they must be injectable.
 
 @deprecated {@link FactoryProvider} now works better with the standard {@literal @Inject}
     annotation. When using that annotation, parameters are matched by name and type rather than
     by position. In addition, values that use the standard {@literal @Inject} constructor
     annotation are eligible for method interception.

 @author jmourits@google.com (Jerome Mourits)
 @author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.assistedinject.AssistedInject -->
  <!-- start class com.google.inject.assistedinject.FactoryProvider -->
  <class name="FactoryProvider" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Provider&lt;F&gt;"/>
    <implements name="com.google.inject.spi.HasDependencies"/>
    <method name="newFactory" return="com.google.inject.Provider&lt;F&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="factoryType" type="java.lang.Class&lt;F&gt;"/>
      <param name="implementationType" type="java.lang.Class&lt;?&gt;"/>
    </method>
    <method name="newFactory" return="com.google.inject.Provider&lt;F&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="factoryType" type="com.google.inject.TypeLiteral&lt;F&gt;"/>
      <param name="implementationType" type="com.google.inject.TypeLiteral&lt;?&gt;"/>
    </method>
    <method name="getDependencies" return="java.util.Set&lt;com.google.inject.spi.Dependency&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="F"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Provides a factory that combines the caller's arguments with injector-supplied values to
 construct objects.

 <h3>Defining a factory</h3>
 Create an interface whose methods return the constructed type, or any of its supertypes. The
 method's parameters are the arguments required to build the constructed type.
 <pre>public interface PaymentFactory {
   Payment create(Date startDate, Money amount);
 }</pre>
 You can name your factory methods whatever you like, such as <i>create</i>, <i>createPayment</i>
 or <i>newPayment</i>.

 <h3>Creating a type that accepts factory parameters</h3>
 {@code constructedType} is a concrete class with an {@literal @}{@link Inject}-annotated
 constructor. In addition to injector-supplied parameters, the constructor should have
 parameters that match each of the factory method's parameters. Each factory-supplied parameter
 requires an {@literal @}{@link Assisted} annotation. This serves to document that the parameter
 is not bound by your application's modules.
 <pre>public class RealPayment implements Payment {
   {@literal @}Inject
   public RealPayment(
      CreditService creditService,
      AuthService authService,
      <strong>{@literal @}Assisted Date startDate</strong>,
      <strong>{@literal @}Assisted Money amount</strong>) {
     ...
   }
 }</pre>
 Any parameter that permits a null value should also be annotated {@code @Nullable}.

 <h3>Configuring factories</h3>
 In your {@link com.google.inject.Module module}, bind the factory interface to the returned
 factory:
 <pre>bind(PaymentFactory.class).toProvider(
     FactoryProvider.newFactory(PaymentFactory.class, RealPayment.class));</pre>
 As a side-effect of this binding, Guice will inject the factory to initialize it for use. The
 factory cannot be used until the injector has been initialized.

 <h3>Using the factory</h3>
 Inject your factory into your application classes. When you use the factory, your arguments
 will be combined with values from the injector to construct an instance.
 <pre>public class PaymentAction {
   {@literal @}Inject private PaymentFactory paymentFactory;

   public void doPayment(Money amount) {
     Payment payment = paymentFactory.create(new Date(), amount);
     payment.apply();
   }
 }</pre>

 <h3>Making parameter types distinct</h3>
 The types of the factory method's parameters must be distinct. To use multiple parameters of
 the same type, use a named {@literal @}{@link Assisted} annotation to disambiguate the
 parameters. The names must be applied to the factory method's parameters:

 <pre>public interface PaymentFactory {
   Payment create(
       <strong>{@literal @}Assisted("startDate")</strong> Date startDate,
       <strong>{@literal @}Assisted("dueDate")</strong> Date dueDate,
       Money amount);
 } </pre>
 ...and to the concrete type's constructor parameters:
 <pre>public class RealPayment implements Payment {
   {@literal @}Inject
   public RealPayment(
      CreditService creditService,
      AuthService authService,
      <strong>{@literal @}Assisted("startDate")</strong> Date startDate,
      <strong>{@literal @}Assisted("dueDate")</strong> Date dueDate,
      <strong>{@literal @}Assisted</strong> Money amount) {
     ...
   }
 }</pre>

 <h3>Values are created by Guice</h3>
 Returned factories use child injectors to create values. The values are eligible for method
 interception. In addition, {@literal @}{@literal Inject} members will be injected before they are
 returned.

 <h3>Backwards compatibility using {@literal @}AssistedInject</h3>
 Instead of the {@literal @}Inject annotation, you may annotate the constructed classes with
 {@literal @}{@link AssistedInject}. This triggers a limited backwards-compatability mode.

 <p>Instead of matching factory method arguments to constructor parameters using their names, the
 <strong>parameters are matched by their order</strong>. The first factory method argument is
 used for the first {@literal @}Assisted constructor parameter, etc.. Annotation names have no
 effect.

 <p>Returned values are <strong>not created by Guice</strong>. These types are not eligible for
 method interception. They do receive post-construction member injection.

 @param <F> The factory interface

 @author jmourits@google.com (Jerome Mourits)
 @author jessewilson@google.com (Jesse Wilson)
 @author dtm@google.com (Daniel Martin)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.assistedinject.FactoryProvider -->
</package>
<package name="com.google.inject.binder">
  <!-- start interface com.google.inject.binder.AnnotatedBindingBuilder -->
  <interface name="AnnotatedBindingBuilder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.binder.LinkedBindingBuilder&lt;T&gt;"/>
    <method name="annotatedWith" return="com.google.inject.binder.LinkedBindingBuilder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="annotatedWith" return="com.google.inject.binder.LinkedBindingBuilder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.binder.AnnotatedBindingBuilder -->
  <!-- start interface com.google.inject.binder.AnnotatedConstantBindingBuilder -->
  <interface name="AnnotatedConstantBindingBuilder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="annotatedWith" return="com.google.inject.binder.ConstantBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="annotatedWith" return="com.google.inject.binder.ConstantBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.binder.AnnotatedConstantBindingBuilder -->
  <!-- start interface com.google.inject.binder.AnnotatedElementBuilder -->
  <interface name="AnnotatedElementBuilder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="annotatedWith"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="annotatedWith"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.binder.AnnotatedElementBuilder -->
  <!-- start interface com.google.inject.binder.ConstantBindingBuilder -->
  <interface name="ConstantBindingBuilder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="double"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="float"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="short"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="char"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="E extends java.lang.Enum&lt;E&gt;"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Binds to a constant value.]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.binder.ConstantBindingBuilder -->
  <!-- start interface com.google.inject.binder.LinkedBindingBuilder -->
  <interface name="LinkedBindingBuilder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.binder.ScopedBindingBuilder"/>
    <method name="to" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="implementation" type="java.lang.Class&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="to" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="implementation" type="com.google.inject.TypeLiteral&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="to" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="targetKey" type="com.google.inject.Key&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="toInstance"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="T"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.

 @see com.google.inject.Injector#injectMembers]]>
      </doc>
    </method>
    <method name="toProvider" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="provider" type="com.google.inject.Provider&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.

 @see com.google.inject.Injector#injectMembers]]>
      </doc>
    </method>
    <method name="toProvider" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerType" type="java.lang.Class&lt;? extends com.google.inject.Provider&lt;? extends T&gt;&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="toProvider" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerKey" type="com.google.inject.Key&lt;? extends com.google.inject.Provider&lt;? extends T&gt;&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.binder.LinkedBindingBuilder -->
  <!-- start interface com.google.inject.binder.ScopedBindingBuilder -->
  <interface name="ScopedBindingBuilder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="in"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scopeAnnotation" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="in"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scope" type="com.google.inject.Scope"/>
      <doc>
      <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <method name="asEagerSingleton"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Instructs the {@link com.google.inject.Injector} to eagerly initialize this
 singleton-scoped binding upon creation. Useful for application
 initialization logic.  See the EDSL examples at
 {@link com.google.inject.Binder}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[See the EDSL examples at {@link com.google.inject.Binder}.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.binder.ScopedBindingBuilder -->
</package>
<package name="com.google.inject.jndi">
  <!-- start class com.google.inject.jndi.JndiIntegration -->
  <class name="JndiIntegration" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="fromJndi" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates a provider which looks up objects in JNDI using the given name.
 Example usage:

 <pre>
 bind(DataSource.class).toProvider(fromJndi(DataSource.class, "java:..."));
 </pre>]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Integrates Guice with JNDI. Requires a binding to 
 {@link javax.naming.Context}.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.jndi.JndiIntegration -->
</package>
<package name="com.google.inject.matcher">
  <!-- start class com.google.inject.matcher.AbstractMatcher -->
  <class name="AbstractMatcher" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.matcher.Matcher&lt;T&gt;"/>
    <constructor name="AbstractMatcher"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="and" return="com.google.inject.matcher.Matcher&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.inject.matcher.Matcher&lt;? super T&gt;"/>
    </method>
    <method name="or" return="com.google.inject.matcher.Matcher&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.inject.matcher.Matcher&lt;? super T&gt;"/>
    </method>
    <doc>
    <![CDATA[Implements {@code and()} and {@code or()}.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.matcher.AbstractMatcher -->
  <!-- start interface com.google.inject.matcher.Matcher -->
  <interface name="Matcher"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="matches" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="T"/>
      <doc>
      <![CDATA[Returns {@code true} if this matches {@code t}, {@code false} otherwise.]]>
      </doc>
    </method>
    <method name="and" return="com.google.inject.matcher.Matcher&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.inject.matcher.Matcher&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns a new matcher which returns {@code true} if both this and the
 given matcher return {@code true}.]]>
      </doc>
    </method>
    <method name="or" return="com.google.inject.matcher.Matcher&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.inject.matcher.Matcher&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns a new matcher which returns {@code true} if either this or the
 given matcher return {@code true}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Returns {@code true} or {@code false} for a given input.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.matcher.Matcher -->
  <!-- start class com.google.inject.matcher.Matchers -->
  <class name="Matchers" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="any" return="com.google.inject.matcher.Matcher&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a matcher which matches any input.]]>
      </doc>
    </method>
    <method name="not" return="com.google.inject.matcher.Matcher&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="com.google.inject.matcher.Matcher&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Inverts the given matcher.]]>
      </doc>
    </method>
    <method name="annotatedWith" return="com.google.inject.matcher.Matcher&lt;java.lang.reflect.AnnotatedElement&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[Returns a matcher which matches elements (methods, classes, etc.)
 with a given annotation.]]>
      </doc>
    </method>
    <method name="annotatedWith" return="com.google.inject.matcher.Matcher&lt;java.lang.reflect.AnnotatedElement&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Returns a matcher which matches elements (methods, classes, etc.)
 with a given annotation.]]>
      </doc>
    </method>
    <method name="subclassesOf" return="com.google.inject.matcher.Matcher&lt;java.lang.Class&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="superclass" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a matcher which matches subclasses of the given type (as well as
 the given type).]]>
      </doc>
    </method>
    <method name="only" return="com.google.inject.matcher.Matcher&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns a matcher which matches objects equal to the given object.]]>
      </doc>
    </method>
    <method name="identicalTo" return="com.google.inject.matcher.Matcher&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns a matcher which matches only the given object.]]>
      </doc>
    </method>
    <method name="inPackage" return="com.google.inject.matcher.Matcher&lt;java.lang.Class&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="targetPackage" type="java.lang.Package"/>
      <doc>
      <![CDATA[Returns a matcher which matches classes in the given package. Packages are specific to their
 classloader, so classes with the same package name may not have the same package at runtime.]]>
      </doc>
    </method>
    <method name="inSubpackage" return="com.google.inject.matcher.Matcher&lt;java.lang.Class&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="targetPackageName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a matcher which matches classes in the given package and its subpackages. Unlike
 {@link #inPackage(Package) inPackage()}, this matches classes from any classloader.
 
 @since 2.0]]>
      </doc>
    </method>
    <method name="returns" return="com.google.inject.matcher.Matcher&lt;java.lang.reflect.Method&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="returnType" type="com.google.inject.matcher.Matcher&lt;? super java.lang.Class&lt;?&gt;&gt;"/>
      <doc>
      <![CDATA[Returns a matcher which matches methods with matching return types.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Matcher implementations. Supports matching classes and methods.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.matcher.Matchers -->
</package>
<package name="com.google.inject.multibindings">
  <!-- start class com.google.inject.multibindings.MapBinder -->
  <class name="MapBinder" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="newMapBinder" return="com.google.inject.multibindings.MapBinder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="keyType" type="com.google.inject.TypeLiteral&lt;K&gt;"/>
      <param name="valueType" type="com.google.inject.TypeLiteral&lt;V&gt;"/>
      <doc>
      <![CDATA[Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a
 {@link Map} that is itself bound with no binding annotation.]]>
      </doc>
    </method>
    <method name="newMapBinder" return="com.google.inject.multibindings.MapBinder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="keyType" type="java.lang.Class&lt;K&gt;"/>
      <param name="valueType" type="java.lang.Class&lt;V&gt;"/>
      <doc>
      <![CDATA[Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a
 {@link Map} that is itself bound with no binding annotation.]]>
      </doc>
    </method>
    <method name="newMapBinder" return="com.google.inject.multibindings.MapBinder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="keyType" type="com.google.inject.TypeLiteral&lt;K&gt;"/>
      <param name="valueType" type="com.google.inject.TypeLiteral&lt;V&gt;"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a
 {@link Map} that is itself bound with {@code annotation}.]]>
      </doc>
    </method>
    <method name="newMapBinder" return="com.google.inject.multibindings.MapBinder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="keyType" type="java.lang.Class&lt;K&gt;"/>
      <param name="valueType" type="java.lang.Class&lt;V&gt;"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a
 {@link Map} that is itself bound with {@code annotation}.]]>
      </doc>
    </method>
    <method name="newMapBinder" return="com.google.inject.multibindings.MapBinder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="keyType" type="com.google.inject.TypeLiteral&lt;K&gt;"/>
      <param name="valueType" type="com.google.inject.TypeLiteral&lt;V&gt;"/>
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a
 {@link Map} that is itself bound with {@code annotationType}.]]>
      </doc>
    </method>
    <method name="newMapBinder" return="com.google.inject.multibindings.MapBinder&lt;K, V&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="keyType" type="java.lang.Class&lt;K&gt;"/>
      <param name="valueType" type="java.lang.Class&lt;V&gt;"/>
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a
 {@link Map} that is itself bound with {@code annotationType}.]]>
      </doc>
    </method>
    <method name="addBinding" return="com.google.inject.binder.LinkedBindingBuilder&lt;V&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <doc>
      <![CDATA[Returns a binding builder used to add a new entry in the map. Each
 key must be distinct (and non-null). Bound providers will be evaluated each
 time the map is injected.

 <p>It is an error to call this method without also calling one of the
 {@code to} methods on the returned binding builder.

 <p>Scoping elements independently is supported. Use the {@code in} method
 to specify a binding scope.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An API to bind multiple map entries separately, only to later inject them as
 a complete map. MapBinder is intended for use in your application's module:
 <pre><code>
 public class SnacksModule extends AbstractModule {
   protected void configure() {
     MapBinder&lt;String, Snack&gt; mapbinder
         = MapBinder.newMapBinder(binder(), String.class, Snack.class);
     mapbinder.addBinding("twix").toInstance(new Twix());
     mapbinder.addBinding("snickers").toProvider(SnickersProvider.class);
     mapbinder.addBinding("skittles").to(Skittles.class);
   }
 }</code></pre>

 <p>With this binding, a {@link Map}{@code <String, Snack>} can now be 
 injected:
 <pre><code>
 class SnackMachine {
   {@literal @}Inject
   public SnackMachine(Map&lt;String, Snack&gt; snacks) { ... }
 }</code></pre>
 
 <p>In addition to binding {@code Map<K, V>}, a mapbinder will also bind
 {@code Map<K, Provider<V>>} for lazy value provision:
 <pre><code>
 class SnackMachine {
   {@literal @}Inject
   public SnackMachine(Map&lt;String, Provider&lt;Snack&gt;&gt; snackProviders) { ... }
 }</code></pre>

 <p>Creating mapbindings from different modules is supported. For example, it
 is okay to have both {@code CandyModule} and {@code ChipsModule} both
 create their own {@code MapBinder<String, Snack>}, and to each contribute 
 bindings to the snacks map. When that map is injected, it will contain 
 entries from both modules.

 <p>Values are resolved at map injection time. If a value is bound to a
 provider, that provider's get method will be called each time the map is
 injected (unless the binding is also scoped, or a map of providers is injected).

 <p>Annotations are used to create different maps of the same key/value
 type. Each distinct annotation gets its own independent map.

 <p><strong>Keys must be distinct.</strong> If the same key is bound more than
 once, map injection will fail.

 <p><strong>Keys must be non-null.</strong> {@code addBinding(null)} will 
 throw an unchecked exception.

 <p><strong>Values must be non-null to use map injection.</strong> If any
 value is null, map injection will fail (although injecting a map of providers
 will not).

 @author dpb@google.com (David P. Baker)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.multibindings.MapBinder -->
  <!-- start class com.google.inject.multibindings.Multibinder -->
  <class name="Multibinder" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="newSetBinder" return="com.google.inject.multibindings.Multibinder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="type" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is
 itself bound with no binding annotation.]]>
      </doc>
    </method>
    <method name="newSetBinder" return="com.google.inject.multibindings.Multibinder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is
 itself bound with no binding annotation.]]>
      </doc>
    </method>
    <method name="newSetBinder" return="com.google.inject.multibindings.Multibinder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="type" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is
 itself bound with {@code annotation}.]]>
      </doc>
    </method>
    <method name="newSetBinder" return="com.google.inject.multibindings.Multibinder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is
 itself bound with {@code annotation}.]]>
      </doc>
    </method>
    <method name="newSetBinder" return="com.google.inject.multibindings.Multibinder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="type" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is
 itself bound with {@code annotationType}.]]>
      </doc>
    </method>
    <method name="newSetBinder" return="com.google.inject.multibindings.Multibinder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is
 itself bound with {@code annotationType}.]]>
      </doc>
    </method>
    <method name="addBinding" return="com.google.inject.binder.LinkedBindingBuilder&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a binding builder used to add a new element in the set. Each
 bound element must have a distinct value. Bound providers will be
 evaluated each time the set is injected.

 <p>It is an error to call this method without also calling one of the
 {@code to} methods on the returned binding builder.

 <p>Scoping elements independently is supported. Use the {@code in} method
 to specify a binding scope.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An API to bind multiple values separately, only to later inject them as a
 complete collection. Multibinder is intended for use in your application's
 module:
 <pre><code>
 public class SnacksModule extends AbstractModule {
   protected void configure() {
     Multibinder&lt;Snack&gt; multibinder
         = Multibinder.newSetBinder(binder(), Snack.class);
     multibinder.addBinding().toInstance(new Twix());
     multibinder.addBinding().toProvider(SnickersProvider.class);
     multibinder.addBinding().to(Skittles.class);
   }
 }</code></pre>

 <p>With this binding, a {@link Set}{@code <Snack>} can now be injected:
 <pre><code>
 class SnackMachine {
   {@literal @}Inject
   public SnackMachine(Set&lt;Snack&gt; snacks) { ... }
 }</code></pre>

 <p>Create multibindings from different modules is supported. For example, it
 is okay to have both {@code CandyModule} and {@code ChipsModule} to both
 create their own {@code Multibinder<Snack>}, and to each contribute bindings
 to the set of snacks. When that set is injected, it will contain elements
 from both modules.

 <p>Elements are resolved at set injection time. If an element is bound to a
 provider, that provider's get method will be called each time the set is
 injected (unless the binding is also scoped).

 <p>Annotations are be used to create different sets of the same element
 type. Each distinct annotation gets its own independent collection of
 elements.

 <p><strong>Elements must be distinct.</strong> If multiple bound elements
 have the same value, set injection will fail.

 <p><strong>Elements must be non-null.</strong> If any set element is null,
 set injection will fail.

 @author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.multibindings.Multibinder -->
</package>
<package name="com.google.inject.name">
  <!-- start class com.google.inject.name.Named -->
  <class name="Named"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotates named things.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.name.Named -->
  <!-- start class com.google.inject.name.Names -->
  <class name="Names" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="named" return="com.google.inject.name.Named"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates a {@link Named} annotation with {@code name} as the value.]]>
      </doc>
    </method>
    <method name="bindProperties"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="properties" type="java.util.Map&lt;java.lang.String, java.lang.String&gt;"/>
      <doc>
      <![CDATA[Creates a constant binding to {@code @Named(key)} for each entry in
 {@code properties}.]]>
      </doc>
    </method>
    <method name="bindProperties"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="properties" type="java.util.Properties"/>
      <doc>
      <![CDATA[Creates a constant binding to {@code @Named(key)} for each property. This
 method binds all properties including those inherited from 
 {@link Properties#defaults defaults}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility methods for use with {@code @}{@link Named}.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.name.Names -->
</package>
<package name="com.google.inject.servlet">
  <!-- start class com.google.inject.servlet.GuiceFilter -->
  <class name="GuiceFilter" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="GuiceFilter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="doFilter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="servletRequest" type="ServletRequest"/>
      <param name="servletResponse" type="ServletResponse"/>
      <param name="filterChain" type="FilterChain"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="ServletException" type="ServletException"/>
    </method>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filterConfig" type="FilterConfig"/>
      <exception name="ServletException" type="ServletException"/>
    </method>
    <method name="destroy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[<p>
 Apply this filter in web.xml above all other filters (typically), to all requests where you plan
  to use servlet scopes. This is also needed in order to dispatch requests to injectable filters
  and servlets:
  <pre>
  &lt;filter&gt;
    &lt;filter-name&gt;guiceFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;<b>com.google.inject.servlet.GuiceFilter</b>&lt;/filter-class&gt;
  &lt;/filter&gt;

  &lt;filter-mapping&gt;
    &lt;filter-name&gt;guiceFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;
  </pre>

 This filter must appear before every filter that makes use of Guice injection or servlet
 scopes functionality. Typically, you will only register this filter in web.xml and register
 any other filters (and servlets) using a {@link ServletModule}.

 @author crazybob@google.com (Bob Lee)
 @author dhanji@gmail.com (Dhanji R. Prasanna)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.servlet.GuiceFilter -->
  <!-- start class com.google.inject.servlet.GuiceServletContextListener -->
  <class name="GuiceServletContextListener" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="GuiceServletContextListener"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="contextInitialized"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="servletContextEvent" type="ServletContextEvent"/>
    </method>
    <method name="contextDestroyed"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="servletContextEvent" type="ServletContextEvent"/>
    </method>
    <method name="getInjector" return="com.google.inject.Injector"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Override this method to create (or otherwise obtain a reference to) your
 injector.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[As of Guice 2.0 you can still use (your subclasses of) {@code GuiceServletContextListener}
 class as a logical place to create and configure your injector. This will ensure the injector
 is created when the web application is deployed.
 
 @author Kevin Bourrillion (kevinb@google.com)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.servlet.GuiceServletContextListener -->
  <!-- start class com.google.inject.servlet.RequestParameters -->
  <class name="RequestParameters"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Apply this to field or parameters of type {@code Map<String, String[]>}
 when you want the HTTP request parameter map to be injected.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.servlet.RequestParameters -->
  <!-- start class com.google.inject.servlet.RequestScoped -->
  <class name="RequestScoped"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Apply this to implementation classes when you want one instance per request.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.servlet.RequestScoped -->
  <!-- start class com.google.inject.servlet.ServletModule -->
  <class name="ServletModule" extends="com.google.inject.AbstractModule"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ServletModule"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="configureServlets"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<h3>Servlet Mapping EDSL</h3>

 <p> Part of the EDSL builder language for configuring servlets
 and filters with guice-servlet. Think of this as an in-code replacement for web.xml.
 Filters and servlets are configured here using simple java method calls. Here is a typical
 example of registering a filter when creating your Guice injector:

 <pre>
   Guice.createInjector(..., new ServletModule() {

     {@literal @}Override
     protected void configureServlets() {
       <b>serve("*.html").with(MyServlet.class)</b>
     }
   }
 </pre>

 This registers a servlet (subclass of {@code HttpServlet}) called {@code MyServlet} to service
 any web pages ending in {@code .html}. You can also use a path-style syntax to register
 servlets:

 <pre>
       <b>serve("/my/*").with(MyServlet.class)</b>
 </pre>

 Every servlet (or filter) is required to be a singleton. If you cannot annotate the class
 directly, you should add a separate {@code bind(..).in(Singleton.class)} rule elsewhere in
 your module. Mapping a servlet that is bound under any other scope is an error.

 <p>
 <h4>Dispatch Order</h4>
 You are free to register as many servlets and filters as you like this way. They will
 be compared and dispatched in the order in which the filter methods are called:

 <pre>

   Guice.createInjector(..., new ServletModule() {

     {@literal @}Override
     protected void configureServlets() {
       filter("/*").through(MyFilter.class);
       filter("*.css").through(MyCssFilter.class);
       // etc..

       serve("*.html").with(MyServlet.class);
       serve("/my/*").with(MyServlet.class);
       // etc..
      }
    }
 </pre>
 This will traverse down the list of rules in lexical order. For example, a url
  "{@code /my/file.js}" (after it runs through the matching filters) will first
  be compared against the servlet mapping:
 
 <pre>
       serve("*.html").with(MyServlet.class);
 </pre>
 And failing that, it will descend to the next servlet mapping:

 <pre>
       serve("/my/*").with(MyServlet.class);
 </pre>

 Since this rule matches, Guice Servlet will dispatch to {@code MyServlet}. These
 two mapping rules can also be written in more compact form using varargs syntax:

 <pre>
       serve(<b>"*.html", "/my/*"</b>).with(MyServlet.class);
 </pre>
 
 This way you can map several URI patterns to the same servlet. A similar syntax is
 also available for filter mappings.

 <p>
 <h4>Regular Expressions</h4>
 You can also map servlets (or filters) to URIs using regular expressions:
 <pre>
    <b>serveRegex("(.)*ajax(.)*").with(MyAjaxServlet.class)</b>
 </pre>

 This will map any URI containing the text "ajax" in it to {@code MyAjaxServlet}. Such as:
 <ul>
 <li>http://www.google.com/ajax.html</li>
 <li>http://www.google.com/content/ajax/index</li>
 <li>http://www.google.com/it/is_totally_ajaxian</li>
 </ul>


 <h3>Initialization Parameters</h3>

 Servlets (and filters) allow you to pass in init params
 using the {@code <init-param>} tag in web.xml. You can similarly pass in parameters to
 Servlets and filters registered in Guice-servlet using a {@link java.util.Map} of parameter
 name/value pairs. For example, to initialize {@code MyServlet} with two parameters
 ({@code name="Dhanji", site="google.com"}) you could write:

 <pre>
  Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;();
  params.put("name", "Dhanji");
  params.put("site", "google.com");

  ...
      serve("/*").with(MyServlet.class, <b>params</b>)
 </pre>

 <p>
 <h3>Binding Keys</h3>

 You can also bind keys rather than classes. This lets you hide
 implementations with package-local visbility and expose them using
 only a Guice module and an annotation:

 <pre>
  ...
      filter("/*").through(<b>Key.get(Filter.class, Fave.class)</b>);
 </pre>

 Where {@code Filter.class} refers to the Servlet API interface and {@code Fave.class} is a
 custom binding annotation. Elsewhere (in one of your own modules) you can bind this
 filter's implementation:

 <pre>
   bind(Filter.class)<b>.annotatedWith(Fave.class)</b>.to(MyFilterImpl.class);
 </pre>

 See {@link com.google.inject.Binder} for more information on binding syntax.

 <p>
 <h3>Multiple Modules</h3>

 It is sometimes useful to capture servlet and filter mappings from multiple different
 modules. This is essential if you want to package and offer drop-in Guice plugins that
 provide servlet functionality.

 <p>
 Guice Servlet allows you to register several instances of {@code ServletModule} to your
 injector. The order in which these modules are installed determines the dispatch order
 of filters and the precedence order of servlets. For example, if you had two servlet modules,
 {@code RpcModule} and {@code WebServiceModule} and they each contained a filter that mapped
 to the same URI pattern, {@code "/*"}:

 <p>
 In {@code RpcModule}:
 <pre>
     filter("/*").through(RpcFilter.class);
 </pre>

 In {@code WebServiceModule}:
 <pre>
     filter("/*").through(WebServiceFilter.class);
 </pre>

 Then the order in which these filters are dispatched is determined by the order in which
 the modules are installed:

 <pre>
   <b>install(new WebServiceModule());</b>
   install(new RpcModule());
 </pre>

 In the case shown above {@code WebServiceFilter} will run first.
 
 @since 2.0]]>
      </doc>
    </method>
    <method name="filter" return="com.google.inject.servlet.ServletModule.FilterKeyBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="urlPattern" type="java.lang.String"/>
      <param name="morePatterns" type="java.lang.String[]"/>
      <doc>
      <![CDATA[@param urlPattern Any Servlet-style pattern. examples: /*, /html/*, *.html, etc.
 @since 2.0]]>
      </doc>
    </method>
    <method name="filterRegex" return="com.google.inject.servlet.ServletModule.FilterKeyBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="regex" type="java.lang.String"/>
      <param name="regexes" type="java.lang.String[]"/>
      <doc>
      <![CDATA[@param regex Any Java-style regular expression.
 @since 2.0]]>
      </doc>
    </method>
    <method name="serve" return="com.google.inject.servlet.ServletModule.ServletKeyBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="urlPattern" type="java.lang.String"/>
      <param name="morePatterns" type="java.lang.String[]"/>
      <doc>
      <![CDATA[@param urlPattern Any Servlet-style pattern. examples: /*, /html/*, *.html, etc.
 @since 2.0]]>
      </doc>
    </method>
    <method name="serveRegex" return="com.google.inject.servlet.ServletModule.ServletKeyBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="regex" type="java.lang.String"/>
      <param name="regexes" type="java.lang.String[]"/>
      <doc>
      <![CDATA[@param regex Any Java-style regular expression.
 @since 2.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Configures the servlet scopes and creates bindings for the servlet API
 objects so you can inject the request, response, session, etc.

 <p>
 You should subclass this module to register servlets and
 filters in the {@link #configureServlets()} method.

 @author crazybob@google.com (Bob Lee)
 @author dhanji@gmail.com (Dhanji R. Prasanna)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.servlet.ServletModule -->
  <!-- start interface com.google.inject.servlet.ServletModule.FilterKeyBindingBuilder -->
  <interface name="ServletModule.FilterKeyBindingBuilder"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="through"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filterKey" type="java.lang.Class&lt;? extends Filter&gt;"/>
    </method>
    <method name="through"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filterKey" type="com.google.inject.Key&lt;? extends Filter&gt;"/>
    </method>
    <method name="through"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dummyFilterClass" type="java.lang.Class&lt;? extends Filter&gt;"/>
      <param name="contextParams" type="java.util.Map&lt;java.lang.String, java.lang.String&gt;"/>
    </method>
    <method name="through"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dummyFilterClass" type="com.google.inject.Key&lt;? extends Filter&gt;"/>
      <param name="contextParams" type="java.util.Map&lt;java.lang.String, java.lang.String&gt;"/>
    </method>
    <doc>
    <![CDATA[See the EDSL examples at {@link ServletModule#configureServlets()}

 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.servlet.ServletModule.FilterKeyBindingBuilder -->
  <!-- start interface com.google.inject.servlet.ServletModule.ServletKeyBindingBuilder -->
  <interface name="ServletModule.ServletKeyBindingBuilder"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="with"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="servletKey" type="java.lang.Class&lt;? extends HttpServlet&gt;"/>
    </method>
    <method name="with"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="servletKey" type="com.google.inject.Key&lt;? extends HttpServlet&gt;"/>
    </method>
    <method name="with"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="servletKey" type="java.lang.Class&lt;? extends HttpServlet&gt;"/>
      <param name="contextParams" type="java.util.Map&lt;java.lang.String, java.lang.String&gt;"/>
    </method>
    <method name="with"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="servletKey" type="com.google.inject.Key&lt;? extends HttpServlet&gt;"/>
      <param name="contextParams" type="java.util.Map&lt;java.lang.String, java.lang.String&gt;"/>
    </method>
    <doc>
    <![CDATA[See the EDSL examples at {@link ServletModule#configureServlets()}

 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.servlet.ServletModule.ServletKeyBindingBuilder -->
  <!-- start class com.google.inject.servlet.ServletScopes -->
  <class name="ServletScopes" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <field name="REQUEST" type="com.google.inject.Scope"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP servlet request scope.]]>
      </doc>
    </field>
    <field name="SESSION" type="com.google.inject.Scope"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP session scope.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Servlet scopes.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.servlet.ServletScopes -->
  <!-- start class com.google.inject.servlet.SessionScoped -->
  <class name="SessionScoped"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Apply this to implementation classes when you want one instance per session.

 @see com.google.inject.Scopes#SINGLETON
 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.servlet.SessionScoped -->
</package>
<package name="com.google.inject.spi">
  <!-- start interface com.google.inject.spi.BindingScopingVisitor -->
  <interface name="BindingScopingVisitor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="visitEagerSingleton" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Visit an eager singleton or single instance. This scope strategy is found on both module and
 injector bindings.]]>
      </doc>
    </method>
    <method name="visitScope" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scope" type="com.google.inject.Scope"/>
      <doc>
      <![CDATA[Visit a scope instance. This scope strategy is found on both module and injector bindings.]]>
      </doc>
    </method>
    <method name="visitScopeAnnotation" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scopeAnnotation" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[Visit a scope annotation. This scope strategy is found only on module bindings. The instance
 that implements this scope is registered by {@link com.google.inject.Binder#bindScope(Class,
 Scope) Binder.bindScope()}.]]>
      </doc>
    </method>
    <method name="visitNoScoping" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Visit an unspecified or unscoped strategy. On a module, this strategy indicates that the
 injector should use scoping annotations to find a scope. On an injector, it indicates that
 no scope is applied to the binding. An unscoped binding will behave like a scoped one when it
 is linked to a scoped binding.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Visits each of the strategies used to scope an injection.

 @param <V> any type to be returned by the visit method. Use {@link Void} with
     {@code return null} if no return type is needed.
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.BindingScopingVisitor -->
  <!-- start interface com.google.inject.spi.BindingTargetVisitor -->
  <interface name="BindingTargetVisitor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.InstanceBinding&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Visit a instance binding. The same instance is returned for every injection. This target is
 found in both module and injector bindings.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ProviderInstanceBinding&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Visit a provider instance binding. The provider's {@code get} method is invoked to resolve
 injections. This target is found in both module and injector bindings.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ProviderKeyBinding&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Visit a provider key binding. To resolve injections, the provider key is first resolved, then
 that provider's {@code get} method is invoked. This target is found in both module and injector
 bindings.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.LinkedKeyBinding&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Visit a linked key binding. The other key's binding is used to resolve injections. This
 target is found in both module and injector bindings.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ExposedBinding&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Visit a binding to a key exposed from an enclosed private environment. This target is only
 found in injector bindings.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.UntargettedBinding&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Visit an untargetted binding. This target is found only on module bindings. It indicates
 that the injector should use its implicit binding strategies to resolve injections.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ConstructorBinding&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Visit a constructor binding. To resolve injections, an instance is instantiated by invoking
 {@code constructor}. This target is found only on injector bindings.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ConvertedConstantBinding&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Visit a binding created from converting a bound instance to a new type. The source binding
 has the same binding annotation but a different type. This target is found only on injector
 bindings.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ProviderBinding&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Visit a binding to a {@link com.google.inject.Provider} that delegates to the binding for the
 provided type. This target is found only on injector bindings.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Visits each of the strategies used to find an instance to satisfy an injection.

 @param <V> any type to be returned by the visit method. Use {@link Void} with
     {@code return null} if no return type is needed.
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.BindingTargetVisitor -->
  <!-- start interface com.google.inject.spi.ConstructorBinding -->
  <interface name="ConstructorBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binding&lt;T&gt;"/>
    <implements name="com.google.inject.spi.HasDependencies"/>
    <method name="getConstructor" return="com.google.inject.spi.InjectionPoint"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the constructor this binding injects.]]>
      </doc>
    </method>
    <method name="getInjectableMembers" return="java.util.Set&lt;com.google.inject.spi.InjectionPoint&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns all instance method and field injection points on {@code type}.

 @return a possibly empty set of injection points. The set has a specified iteration order. All
      fields are returned and then all methods. Within the fields, supertype fields are returned
      before subtype fields. Similarly, supertype methods are returned before subtype methods.]]>
      </doc>
    </method>
    <method name="getMethodInterceptors" return="java.util.Map&lt;java.lang.reflect.Method, java.util.List&lt;org.aopalliance.intercept.MethodInterceptor&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the interceptors applied to each method, in the order that they will be applied.

 @return a possibly empty map]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding to the constructor of a concrete clss. To resolve injections, an instance is
 instantiated by invoking the constructor.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ConstructorBinding -->
  <!-- start interface com.google.inject.spi.ConvertedConstantBinding -->
  <interface name="ConvertedConstantBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binding&lt;T&gt;"/>
    <implements name="com.google.inject.spi.HasDependencies"/>
    <method name="getValue" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the converted value.]]>
      </doc>
    </method>
    <method name="getSourceKey" return="com.google.inject.Key&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the key for the source binding. That binding can e retrieved from an injector using
 {@link com.google.inject.Injector#getBinding(Key) Injector.getBinding(key)}.]]>
      </doc>
    </method>
    <method name="getDependencies" return="java.util.Set&lt;com.google.inject.spi.Dependency&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a singleton set containing only the converted key.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding created from converting a bound instance to a new type. The source binding has the same
 binding annotation but a different type.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ConvertedConstantBinding -->
  <!-- start class com.google.inject.spi.DefaultBindingScopingVisitor -->
  <class name="DefaultBindingScopingVisitor" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.BindingScopingVisitor&lt;V&gt;"/>
    <constructor name="DefaultBindingScopingVisitor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="visitOther" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default visit implementation. Returns {@code null}.]]>
      </doc>
    </method>
    <method name="visitEagerSingleton" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="visitScope" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scope" type="com.google.inject.Scope"/>
    </method>
    <method name="visitScopeAnnotation" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scopeAnnotation" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
    </method>
    <method name="visitNoScoping" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[No-op visitor for subclassing. All interface methods simply delegate to
 {@link #visitOther()}, returning its result.

 @param <V> any type to be returned by the visit method. Use {@link Void} with
     {@code return null} if no return type is needed.
 
 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.DefaultBindingScopingVisitor -->
  <!-- start class com.google.inject.spi.DefaultBindingTargetVisitor -->
  <class name="DefaultBindingTargetVisitor" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.BindingTargetVisitor&lt;T, V&gt;"/>
    <constructor name="DefaultBindingTargetVisitor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="visitOther" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.Binding&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Default visit implementation. Returns {@code null}.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instanceBinding" type="com.google.inject.spi.InstanceBinding&lt;? extends T&gt;"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerInstanceBinding" type="com.google.inject.spi.ProviderInstanceBinding&lt;? extends T&gt;"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerKeyBinding" type="com.google.inject.spi.ProviderKeyBinding&lt;? extends T&gt;"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="linkedKeyBinding" type="com.google.inject.spi.LinkedKeyBinding&lt;? extends T&gt;"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="exposedBinding" type="com.google.inject.spi.ExposedBinding&lt;? extends T&gt;"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="untargettedBinding" type="com.google.inject.spi.UntargettedBinding&lt;? extends T&gt;"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="constructorBinding" type="com.google.inject.spi.ConstructorBinding&lt;? extends T&gt;"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="convertedConstantBinding" type="com.google.inject.spi.ConvertedConstantBinding&lt;? extends T&gt;"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerBinding" type="com.google.inject.spi.ProviderBinding&lt;? extends T&gt;"/>
    </method>
    <doc>
    <![CDATA[No-op visitor for subclassing. All interface methods simply delegate to {@link
 #visitOther(Binding)}, returning its result.

 @param <V> any type to be returned by the visit method. Use {@link Void} with
     {@code return null} if no return type is needed.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.DefaultBindingTargetVisitor -->
  <!-- start class com.google.inject.spi.DefaultElementVisitor -->
  <class name="DefaultElementVisitor" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.ElementVisitor&lt;V&gt;"/>
    <constructor name="DefaultElementVisitor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="visitOther" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="element" type="com.google.inject.spi.Element"/>
      <doc>
      <![CDATA[Default visit implementation. Returns {@code null}.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="com.google.inject.spi.Message"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.Binding&lt;T&gt;"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="interceptorBinding" type="com.google.inject.spi.InterceptorBinding"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scopeBinding" type="com.google.inject.spi.ScopeBinding"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeConverterBinding" type="com.google.inject.spi.TypeConverterBinding"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerLookup" type="com.google.inject.spi.ProviderLookup&lt;T&gt;"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="injectionRequest" type="com.google.inject.spi.InjectionRequest"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="staticInjectionRequest" type="com.google.inject.spi.StaticInjectionRequest"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="privateElements" type="com.google.inject.spi.PrivateElements"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lookup" type="com.google.inject.spi.MembersInjectorLookup&lt;T&gt;"/>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.TypeListenerBinding"/>
    </method>
    <doc>
    <![CDATA[No-op visitor for subclassing. All interface methods simply delegate to
 {@link #visitOther(Element)}, returning its result.

 @param <V> any type to be returned by the visit method. Use {@link Void} with
     {@code return null} if no return type is needed.

 @author sberlin@gmail.com (Sam Berlin)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.DefaultElementVisitor -->
  <!-- start class com.google.inject.spi.Dependency -->
  <class name="Dependency" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="com.google.inject.spi.Dependency&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns a new dependency that is not attached to an injection point. The returned dependency is
 nullable.]]>
      </doc>
    </method>
    <method name="forInjectionPoints" return="java.util.Set&lt;com.google.inject.spi.Dependency&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="injectionPoints" type="java.util.Set&lt;com.google.inject.spi.InjectionPoint&gt;"/>
      <doc>
      <![CDATA[Returns the dependencies from the given injection points.]]>
      </doc>
    </method>
    <method name="getKey" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the key to the binding that satisfies this dependency.]]>
      </doc>
    </method>
    <method name="isNullable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if null is a legal value for this dependency.]]>
      </doc>
    </method>
    <method name="getInjectionPoint" return="com.google.inject.spi.InjectionPoint"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the injection point to which this dependency belongs, or null if this dependency isn't
 attached to a particular injection point.]]>
      </doc>
    </method>
    <method name="getParameterIndex" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the index of this dependency in the injection point's parameter list, or {@code -1} if
 this dependency does not belong to a parameter list. Only method and constuctor dependencies
 are elements in a parameter list.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A variable that can be resolved by an injector.

 <p>Use {@link #get} to build a freestanding dependency, or {@link InjectionPoint} to build one
 that's attached to a constructor, method or field.

 @author crazybob@google.com (Bob Lee)
 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.Dependency -->
  <!-- start interface com.google.inject.spi.Element -->
  <interface name="Element"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an arbitrary object containing information about the "place" where this element was
 configured. Used by Guice in the production of descriptive error messages.

 <p>Tools might specially handle types they know about; {@code StackTraceElement} is a good
 example. Tools should simply call {@code toString()} on the source object if the type is
 unfamiliar.]]>
      </doc>
    </method>
    <method name="acceptVisitor" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor&lt;T&gt;"/>
      <doc>
      <![CDATA[Accepts an element visitor. Invokes the visitor method specific to this element's type.

 @param visitor to call back on]]>
      </doc>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <doc>
      <![CDATA[Writes this module element to the given binder (optional operation).

 @param binder to apply configuration element to
 @throws UnsupportedOperationException if the {@code applyTo} method is not supported by this
     element.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A core component of a module or injector.

 <p>The elements of a module can be inspected, validated and rewritten. Use {@link
 Elements#getElements(com.google.inject.Module[]) Elements.getElements()} to read the elements
 from a module, and {@link Elements#getModule(Iterable) Elements.getModule()} to rewrite them.
 This can be used for static analysis and generation of Guice modules.

 <p>The elements of an injector can be inspected and exercised. Use {@link
 com.google.inject.Injector#getBindings Injector.getBindings()} to reflect on Guice injectors.

 @author jessewilson@google.com (Jesse Wilson)
 @author crazybob@google.com (Bob Lee)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.Element -->
  <!-- start class com.google.inject.spi.Elements -->
  <class name="Elements" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Elements"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getElements" return="java.util.List&lt;com.google.inject.spi.Element&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="com.google.inject.Module[]"/>
      <doc>
      <![CDATA[Records the elements executed by {@code modules}.]]>
      </doc>
    </method>
    <method name="getElements" return="java.util.List&lt;com.google.inject.spi.Element&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stage" type="com.google.inject.Stage"/>
      <param name="modules" type="com.google.inject.Module[]"/>
      <doc>
      <![CDATA[Records the elements executed by {@code modules}.]]>
      </doc>
    </method>
    <method name="getElements" return="java.util.List&lt;com.google.inject.spi.Element&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Iterable&lt;? extends com.google.inject.Module&gt;"/>
      <doc>
      <![CDATA[Records the elements executed by {@code modules}.]]>
      </doc>
    </method>
    <method name="getElements" return="java.util.List&lt;com.google.inject.spi.Element&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stage" type="com.google.inject.Stage"/>
      <param name="modules" type="java.lang.Iterable&lt;? extends com.google.inject.Module&gt;"/>
      <doc>
      <![CDATA[Records the elements executed by {@code modules}.]]>
      </doc>
    </method>
    <method name="getModule" return="com.google.inject.Module"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="java.lang.Iterable&lt;? extends com.google.inject.spi.Element&gt;"/>
      <doc>
      <![CDATA[Returns the module composed of {@code elements}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Exposes elements of a module so they can be inspected, validated or {@link
 Element#applyTo(Binder) rewritten}.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.Elements -->
  <!-- start interface com.google.inject.spi.ElementVisitor -->
  <interface name="ElementVisitor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.Binding&lt;T&gt;"/>
      <doc>
      <![CDATA[Visit a mapping from a key (type and optional annotation) to the strategy for getting
 instances of the type.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.InterceptorBinding"/>
      <doc>
      <![CDATA[Visit a registration of interceptors for matching methods of matching classes.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.ScopeBinding"/>
      <doc>
      <![CDATA[Visit a registration of a scope annotation with the scope that implements it.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.TypeConverterBinding"/>
      <doc>
      <![CDATA[Visit a registration of type converters for matching target types.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="com.google.inject.spi.InjectionRequest"/>
      <doc>
      <![CDATA[Visit a request to inject the instance fields and methods of an instance.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="com.google.inject.spi.StaticInjectionRequest"/>
      <doc>
      <![CDATA[Visit a request to inject the static fields and methods of type.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lookup" type="com.google.inject.spi.ProviderLookup&lt;T&gt;"/>
      <doc>
      <![CDATA[Visit a lookup of the provider for a type.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lookup" type="com.google.inject.spi.MembersInjectorLookup&lt;T&gt;"/>
      <doc>
      <![CDATA[Visit a lookup of the members injector.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="com.google.inject.spi.Message"/>
      <doc>
      <![CDATA[Visit an error message and the context in which it occured.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elements" type="com.google.inject.spi.PrivateElements"/>
      <doc>
      <![CDATA[Visit a collection of configuration elements for a {@linkplain com.google.inject.PrivateBinder
 private binder}.]]>
      </doc>
    </method>
    <method name="visit" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="com.google.inject.spi.TypeListenerBinding"/>
      <doc>
      <![CDATA[Visit an injectable type listener binding.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Visit elements.

 @param <V> any type to be returned by the visit method. Use {@link Void} with
     {@code return null} if no return type is needed.
 
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ElementVisitor -->
  <!-- start interface com.google.inject.spi.ExposedBinding -->
  <interface name="ExposedBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binding&lt;T&gt;"/>
    <implements name="com.google.inject.spi.HasDependencies"/>
    <method name="getPrivateElements" return="com.google.inject.spi.PrivateElements"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the enclosed environment that holds the original binding.]]>
      </doc>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <doc>
      <![CDATA[Unsupported. Always throws {@link UnsupportedOperationException}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding to a key exposed from an enclosed private environment.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ExposedBinding -->
  <!-- start interface com.google.inject.spi.HasDependencies -->
  <interface name="HasDependencies"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getDependencies" return="java.util.Set&lt;com.google.inject.spi.Dependency&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the known dependencies for this type. If this has dependencies whose values are not
 known statically, a dependency for the {@link com.google.inject.Injector Injector} will be
 included in the returned set.
 
 @return a possibly empty set]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Implemented by {@link com.google.inject.Binding bindings}, {@link com.google.inject.Provider
 providers} and instances that expose their dependencies explicitly.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.HasDependencies -->
  <!-- start interface com.google.inject.spi.InjectionListener -->
  <interface name="InjectionListener"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="afterInjection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="injectee" type="I"/>
      <doc>
      <![CDATA[Invoked by Guice after it injects the fields and methods of instance.

 @param injectee instance that Guice injected dependencies into]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Listens for injections into instances of type {@code I}. Useful for performing further
 injections, post-injection initialization, and more.

 @author crazybob@google.com (Bob Lee)
 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.InjectionListener -->
  <!-- start class com.google.inject.spi.InjectionPoint -->
  <class name="InjectionPoint" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getMember" return="java.lang.reflect.Member"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the injected constructor, field, or method.]]>
      </doc>
    </method>
    <method name="getDependencies" return="java.util.List&lt;com.google.inject.spi.Dependency&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the dependencies for this injection point. If the injection point is for a method or
 constructor, the dependencies will correspond to that member's parameters. Field injection
 points always have a single dependency for the field itself.

 @return a possibly-empty list]]>
      </doc>
    </method>
    <method name="isOptional" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if this injection point shall be skipped if the injector cannot resolve bindings
 for all required dependencies. Both explicit bindings (as specified in a module), and implicit
 bindings ({@literal @}{@link com.google.inject.ImplementedBy ImplementedBy}, default
 constructors etc.) may be used to satisfy optional injection points.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="forConstructorOf" return="com.google.inject.spi.InjectionPoint"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a new injection point for the injectable constructor of {@code type}.

 @param type a concrete type with exactly one constructor annotated {@literal @}{@link Inject},
     or a no-arguments constructor that is not private.
 @throws ConfigurationException if there is no injectable constructor, more than one injectable
     constructor, or if parameters of the injectable constructor are malformed, such as a
     parameter with multiple binding annotations.]]>
      </doc>
    </method>
    <method name="forConstructorOf" return="com.google.inject.spi.InjectionPoint"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a new injection point for the injectable constructor of {@code type}.

 @param type a concrete type with exactly one constructor annotated {@literal @}{@link Inject},
     or a no-arguments constructor that is not private.
 @throws ConfigurationException if there is no injectable constructor, more than one injectable
     constructor, or if parameters of the injectable constructor are malformed, such as a
     parameter with multiple binding annotations.]]>
      </doc>
    </method>
    <method name="forStaticMethodsAndFields" return="java.util.Set&lt;com.google.inject.spi.InjectionPoint&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral"/>
      <doc>
      <![CDATA[Returns all static method and field injection points on {@code type}.

 @return a possibly empty set of injection points. The set has a specified iteration order. All
      fields are returned and then all methods. Within the fields, supertype fields are returned
      before subtype fields. Similarly, supertype methods are returned before subtype methods.
 @throws ConfigurationException if there is a malformed injection point on {@code type}, such as
      a field with multiple binding annotations. The exception's {@link
      ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>}
      of the valid injection points.]]>
      </doc>
    </method>
    <method name="forStaticMethodsAndFields" return="java.util.Set&lt;com.google.inject.spi.InjectionPoint&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns all static method and field injection points on {@code type}.

 @return a possibly empty set of injection points. The set has a specified iteration order. All
      fields are returned and then all methods. Within the fields, supertype fields are returned
      before subtype fields. Similarly, supertype methods are returned before subtype methods.
 @throws ConfigurationException if there is a malformed injection point on {@code type}, such as
      a field with multiple binding annotations. The exception's {@link
      ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>}
      of the valid injection points.]]>
      </doc>
    </method>
    <method name="forInstanceMethodsAndFields" return="java.util.Set&lt;com.google.inject.spi.InjectionPoint&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns all instance method and field injection points on {@code type}.

 @return a possibly empty set of injection points. The set has a specified iteration order. All
      fields are returned and then all methods. Within the fields, supertype fields are returned
      before subtype fields. Similarly, supertype methods are returned before subtype methods.
 @throws ConfigurationException if there is a malformed injection point on {@code type}, such as
      a field with multiple binding annotations. The exception's {@link
      ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>}
      of the valid injection points.]]>
      </doc>
    </method>
    <method name="forInstanceMethodsAndFields" return="java.util.Set&lt;com.google.inject.spi.InjectionPoint&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns all instance method and field injection points on {@code type}.

 @return a possibly empty set of injection points. The set has a specified iteration order. All
      fields are returned and then all methods. Within the fields, supertype fields are returned
      before subtype fields. Similarly, supertype methods are returned before subtype methods.
 @throws ConfigurationException if there is a malformed injection point on {@code type}, such as
      a field with multiple binding annotations. The exception's {@link
      ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>}
      of the valid injection points.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A constructor, field or method that can receive injections. Typically this is a member with the
 {@literal @}{@link Inject} annotation. For non-private, no argument constructors, the member may
 omit the annotation. 

 @author crazybob@google.com (Bob Lee)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.InjectionPoint -->
  <!-- start class com.google.inject.spi.InjectionRequest -->
  <class name="InjectionRequest" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <constructor name="InjectionRequest" type="java.lang.Object, com.google.inject.TypeLiteral&lt;T&gt;, T"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getInstance" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getType" return="com.google.inject.TypeLiteral&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getInjectionPoints" return="java.util.Set&lt;com.google.inject.spi.InjectionPoint&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ConfigurationException" type="com.google.inject.ConfigurationException"/>
      <doc>
      <![CDATA[Returns the instance methods and fields of {@code instance} that will be injected to fulfill
 this request.

 @return a possibly empty set of injection points. The set has a specified iteration order. All
      fields are returned and then all methods. Within the fields, supertype fields are returned
      before subtype fields. Similarly, supertype methods are returned before subtype methods.
 @throws ConfigurationException if there is a malformed injection point on the class of {@code
      instance}, such as a field with multiple binding annotations. The exception's {@link
      ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>}
      of the valid injection points.]]>
      </doc>
    </method>
    <method name="acceptVisitor" return="R"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor&lt;R&gt;"/>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <doc>
    <![CDATA[A request to inject the instance fields and methods of an instance. Requests are created
 explicitly in a module using {@link com.google.inject.Binder#requestInjection(Object)
 requestInjection()} statements:
 <pre>
     requestInjection(serviceInstance);</pre>

 @author mikeward@google.com (Mike Ward)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.InjectionRequest -->
  <!-- start interface com.google.inject.spi.InstanceBinding -->
  <interface name="InstanceBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binding&lt;T&gt;"/>
    <implements name="com.google.inject.spi.HasDependencies"/>
    <method name="getInstance" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the user-supplied instance.]]>
      </doc>
    </method>
    <method name="getInjectionPoints" return="java.util.Set&lt;com.google.inject.spi.InjectionPoint&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the field and method injection points of the instance, injected at injector-creation
 time only.

 @return a possibly empty set]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding to a single instance. The same instance is returned for every injection.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.InstanceBinding -->
  <!-- start class com.google.inject.spi.InterceptorBinding -->
  <class name="InterceptorBinding" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getClassMatcher" return="com.google.inject.matcher.Matcher&lt;? super java.lang.Class&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMethodMatcher" return="com.google.inject.matcher.Matcher&lt;? super java.lang.reflect.Method&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getInterceptors" return="java.util.List&lt;MethodInterceptor&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="acceptVisitor" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor&lt;T&gt;"/>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <doc>
    <![CDATA[Registration of interceptors for matching methods of matching classes. Instances are created
 explicitly in a module using {@link com.google.inject.Binder#bindInterceptor(
 Matcher, Matcher, MethodInterceptor[]) bindInterceptor()} statements:
 <pre>
     bindInterceptor(Matchers.subclassesOf(MyAction.class),
         Matchers.annotatedWith(Transactional.class),
         new MyTransactionInterceptor());</pre>

 or from an injectable type listener using {@link TypeEncounter#bindInterceptor(Matcher,
 org.aopalliance.intercept.MethodInterceptor[]) TypeEncounter.bindInterceptor()}.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.InterceptorBinding -->
  <!-- start interface com.google.inject.spi.LinkedKeyBinding -->
  <interface name="LinkedKeyBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binding&lt;T&gt;"/>
    <method name="getLinkedKey" return="com.google.inject.Key&lt;? extends T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the linked key used to resolve injections. That binding can be retrieved from an
 injector using {@link com.google.inject.Injector#getBinding(Key) Injector.getBinding(key)}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding to a linked key. The other key's binding is used to resolve injections.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.LinkedKeyBinding -->
  <!-- start class com.google.inject.spi.MembersInjectorLookup -->
  <class name="MembersInjectorLookup" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <constructor name="MembersInjectorLookup" type="java.lang.Object, com.google.inject.TypeLiteral&lt;T&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getType" return="com.google.inject.TypeLiteral&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the type containing the members to be injected.]]>
      </doc>
    </method>
    <method name="acceptVisitor" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor&lt;T&gt;"/>
    </method>
    <method name="initializeDelegate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="com.google.inject.MembersInjector&lt;T&gt;"/>
      <doc>
      <![CDATA[Sets the actual members injector.

 @throws IllegalStateException if the delegate is already set]]>
      </doc>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="getDelegate" return="com.google.inject.MembersInjector&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the delegate members injector, or {@code null} if it has not yet been initialized.
 The delegate will be initialized when this element is processed, or otherwise used to create
 an injector.]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the looked up members injector. The result is not valid until this lookup has been
 initialized, which usually happens when the injector is created. The members injector will
 throw an {@code IllegalStateException} if you try to use it beforehand.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A lookup of the members injector for a type. Lookups are created explicitly in a module using
 {@link com.google.inject.Binder#getMembersInjector(Class) getMembersInjector()} statements:
 <pre>
     MembersInjector&lt;PaymentService&gt; membersInjector
         = getMembersInjector(PaymentService.class);</pre>

 @author crazybob@google.com (Bob Lee)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.MembersInjectorLookup -->
  <!-- start class com.google.inject.spi.Message -->
  <class name="Message" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <implements name="com.google.inject.spi.Element"/>
    <constructor name="Message" type="java.util.List&lt;java.lang.Object&gt;, java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 2.0]]>
      </doc>
    </constructor>
    <constructor name="Message" type="java.lang.Object, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Message" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSource" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSources" return="java.util.List&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 2.0]]>
      </doc>
    </method>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the error message text.]]>
      </doc>
    </method>
    <method name="acceptVisitor" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor&lt;T&gt;"/>
      <doc>
      <![CDATA[@since 2.0]]>
      </doc>
    </method>
    <method name="getCause" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the throwable that caused this message, or {@code null} if this
 message was not caused by a throwable.

 @since 2.0]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <doc>
      <![CDATA[@since 2.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An error message and the context in which it occured. Messages are usually created internally by
 Guice and its extensions. Messages can be created explicitly in a module using {@link
 com.google.inject.Binder#addError(Throwable) addError()} statements:
 <pre>
     try {
       bindPropertiesFromFile();
     } catch (IOException e) {
       addError(e);
     }</pre>

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.Message -->
  <!-- start interface com.google.inject.spi.PrivateElements -->
  <interface name="PrivateElements"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <method name="getElements" return="java.util.List&lt;com.google.inject.spi.Element&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the configuration information in this private environment.]]>
      </doc>
    </method>
    <method name="getInjector" return="com.google.inject.Injector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the child injector that hosts these private elements, or null if the elements haven't
 been used to create an injector.]]>
      </doc>
    </method>
    <method name="getExposedKeys" return="java.util.Set&lt;com.google.inject.Key&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the unique exposed keys for these private elements.]]>
      </doc>
    </method>
    <method name="getExposedSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns an arbitrary object containing information about the "place" where this key was
 exposed. Used by Guice in the production of descriptive error messages.

 <p>Tools might specially handle types they know about; {@code StackTraceElement} is a good
 example. Tools should simply call {@code toString()} on the source object if the type is
 unfamiliar.

 @param key one of the keys exposed by this module.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A private collection of elements that are hidden from the enclosing injector or module by
 default. See {@link com.google.inject.PrivateModule PrivateModule} for details.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.PrivateElements -->
  <!-- start interface com.google.inject.spi.ProviderBinding -->
  <interface name="ProviderBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binding&lt;T&gt;"/>
    <method name="getProvidedKey" return="com.google.inject.Key&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the key whose binding is used to {@link Provider#get provide instances}. That binding
 can be retrieved from an injector using {@link com.google.inject.Injector#getBinding(Key)
 Injector.getBinding(providedKey)}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding to a {@link Provider} that delegates to the binding for the provided type. This binding
 is used whenever a {@code Provider<T>} is injected (as opposed to injecting {@code T} directly).

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ProviderBinding -->
  <!-- start interface com.google.inject.spi.ProviderInstanceBinding -->
  <interface name="ProviderInstanceBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binding&lt;T&gt;"/>
    <implements name="com.google.inject.spi.HasDependencies"/>
    <method name="getProviderInstance" return="com.google.inject.Provider&lt;? extends T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the user-supplied, unscoped provider.]]>
      </doc>
    </method>
    <method name="getInjectionPoints" return="java.util.Set&lt;com.google.inject.spi.InjectionPoint&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the field and method injection points of the provider, injected at injector-creation
 time only.

 @return a possibly empty set]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding to a provider instance. The provider's {@code get} method is invoked to resolve
 injections.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ProviderInstanceBinding -->
  <!-- start interface com.google.inject.spi.ProviderKeyBinding -->
  <interface name="ProviderKeyBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binding&lt;T&gt;"/>
    <method name="getProviderKey" return="com.google.inject.Key&lt;? extends com.google.inject.Provider&lt;? extends T&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the key used to resolve the provider's binding. That binding can be retrieved from an
 injector using {@link com.google.inject.Injector#getBinding(Key)
 Injector.getBinding(providerKey)}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A binding to a provider key. To resolve injections, the provider key is first resolved, then that
 provider's {@code get} method is invoked.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ProviderKeyBinding -->
  <!-- start class com.google.inject.spi.ProviderLookup -->
  <class name="ProviderLookup" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <constructor name="ProviderLookup" type="java.lang.Object, com.google.inject.Key&lt;T&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getKey" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="acceptVisitor" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor&lt;T&gt;"/>
    </method>
    <method name="initializeDelegate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegate" type="com.google.inject.Provider&lt;T&gt;"/>
      <doc>
      <![CDATA[Sets the actual provider.

 @throws IllegalStateException if the delegate is already set]]>
      </doc>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="getDelegate" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the delegate provider, or {@code null} if it has not yet been initialized. The delegate
 will be initialized when this element is processed, or otherwise used to create an injector.]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the looked up provider. The result is not valid until this lookup has been initialized,
 which usually happens when the injector is created. The provider will throw an {@code
 IllegalStateException} if you try to use it beforehand.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A lookup of the provider for a type. Lookups are created explicitly in a module using
 {@link com.google.inject.Binder#getProvider(Class) getProvider()} statements:
 <pre>
     Provider&lt;PaymentService&gt; paymentServiceProvider
         = getProvider(PaymentService.class);</pre>

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.ProviderLookup -->
  <!-- start interface com.google.inject.spi.ProviderWithDependencies -->
  <interface name="ProviderWithDependencies"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Provider&lt;T&gt;"/>
    <implements name="com.google.inject.spi.HasDependencies"/>
    <doc>
    <![CDATA[A provider with dependencies on other injected types. If a {@link Provider} has dependencies that
 aren't specified in injections, this interface should be used to expose all dependencies.

 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.ProviderWithDependencies -->
  <!-- start class com.google.inject.spi.ScopeBinding -->
  <class name="ScopeBinding" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getAnnotationType" return="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getScope" return="com.google.inject.Scope"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="acceptVisitor" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor&lt;T&gt;"/>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <doc>
    <![CDATA[Registration of a scope annotation with the scope that implements it. Instances are created
 explicitly in a module using {@link com.google.inject.Binder#bindScope(Class, Scope) bindScope()}
 statements:
 <pre>
     Scope recordScope = new RecordScope();
     bindScope(RecordScoped.class, new RecordScope());</pre>

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.ScopeBinding -->
  <!-- start class com.google.inject.spi.StaticInjectionRequest -->
  <class name="StaticInjectionRequest" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getType" return="java.lang.Class&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getInjectionPoints" return="java.util.Set&lt;com.google.inject.spi.InjectionPoint&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ConfigurationException" type="com.google.inject.ConfigurationException"/>
      <doc>
      <![CDATA[Returns the static methods and fields of {@code type} that will be injected to fulfill this
 request.

 @return a possibly empty set of injection points. The set has a specified iteration order. All
      fields are returned and then all methods. Within the fields, supertype fields are returned
      before subtype fields. Similarly, supertype methods are returned before subtype methods.
 @throws ConfigurationException if there is a malformed injection point on {@code type}, such as
      a field with multiple binding annotations. The exception's {@link
      ConfigurationException#getPartialValue() partial value} is a {@code Set<InjectionPoint>}
      of the valid injection points.]]>
      </doc>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="acceptVisitor" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor&lt;T&gt;"/>
    </method>
    <doc>
    <![CDATA[A request to inject the static fields and methods of a type. Requests are created
 explicitly in a module using {@link com.google.inject.Binder#requestStaticInjection(Class[])
 requestStaticInjection()} statements:
 <pre>
     requestStaticInjection(MyLegacyService.class);</pre>

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.StaticInjectionRequest -->
  <!-- start interface com.google.inject.spi.TypeConverter -->
  <interface name="TypeConverter"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="convert" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <param name="toType" type="com.google.inject.TypeLiteral&lt;?&gt;"/>
      <doc>
      <![CDATA[Converts a string value. Throws an exception if a conversion error occurs.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Converts constant string values to a different type.

 @author crazybob@google.com (Bob Lee)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.TypeConverter -->
  <!-- start class com.google.inject.spi.TypeConverterBinding -->
  <class name="TypeConverterBinding" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTypeMatcher" return="com.google.inject.matcher.Matcher&lt;? super com.google.inject.TypeLiteral&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTypeConverter" return="com.google.inject.spi.TypeConverter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="acceptVisitor" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor&lt;T&gt;"/>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <doc>
    <![CDATA[Registration of type converters for matching target types. Instances are created
 explicitly in a module using {@link com.google.inject.Binder#convertToTypes(Matcher,
 TypeConverter) convertToTypes()} statements:
 <pre>
     convertToTypes(Matchers.only(DateTime.class), new DateTimeConverter());</pre>

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.TypeConverterBinding -->
  <!-- start interface com.google.inject.spi.TypeEncounter -->
  <interface name="TypeEncounter"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <param name="arguments" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Records an error message for type {@code I} which will be presented to the user at a later
 time. Unlike throwing an exception, this enable us to continue configuring the Injector and
 discover more errors. Uses {@link String#format(String, Object[])} to insert the arguments
 into the message.]]>
      </doc>
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Records an exception for type {@code I}, the full details of which will be logged, and the
 message of which will be presented to the user at a later time. If your type listener calls
 something that you worry may fail, you should catch the exception and pass it to this method.]]>
      </doc>
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="com.google.inject.spi.Message"/>
      <doc>
      <![CDATA[Records an error message to be presented to the user at a later time.]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the provider used to obtain instances for the given injection key. The returned
 provider will not be valid until the injector has been created. The provider will throw an
 {@code IllegalStateException} if you try to use it beforehand.]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the provider used to obtain instances for the given injection type. The returned
 provider will not be valid until the injetor has been created. The provider will throw an
 {@code IllegalStateException} if you try to use it beforehand.]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the members injector used to inject dependencies into methods and fields on instances
 of the given type {@code T}. The returned members injector will not be valid until the main
 injector has been created. The members injector will throw an {@code IllegalStateException}
 if you try to use it beforehand.

 @param typeLiteral type to get members injector for]]>
      </doc>
    </method>
    <method name="getMembersInjector" return="com.google.inject.MembersInjector&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Returns the members injector used to inject dependencies into methods and fields on instances
 of the given type {@code T}. The returned members injector will not be valid until the main
 injector has been created. The members injector will throw an {@code IllegalStateException}
 if you try to use it beforehand.

 @param type type to get members injector for]]>
      </doc>
    </method>
    <method name="register"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="membersInjector" type="com.google.inject.MembersInjector&lt;? super I&gt;"/>
      <doc>
      <![CDATA[Registers a members injector for type {@code I}. Guice will use the members injector after its
 performed its own injections on an instance of {@code I}.]]>
      </doc>
    </method>
    <method name="register"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="com.google.inject.spi.InjectionListener&lt;? super I&gt;"/>
      <doc>
      <![CDATA[Registers an injection listener for type {@code I}. Guice will notify the listener after all
 injections have been performed on an instance of {@code I}.]]>
      </doc>
    </method>
    <method name="bindInterceptor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="methodMatcher" type="com.google.inject.matcher.Matcher&lt;? super java.lang.reflect.Method&gt;"/>
      <param name="interceptors" type="org.aopalliance.intercept.MethodInterceptor[]"/>
      <doc>
      <![CDATA[Binds method interceptor[s] to methods matched in type {@code I} and its supertypes. A
 method is eligible for interception if:

 <ul>
  <li>Guice created the instance the method is on</li>
  <li>Neither the enclosing type nor the method is final</li>
  <li>And the method is package-private or more accessible</li>
 </ul>

 @param methodMatcher matches methods the interceptor should apply to. For
     example: {@code annotatedWith(Transactional.class)}.
 @param interceptors to bind]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Context of an injectable type encounter. Enables reporting errors, registering injection
 listeners and binding method interceptors for injectable type {@code I}. It is an error to use
 an encounter after the {@link TypeListener#hear(TypeLiteral, TypeEncounter) hear()} method has
 returned.

 @param <I> the injectable type encountered
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.TypeEncounter -->
  <!-- start interface com.google.inject.spi.TypeListener -->
  <interface name="TypeListener"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="hear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral&lt;I&gt;"/>
      <param name="encounter" type="com.google.inject.spi.TypeEncounter&lt;I&gt;"/>
      <doc>
      <![CDATA[Invoked when Guice encounters a new type eligible for constructor or members injection.
 Called during injector creation (or afterwords if Guice encounters a type at run time and
 creates a JIT binding).

 @param type encountered by Guice
 @param encounter context of this encounter, enables reporting errors, registering injection
     listeners and binding method interceptors for {@code type}.

 @param <I> the injectable type]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Listens for Guice to encounter injectable types. If a given type has its constructor injected in
 one situation but only its methods and fields injected in another, Guice will notify this
 listener once.

 <p>Useful for extra type checking, {@linkplain TypeEncounter#register(InjectionListener)
 registering injection listeners}, and {@linkplain TypeEncounter#bindInterceptor(
 com.google.inject.matcher.Matcher, org.aopalliance.intercept.MethodInterceptor[])
 binding method interceptors}.
 
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.TypeListener -->
  <!-- start class com.google.inject.spi.TypeListenerBinding -->
  <class name="TypeListenerBinding" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.spi.Element"/>
    <method name="getListener" return="com.google.inject.spi.TypeListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the registered listener.]]>
      </doc>
    </method>
    <method name="getTypeMatcher" return="com.google.inject.matcher.Matcher&lt;? super com.google.inject.TypeLiteral&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the type matcher which chooses which types the listener should be notified of.]]>
      </doc>
    </method>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="acceptVisitor" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.google.inject.spi.ElementVisitor&lt;T&gt;"/>
    </method>
    <method name="applyTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <doc>
    <![CDATA[Binds types (picked using a Matcher) to an type listener. Registrations are created explicitly in
 a module using {@link com.google.inject.Binder#bindListener(Matcher, TypeListener)} statements:

 <pre>
     register(only(new TypeLiteral&lt;PaymentService&lt;CreditCard>>() {}), listener);</pre>

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.TypeListenerBinding -->
  <!-- start interface com.google.inject.spi.UntargettedBinding -->
  <interface name="UntargettedBinding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Binding&lt;T&gt;"/>
    <doc>
    <![CDATA[An untargetted binding. This binding indicates that the injector should use its implicit binding
 strategies to resolve injections.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.UntargettedBinding -->
</package>
<package name="com.google.inject.spring">
  <!-- start class com.google.inject.spring.SpringIntegration -->
  <class name="SpringIntegration" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="fromSpring" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates a provider which looks up objects from Spring using the given name.
 Expects a binding to {@link
 org.springframework.beans.factory.BeanFactory}. Example usage:

 <pre>
 bind(DataSource.class)
   .toProvider(fromSpring(DataSource.class, "dataSource"));
 </pre>]]>
      </doc>
    </method>
    <method name="bindAll"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="beanFactory" type="ListableBeanFactory"/>
      <doc>
      <![CDATA[Binds all Spring beans from the given factory by name. For a Spring bean
 named "foo", this method creates a binding to the bean's type and
 {@code @Named("foo")}.

 @see com.google.inject.name.Named
 @see com.google.inject.name.Names#named(String)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Integrates Guice with Spring.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spring.SpringIntegration -->
</package>
<package name="com.google.inject.struts2">
  <!-- start class com.google.inject.struts2.GuiceObjectFactory -->
  <class name="GuiceObjectFactory" extends="ObjectFactory"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="GuiceObjectFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isNoArgConstructorRequired" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getClassInstance" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="ClassNotFoundException" type="java.lang.ClassNotFoundException"/>
    </method>
    <method name="buildBean" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class"/>
      <param name="extraContext" type="java.util.Map"/>
    </method>
    <method name="buildInterceptor" return="Interceptor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="interceptorConfig" type="InterceptorConfig"/>
      <param name="interceptorRefParams" type="java.util.Map"/>
      <exception name="ConfigurationException" type="ConfigurationException"/>
    </method>
  </class>
  <!-- end class com.google.inject.struts2.GuiceObjectFactory -->
</package>
<package name="com.google.inject.throwingproviders">
  <!-- start interface com.google.inject.throwingproviders.ThrowingProvider -->
  <interface name="ThrowingProvider"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <doc>
    <![CDATA[Alternative to the Guice {@link com.google.inject.Provider} that throws
 a checked Exception. Users may not inject {@code T} directly.

 <p>This interface must be extended to use application-specific exception types.
 Such subinterfaces may not define new methods:
 <pre>
 public interface RemoteProvider&lt;T&gt; extends ThrowingProvider&lt;T, RemoteException&gt; { }
 </pre>

 <p>When this type is bound using {@link ThrowingProviderBinder}, the value returned
 or exception thrown by {@link #get} will be scoped. As a consequence, {@link #get}
 will invoked at most once within each scope.

 @author jmourits@google.com (Jerome Mourits)
 @author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.throwingproviders.ThrowingProvider -->
  <!-- start class com.google.inject.throwingproviders.ThrowingProviderBinder -->
  <class name="ThrowingProviderBinder" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="create" return="com.google.inject.throwingproviders.ThrowingProviderBinder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
    </method>
    <method name="bind" return="com.google.inject.throwingproviders.ThrowingProviderBinder.SecondaryBinder&lt;P&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="interfaceType" type="java.lang.Class&lt;P&gt;"/>
      <param name="valueType" type="java.lang.reflect.Type"/>
    </method>
    <doc>
    <![CDATA[<p>Builds a binding for a {@link ThrowingProvider} using a fluent API:
 <pre><code>ThrowingProviderBinder.create(binder())
    .bind(RemoteProvider.class, Customer.class)
    .to(RemoteCustomerProvider.class)
    .in(RequestScope.class);
 </code></pre>
 
 @author jmourits@google.com (Jerome Mourits)
 @author jessewilson@google.com (Jesse Wilson)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.throwingproviders.ThrowingProviderBinder -->
  <!-- start class com.google.inject.throwingproviders.ThrowingProviderBinder.SecondaryBinder -->
  <class name="ThrowingProviderBinder.SecondaryBinder" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ThrowingProviderBinder.SecondaryBinder" type="java.lang.Class&lt;P&gt;, java.lang.reflect.Type"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="annotatedWith" return="com.google.inject.throwingproviders.ThrowingProviderBinder.SecondaryBinder&lt;P&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
    </method>
    <method name="annotatedWith" return="com.google.inject.throwingproviders.ThrowingProviderBinder.SecondaryBinder&lt;P&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotation" type="java.lang.annotation.Annotation"/>
    </method>
    <method name="to" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="P extends com.google.inject.throwingproviders.ThrowingProvider"/>
    </method>
    <method name="to" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="targetType" type="java.lang.Class&lt;? extends P&gt;"/>
    </method>
    <method name="to" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="targetKey" type="com.google.inject.Key&lt;? extends P&gt;"/>
    </method>
  </class>
  <!-- end class com.google.inject.throwingproviders.ThrowingProviderBinder.SecondaryBinder -->
</package>
<package name="com.google.inject.tools.jmx">
  <!-- start interface com.google.inject.tools.jmx.ManagedBindingMBean -->
  <interface name="ManagedBindingMBean"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getSource" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the source of this binding.]]>
      </doc>
    </method>
    <method name="getProvider" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the provider to which this binding is bound.]]>
      </doc>
    </method>
    <method name="getKey" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the binding key.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[JMX interface to bindings.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.tools.jmx.ManagedBindingMBean -->
  <!-- start class com.google.inject.tools.jmx.Manager -->
  <class name="Manager" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Manager"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="manage"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="domain" type="java.lang.String"/>
      <param name="injector" type="com.google.inject.Injector"/>
      <doc>
      <![CDATA[Registers all the bindings of an Injector with the platform MBean server.
 Consider using the name of your root {@link Module} class as the domain.]]>
      </doc>
    </method>
    <method name="manage"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="server" type="javax.management.MBeanServer"/>
      <param name="domain" type="java.lang.String"/>
      <param name="injector" type="com.google.inject.Injector"/>
      <doc>
      <![CDATA[Registers all the bindings of an Injector with the given MBean server.
 Consider using the name of your root {@link Module} class as the domain.]]>
      </doc>
    </method>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Run with no arguments for usage instructions.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides a JMX interface to Guice.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.tools.jmx.Manager -->
</package>
<package name="com.google.inject.util">
  <!-- start class com.google.inject.util.Modules -->
  <class name="Modules" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="override" return="com.google.inject.util.Modules.OverriddenModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="com.google.inject.Module[]"/>
      <doc>
      <![CDATA[Returns a builder that creates a module that overlays override modules over the given
 modules. If a key is bound in both sets of modules, only the binding from the override modules
 is kept. This can be used to replace the bindings of a production module with test bindings:
 <pre>
 Module functionalTestModule
     = Modules.override(new ProductionModule()).with(new TestModule());
 </pre>

 <p>Prefer to write smaller modules that can be reused and tested without overrides.

 @param modules the modules whose bindings are open to be overridden]]>
      </doc>
    </method>
    <method name="override" return="com.google.inject.util.Modules.OverriddenModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Iterable&lt;? extends com.google.inject.Module&gt;"/>
      <doc>
      <![CDATA[Returns a builder that creates a module that overlays override modules over the given
 modules. If a key is bound in both sets of modules, only the binding from the override modules
 is kept. This can be used to replace the bindings of a production module with test bindings:
 <pre>
 Module functionalTestModule
     = Modules.override(getProductionModules()).with(getTestModules());
 </pre>

 <p>Prefer to write smaller modules that can be reused and tested without overrides.

 @param modules the modules whose bindings are open to be overridden]]>
      </doc>
    </method>
    <method name="combine" return="com.google.inject.Module"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="com.google.inject.Module[]"/>
      <doc>
      <![CDATA[Returns a new module that installs all of {@code modules}.]]>
      </doc>
    </method>
    <method name="combine" return="com.google.inject.Module"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Iterable&lt;? extends com.google.inject.Module&gt;"/>
      <doc>
      <![CDATA[Returns a new module that installs all of {@code modules}.]]>
      </doc>
    </method>
    <field name="EMPTY_MODULE" type="com.google.inject.Module"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Static utility methods for creating and working with instances of {@link Module}.

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.util.Modules -->
  <!-- start interface com.google.inject.util.Modules.OverriddenModuleBuilder -->
  <interface name="Modules.OverriddenModuleBuilder"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="with" return="com.google.inject.Module"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="overrides" type="com.google.inject.Module[]"/>
      <doc>
      <![CDATA[See the EDSL example at {@link Modules#override(Module[]) override()}.]]>
      </doc>
    </method>
    <method name="with" return="com.google.inject.Module"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="overrides" type="java.lang.Iterable&lt;? extends com.google.inject.Module&gt;"/>
      <doc>
      <![CDATA[See the EDSL example at {@link Modules#override(Module[]) override()}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[See the EDSL example at {@link Modules#override(Module[]) override()}.]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.util.Modules.OverriddenModuleBuilder -->
  <!-- start class com.google.inject.util.Providers -->
  <class name="Providers" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="of" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="T"/>
      <doc>
      <![CDATA[Returns a provider which always provides {@code instance}.  This should not
 be necessary to use in your application, but is helpful for several types
 of unit tests.

 @param instance the instance that should always be provided.  This is also
     permitted to be null, to enable aggressive testing, although in real
     life a Guice-supplied Provider will never return null.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods for creating and working with instances of
 {@link Provider}.

 @author Kevin Bourrillion (kevinb9n@gmail.com)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.util.Providers -->
  <!-- start class com.google.inject.util.Types -->
  <class name="Types" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="newParameterizedType" return="java.lang.reflect.ParameterizedType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rawType" type="java.lang.reflect.Type"/>
      <param name="typeArguments" type="java.lang.reflect.Type[]"/>
      <doc>
      <![CDATA[Returns a new parameterized type, applying {@code typeArguments} to
 {@code rawType}. The returned type does not have an owner type.

 @return a {@link java.io.Serializable serializable} parameterized type.]]>
      </doc>
    </method>
    <method name="newParameterizedTypeWithOwner" return="java.lang.reflect.ParameterizedType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ownerType" type="java.lang.reflect.Type"/>
      <param name="rawType" type="java.lang.reflect.Type"/>
      <param name="typeArguments" type="java.lang.reflect.Type[]"/>
      <doc>
      <![CDATA[Returns a new parameterized type, applying {@code typeArguments} to
 {@code rawType} and enclosed by {@code ownerType}.

 @return a {@link java.io.Serializable serializable} parameterized type.]]>
      </doc>
    </method>
    <method name="arrayOf" return="java.lang.reflect.GenericArrayType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="componentType" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns an array type whose elements are all instances of
 {@code componentType}.

 @return a {@link java.io.Serializable serializable} generic array type.]]>
      </doc>
    </method>
    <method name="subtypeOf" return="java.lang.reflect.WildcardType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bound" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns a type that represents an unknown type that extends {@code bound}.
 For example, if {@code bound} is {@code CharSequence.class}, this returns
 {@code ? extends CharSequence}. If {@code bound} is {@code Object.class},
 this returns {@code ?}, which is shorthand for {@code ? extends Object}.]]>
      </doc>
    </method>
    <method name="supertypeOf" return="java.lang.reflect.WildcardType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bound" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns a type that represents an unknown supertype of {@code bound}. For
 example, if {@code bound} is {@code String.class}, this returns {@code ?
 super String}.]]>
      </doc>
    </method>
    <method name="listOf" return="java.lang.reflect.ParameterizedType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elementType" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns a type modelling a {@link List} whose elements are of type
 {@code elementType}.

 @return a {@link java.io.Serializable serializable} parameterized type.]]>
      </doc>
    </method>
    <method name="setOf" return="java.lang.reflect.ParameterizedType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="elementType" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns a type modelling a {@link Set} whose elements are of type
 {@code elementType}.

 @return a {@link java.io.Serializable serializable} parameterized type.]]>
      </doc>
    </method>
    <method name="mapOf" return="java.lang.reflect.ParameterizedType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyType" type="java.lang.reflect.Type"/>
      <param name="valueType" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns a type modelling a {@link Map} whose keys are of type
 {@code keyType} and whose values are of type {@code valueType}.

 @return a {@link java.io.Serializable serializable} parameterized type.]]>
      </doc>
    </method>
    <method name="providerOf" return="java.lang.reflect.ParameterizedType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providedType" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Returns a type modelling a {@link Provider} that provides elements of type
 {@code elementType}.

 @return a {@link java.io.Serializable serializable} parameterized type.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static methods for working with types.

 @author crazybob@google.com (Bob Lee)
 @since 2.0]]>
    </doc>
  </class>
  <!-- end class com.google.inject.util.Types -->
</package>

</api>
