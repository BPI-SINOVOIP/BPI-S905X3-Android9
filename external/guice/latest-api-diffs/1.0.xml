<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->
<!-- on Tue May 19 17:01:51 PDT 2009 -->

<api
  xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
  xsi:noNamespaceSchemaLocation='api.xsd'
  name="1.0"
  jdversion="1.1.1">

<!--  Command line arguments =  -doclet jdiff.JDiff -docletpath /Applications/bin/jdiff-1.1.1/jdiff.jar:/Applications/bin/jdiff-1.1.1/xerces.jar -d /Users/jessewilson/Guice/guice-everything/api-diffs -classpath /usr/share/ant/lib/ant-launcher.jar:/usr/share/ant/lib/ant-jai.jar:/usr/share/ant/lib/ant-jmf.jar:/usr/share/ant/lib/ant-junit.jar:/usr/share/ant/lib/ant-nodeps.jar:/usr/share/ant/lib/ant-swing.jar:/usr/share/ant/lib/ant-testutil.jar:/usr/share/ant/lib/ant-trax.jar:/usr/share/ant/lib/ant.jar:/usr/share/ant/lib/junit.jar:/usr/share/ant/lib/xercesImpl.jar:/usr/share/ant/lib/xml-apis.jar -sourcepath /Users/jessewilson/Guice/guice-everything/tags/1.0/src:/Users/jessewilson/Guice/guice-everything/tags/1.0/servlet/src:/Users/jessewilson/Guice/guice-everything/tags/1.0/spring/src:/Users/jessewilson/Guice/guice-everything/tags/1.0/struts2/plugin/src -apiname 1.0 -baseURI http://www.w3.org -apidir /Users/jessewilson/Guice/guice-everything/api-diffs -source 1.5 -->
<package name="com.google.inject">
  <!-- start class com.google.inject.AbstractModule -->
  <class name="AbstractModule" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.Module"/>
    <constructor name="AbstractModule"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="com.google.inject.Binder"/>
    </method>
    <method name="configure"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Configures a {@link Binder} via the exposed methods.]]>
      </doc>
    </method>
    <method name="binder" return="com.google.inject.Binder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets direct access to the underlying {@code Binder}.]]>
      </doc>
    </method>
    <method name="bindScope"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="scopeAnnotation" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <param name="scope" type="com.google.inject.Scope"/>
      <doc>
      <![CDATA[@see Binder#bindScope(Class, Scope)]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.LinkedBindingBuilder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#bind(Key)]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.AnnotatedBindingBuilder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#bind(TypeLiteral)]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.AnnotatedBindingBuilder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[@see Binder#bind(Class)]]>
      </doc>
    </method>
    <method name="bindConstant" return="com.google.inject.binder.AnnotatedConstantBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see Binder#bindConstant()]]>
      </doc>
    </method>
    <method name="install"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="module" type="com.google.inject.Module"/>
      <doc>
      <![CDATA[@see Binder#install(Module)]]>
      </doc>
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <param name="arguments" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[@see Binder#addError(String, Object[])]]>
      </doc>
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[@see Binder#addError(Throwable)]]>
      </doc>
    </method>
    <method name="requestStaticInjection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="types" type="java.lang.Class[]"/>
      <doc>
      <![CDATA[@see Binder#requestStaticInjection(Class[])]]>
      </doc>
    </method>
    <method name="bindInterceptor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="classMatcher" type="com.google.inject.matcher.Matcher&lt;? super java.lang.Class&lt;?&gt;&gt;"/>
      <param name="methodMatcher" type="com.google.inject.matcher.Matcher&lt;? super java.lang.reflect.Method&gt;"/>
      <param name="interceptors" type="MethodInterceptor[]"/>
      <doc>
      <![CDATA[@see Binder#bindInterceptor(com.google.inject.matcher.Matcher,
  com.google.inject.matcher.Matcher,
  org.aopalliance.intercept.MethodInterceptor[])]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A support class for {@link Module}s which reduces repetition and results in
 a more readable configuration. Simply extend this class, implement {@link
 #configure()}, and call the inherited methods which mirror those found in
 {@link Binder}. For example:

 <pre>
 import static com.google.inject.Names.named;

 public class MyModule extends AbstractModule {
   protected void configure() {
     bind(Foo.class).to(FooImpl.class).in(Scopes.SINGLETON);
     bind(BarImpl.class);
     link(Bar.class).to(BarImpl.class);
     bindConstant(named("port")).to(8080);
   }
 }
 </pre>

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.AbstractModule -->
  <!-- start interface com.google.inject.Binder -->
  <interface name="Binder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="bindInterceptor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classMatcher" type="com.google.inject.matcher.Matcher&lt;? super java.lang.Class&lt;?&gt;&gt;"/>
      <param name="methodMatcher" type="com.google.inject.matcher.Matcher&lt;? super java.lang.reflect.Method&gt;"/>
      <param name="interceptors" type="MethodInterceptor[]"/>
      <doc>
      <![CDATA[Binds a method interceptor to methods matched by class and method
 matchers.

 @param classMatcher matches classes the interceptor should apply to. For
     example: {@code only(Runnable.class)}.
 @param methodMatcher matches methods the interceptor should apply to. For
     example: {@code annotatedWith(Transactional.class)}.
 @param interceptors to bind]]>
      </doc>
    </method>
    <method name="bindScope"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <param name="scope" type="com.google.inject.Scope"/>
      <doc>
      <![CDATA[Binds a scope to an annotation.]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.LinkedBindingBuilder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[Creates a binding to a key.]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.AnnotatedBindingBuilder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[Creates a binding to a type.]]>
      </doc>
    </method>
    <method name="bind" return="com.google.inject.binder.AnnotatedBindingBuilder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Creates a binding to a type.]]>
      </doc>
    </method>
    <method name="bindConstant" return="com.google.inject.binder.AnnotatedConstantBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Binds a constant value to an annotation.]]>
      </doc>
    </method>
    <method name="requestStaticInjection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="types" type="java.lang.Class[]"/>
      <doc>
      <![CDATA[Upon successful creation, the {@link Injector} will inject static fields
 and methods in the given classes.

 @param types for which static members will be injected]]>
      </doc>
    </method>
    <method name="install"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="module" type="com.google.inject.Module"/>
      <doc>
      <![CDATA[Uses the given module to configure more bindings.]]>
      </doc>
    </method>
    <method name="currentStage" return="com.google.inject.Stage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the current stage.]]>
      </doc>
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <param name="arguments" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Records an error message which will be presented to the user at a later
 time. Unlike throwing an exception, this enable us to continue
 configuring the Injector and discover more errors. Uses {@link
 String#format(String, Object[])} to insert the arguments into the
 message.]]>
      </doc>
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Records an exception, the full details of which will be logged, and the
 message of which will be presented to the user at a later
 time. If your Module calls something that you worry may fail, you should
 catch the exception and pass it into this.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Collects configuration information (primarily <i>bindings</i>) which will be
 used to create an {@link Injector}. Guice provides this object to your
 application's {@link Module}s so they may each contribute
 their own bindings.

 <p>The bindings contributed by {@code Module}s define how the {@code
 Injector} resolves dependencies. A {@link Key} consisting of a type
 and optional annotation uniquely identifies a binding within an {@code
 Injector}.

 <p>You may bind from a key to:

 <ul>
 <li>Another binding, which this binding's key is now "aliased to"
 <li>Another binding, which references a {@link Provider} for this key
 <li>A preconstructed instance
 <li>A preconstructed instance which should be used as the {@link Provider}
   for this binding
 </ul>

 <p>In addition, a binding may have an associated scope, such as
 {@link Scopes#SINGLETON}, and singleton bindings may specify eager or lazy
 initialization.

 <p>See the users' guide appendix, "How the Injector resolves injection
 requests," to better understand binding resolution.

 <p>After an {@code Injector} has been created, its bindings may be
 examined using methods like {@link Injector#getBinding(Key)}, but this
 read-only {@link Binding} type is not used when <i>creating</i> the
 bindings.]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.Binder -->
  <!-- start interface com.google.inject.Binding -->
  <interface name="Binding"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getKey" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the key for this binding.]]>
      </doc>
    </method>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an arbitrary object containing information about the "place"
 where this binding was configured. Used by Guice in the production of
 descriptive error messages.]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the provider guice uses to fulfill requests for this binding.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A mapping from a key (type and optional annotation) to a provider of
 instances of that type.  This interface is part of the {@link Injector}
 introspection API and is intended primary for use by tools.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.Binding -->
  <!-- start class com.google.inject.BindingAnnotation -->
  <class name="BindingAnnotation"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotates annotations which are used for binding. Only one such annotation
 may apply to a single injection point. You must also annotate binder
 annotations with {@code @Retention(RUNTIME)}. For example:

 <pre>
   {@code @}Retention(RUNTIME)
   {@code @}Target({ FIELD, PARAMETER })
   {@code @}BindingAnnotation
   public {@code @}interface Transactional {}
 </pre>

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.BindingAnnotation -->
  <!-- start class com.google.inject.CreationException -->
  <class name="CreationException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CreationException" type="java.util.Collection&lt;com.google.inject.spi.Message&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new exception for the given errors.]]>
      </doc>
    </constructor>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getErrorMessages" return="java.util.Collection&lt;com.google.inject.spi.Message&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the error messages which resulted in this exception.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Thrown when errors occur while creating a {@link Injector}. Includes a list
 of encountered errors. Typically, a client should catch this exception, log
 it, and stop execution.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.CreationException -->
  <!-- start class com.google.inject.Guice -->
  <class name="Guice" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="createInjector" return="com.google.inject.Injector"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="com.google.inject.Module[]"/>
      <doc>
      <![CDATA[Creates an injector for the given set of modules.

 @throws CreationException from which you can retrieve the individual error
  messages]]>
      </doc>
    </method>
    <method name="createInjector" return="com.google.inject.Injector"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Iterable&lt;com.google.inject.Module&gt;"/>
      <doc>
      <![CDATA[Creates an injector for the given set of modules.

 @throws CreationException from which you can retrieve the individual error
  messages]]>
      </doc>
    </method>
    <method name="createInjector" return="com.google.inject.Injector"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stage" type="com.google.inject.Stage"/>
      <param name="modules" type="com.google.inject.Module[]"/>
      <doc>
      <![CDATA[Creates an injector for the given set of modules, in a given development
 stage.

 @throws CreationException from which you can retrieve the individual error
  messages.]]>
      </doc>
    </method>
    <method name="createInjector" return="com.google.inject.Injector"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stage" type="com.google.inject.Stage"/>
      <param name="modules" type="java.lang.Iterable&lt;com.google.inject.Module&gt;"/>
      <doc>
      <![CDATA[Creates an injector for the given set of modules, in a given development
 stage.

 @throws CreationException from which you can retrieve the individual error
  messages.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The entry point to the Guice framework. Creates {@link Injector}s from
 {@link Module}s.]]>
    </doc>
  </class>
  <!-- end class com.google.inject.Guice -->
  <!-- start class com.google.inject.ImplementedBy -->
  <class name="ImplementedBy"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[A pointer to the default implementation of a type.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.ImplementedBy -->
  <!-- start class com.google.inject.Inject -->
  <class name="Inject"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotates members of your implementation class (constructors, methods
 and fields) into which the {@link Injector} should inject values.
 The Injector fulfills injection requests for:

 <ul>
 <li>Every instance it constructs. The class being constructed must have
 exactly one of its constructors marked with {@code @Inject} or must have a
 constructor taking no parameters. The Injector then proceeds to perform
 method and field injections.
 
 <li>Pre-constructed instances passed to {@link Injector#injectMembers},
 {@link com.google.inject.binder.LinkedBindingBuilder#toInstance(Object)} and
 {@link com.google.inject.binder.LinkedBindingBuilder#toProvider(Provider)}.
 In this case all constructors are, of course, ignored.

 <li>Static fields and methods of classes which any {@link Module} has
 specifically requested static injection for, using
 {@link Binder#requestStaticInjection}.
 </ul>

 In all cases, a member can be injected regardless of its Java access
 specifier (private, default, protected, public).

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.Inject -->
  <!-- start interface com.google.inject.Injector -->
  <interface name="Injector"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="injectMembers"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Injects dependencies into the fields and methods of an existing object.
 Does not inject the constructor.]]>
      </doc>
    </method>
    <method name="getBindings" return="java.util.Map&lt;com.google.inject.Key&lt;?&gt;, com.google.inject.Binding&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets all explicit bindings.]]>
      </doc>
    </method>
    <method name="getBinding" return="com.google.inject.Binding&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[Gets a binding for the given key.]]>
      </doc>
    </method>
    <method name="findBindingsByType" return="java.util.List&lt;com.google.inject.Binding&lt;T&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[Finds all bindings to the given type.]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[Gets the provider bound to the given key.]]>
      </doc>
    </method>
    <method name="getProvider" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Gets the provider bound to the given type.]]>
      </doc>
    </method>
    <method name="getInstance" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <doc>
      <![CDATA[Gets an instance bound to the given key; equivalent to
 {@code getProvider(key).get()}.]]>
      </doc>
    </method>
    <method name="getInstance" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Gets an instance bound to the given type; equivalent to
 {@code getProvider(type).get()}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Fulfills requests for the object instances that make up your application,
 always ensuring that these instances are properly injected before they are
 returned. The {@code Injector} is the heart of the Guice framework,
 although you don't typically interact with it directly very often. This
 "behind-the-scenes" operation is what distinguishes the dependency
 injection pattern from its cousin, service locator.

 <p>The {@code Injector} API has a few additional features: it allows
 pre-constructed instances to have their fields and methods injected and
 offers programmatic introspection to support tool development.

 <p>Contains several default bindings:

 <ul>
 <li>This {@link Injector} instance itself
 <li>A {@code Provider<T>} for each binding of type {@code T}
 <li>The {@link java.util.logging.Logger} for the class being injected
 <li>The {@link Stage} in which the Injector was created
 </ul>

 Injectors are created using the facade class {@link Guice}.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.Injector -->
  <!-- start class com.google.inject.Key -->
  <class name="Key" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Key" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new key. Derives the type from this class's type parameter.

 <p>Clients create an empty anonymous subclass. Doing so embeds the type
 parameter in the anonymous class's type hierarchy so we can reconstitute it
 at runtime despite erasure.

 <p>Example usage for a binding of type {@code Foo} annotated with
 {@code @Bar}:

 <p>{@code new Key<Foo>(Bar.class) {}}.]]>
      </doc>
    </constructor>
    <constructor name="Key" type="java.lang.annotation.Annotation"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new key. Derives the type from this class's type parameter.

 <p>Clients create an empty anonymous subclass. Doing so embeds the type
 parameter in the anonymous class's type hierarchy so we can reconstitute it
 at runtime despite erasure.

 <p>Example usage for a binding of type {@code Foo} annotated with
 {@code @Bar}:

 <p>{@code new Key<Foo>(new Bar()) {}}.]]>
      </doc>
    </constructor>
    <constructor name="Key"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new key. Derives the type from this class's type parameter.

 <p>Clients create an empty anonymous subclass. Doing so embeds the type
 parameter in the anonymous class's type hierarchy so we can reconstitute it
 at runtime despite erasure.

 <p>Example usage for a binding of type {@code Foo}:

 <p>{@code new Key<Foo>() {}}.]]>
      </doc>
    </constructor>
    <method name="getTypeLiteral" return="com.google.inject.TypeLiteral&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the key type.]]>
      </doc>
    </method>
    <method name="getAnnotationType" return="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the annotation type.]]>
      </doc>
    </method>
    <method name="getAnnotation" return="java.lang.annotation.Annotation"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the annotation.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Gets a key for an injection type.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[Gets a key for an injection type and an annotation type.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Gets a key for an injection type and an annotation.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.Key&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Gets a key for an injection type.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.Key&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[Gets a key for an injection type and an annotation type.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.Key&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Gets a key for an injection type and an annotation.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <doc>
      <![CDATA[Gets a key for an injection type.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[Gets a key for an injection type and an annotation type.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.Key&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeLiteral" type="com.google.inject.TypeLiteral&lt;T&gt;"/>
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Gets a key for an injection type and an annotation.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Binding key consisting of an injection type and an optional annotation.
 Matches the type and annotation at a point of injection.

 <p>For example, {@code Key.get(Service.class, Transactional.class)} will
 match:

 <pre>
   {@literal @}Inject
   public void setService({@literal @}Transactional Service service) {
     ...
   }
 </pre>

 <p>{@code Key} supports generic types via subclassing just like {@link
 TypeLiteral}.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.Key -->
  <!-- start interface com.google.inject.Module -->
  <interface name="Module"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <doc>
      <![CDATA[Contributes bindings and other configurations to a {@code Binder}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A module contributes configuration information, typically interface
 bindings, which will be used to create an {@link Injector}. A guice-based
 application is ultimately composed of little more than a set of
 {@code Module}s and some bootstrapping code.

 <p>Your Module classes can use a more streamlined syntax by extending
 {@link AbstractModule} rather than implementing this interface directly.]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.Module -->
  <!-- start class com.google.inject.ProvidedBy -->
  <class name="ProvidedBy"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[A pointer to the default provider type for a type.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.ProvidedBy -->
  <!-- start interface com.google.inject.Provider -->
  <interface name="Provider"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Provides an instance of {@code T}. Must never return {@code null}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Simply, any object capable of providing instances of type {@code T}.
 Providers are used in numerous ways by the Guice framework:

 <ul>
 <li>When the default means for obtaining instances (an injectable or
 parameterless constructor) is insufficient for a particular binding, the
 module can specify a custom {@code Provider} instead, to control exactly how
 Guice creates or obtains instances for the binding.

 <li>An implementation class may always choose to have a {@code Provider<T>}
 instance injected, rather than having a {@code T} injected directly.  This
 may give you access to multiple instances, instances you wish to safely
 mutate and discard, instances which are out of scope (e.g. using a
 {@code @RequestScoped} object from within a {@code @SessionScoped} object),
 or instances you don't want to initialize until they are absolutely needed.

 <li>A custom {@link Scope} is implemented as a decorator of
 {@code Provider<T>}, which decides when to delegate to the backing provider
 and when to provide the instance some other way.

 <li>The {@link Injector} offers access to the {@code Provider<T>} it uses
 to fulfill requests for a given key, via the {@link Injector#getProvider}
 methods.
 </ul>

 @param <T> the type of object this provider provides

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.Provider -->
  <!-- start interface com.google.inject.Scope -->
  <interface name="Scope"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="scope" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.google.inject.Key&lt;T&gt;"/>
      <param name="unscoped" type="com.google.inject.Provider&lt;T&gt;"/>
      <doc>
      <![CDATA[Scopes a provider. The returned locator returns objects from this scope. If
 an object does not exist in this scope, the provider can use the given
 unscoped provider to retrieve one.

 <p>Scope implementations are strongly encouraged to override
 {@link Object#toString} in the returned provider and include the backing
 provider's {@code toString()} output.

 @param key binding key
 @param unscoped locates an instance when one doesn't already exist in this
  scope.
 @return a new provider which only delegates to the given unscoped provider
  when an instance of the requested object doesn't already exist in this
  scope]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A short but useful description of this scope.  For comparison, the standard
 scopes that ship with guice use the descriptions
 {@code "Scopes.SINGLETON"}, {@code "ServletScopes.SESSION"} and
 {@code "ServletScopes.REQUEST"}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A scope is a level of visibility that instances provided by Guice may have.
 By default, an instance created by the {@link Injector} has <i>no
 scope</i>, meaning it has no state from the framework's perspective -- the
 {@code Injector} creates it, injects it once into the class that required it,
 and then immediately forgets it. Associating a scope with a particular binding
 allows the created instance to be "remembered" and possibly used again for
 other injections.

 @see Scopes#SINGLETON

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.Scope -->
  <!-- start class com.google.inject.ScopeAnnotation -->
  <class name="ScopeAnnotation"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotates annotations which are used for scoping. Only one such annotation
 may apply to a single implementation class. You must also annotate scope
 annotations with {@code @Retention(RUNTIME)}. For example:

 <pre>
   {@code @}Retention(RUNTIME)
   {@code @}Target(TYPE)
   {@code @}ScopeAnnotation
   public {@code @}interface SessionScoped {}
 </pre>

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.ScopeAnnotation -->
  <!-- start class com.google.inject.Scopes -->
  <class name="Scopes" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <field name="SINGLETON" type="com.google.inject.Scope"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[One instance per {@link Injector}. Also see {@code @}{@link Singleton}.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Built in scope implementations.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.Scopes -->
  <!-- start class com.google.inject.Singleton -->
  <class name="Singleton"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Apply this to implementation classes when you want only one instance
 (per {@link Injector}) to be reused for all injections for that binding.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.Singleton -->
  <!-- start class com.google.inject.Stage -->
  <class name="Stage" extends="java.lang.Enum&lt;com.google.inject.Stage&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.google.inject.Stage[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.google.inject.Stage"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[The stage we're running in.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.Stage -->
  <!-- start class com.google.inject.TypeLiteral -->
  <class name="TypeLiteral" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="TypeLiteral"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new type literal. Derives represented class from type
 parameter.

 <p>Clients create an empty anonymous subclass. Doing so embeds the type
 parameter in the anonymous class's type hierarchy so we can reconstitute it
 at runtime despite erasure.]]>
      </doc>
    </constructor>
    <method name="getType" return="java.lang.reflect.Type"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets underlying {@code Type} instance.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="com.google.inject.TypeLiteral&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.reflect.Type"/>
      <doc>
      <![CDATA[Gets type literal for the given {@code Type} instance.]]>
      </doc>
    </method>
    <method name="get" return="com.google.inject.TypeLiteral&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Gets type literal for the given {@code Class} instance.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a generic type {@code T}. Java doesn't yet provide a way to
 represent generic types, so this class does. Forces clients to create a
 subclass of this class which enables retrieval the type information even at
 runtime.

 <p>For example, to create a type literal for {@code List<String>}, you can
 create an empty anonymous inner class:

 <p>
 {@code TypeLiteral<List<String>> list = new TypeLiteral<List<String>>() {};}

 <p>Assumes that type {@code T} implements {@link Object#equals} and
 {@link Object#hashCode()} as value (as opposed to identity) comparison.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.TypeLiteral -->
</package>
<package name="com.google.inject.binder">
  <!-- start interface com.google.inject.binder.AnnotatedBindingBuilder -->
  <interface name="AnnotatedBindingBuilder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.binder.LinkedBindingBuilder&lt;T&gt;"/>
    <method name="annotatedWith" return="com.google.inject.binder.LinkedBindingBuilder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[Specifies an annotation type for this binding.]]>
      </doc>
    </method>
    <method name="annotatedWith" return="com.google.inject.binder.LinkedBindingBuilder&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Specifies an annotation value for this binding.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Specifies the annotation for a binding. 

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.binder.AnnotatedBindingBuilder -->
  <!-- start interface com.google.inject.binder.AnnotatedConstantBindingBuilder -->
  <interface name="AnnotatedConstantBindingBuilder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="annotatedWith" return="com.google.inject.binder.ConstantBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[Specifies an annotation type for this binding.]]>
      </doc>
    </method>
    <method name="annotatedWith" return="com.google.inject.binder.ConstantBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Specifies an annotation value for this binding.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Specifies the annotation for a constant binding.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.binder.AnnotatedConstantBindingBuilder -->
  <!-- start interface com.google.inject.binder.ConstantBindingBuilder -->
  <interface name="ConstantBindingBuilder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="double"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="float"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="short"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="char"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <method name="to"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="E extends java.lang.Enum&lt;E&gt;"/>
      <doc>
      <![CDATA[Binds constant to the given value.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Binds to a constant value.]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.binder.ConstantBindingBuilder -->
  <!-- start interface com.google.inject.binder.LinkedBindingBuilder -->
  <interface name="LinkedBindingBuilder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.binder.ScopedBindingBuilder"/>
    <method name="to" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="implementation" type="java.lang.Class&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Binds to another binding with the specified type.]]>
      </doc>
    </method>
    <method name="to" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="implementation" type="com.google.inject.TypeLiteral&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Binds to another binding with the specified type.]]>
      </doc>
    </method>
    <method name="to" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="targetKey" type="com.google.inject.Key&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Binds to another binding with the specified key.]]>
      </doc>
    </method>
    <method name="toInstance"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="T"/>
      <doc>
      <![CDATA[Binds to the given instance. The Injector will automatically inject the
 members of this instance when it is first created. See {@link
 com.google.inject.Injector#injectMembers(Object)}.]]>
      </doc>
    </method>
    <method name="toProvider" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="provider" type="com.google.inject.Provider&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Binds to instances generated by the given Provider. The Injector will
 automatically inject the members of this provider instance when it is first
 created. See {@link com.google.inject.Injector#injectMembers(Object)}.]]>
      </doc>
    </method>
    <method name="toProvider" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerType" type="java.lang.Class&lt;? extends com.google.inject.Provider&lt;? extends T&gt;&gt;"/>
      <doc>
      <![CDATA[Binds to instances from the provider bound to the given provider type.]]>
      </doc>
    </method>
    <method name="toProvider" return="com.google.inject.binder.ScopedBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerKey" type="com.google.inject.Key&lt;? extends com.google.inject.Provider&lt;? extends T&gt;&gt;"/>
      <doc>
      <![CDATA[Binds to instances from the provider bound to the given key.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Links a binding to another binding or an instance.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.binder.LinkedBindingBuilder -->
  <!-- start interface com.google.inject.binder.ScopedBindingBuilder -->
  <interface name="ScopedBindingBuilder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="in"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scopeAnnotation" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[Specifies the scope. References the annotation passed to {@link
 com.google.inject.Binder#bindScope(Class, com.google.inject.Scope)}.]]>
      </doc>
    </method>
    <method name="in"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scope" type="com.google.inject.Scope"/>
      <doc>
      <![CDATA[Specifies the scope.]]>
      </doc>
    </method>
    <method name="asEagerSingleton"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Instructs the {@link com.google.inject.Injector} to eagerly initialize this
 singleton-scoped binding upon creation. Useful for application
 initialization logic.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Specifies the scope for a binding.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.binder.ScopedBindingBuilder -->
</package>
<package name="com.google.inject.jndi">
  <!-- start class com.google.inject.jndi.JndiIntegration -->
  <class name="JndiIntegration" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="fromJndi" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates a provider which looks up objects in JNDI using the given name.
 Example usage:

 <pre>
 bind(DataSource.class).toProvider(fromJndi(DataSource.class, "java:..."));
 </pre>]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Integrates Guice with JNDI. Requires a binding to 
 {@link javax.naming.Context}.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.jndi.JndiIntegration -->
</package>
<package name="com.google.inject.matcher">
  <!-- start class com.google.inject.matcher.AbstractMatcher -->
  <class name="AbstractMatcher" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.google.inject.matcher.Matcher&lt;T&gt;"/>
    <constructor name="AbstractMatcher"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="and" return="com.google.inject.matcher.Matcher&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.inject.matcher.Matcher&lt;? super T&gt;"/>
    </method>
    <method name="or" return="com.google.inject.matcher.Matcher&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.inject.matcher.Matcher&lt;? super T&gt;"/>
    </method>
    <doc>
    <![CDATA[Implements {@code and()} and {@code or()}.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.matcher.AbstractMatcher -->
  <!-- start interface com.google.inject.matcher.Matcher -->
  <interface name="Matcher"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="matches" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="T"/>
      <doc>
      <![CDATA[Returns {@code true} if this matches {@code t}, {@code false} otherwise.]]>
      </doc>
    </method>
    <method name="and" return="com.google.inject.matcher.Matcher&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.inject.matcher.Matcher&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns a new matcher which returns {@code true} if both this and the
 given matcher return {@code true}.]]>
      </doc>
    </method>
    <method name="or" return="com.google.inject.matcher.Matcher&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="com.google.inject.matcher.Matcher&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Returns a new matcher which returns {@code true} if either this or the
 given matcher return {@code true}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Returns {@code true} or {@code false} for a given input.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.matcher.Matcher -->
  <!-- start class com.google.inject.matcher.Matchers -->
  <class name="Matchers" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="any" return="com.google.inject.matcher.Matcher&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a matcher which matches any input.]]>
      </doc>
    </method>
    <method name="not" return="com.google.inject.matcher.Matcher&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="com.google.inject.matcher.Matcher&lt;? super T&gt;"/>
      <doc>
      <![CDATA[Inverts the given matcher.]]>
      </doc>
    </method>
    <method name="annotatedWith" return="com.google.inject.matcher.Matcher&lt;java.lang.reflect.AnnotatedElement&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <doc>
      <![CDATA[Returns a matcher which matches elements (methods, classes, etc.)
 with a given annotation.]]>
      </doc>
    </method>
    <method name="annotatedWith" return="com.google.inject.matcher.Matcher&lt;java.lang.reflect.AnnotatedElement&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotation" type="java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Returns a matcher which matches elements (methods, classes, etc.)
 with a given annotation.]]>
      </doc>
    </method>
    <method name="subclassesOf" return="com.google.inject.matcher.Matcher&lt;java.lang.Class&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="superclass" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Returns a matcher which matches subclasses of the given type (as well as
 the given type).]]>
      </doc>
    </method>
    <method name="only" return="com.google.inject.matcher.Matcher&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns a matcher which matches objects equal to the given object.]]>
      </doc>
    </method>
    <method name="identicalTo" return="com.google.inject.matcher.Matcher&lt;java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns a matcher which matches only the given object.]]>
      </doc>
    </method>
    <method name="inPackage" return="com.google.inject.matcher.Matcher&lt;java.lang.Class&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="java.lang.Package"/>
      <doc>
      <![CDATA[Returns a matcher which matches classes in the given package.]]>
      </doc>
    </method>
    <method name="returns" return="com.google.inject.matcher.Matcher&lt;java.lang.reflect.Method&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="returnType" type="com.google.inject.matcher.Matcher&lt;? super java.lang.Class&lt;?&gt;&gt;"/>
      <doc>
      <![CDATA[Returns a matcher which matches methods with matching return types.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Matcher implementations. Supports matching classes and methods.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.matcher.Matchers -->
</package>
<package name="com.google.inject.name">
  <!-- start class com.google.inject.name.Named -->
  <class name="Named"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotates named things.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.name.Named -->
  <!-- start class com.google.inject.name.Names -->
  <class name="Names" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="named" return="com.google.inject.name.Named"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates a {@link Named} annotation with {@code name} as the value.]]>
      </doc>
    </method>
    <method name="bindProperties"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="properties" type="java.util.Map&lt;java.lang.String, java.lang.String&gt;"/>
      <doc>
      <![CDATA[Creates a constant binding to {@code @Named(key)} for each property.]]>
      </doc>
    </method>
    <method name="bindProperties"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="properties" type="java.util.Properties"/>
      <doc>
      <![CDATA[Creates a constant binding to {@code @Named(key)} for each property.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility methods for use with {@code @}{@link Named}.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.name.Names -->
</package>
<package name="com.google.inject.servlet">
  <!-- start class com.google.inject.servlet.GuiceFilter -->
  <class name="GuiceFilter" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="GuiceFilter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="doFilter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="servletRequest" type="ServletRequest"/>
      <param name="servletResponse" type="ServletResponse"/>
      <param name="filterChain" type="FilterChain"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="ServletException" type="ServletException"/>
    </method>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filterConfig" type="FilterConfig"/>
      <exception name="ServletException" type="ServletException"/>
    </method>
    <method name="destroy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Apply this filter to all requests where you plan to use servlet scopes.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.servlet.GuiceFilter -->
  <!-- start class com.google.inject.servlet.RequestParameters -->
  <class name="RequestParameters"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Apply this to field or parameters of type {@code Map<String, String[]>}
 when you want the HTTP request parameter map to be injected.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.servlet.RequestParameters -->
  <!-- start class com.google.inject.servlet.RequestScoped -->
  <class name="RequestScoped"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Apply this to implementation classes when you want one instance per request.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.servlet.RequestScoped -->
  <!-- start class com.google.inject.servlet.ServletModule -->
  <class name="ServletModule" extends="com.google.inject.AbstractModule"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ServletModule"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Configures the servlet scopes and creates bindings for the servlet API
 objects so you can inject the request, response, session, etc.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.servlet.ServletModule -->
  <!-- start class com.google.inject.servlet.ServletScopes -->
  <class name="ServletScopes" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <field name="REQUEST" type="com.google.inject.Scope"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP servlet request scope.]]>
      </doc>
    </field>
    <field name="SESSION" type="com.google.inject.Scope"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTTP session scope.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Servlet scopes.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.servlet.ServletScopes -->
  <!-- start class com.google.inject.servlet.SessionScoped -->
  <class name="SessionScoped"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Apply this to implementation classes when you want one instance per session.

 @see com.google.inject.Scopes#SINGLETON
 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.servlet.SessionScoped -->
</package>
<package name="com.google.inject.spi">
  <!-- start class com.google.inject.spi.Message -->
  <class name="Message" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Message" type="java.lang.Object, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Message" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the source of the configuration which resulted in this error message.]]>
      </doc>
    </method>
    <method name="getSourceString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation of the source object.]]>
      </doc>
    </method>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the error message text.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[A message. Contains a source pointing to the code which resulted
 in this message and a text message.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.Message -->
  <!-- start interface com.google.inject.spi.SourceProvider -->
  <interface name="SourceProvider"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="source" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an object pointing to the current location within the
 configuration. If we run into a problem later, we'll be able to trace it
 back to the original source. Useful for debugging.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides source objects to the {@link com.google.inject.Binder}.
 A source object is any object which points back to the current location
 within the configuration. Guice uses source objects in error messages
 and associates them with bindings.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.spi.SourceProvider -->
  <!-- start class com.google.inject.spi.SourceProviders -->
  <class name="SourceProviders" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="skip"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Instructs stacktrace-based providers to skip the given class in the stack
 trace when determining the source. Use this to keep the binder from
 logging utility methods as the sources of bindings (i.e. it will skip to
 the utility methods' callers instead).

 <p>Skipping only takes place after this method is called.]]>
      </doc>
    </method>
    <method name="getSkippedClassNames" return="java.util.Set&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the set of class names which should be skipped by stacktrace-based
 providers.]]>
      </doc>
    </method>
    <method name="defaultSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the current source obtained from the default provider.]]>
      </doc>
    </method>
    <method name="withDefault"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sourceProvider" type="com.google.inject.spi.SourceProvider"/>
      <param name="r" type="java.lang.Runnable"/>
      <doc>
      <![CDATA[Sets the default source provider, runs the given command, and then
 restores the previous default source provider.]]>
      </doc>
    </method>
    <field name="UNKNOWN_SOURCE" type="java.lang.Object"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Provides access to the default {@link SourceProvider} implementation and
 common controls for certain implementations.
 
 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spi.SourceProviders -->
</package>
<package name="com.google.inject.spring">
  <!-- start class com.google.inject.spring.SpringIntegration -->
  <class name="SpringIntegration" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="fromSpring" return="com.google.inject.Provider&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates a provider which looks up objects from Spring using the given name.
 Expects a binding to {@link
 org.springframework.beans.factory.BeanFactory}. Example usage:

 <pre>
 bind(DataSource.class)
   .toProvider(fromSpring(DataSource.class, "dataSource"));
 </pre>]]>
      </doc>
    </method>
    <method name="bindAll"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.google.inject.Binder"/>
      <param name="beanFactory" type="ListableBeanFactory"/>
      <doc>
      <![CDATA[Binds all Spring beans from the given factory by name. For a Spring bean
 named "foo", this method creates a binding to the bean's type and
 {@code @Named("foo")}.

 @see com.google.inject.name.Named
 @see com.google.inject.name.Names#named(String)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Integrates Guice with Spring.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.spring.SpringIntegration -->
</package>
<package name="com.google.inject.struts2">
  <!-- start class com.google.inject.struts2.GuiceObjectFactory -->
  <class name="GuiceObjectFactory" extends="ObjectFactory"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="GuiceObjectFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isNoArgConstructorRequired" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getClassInstance" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="ClassNotFoundException" type="java.lang.ClassNotFoundException"/>
    </method>
    <method name="buildBean" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class"/>
      <param name="extraContext" type="java.util.Map"/>
    </method>
    <method name="buildInterceptor" return="Interceptor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="interceptorConfig" type="InterceptorConfig"/>
      <param name="interceptorRefParams" type="java.util.Map"/>
      <exception name="ConfigurationException" type="ConfigurationException"/>
    </method>
  </class>
  <!-- end class com.google.inject.struts2.GuiceObjectFactory -->
</package>
<package name="com.google.inject.tools.jmx">
  <!-- start interface com.google.inject.tools.jmx.ManagedBindingMBean -->
  <interface name="ManagedBindingMBean"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getSource" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the source of this binding.]]>
      </doc>
    </method>
    <method name="getProvider" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the provider to which this binding is bound.]]>
      </doc>
    </method>
    <method name="getKey" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the binding key.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[JMX interface to bindings.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </interface>
  <!-- end interface com.google.inject.tools.jmx.ManagedBindingMBean -->
  <!-- start class com.google.inject.tools.jmx.Manager -->
  <class name="Manager" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Manager"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="manage"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="domain" type="java.lang.String"/>
      <param name="injector" type="com.google.inject.Injector"/>
      <doc>
      <![CDATA[Registers all the bindings of an Injector with the platform MBean server.
 Consider using the name of your root {@link Module} class as the domain.]]>
      </doc>
    </method>
    <method name="manage"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="server" type="javax.management.MBeanServer"/>
      <param name="domain" type="java.lang.String"/>
      <param name="injector" type="com.google.inject.Injector"/>
      <doc>
      <![CDATA[Registers all the bindings of an Injector with the given MBean server.
 Consider using the name of your root {@link Module} class as the domain.]]>
      </doc>
    </method>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Run with no arguments for usage instructions.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides a JMX interface to Guice.

 @author crazybob@google.com (Bob Lee)]]>
    </doc>
  </class>
  <!-- end class com.google.inject.tools.jmx.Manager -->
</package>

</api>
