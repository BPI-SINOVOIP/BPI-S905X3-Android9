#!/bin/sh

# Copyright (c) 2013 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# What this script does:
# ----------------------
# (1) run machine_replay.sh on the remote machine to replay the gestures
#     and to generate new logs,
# (2) remove the old logs in tests/logs/ for every board on the host, and
# (3) scp the new logs from the machine into the proper board on the host.
#
# Note: this script needs to be invoked in the firmware_TouchMTB home directory:
#       .../autotest/files/client/site_tests/firmware_TouchMTB
#       inside chroot on the host.
#
# Usage:
#   (cr) .../firmware_TouchMTB $ tools/host_replay.sh -m $MACHINE_IP -s
# Example:
#   (cr) .../firmware_TouchMTB $ tools/host_replay.sh -m 172.30.210.110 -s


# Confirm that current working directory is firmware_TouchMTB.
PROG=$0
BASE_PROJ="firmware_TouchMTB"
if [ `basename $(realpath .)` != "$BASE_PROJ" ]; then
  echo "You need to execute $PROG under $BASE_PROJ on the host."
  exit 1
fi

# Source the local common script.
. "$(dirname "$PROG")/firmware_common.sh" || exit 1

# Source the cros common script and assert that this is inside chroot.
source_cros_common_script
assert_inside_chroot


# Read command flags
. /usr/share/misc/shflags
DEFINE_string machine_ip "" "the machine ip address" "m"

FLAGS_HELP="USAGE: $PROG [flags]"

FLAGS "$@" || exit 1
eval set -- "${FLAGS_ARGV}"
set -e

# Check if the machine ip has been specified.
if [ -z $FLAGS_machine_ip ]; then
  echo You need to specify the machine ip with the option '"-m"'. E.g.;
  echo -e "(cr) $ tools/host_replay.sh -m 10.20.30.40\n"
  exit 1
fi


MACHINE_PROJ_DIR="/usr/local/autotest/tests/$BASE_PROJ"
MACHINE_LOG_ROOT="/tmp/touch_firmware_test"
MACHINE_REPLAY="tools/machine_replay.sh"
HOST_TMP_LOG_DIR="/tmp/touch_firmware_logs"


# Invoke the machine replay script.
run_remote_machine_replay() {
  echo Replaying on the machine_ip: $FLAGS_machine_ip
  ssh root@$FLAGS_machine_ip "${MACHINE_PROJ_DIR}/${MACHINE_REPLAY} -b $board"
}


# Remove the old log files on the host.
# There usually exist multiple sub-directories for multiple rounds
# (generated by the robot or manually) for every board.
# We allow only a log file in every round. Since the new log files are
# to be generated in next step, we need to remove the old log ones here.
# Otherwise, it becomes a bit difficult to determine which one is
# the old log file in every round sub-directory to remove manually.
# These new logs are supposed to be checked in to gerrit so that the
# unit tests can be run correctly.
remove_old_logs_on_host() {
  log_files=$(find ${board} -name "*.log" -type f 2>/dev/null)
  # Since there are multiple filenames in $log_files, note that
  # there should be no double quotes around $log_files after git rm.
  [ -n "$log_files" ] && git rm $log_files
}


# Scp the new logs from the machine to the host.
scp_logs_from_machine_to_host() {
  # Get the new log files generated on the machine side.
  LOG_PATHNAMES=`ssh root@$FLAGS_machine_ip "ls ${MACHINE_LOG_ROOT}/*/*.log"`

  make_empty_dir "$HOST_TMP_LOG_DIR"
  scp root@$FLAGS_machine_ip:"${MACHINE_LOG_ROOT}"/*/*.log "$HOST_TMP_LOG_DIR"
  for file in $LOG_PATHNAMES; do
    # Read the log base directories and the log filenames so that we know
    # how to copy the files into the proper paths on the host.
    read log_dir log_file <<< `echo $file | awk -F/ 'BEGIN{OFS=" ";} \
                                                     {print $(NF-1), $NF;}'`
    cp "${HOST_TMP_LOG_DIR}/${log_file}" "${board}/${log_dir}/${log_file}"
  done
  rm -fr "$HOST_TMP_LOG_DIR"
}


boards=`find tests/logs/* -maxdepth 0 -type d`
for board in $boards; do
  run_remote_machine_replay
  remove_old_logs_on_host
  scp_logs_from_machine_to_host
done
