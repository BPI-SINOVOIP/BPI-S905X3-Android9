/*
 * DO NOT EDIT THIS FILE. It was generated from linux/if.h.
 *
 * Copyright (c) 2013 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

/*
 * INET         An implementation of the TCP/IP protocol suite for the LINUX
 *              operating system.  INET is implemented using the  BSD Socket
 *              interface as the means of communication with the user level.
 *
 *              Global definitions for the INET interface module.
 *
 * Version:     @(#)if.h        1.0.2   04/18/93
 *
 * Authors:     Original taken from Berkeley UNIX 4.3, (c) UCB 1982-1988
 *              Ross Biro
 *              Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
 *
 *              This program is free software; you can redistribute it and/or
 *              modify it under the terms of the GNU General Public License
 *              as published by the Free Software Foundation; either version
 *              2 of the License, or (at your option) any later version.
 */

#include <Python.h>
#include <sys/ioctl.h>
#include <netinet/in.h>
#include <linux/if.h>

void _init_linux_if_h(PyObject *m) {
  PyModule_AddIntMacro(m, IFNAMSIZ);
  PyModule_AddIntMacro(m, IFALIASZ);

  /**
   * enum net_device_flags - &struct net_device flags
   *
   * These are the &struct net_device flags, they can be set by drivers, the
   * kernel and some can be triggered by userspace. Userspace can query and
   * set these flags using userspace utilities but there is also a sysfs
   * entry available for all dev flags which can be queried and set. These flags
   * are shared for all types of net_devices. The sysfs entries are available
   * via /sys/class/net/<dev>/flags. Flags which can be toggled through sysfs
   * are annotated below, note that only a few flags can be toggled and some
   * other flags are always always preserved from the original net_device flags
   * even if you try to set them via sysfs. Flags which are always preserved
   * are kept under the flag grouping @IFF_VOLATILE. Flags which are __volatile__
   * are annotated below as such.
   *
   * You should have a pretty good reason to be extending these flags.
   *
   * @IFF_UP: interface is up. Can be toggled through sysfs.
   * @IFF_BROADCAST: broadcast address valid. Volatile.
   * @IFF_DEBUG: turn on debugging. Can be toggled through sysfs.
   * @IFF_LOOPBACK: is a loopback net. Volatile.
   * @IFF_POINTOPOINT: interface is has p-p link. Volatile.
   * @IFF_NOTRAILERS: avoid use of trailers. Can be toggled through sysfs.
   *      Volatile.
   * @IFF_RUNNING: interface RFC2863 OPER_UP. Volatile.
   * @IFF_NOARP: no ARP protocol. Can be toggled through sysfs. Volatile.
   * @IFF_PROMISC: receive all packets. Can be toggled through sysfs.
   * @IFF_ALLMULTI: receive all multicast packets. Can be toggled through
   *      sysfs.
   * @IFF_MASTER: master of a load balancer. Volatile.
   * @IFF_SLAVE: slave of a load balancer. Volatile.
   * @IFF_MULTICAST: Supports multicast. Can be toggled through sysfs.
   * @IFF_PORTSEL: can set media type. Can be toggled through sysfs.
   * @IFF_AUTOMEDIA: auto media select active. Can be toggled through sysfs.
   * @IFF_DYNAMIC: dialup device with changing addresses. Can be toggled
   *      through sysfs.
   * @IFF_LOWER_UP: driver signals L1 up. Volatile.
   * @IFF_DORMANT: driver signals dormant. Volatile.
   * @IFF_ECHO: echo sent packets. Volatile.
   */
  /* enum net_device_flags */
  PyModule_AddIntMacro(m, IFF_UP);
  PyModule_AddIntMacro(m, IFF_BROADCAST);
  PyModule_AddIntMacro(m, IFF_DEBUG);
  PyModule_AddIntMacro(m, IFF_LOOPBACK);
  PyModule_AddIntMacro(m, IFF_POINTOPOINT);
  PyModule_AddIntMacro(m, IFF_NOTRAILERS);
  PyModule_AddIntMacro(m, IFF_RUNNING);
  PyModule_AddIntMacro(m, IFF_NOARP);
  PyModule_AddIntMacro(m, IFF_PROMISC);
  PyModule_AddIntMacro(m, IFF_ALLMULTI);
  PyModule_AddIntMacro(m, IFF_MASTER);
  PyModule_AddIntMacro(m, IFF_SLAVE);
  PyModule_AddIntMacro(m, IFF_MULTICAST);
  PyModule_AddIntMacro(m, IFF_PORTSEL);
  PyModule_AddIntMacro(m, IFF_AUTOMEDIA);
  PyModule_AddIntMacro(m, IFF_DYNAMIC);
  PyModule_AddIntMacro(m, IFF_LOWER_UP);
  PyModule_AddIntMacro(m, IFF_DORMANT);
  PyModule_AddIntMacro(m, IFF_ECHO);

  PyModule_AddIntMacro(m, IFF_UP);
  PyModule_AddIntMacro(m, IFF_BROADCAST);
  PyModule_AddIntMacro(m, IFF_DEBUG);
  PyModule_AddIntMacro(m, IFF_LOOPBACK);
  PyModule_AddIntMacro(m, IFF_POINTOPOINT);
  PyModule_AddIntMacro(m, IFF_NOTRAILERS);
  PyModule_AddIntMacro(m, IFF_RUNNING);
  PyModule_AddIntMacro(m, IFF_NOARP);
  PyModule_AddIntMacro(m, IFF_PROMISC);
  PyModule_AddIntMacro(m, IFF_ALLMULTI);
  PyModule_AddIntMacro(m, IFF_MASTER);
  PyModule_AddIntMacro(m, IFF_SLAVE);
  PyModule_AddIntMacro(m, IFF_MULTICAST);
  PyModule_AddIntMacro(m, IFF_PORTSEL);
  PyModule_AddIntMacro(m, IFF_AUTOMEDIA);
  PyModule_AddIntMacro(m, IFF_DYNAMIC);
  PyModule_AddIntMacro(m, IFF_LOWER_UP);
  PyModule_AddIntMacro(m, IFF_DORMANT);
  PyModule_AddIntMacro(m, IFF_ECHO);

  PyModule_AddIntMacro(m, IFF_VOLATILE);

  PyModule_AddIntMacro(m, IF_GET_IFACE);
  PyModule_AddIntMacro(m, IF_GET_PROTO);

  /* For definitions see hdlc.h */
  PyModule_AddIntMacro(m, IF_IFACE_V35);
  PyModule_AddIntMacro(m, IF_IFACE_V24);
  PyModule_AddIntMacro(m, IF_IFACE_X21);
  PyModule_AddIntMacro(m, IF_IFACE_T1);
  PyModule_AddIntMacro(m, IF_IFACE_E1);
  PyModule_AddIntMacro(m, IF_IFACE_SYNC_SERIAL);
  PyModule_AddIntMacro(m, IF_IFACE_X21D);

  /* For definitions see hdlc.h */
  PyModule_AddIntMacro(m, IF_PROTO_HDLC);
  PyModule_AddIntMacro(m, IF_PROTO_PPP);
  PyModule_AddIntMacro(m, IF_PROTO_CISCO);
  PyModule_AddIntMacro(m, IF_PROTO_FR);
  PyModule_AddIntMacro(m, IF_PROTO_FR_ADD_PVC);
  PyModule_AddIntMacro(m, IF_PROTO_FR_DEL_PVC);
  PyModule_AddIntMacro(m, IF_PROTO_X25);
  PyModule_AddIntMacro(m, IF_PROTO_HDLC_ETH);
  PyModule_AddIntMacro(m, IF_PROTO_FR_ADD_ETH_PVC);
  PyModule_AddIntMacro(m, IF_PROTO_FR_DEL_ETH_PVC);
  PyModule_AddIntMacro(m, IF_PROTO_FR_PVC);
  PyModule_AddIntMacro(m, IF_PROTO_FR_ETH_PVC);
  PyModule_AddIntMacro(m, IF_PROTO_RAW);

  /* RFC 2863 operational status */
  PyModule_AddIntMacro(m, IF_OPER_UNKNOWN);
  PyModule_AddIntMacro(m, IF_OPER_NOTPRESENT);
  PyModule_AddIntMacro(m, IF_OPER_DOWN);
  PyModule_AddIntMacro(m, IF_OPER_LOWERLAYERDOWN);
  PyModule_AddIntMacro(m, IF_OPER_TESTING);
  PyModule_AddIntMacro(m, IF_OPER_DORMANT);
  PyModule_AddIntMacro(m, IF_OPER_UP);

  /* link modes */
  PyModule_AddIntMacro(m, IF_LINK_MODE_DEFAULT);
  PyModule_AddIntMacro(m, IF_LINK_MODE_DORMANT);
}
