/*
* Copyright (C) 2016 The Android Open Source Project
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*      http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

int __attribute__((kernel)) my_foreach_kernel(int a) {
  // This kernel is unused, but we want to make sure it is not listed as a
  // reduction kernel by the debugger
  return a + 1;
}

typedef struct MinUserType {
  int32_t a;
  int32_t b;
} user_t;

int32_t b_startval;
int32_t a_startval;
float multiplier;

static void find_min_user_type_init(user_t *alloc) {
  alloc->a = a_startval;
  alloc->b = b_startval;
}

static void find_min_user_type_accum(user_t *accum, const user_t val) {
  if (val.a + val.b * multiplier < accum->a + accum->b * multiplier) {
    accum->a = val.a;
    accum->b = val.b;
  }
}

// Combiners are autogenerated if the user has not defined the combiner.
// We specialise the tests for lldb's handling of this behaviour as well,
// generating two test apps from the same source.
// This combiner is equivalent to the accumulator.
#if defined(RSTESTS_USER_COMBINER)
static void find_min_user_type_comb(user_t *accum, const user_t *val) {
  if (val->a + val->b * multiplier < accum->a + accum->b * multiplier) {
    accum->a = val->a;
    accum->b = val->b;
  }
}
#endif

static void find_min_user_type_outc(float *output, const user_t *val) {
  *output = val->a + val->b * multiplier;
}
