/*
 * Copyright (C) 2011-2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * This file is auto-generated. DO NOT MODIFY!
 * The source Renderscript file: reduce_general_inputs.rs
 */

package inputs;

import android.os.Build;
import android.os.Process;
import java.lang.reflect.Field;
import android.renderscript.*;
import inputs.reduce_general_inputsBitCode;

/**
 * @hide
 */
public class ScriptC_reduce_general_inputs extends ScriptC {
    private static final String __rs_resource_name = "reduce_general_inputs";
    // Constructor
    public  ScriptC_reduce_general_inputs(RenderScript rs) {
        super(rs,
              __rs_resource_name,
              reduce_general_inputsBitCode.getBitCode32(),
              reduce_general_inputsBitCode.getBitCode64());
        mRSLocal = rs;
        __I32 = Element.I32(rs);
        __F16 = Element.F16(rs);
        __F16_2 = Element.F16_2(rs);
        __F16_4 = Element.F16_4(rs);
        __F32 = Element.F32(rs);
        __F32_2 = Element.F32_2(rs);
        __F32_4 = Element.F32_4(rs);
        __I8 = Element.I8(rs);
        __I8_2 = Element.I8_2(rs);
        __I8_4 = Element.I8_4(rs);
        __I16 = Element.I16(rs);
        __I16_2 = Element.I16_2(rs);
        __I16_4 = Element.I16_4(rs);
        __U8 = Element.U8(rs);
        __U8_2 = Element.U8_2(rs);
        __U8_4 = Element.U8_4(rs);
        __U16 = Element.U16(rs);
        __U16_2 = Element.U16_2(rs);
        __U16_4 = Element.U16_4(rs);
        __BOOLEAN = Element.BOOLEAN(rs);
        __ScriptField_MyStruct = ScriptField_MyStruct.createElement(rs);
    }

    private Element __BOOLEAN;
    private Element __F16;
    private Element __F16_2;
    private Element __F16_4;
    private Element __F32;
    private Element __F32_2;
    private Element __F32_4;
    private Element __I16;
    private Element __I16_2;
    private Element __I16_4;
    private Element __I32;
    private Element __I8;
    private Element __I8_2;
    private Element __I8_4;
    private Element __ScriptField_MyStruct;
    private Element __U16;
    private Element __U16_2;
    private Element __U16_4;
    private Element __U8;
    private Element __U8_2;
    private Element __U8_4;
    private RenderScript mRSLocal;
    // To obtain the result, invoke get(), which blocks
    // until the asynchronously-launched operation has completed.
    public static class result_int {
        public int get() {
            if (!mGotResult) {
                int[] outArray = new int[1];
                mOut.copyTo(outArray);
                mResult = outArray[0];
                mOut.destroy();
                mOut = null;  // make Java object eligible for garbage collection
                if (mTempIns != null) {
                    for (Allocation tempIn : mTempIns) {
                        tempIn.destroy();
                    }

                    mTempIns = null;  // make Java objects eligible for garbage collection
                }

                mGotResult = true;
            }

            return mResult;
        }

        private  result_int(Allocation out) {
            mTempIns = null;
            mOut = out;
            mGotResult = false;
        }

        private Allocation[] mTempIns;
        private Allocation mOut;
        private boolean mGotResult;
        private int mResult;
    }

    private final static int mExportReduceIdx_my_half_half_0 = 0;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_half_half_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half_half_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half a"
    // ain2 = "half b"
    public result_int reduce_my_half_half_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half_half_0(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "half b"
    public result_int reduce_my_half_half_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_half_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_half_1 = 1;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_half_half_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half_half_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half a"
    // ain2 = "half b"
    public result_int reduce_my_half_half_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half_half_1(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "half b"
    public result_int reduce_my_half_half_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_half_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_half2_0 = 2;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_half_half2_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half_half2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half a"
    // ain2 = "half2 b"
    public result_int reduce_my_half_half2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half_half2_0(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "half2 b"
    public result_int reduce_my_half_half2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_half2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_half2_1 = 3;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_half_half2_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half_half2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half a"
    // ain2 = "half2 b"
    public result_int reduce_my_half_half2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half_half2_1(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "half2 b"
    public result_int reduce_my_half_half2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_half2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_half4_0 = 4;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_half_half4_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half_half4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half a"
    // ain2 = "half4 b"
    public result_int reduce_my_half_half4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half_half4_0(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "half4 b"
    public result_int reduce_my_half_half4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_half4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_half4_1 = 5;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_half_half4_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half_half4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half a"
    // ain2 = "half4 b"
    public result_int reduce_my_half_half4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half_half4_1(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "half4 b"
    public result_int reduce_my_half_half4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_half4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_float_0 = 6;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_half_float_0(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half_float_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half a"
    // ain2 = "float b"
    public result_int reduce_my_half_float_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half_float_0(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "float b"
    public result_int reduce_my_half_float_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_float_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_float_1 = 7;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_half_float_1(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half_float_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half a"
    // ain2 = "float b"
    public result_int reduce_my_half_float_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half_float_1(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "float b"
    public result_int reduce_my_half_float_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_float_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_float2_0 = 8;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_half_float2_0(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half_float2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half a"
    // ain2 = "float2 b"
    public result_int reduce_my_half_float2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half_float2_0(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "float2 b"
    public result_int reduce_my_half_float2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_float2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_float2_1 = 9;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_half_float2_1(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half_float2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half a"
    // ain2 = "float2 b"
    public result_int reduce_my_half_float2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half_float2_1(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "float2 b"
    public result_int reduce_my_half_float2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_float2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_float4_0 = 10;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_half_float4_0(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half_float4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half a"
    // ain2 = "float4 b"
    public result_int reduce_my_half_float4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half_float4_0(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "float4 b"
    public result_int reduce_my_half_float4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_float4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_float4_1 = 11;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_half_float4_1(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half_float4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half a"
    // ain2 = "float4 b"
    public result_int reduce_my_half_float4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half_float4_1(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "float4 b"
    public result_int reduce_my_half_float4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_float4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_char_0 = 12;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_half_char_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half_char_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half a"
    // ain2 = "char b"
    public result_int reduce_my_half_char_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half_char_0(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "char b"
    public result_int reduce_my_half_char_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_char_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_char_1 = 13;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_half_char_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half_char_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half a"
    // ain2 = "char b"
    public result_int reduce_my_half_char_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half_char_1(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "char b"
    public result_int reduce_my_half_char_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_char_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_char2_0 = 14;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_half_char2_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half_char2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half a"
    // ain2 = "char2 b"
    public result_int reduce_my_half_char2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half_char2_0(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "char2 b"
    public result_int reduce_my_half_char2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_char2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_char2_1 = 15;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_half_char2_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half_char2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half a"
    // ain2 = "char2 b"
    public result_int reduce_my_half_char2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half_char2_1(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "char2 b"
    public result_int reduce_my_half_char2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_char2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_char4_0 = 16;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_half_char4_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half_char4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half a"
    // ain2 = "char4 b"
    public result_int reduce_my_half_char4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half_char4_0(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "char4 b"
    public result_int reduce_my_half_char4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_char4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_char4_1 = 17;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_half_char4_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half_char4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half a"
    // ain2 = "char4 b"
    public result_int reduce_my_half_char4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half_char4_1(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "char4 b"
    public result_int reduce_my_half_char4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_char4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_short_0 = 18;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_half_short_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half_short_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half a"
    // ain2 = "short b"
    public result_int reduce_my_half_short_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half_short_0(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "short b"
    public result_int reduce_my_half_short_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_short_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_short_1 = 19;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_half_short_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half_short_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half a"
    // ain2 = "short b"
    public result_int reduce_my_half_short_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half_short_1(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "short b"
    public result_int reduce_my_half_short_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_short_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_short2_0 = 20;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_half_short2_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half_short2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half a"
    // ain2 = "short2 b"
    public result_int reduce_my_half_short2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half_short2_0(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "short2 b"
    public result_int reduce_my_half_short2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_short2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_short2_1 = 21;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_half_short2_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half_short2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half a"
    // ain2 = "short2 b"
    public result_int reduce_my_half_short2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half_short2_1(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "short2 b"
    public result_int reduce_my_half_short2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_short2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_short4_0 = 22;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_half_short4_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half_short4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half a"
    // ain2 = "short4 b"
    public result_int reduce_my_half_short4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half_short4_0(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "short4 b"
    public result_int reduce_my_half_short4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_short4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_short4_1 = 23;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_half_short4_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half_short4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half a"
    // ain2 = "short4 b"
    public result_int reduce_my_half_short4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half_short4_1(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "short4 b"
    public result_int reduce_my_half_short4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_short4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_uchar_0 = 24;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_half_uchar_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half_uchar_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half a"
    // ain2 = "uchar b"
    public result_int reduce_my_half_uchar_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half_uchar_0(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "uchar b"
    public result_int reduce_my_half_uchar_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_uchar_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_uchar_1 = 25;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_half_uchar_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half_uchar_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half a"
    // ain2 = "uchar b"
    public result_int reduce_my_half_uchar_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half_uchar_1(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "uchar b"
    public result_int reduce_my_half_uchar_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_uchar_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_uchar2_0 = 26;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_half_uchar2_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half_uchar2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_half_uchar2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half_uchar2_0(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_half_uchar2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_uchar2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_uchar2_1 = 27;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_half_uchar2_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half_uchar2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_half_uchar2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half_uchar2_1(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_half_uchar2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_uchar2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_uchar4_0 = 28;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_half_uchar4_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half_uchar4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_half_uchar4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half_uchar4_0(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_half_uchar4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_uchar4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_uchar4_1 = 29;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_half_uchar4_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half_uchar4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_half_uchar4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half_uchar4_1(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_half_uchar4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_uchar4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_ushort_0 = 30;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_half_ushort_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half_ushort_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half a"
    // ain2 = "ushort b"
    public result_int reduce_my_half_ushort_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half_ushort_0(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "ushort b"
    public result_int reduce_my_half_ushort_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_ushort_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_ushort_1 = 31;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_half_ushort_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half_ushort_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half a"
    // ain2 = "ushort b"
    public result_int reduce_my_half_ushort_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half_ushort_1(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "ushort b"
    public result_int reduce_my_half_ushort_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_ushort_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_ushort2_0 = 32;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_half_ushort2_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half_ushort2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_half_ushort2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half_ushort2_0(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_half_ushort2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_ushort2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_ushort2_1 = 33;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_half_ushort2_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half_ushort2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_half_ushort2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half_ushort2_1(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_half_ushort2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_ushort2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_ushort4_0 = 34;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_half_ushort4_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half_ushort4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_half_ushort4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half_ushort4_0(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_half_ushort4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_ushort4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_ushort4_1 = 35;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_half_ushort4_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half_ushort4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_half_ushort4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half_ushort4_1(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_half_ushort4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_ushort4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_bool_0 = 36;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_half_bool_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __BOOLEAN, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half_bool_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half a"
    // ain2 = "bool b"
    public result_int reduce_my_half_bool_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half_bool_0(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "bool b"
    public result_int reduce_my_half_bool_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_bool_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_bool_1 = 37;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_half_bool_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __BOOLEAN, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half_bool_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half a"
    // ain2 = "bool b"
    public result_int reduce_my_half_bool_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half_bool_1(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "bool b"
    public result_int reduce_my_half_bool_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_bool_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_rs_matrix2x2_0 = 38;
    // ain1 = "half a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_half_rs_matrix2x2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half_rs_matrix2x2_0(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_half_rs_matrix2x2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_rs_matrix2x2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_rs_matrix2x2_1 = 39;
    // ain1 = "half a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_half_rs_matrix2x2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half_rs_matrix2x2_1(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_half_rs_matrix2x2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_rs_matrix2x2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_MyStruct_0 = 40;
    // ain1 = "half a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_half_MyStruct_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half_MyStruct_0(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_half_MyStruct_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_MyStruct_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half_MyStruct_1 = 41;
    // ain1 = "half a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_half_MyStruct_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half_MyStruct_1(ain1, ain2, null);
    }

    // ain1 = "half a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_half_MyStruct_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half_MyStruct_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_half_0 = 42;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_half2_half_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half2_half_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half2 a"
    // ain2 = "half b"
    public result_int reduce_my_half2_half_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_half_0(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "half b"
    public result_int reduce_my_half2_half_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_half_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_half_1 = 43;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_half2_half_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half2_half_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half2 a"
    // ain2 = "half b"
    public result_int reduce_my_half2_half_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_half_1(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "half b"
    public result_int reduce_my_half2_half_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_half_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_half2_0 = 44;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_half2_half2_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half2_half2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half2 a"
    // ain2 = "half2 b"
    public result_int reduce_my_half2_half2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_half2_0(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "half2 b"
    public result_int reduce_my_half2_half2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_half2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_half2_1 = 45;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_half2_half2_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half2_half2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half2 a"
    // ain2 = "half2 b"
    public result_int reduce_my_half2_half2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_half2_1(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "half2 b"
    public result_int reduce_my_half2_half2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_half2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_half4_0 = 46;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_half2_half4_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half2_half4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half2 a"
    // ain2 = "half4 b"
    public result_int reduce_my_half2_half4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_half4_0(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "half4 b"
    public result_int reduce_my_half2_half4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_half4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_half4_1 = 47;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_half2_half4_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half2_half4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half2 a"
    // ain2 = "half4 b"
    public result_int reduce_my_half2_half4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_half4_1(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "half4 b"
    public result_int reduce_my_half2_half4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_half4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_float_0 = 48;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_half2_float_0(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half2_float_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half2 a"
    // ain2 = "float b"
    public result_int reduce_my_half2_float_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_float_0(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "float b"
    public result_int reduce_my_half2_float_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_float_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_float_1 = 49;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_half2_float_1(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half2_float_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half2 a"
    // ain2 = "float b"
    public result_int reduce_my_half2_float_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_float_1(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "float b"
    public result_int reduce_my_half2_float_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_float_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_float2_0 = 50;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_half2_float2_0(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half2_float2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half2 a"
    // ain2 = "float2 b"
    public result_int reduce_my_half2_float2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_float2_0(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "float2 b"
    public result_int reduce_my_half2_float2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_float2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_float2_1 = 51;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_half2_float2_1(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half2_float2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half2 a"
    // ain2 = "float2 b"
    public result_int reduce_my_half2_float2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_float2_1(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "float2 b"
    public result_int reduce_my_half2_float2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_float2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_float4_0 = 52;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_half2_float4_0(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half2_float4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half2 a"
    // ain2 = "float4 b"
    public result_int reduce_my_half2_float4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_float4_0(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "float4 b"
    public result_int reduce_my_half2_float4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_float4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_float4_1 = 53;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_half2_float4_1(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half2_float4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half2 a"
    // ain2 = "float4 b"
    public result_int reduce_my_half2_float4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_float4_1(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "float4 b"
    public result_int reduce_my_half2_float4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_float4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_char_0 = 54;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_half2_char_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half2_char_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half2 a"
    // ain2 = "char b"
    public result_int reduce_my_half2_char_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_char_0(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "char b"
    public result_int reduce_my_half2_char_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_char_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_char_1 = 55;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_half2_char_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half2_char_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half2 a"
    // ain2 = "char b"
    public result_int reduce_my_half2_char_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_char_1(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "char b"
    public result_int reduce_my_half2_char_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_char_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_char2_0 = 56;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_half2_char2_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half2_char2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half2 a"
    // ain2 = "char2 b"
    public result_int reduce_my_half2_char2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_char2_0(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "char2 b"
    public result_int reduce_my_half2_char2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_char2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_char2_1 = 57;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_half2_char2_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half2_char2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half2 a"
    // ain2 = "char2 b"
    public result_int reduce_my_half2_char2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_char2_1(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "char2 b"
    public result_int reduce_my_half2_char2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_char2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_char4_0 = 58;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_half2_char4_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half2_char4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half2 a"
    // ain2 = "char4 b"
    public result_int reduce_my_half2_char4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_char4_0(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "char4 b"
    public result_int reduce_my_half2_char4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_char4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_char4_1 = 59;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_half2_char4_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half2_char4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half2 a"
    // ain2 = "char4 b"
    public result_int reduce_my_half2_char4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_char4_1(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "char4 b"
    public result_int reduce_my_half2_char4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_char4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_short_0 = 60;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_half2_short_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half2_short_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half2 a"
    // ain2 = "short b"
    public result_int reduce_my_half2_short_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_short_0(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "short b"
    public result_int reduce_my_half2_short_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_short_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_short_1 = 61;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_half2_short_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half2_short_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half2 a"
    // ain2 = "short b"
    public result_int reduce_my_half2_short_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_short_1(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "short b"
    public result_int reduce_my_half2_short_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_short_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_short2_0 = 62;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_half2_short2_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half2_short2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half2 a"
    // ain2 = "short2 b"
    public result_int reduce_my_half2_short2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_short2_0(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "short2 b"
    public result_int reduce_my_half2_short2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_short2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_short2_1 = 63;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_half2_short2_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half2_short2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half2 a"
    // ain2 = "short2 b"
    public result_int reduce_my_half2_short2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_short2_1(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "short2 b"
    public result_int reduce_my_half2_short2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_short2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_short4_0 = 64;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_half2_short4_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half2_short4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half2 a"
    // ain2 = "short4 b"
    public result_int reduce_my_half2_short4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_short4_0(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "short4 b"
    public result_int reduce_my_half2_short4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_short4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_short4_1 = 65;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_half2_short4_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half2_short4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half2 a"
    // ain2 = "short4 b"
    public result_int reduce_my_half2_short4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_short4_1(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "short4 b"
    public result_int reduce_my_half2_short4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_short4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_uchar_0 = 66;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_half2_uchar_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half2_uchar_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half2 a"
    // ain2 = "uchar b"
    public result_int reduce_my_half2_uchar_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_uchar_0(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "uchar b"
    public result_int reduce_my_half2_uchar_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_uchar_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_uchar_1 = 67;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_half2_uchar_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half2_uchar_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half2 a"
    // ain2 = "uchar b"
    public result_int reduce_my_half2_uchar_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_uchar_1(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "uchar b"
    public result_int reduce_my_half2_uchar_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_uchar_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_uchar2_0 = 68;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_half2_uchar2_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half2_uchar2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half2 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_half2_uchar2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_uchar2_0(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_half2_uchar2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_uchar2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_uchar2_1 = 69;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_half2_uchar2_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half2_uchar2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half2 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_half2_uchar2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_uchar2_1(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_half2_uchar2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_uchar2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_uchar4_0 = 70;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_half2_uchar4_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half2_uchar4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half2 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_half2_uchar4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_uchar4_0(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_half2_uchar4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_uchar4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_uchar4_1 = 71;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_half2_uchar4_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half2_uchar4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half2 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_half2_uchar4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_uchar4_1(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_half2_uchar4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_uchar4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_ushort_0 = 72;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_half2_ushort_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half2_ushort_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half2 a"
    // ain2 = "ushort b"
    public result_int reduce_my_half2_ushort_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_ushort_0(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "ushort b"
    public result_int reduce_my_half2_ushort_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_ushort_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_ushort_1 = 73;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_half2_ushort_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half2_ushort_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half2 a"
    // ain2 = "ushort b"
    public result_int reduce_my_half2_ushort_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_ushort_1(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "ushort b"
    public result_int reduce_my_half2_ushort_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_ushort_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_ushort2_0 = 74;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_half2_ushort2_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half2_ushort2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half2 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_half2_ushort2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_ushort2_0(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_half2_ushort2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_ushort2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_ushort2_1 = 75;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_half2_ushort2_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half2_ushort2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half2 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_half2_ushort2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_ushort2_1(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_half2_ushort2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_ushort2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_ushort4_0 = 76;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_half2_ushort4_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half2_ushort4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half2 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_half2_ushort4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_ushort4_0(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_half2_ushort4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_ushort4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_ushort4_1 = 77;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_half2_ushort4_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half2_ushort4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half2 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_half2_ushort4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_ushort4_1(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_half2_ushort4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_ushort4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_bool_0 = 78;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_half2_bool_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __BOOLEAN, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half2_bool_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half2 a"
    // ain2 = "bool b"
    public result_int reduce_my_half2_bool_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_bool_0(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "bool b"
    public result_int reduce_my_half2_bool_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_bool_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_bool_1 = 79;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_half2_bool_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __BOOLEAN, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half2_bool_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half2 a"
    // ain2 = "bool b"
    public result_int reduce_my_half2_bool_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_bool_1(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "bool b"
    public result_int reduce_my_half2_bool_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_bool_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_rs_matrix2x2_0 = 80;
    // ain1 = "half2 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_half2_rs_matrix2x2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_rs_matrix2x2_0(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_half2_rs_matrix2x2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_rs_matrix2x2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_rs_matrix2x2_1 = 81;
    // ain1 = "half2 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_half2_rs_matrix2x2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_rs_matrix2x2_1(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_half2_rs_matrix2x2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_rs_matrix2x2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_MyStruct_0 = 82;
    // ain1 = "half2 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_half2_MyStruct_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_MyStruct_0(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_half2_MyStruct_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_MyStruct_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half2_MyStruct_1 = 83;
    // ain1 = "half2 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_half2_MyStruct_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half2_MyStruct_1(ain1, ain2, null);
    }

    // ain1 = "half2 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_half2_MyStruct_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half2_MyStruct_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_half_0 = 84;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_half4_half_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half4_half_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half4 a"
    // ain2 = "half b"
    public result_int reduce_my_half4_half_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_half_0(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "half b"
    public result_int reduce_my_half4_half_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_half_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_half_1 = 85;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_half4_half_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half4_half_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half4 a"
    // ain2 = "half b"
    public result_int reduce_my_half4_half_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_half_1(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "half b"
    public result_int reduce_my_half4_half_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_half_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_half2_0 = 86;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_half4_half2_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half4_half2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half4 a"
    // ain2 = "half2 b"
    public result_int reduce_my_half4_half2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_half2_0(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "half2 b"
    public result_int reduce_my_half4_half2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_half2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_half2_1 = 87;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_half4_half2_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half4_half2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half4 a"
    // ain2 = "half2 b"
    public result_int reduce_my_half4_half2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_half2_1(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "half2 b"
    public result_int reduce_my_half4_half2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_half2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_half4_0 = 88;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_half4_half4_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half4_half4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half4 a"
    // ain2 = "half4 b"
    public result_int reduce_my_half4_half4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_half4_0(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "half4 b"
    public result_int reduce_my_half4_half4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_half4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_half4_1 = 89;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_half4_half4_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half4_half4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half4 a"
    // ain2 = "half4 b"
    public result_int reduce_my_half4_half4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_half4_1(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "half4 b"
    public result_int reduce_my_half4_half4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_half4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_float_0 = 90;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_half4_float_0(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half4_float_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half4 a"
    // ain2 = "float b"
    public result_int reduce_my_half4_float_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_float_0(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "float b"
    public result_int reduce_my_half4_float_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_float_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_float_1 = 91;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_half4_float_1(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half4_float_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half4 a"
    // ain2 = "float b"
    public result_int reduce_my_half4_float_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_float_1(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "float b"
    public result_int reduce_my_half4_float_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_float_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_float2_0 = 92;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_half4_float2_0(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half4_float2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half4 a"
    // ain2 = "float2 b"
    public result_int reduce_my_half4_float2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_float2_0(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "float2 b"
    public result_int reduce_my_half4_float2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_float2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_float2_1 = 93;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_half4_float2_1(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half4_float2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half4 a"
    // ain2 = "float2 b"
    public result_int reduce_my_half4_float2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_float2_1(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "float2 b"
    public result_int reduce_my_half4_float2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_float2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_float4_0 = 94;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_half4_float4_0(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half4_float4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half4 a"
    // ain2 = "float4 b"
    public result_int reduce_my_half4_float4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_float4_0(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "float4 b"
    public result_int reduce_my_half4_float4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_float4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_float4_1 = 95;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_half4_float4_1(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half4_float4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half4 a"
    // ain2 = "float4 b"
    public result_int reduce_my_half4_float4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_float4_1(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "float4 b"
    public result_int reduce_my_half4_float4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_float4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_char_0 = 96;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_half4_char_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half4_char_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half4 a"
    // ain2 = "char b"
    public result_int reduce_my_half4_char_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_char_0(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "char b"
    public result_int reduce_my_half4_char_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_char_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_char_1 = 97;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_half4_char_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half4_char_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half4 a"
    // ain2 = "char b"
    public result_int reduce_my_half4_char_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_char_1(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "char b"
    public result_int reduce_my_half4_char_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_char_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_char2_0 = 98;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_half4_char2_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half4_char2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half4 a"
    // ain2 = "char2 b"
    public result_int reduce_my_half4_char2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_char2_0(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "char2 b"
    public result_int reduce_my_half4_char2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_char2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_char2_1 = 99;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_half4_char2_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half4_char2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half4 a"
    // ain2 = "char2 b"
    public result_int reduce_my_half4_char2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_char2_1(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "char2 b"
    public result_int reduce_my_half4_char2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_char2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_char4_0 = 100;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_half4_char4_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half4_char4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half4 a"
    // ain2 = "char4 b"
    public result_int reduce_my_half4_char4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_char4_0(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "char4 b"
    public result_int reduce_my_half4_char4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_char4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_char4_1 = 101;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_half4_char4_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half4_char4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half4 a"
    // ain2 = "char4 b"
    public result_int reduce_my_half4_char4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_char4_1(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "char4 b"
    public result_int reduce_my_half4_char4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_char4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_short_0 = 102;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_half4_short_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half4_short_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half4 a"
    // ain2 = "short b"
    public result_int reduce_my_half4_short_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_short_0(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "short b"
    public result_int reduce_my_half4_short_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_short_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_short_1 = 103;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_half4_short_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half4_short_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half4 a"
    // ain2 = "short b"
    public result_int reduce_my_half4_short_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_short_1(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "short b"
    public result_int reduce_my_half4_short_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_short_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_short2_0 = 104;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_half4_short2_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half4_short2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half4 a"
    // ain2 = "short2 b"
    public result_int reduce_my_half4_short2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_short2_0(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "short2 b"
    public result_int reduce_my_half4_short2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_short2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_short2_1 = 105;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_half4_short2_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half4_short2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half4 a"
    // ain2 = "short2 b"
    public result_int reduce_my_half4_short2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_short2_1(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "short2 b"
    public result_int reduce_my_half4_short2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_short2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_short4_0 = 106;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_half4_short4_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half4_short4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half4 a"
    // ain2 = "short4 b"
    public result_int reduce_my_half4_short4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_short4_0(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "short4 b"
    public result_int reduce_my_half4_short4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_short4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_short4_1 = 107;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_half4_short4_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half4_short4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half4 a"
    // ain2 = "short4 b"
    public result_int reduce_my_half4_short4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_short4_1(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "short4 b"
    public result_int reduce_my_half4_short4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_short4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_uchar_0 = 108;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_half4_uchar_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half4_uchar_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half4 a"
    // ain2 = "uchar b"
    public result_int reduce_my_half4_uchar_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_uchar_0(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "uchar b"
    public result_int reduce_my_half4_uchar_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_uchar_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_uchar_1 = 109;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_half4_uchar_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half4_uchar_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half4 a"
    // ain2 = "uchar b"
    public result_int reduce_my_half4_uchar_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_uchar_1(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "uchar b"
    public result_int reduce_my_half4_uchar_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_uchar_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_uchar2_0 = 110;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_half4_uchar2_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half4_uchar2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half4 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_half4_uchar2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_uchar2_0(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_half4_uchar2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_uchar2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_uchar2_1 = 111;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_half4_uchar2_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half4_uchar2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half4 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_half4_uchar2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_uchar2_1(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_half4_uchar2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_uchar2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_uchar4_0 = 112;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_half4_uchar4_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half4_uchar4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half4 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_half4_uchar4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_uchar4_0(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_half4_uchar4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_uchar4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_uchar4_1 = 113;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_half4_uchar4_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half4_uchar4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half4 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_half4_uchar4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_uchar4_1(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_half4_uchar4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_uchar4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_ushort_0 = 114;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_half4_ushort_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half4_ushort_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half4 a"
    // ain2 = "ushort b"
    public result_int reduce_my_half4_ushort_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_ushort_0(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "ushort b"
    public result_int reduce_my_half4_ushort_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_ushort_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_ushort_1 = 115;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_half4_ushort_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half4_ushort_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half4 a"
    // ain2 = "ushort b"
    public result_int reduce_my_half4_ushort_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_ushort_1(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "ushort b"
    public result_int reduce_my_half4_ushort_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_ushort_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_ushort2_0 = 116;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_half4_ushort2_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half4_ushort2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half4 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_half4_ushort2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_ushort2_0(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_half4_ushort2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_ushort2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_ushort2_1 = 117;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_half4_ushort2_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half4_ushort2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half4 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_half4_ushort2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_ushort2_1(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_half4_ushort2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_ushort2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_ushort4_0 = 118;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_half4_ushort4_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half4_ushort4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half4 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_half4_ushort4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_ushort4_0(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_half4_ushort4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_ushort4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_ushort4_1 = 119;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_half4_ushort4_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half4_ushort4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half4 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_half4_ushort4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_ushort4_1(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_half4_ushort4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_ushort4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_bool_0 = 120;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_half4_bool_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __BOOLEAN, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half4_bool_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half4 a"
    // ain2 = "bool b"
    public result_int reduce_my_half4_bool_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_bool_0(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "bool b"
    public result_int reduce_my_half4_bool_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_bool_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_bool_1 = 121;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_half4_bool_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __BOOLEAN, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_half4_bool_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "half4 a"
    // ain2 = "bool b"
    public result_int reduce_my_half4_bool_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_bool_1(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "bool b"
    public result_int reduce_my_half4_bool_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_bool_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_rs_matrix2x2_0 = 122;
    // ain1 = "half4 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_half4_rs_matrix2x2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_rs_matrix2x2_0(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_half4_rs_matrix2x2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_rs_matrix2x2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_rs_matrix2x2_1 = 123;
    // ain1 = "half4 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_half4_rs_matrix2x2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_rs_matrix2x2_1(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_half4_rs_matrix2x2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_rs_matrix2x2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_MyStruct_0 = 124;
    // ain1 = "half4 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_half4_MyStruct_0(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_MyStruct_0(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_half4_MyStruct_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_MyStruct_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_half4_MyStruct_1 = 125;
    // ain1 = "half4 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_half4_MyStruct_1(Allocation ain1, Allocation ain2) {
        return reduce_my_half4_MyStruct_1(ain1, ain2, null);
    }

    // ain1 = "half4 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_half4_MyStruct_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_half4_MyStruct_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_half_0 = 126;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_float_half_0(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float_half_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float a"
    // ain2 = "half b"
    public result_int reduce_my_float_half_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float_half_0(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "half b"
    public result_int reduce_my_float_half_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_half_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_half_1 = 127;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_float_half_1(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float_half_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float a"
    // ain2 = "half b"
    public result_int reduce_my_float_half_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float_half_1(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "half b"
    public result_int reduce_my_float_half_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_half_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_half2_0 = 128;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_float_half2_0(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float_half2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float a"
    // ain2 = "half2 b"
    public result_int reduce_my_float_half2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float_half2_0(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "half2 b"
    public result_int reduce_my_float_half2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_half2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_half2_1 = 129;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_float_half2_1(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float_half2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float a"
    // ain2 = "half2 b"
    public result_int reduce_my_float_half2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float_half2_1(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "half2 b"
    public result_int reduce_my_float_half2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_half2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_half4_0 = 130;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_float_half4_0(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float_half4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float a"
    // ain2 = "half4 b"
    public result_int reduce_my_float_half4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float_half4_0(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "half4 b"
    public result_int reduce_my_float_half4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_half4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_half4_1 = 131;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_float_half4_1(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float_half4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float a"
    // ain2 = "half4 b"
    public result_int reduce_my_float_half4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float_half4_1(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "half4 b"
    public result_int reduce_my_float_half4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_half4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_float_0 = 132;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_float_float_0(float[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float_float_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float a"
    // ain2 = "float b"
    public result_int reduce_my_float_float_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float_float_0(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "float b"
    public result_int reduce_my_float_float_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_float_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_float_1 = 133;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_float_float_1(float[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float_float_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float a"
    // ain2 = "float b"
    public result_int reduce_my_float_float_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float_float_1(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "float b"
    public result_int reduce_my_float_float_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_float_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_float2_0 = 134;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_float_float2_0(float[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float_float2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float a"
    // ain2 = "float2 b"
    public result_int reduce_my_float_float2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float_float2_0(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "float2 b"
    public result_int reduce_my_float_float2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_float2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_float2_1 = 135;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_float_float2_1(float[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float_float2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float a"
    // ain2 = "float2 b"
    public result_int reduce_my_float_float2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float_float2_1(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "float2 b"
    public result_int reduce_my_float_float2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_float2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_float4_0 = 136;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_float_float4_0(float[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float_float4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float a"
    // ain2 = "float4 b"
    public result_int reduce_my_float_float4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float_float4_0(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "float4 b"
    public result_int reduce_my_float_float4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_float4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_float4_1 = 137;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_float_float4_1(float[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float_float4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float a"
    // ain2 = "float4 b"
    public result_int reduce_my_float_float4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float_float4_1(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "float4 b"
    public result_int reduce_my_float_float4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_float4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_char_0 = 138;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_float_char_0(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float_char_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float a"
    // ain2 = "char b"
    public result_int reduce_my_float_char_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float_char_0(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "char b"
    public result_int reduce_my_float_char_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_char_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_char_1 = 139;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_float_char_1(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float_char_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float a"
    // ain2 = "char b"
    public result_int reduce_my_float_char_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float_char_1(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "char b"
    public result_int reduce_my_float_char_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_char_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_char2_0 = 140;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_float_char2_0(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float_char2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float a"
    // ain2 = "char2 b"
    public result_int reduce_my_float_char2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float_char2_0(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "char2 b"
    public result_int reduce_my_float_char2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_char2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_char2_1 = 141;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_float_char2_1(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float_char2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float a"
    // ain2 = "char2 b"
    public result_int reduce_my_float_char2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float_char2_1(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "char2 b"
    public result_int reduce_my_float_char2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_char2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_char4_0 = 142;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_float_char4_0(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float_char4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float a"
    // ain2 = "char4 b"
    public result_int reduce_my_float_char4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float_char4_0(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "char4 b"
    public result_int reduce_my_float_char4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_char4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_char4_1 = 143;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_float_char4_1(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float_char4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float a"
    // ain2 = "char4 b"
    public result_int reduce_my_float_char4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float_char4_1(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "char4 b"
    public result_int reduce_my_float_char4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_char4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_short_0 = 144;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_float_short_0(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float_short_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float a"
    // ain2 = "short b"
    public result_int reduce_my_float_short_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float_short_0(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "short b"
    public result_int reduce_my_float_short_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_short_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_short_1 = 145;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_float_short_1(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float_short_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float a"
    // ain2 = "short b"
    public result_int reduce_my_float_short_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float_short_1(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "short b"
    public result_int reduce_my_float_short_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_short_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_short2_0 = 146;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_float_short2_0(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float_short2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float a"
    // ain2 = "short2 b"
    public result_int reduce_my_float_short2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float_short2_0(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "short2 b"
    public result_int reduce_my_float_short2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_short2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_short2_1 = 147;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_float_short2_1(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float_short2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float a"
    // ain2 = "short2 b"
    public result_int reduce_my_float_short2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float_short2_1(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "short2 b"
    public result_int reduce_my_float_short2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_short2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_short4_0 = 148;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_float_short4_0(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float_short4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float a"
    // ain2 = "short4 b"
    public result_int reduce_my_float_short4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float_short4_0(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "short4 b"
    public result_int reduce_my_float_short4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_short4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_short4_1 = 149;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_float_short4_1(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float_short4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float a"
    // ain2 = "short4 b"
    public result_int reduce_my_float_short4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float_short4_1(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "short4 b"
    public result_int reduce_my_float_short4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_short4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_uchar_0 = 150;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_float_uchar_0(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float_uchar_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float a"
    // ain2 = "uchar b"
    public result_int reduce_my_float_uchar_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float_uchar_0(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "uchar b"
    public result_int reduce_my_float_uchar_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_uchar_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_uchar_1 = 151;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_float_uchar_1(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float_uchar_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float a"
    // ain2 = "uchar b"
    public result_int reduce_my_float_uchar_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float_uchar_1(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "uchar b"
    public result_int reduce_my_float_uchar_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_uchar_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_uchar2_0 = 152;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_float_uchar2_0(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float_uchar2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_float_uchar2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float_uchar2_0(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_float_uchar2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_uchar2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_uchar2_1 = 153;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_float_uchar2_1(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float_uchar2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_float_uchar2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float_uchar2_1(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_float_uchar2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_uchar2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_uchar4_0 = 154;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_float_uchar4_0(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float_uchar4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_float_uchar4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float_uchar4_0(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_float_uchar4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_uchar4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_uchar4_1 = 155;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_float_uchar4_1(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float_uchar4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_float_uchar4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float_uchar4_1(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_float_uchar4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_uchar4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_ushort_0 = 156;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_float_ushort_0(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float_ushort_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float a"
    // ain2 = "ushort b"
    public result_int reduce_my_float_ushort_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float_ushort_0(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "ushort b"
    public result_int reduce_my_float_ushort_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_ushort_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_ushort_1 = 157;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_float_ushort_1(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float_ushort_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float a"
    // ain2 = "ushort b"
    public result_int reduce_my_float_ushort_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float_ushort_1(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "ushort b"
    public result_int reduce_my_float_ushort_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_ushort_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_ushort2_0 = 158;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_float_ushort2_0(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float_ushort2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_float_ushort2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float_ushort2_0(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_float_ushort2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_ushort2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_ushort2_1 = 159;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_float_ushort2_1(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float_ushort2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_float_ushort2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float_ushort2_1(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_float_ushort2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_ushort2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_ushort4_0 = 160;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_float_ushort4_0(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float_ushort4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_float_ushort4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float_ushort4_0(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_float_ushort4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_ushort4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_ushort4_1 = 161;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_float_ushort4_1(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float_ushort4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_float_ushort4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float_ushort4_1(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_float_ushort4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_ushort4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_bool_0 = 162;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_float_bool_0(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __BOOLEAN, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float_bool_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float a"
    // ain2 = "bool b"
    public result_int reduce_my_float_bool_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float_bool_0(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "bool b"
    public result_int reduce_my_float_bool_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_bool_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_bool_1 = 163;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_float_bool_1(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __BOOLEAN, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float_bool_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float a"
    // ain2 = "bool b"
    public result_int reduce_my_float_bool_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float_bool_1(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "bool b"
    public result_int reduce_my_float_bool_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_bool_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_rs_matrix2x2_0 = 164;
    // ain1 = "float a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_float_rs_matrix2x2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float_rs_matrix2x2_0(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_float_rs_matrix2x2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_rs_matrix2x2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_rs_matrix2x2_1 = 165;
    // ain1 = "float a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_float_rs_matrix2x2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float_rs_matrix2x2_1(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_float_rs_matrix2x2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_rs_matrix2x2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_MyStruct_0 = 166;
    // ain1 = "float a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_float_MyStruct_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float_MyStruct_0(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_float_MyStruct_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_MyStruct_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float_MyStruct_1 = 167;
    // ain1 = "float a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_float_MyStruct_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float_MyStruct_1(ain1, ain2, null);
    }

    // ain1 = "float a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_float_MyStruct_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float_MyStruct_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_half_0 = 168;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_float2_half_0(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float2_half_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float2 a"
    // ain2 = "half b"
    public result_int reduce_my_float2_half_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_half_0(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "half b"
    public result_int reduce_my_float2_half_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_half_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_half_1 = 169;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_float2_half_1(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float2_half_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float2 a"
    // ain2 = "half b"
    public result_int reduce_my_float2_half_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_half_1(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "half b"
    public result_int reduce_my_float2_half_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_half_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_half2_0 = 170;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_float2_half2_0(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float2_half2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float2 a"
    // ain2 = "half2 b"
    public result_int reduce_my_float2_half2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_half2_0(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "half2 b"
    public result_int reduce_my_float2_half2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_half2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_half2_1 = 171;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_float2_half2_1(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float2_half2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float2 a"
    // ain2 = "half2 b"
    public result_int reduce_my_float2_half2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_half2_1(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "half2 b"
    public result_int reduce_my_float2_half2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_half2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_half4_0 = 172;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_float2_half4_0(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float2_half4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float2 a"
    // ain2 = "half4 b"
    public result_int reduce_my_float2_half4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_half4_0(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "half4 b"
    public result_int reduce_my_float2_half4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_half4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_half4_1 = 173;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_float2_half4_1(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float2_half4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float2 a"
    // ain2 = "half4 b"
    public result_int reduce_my_float2_half4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_half4_1(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "half4 b"
    public result_int reduce_my_float2_half4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_half4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_float_0 = 174;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_float2_float_0(float[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float2_float_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float2 a"
    // ain2 = "float b"
    public result_int reduce_my_float2_float_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_float_0(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "float b"
    public result_int reduce_my_float2_float_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_float_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_float_1 = 175;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_float2_float_1(float[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float2_float_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float2 a"
    // ain2 = "float b"
    public result_int reduce_my_float2_float_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_float_1(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "float b"
    public result_int reduce_my_float2_float_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_float_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_float2_0 = 176;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_float2_float2_0(float[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float2_float2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float2 a"
    // ain2 = "float2 b"
    public result_int reduce_my_float2_float2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_float2_0(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "float2 b"
    public result_int reduce_my_float2_float2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_float2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_float2_1 = 177;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_float2_float2_1(float[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float2_float2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float2 a"
    // ain2 = "float2 b"
    public result_int reduce_my_float2_float2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_float2_1(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "float2 b"
    public result_int reduce_my_float2_float2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_float2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_float4_0 = 178;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_float2_float4_0(float[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float2_float4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float2 a"
    // ain2 = "float4 b"
    public result_int reduce_my_float2_float4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_float4_0(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "float4 b"
    public result_int reduce_my_float2_float4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_float4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_float4_1 = 179;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_float2_float4_1(float[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float2_float4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float2 a"
    // ain2 = "float4 b"
    public result_int reduce_my_float2_float4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_float4_1(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "float4 b"
    public result_int reduce_my_float2_float4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_float4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_char_0 = 180;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_float2_char_0(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float2_char_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float2 a"
    // ain2 = "char b"
    public result_int reduce_my_float2_char_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_char_0(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "char b"
    public result_int reduce_my_float2_char_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_char_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_char_1 = 181;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_float2_char_1(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float2_char_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float2 a"
    // ain2 = "char b"
    public result_int reduce_my_float2_char_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_char_1(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "char b"
    public result_int reduce_my_float2_char_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_char_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_char2_0 = 182;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_float2_char2_0(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float2_char2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float2 a"
    // ain2 = "char2 b"
    public result_int reduce_my_float2_char2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_char2_0(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "char2 b"
    public result_int reduce_my_float2_char2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_char2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_char2_1 = 183;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_float2_char2_1(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float2_char2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float2 a"
    // ain2 = "char2 b"
    public result_int reduce_my_float2_char2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_char2_1(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "char2 b"
    public result_int reduce_my_float2_char2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_char2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_char4_0 = 184;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_float2_char4_0(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float2_char4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float2 a"
    // ain2 = "char4 b"
    public result_int reduce_my_float2_char4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_char4_0(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "char4 b"
    public result_int reduce_my_float2_char4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_char4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_char4_1 = 185;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_float2_char4_1(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float2_char4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float2 a"
    // ain2 = "char4 b"
    public result_int reduce_my_float2_char4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_char4_1(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "char4 b"
    public result_int reduce_my_float2_char4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_char4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_short_0 = 186;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_float2_short_0(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float2_short_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float2 a"
    // ain2 = "short b"
    public result_int reduce_my_float2_short_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_short_0(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "short b"
    public result_int reduce_my_float2_short_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_short_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_short_1 = 187;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_float2_short_1(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float2_short_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float2 a"
    // ain2 = "short b"
    public result_int reduce_my_float2_short_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_short_1(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "short b"
    public result_int reduce_my_float2_short_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_short_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_short2_0 = 188;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_float2_short2_0(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float2_short2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float2 a"
    // ain2 = "short2 b"
    public result_int reduce_my_float2_short2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_short2_0(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "short2 b"
    public result_int reduce_my_float2_short2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_short2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_short2_1 = 189;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_float2_short2_1(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float2_short2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float2 a"
    // ain2 = "short2 b"
    public result_int reduce_my_float2_short2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_short2_1(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "short2 b"
    public result_int reduce_my_float2_short2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_short2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_short4_0 = 190;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_float2_short4_0(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float2_short4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float2 a"
    // ain2 = "short4 b"
    public result_int reduce_my_float2_short4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_short4_0(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "short4 b"
    public result_int reduce_my_float2_short4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_short4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_short4_1 = 191;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_float2_short4_1(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float2_short4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float2 a"
    // ain2 = "short4 b"
    public result_int reduce_my_float2_short4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_short4_1(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "short4 b"
    public result_int reduce_my_float2_short4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_short4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_uchar_0 = 192;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_float2_uchar_0(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float2_uchar_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float2 a"
    // ain2 = "uchar b"
    public result_int reduce_my_float2_uchar_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_uchar_0(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "uchar b"
    public result_int reduce_my_float2_uchar_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_uchar_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_uchar_1 = 193;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_float2_uchar_1(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float2_uchar_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float2 a"
    // ain2 = "uchar b"
    public result_int reduce_my_float2_uchar_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_uchar_1(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "uchar b"
    public result_int reduce_my_float2_uchar_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_uchar_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_uchar2_0 = 194;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_float2_uchar2_0(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float2_uchar2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float2 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_float2_uchar2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_uchar2_0(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_float2_uchar2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_uchar2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_uchar2_1 = 195;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_float2_uchar2_1(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float2_uchar2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float2 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_float2_uchar2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_uchar2_1(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_float2_uchar2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_uchar2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_uchar4_0 = 196;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_float2_uchar4_0(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float2_uchar4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float2 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_float2_uchar4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_uchar4_0(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_float2_uchar4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_uchar4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_uchar4_1 = 197;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_float2_uchar4_1(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float2_uchar4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float2 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_float2_uchar4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_uchar4_1(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_float2_uchar4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_uchar4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_ushort_0 = 198;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_float2_ushort_0(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float2_ushort_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float2 a"
    // ain2 = "ushort b"
    public result_int reduce_my_float2_ushort_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_ushort_0(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "ushort b"
    public result_int reduce_my_float2_ushort_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_ushort_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_ushort_1 = 199;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_float2_ushort_1(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float2_ushort_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float2 a"
    // ain2 = "ushort b"
    public result_int reduce_my_float2_ushort_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_ushort_1(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "ushort b"
    public result_int reduce_my_float2_ushort_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_ushort_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_ushort2_0 = 200;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_float2_ushort2_0(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float2_ushort2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float2 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_float2_ushort2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_ushort2_0(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_float2_ushort2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_ushort2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_ushort2_1 = 201;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_float2_ushort2_1(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float2_ushort2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float2 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_float2_ushort2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_ushort2_1(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_float2_ushort2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_ushort2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_ushort4_0 = 202;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_float2_ushort4_0(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float2_ushort4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float2 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_float2_ushort4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_ushort4_0(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_float2_ushort4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_ushort4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_ushort4_1 = 203;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_float2_ushort4_1(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float2_ushort4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float2 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_float2_ushort4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_ushort4_1(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_float2_ushort4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_ushort4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_bool_0 = 204;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_float2_bool_0(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __BOOLEAN, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float2_bool_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float2 a"
    // ain2 = "bool b"
    public result_int reduce_my_float2_bool_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_bool_0(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "bool b"
    public result_int reduce_my_float2_bool_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_bool_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_bool_1 = 205;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_float2_bool_1(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __BOOLEAN, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float2_bool_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float2 a"
    // ain2 = "bool b"
    public result_int reduce_my_float2_bool_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_bool_1(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "bool b"
    public result_int reduce_my_float2_bool_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_bool_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_rs_matrix2x2_0 = 206;
    // ain1 = "float2 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_float2_rs_matrix2x2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_rs_matrix2x2_0(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_float2_rs_matrix2x2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_rs_matrix2x2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_rs_matrix2x2_1 = 207;
    // ain1 = "float2 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_float2_rs_matrix2x2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_rs_matrix2x2_1(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_float2_rs_matrix2x2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_rs_matrix2x2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_MyStruct_0 = 208;
    // ain1 = "float2 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_float2_MyStruct_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_MyStruct_0(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_float2_MyStruct_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_MyStruct_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float2_MyStruct_1 = 209;
    // ain1 = "float2 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_float2_MyStruct_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float2_MyStruct_1(ain1, ain2, null);
    }

    // ain1 = "float2 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_float2_MyStruct_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float2_MyStruct_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_half_0 = 210;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_float4_half_0(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float4_half_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float4 a"
    // ain2 = "half b"
    public result_int reduce_my_float4_half_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_half_0(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "half b"
    public result_int reduce_my_float4_half_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_half_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_half_1 = 211;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_float4_half_1(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float4_half_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float4 a"
    // ain2 = "half b"
    public result_int reduce_my_float4_half_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_half_1(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "half b"
    public result_int reduce_my_float4_half_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_half_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_half2_0 = 212;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_float4_half2_0(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float4_half2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float4 a"
    // ain2 = "half2 b"
    public result_int reduce_my_float4_half2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_half2_0(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "half2 b"
    public result_int reduce_my_float4_half2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_half2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_half2_1 = 213;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_float4_half2_1(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float4_half2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float4 a"
    // ain2 = "half2 b"
    public result_int reduce_my_float4_half2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_half2_1(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "half2 b"
    public result_int reduce_my_float4_half2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_half2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_half4_0 = 214;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_float4_half4_0(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float4_half4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float4 a"
    // ain2 = "half4 b"
    public result_int reduce_my_float4_half4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_half4_0(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "half4 b"
    public result_int reduce_my_float4_half4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_half4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_half4_1 = 215;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_float4_half4_1(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float4_half4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float4 a"
    // ain2 = "half4 b"
    public result_int reduce_my_float4_half4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_half4_1(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "half4 b"
    public result_int reduce_my_float4_half4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_half4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_float_0 = 216;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_float4_float_0(float[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float4_float_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float4 a"
    // ain2 = "float b"
    public result_int reduce_my_float4_float_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_float_0(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "float b"
    public result_int reduce_my_float4_float_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_float_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_float_1 = 217;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_float4_float_1(float[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float4_float_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float4 a"
    // ain2 = "float b"
    public result_int reduce_my_float4_float_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_float_1(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "float b"
    public result_int reduce_my_float4_float_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_float_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_float2_0 = 218;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_float4_float2_0(float[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float4_float2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float4 a"
    // ain2 = "float2 b"
    public result_int reduce_my_float4_float2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_float2_0(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "float2 b"
    public result_int reduce_my_float4_float2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_float2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_float2_1 = 219;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_float4_float2_1(float[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float4_float2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float4 a"
    // ain2 = "float2 b"
    public result_int reduce_my_float4_float2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_float2_1(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "float2 b"
    public result_int reduce_my_float4_float2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_float2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_float4_0 = 220;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_float4_float4_0(float[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float4_float4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float4 a"
    // ain2 = "float4 b"
    public result_int reduce_my_float4_float4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_float4_0(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "float4 b"
    public result_int reduce_my_float4_float4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_float4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_float4_1 = 221;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_float4_float4_1(float[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float4_float4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float4 a"
    // ain2 = "float4 b"
    public result_int reduce_my_float4_float4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_float4_1(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "float4 b"
    public result_int reduce_my_float4_float4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_float4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_char_0 = 222;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_float4_char_0(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float4_char_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float4 a"
    // ain2 = "char b"
    public result_int reduce_my_float4_char_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_char_0(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "char b"
    public result_int reduce_my_float4_char_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_char_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_char_1 = 223;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_float4_char_1(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float4_char_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float4 a"
    // ain2 = "char b"
    public result_int reduce_my_float4_char_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_char_1(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "char b"
    public result_int reduce_my_float4_char_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_char_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_char2_0 = 224;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_float4_char2_0(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float4_char2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float4 a"
    // ain2 = "char2 b"
    public result_int reduce_my_float4_char2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_char2_0(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "char2 b"
    public result_int reduce_my_float4_char2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_char2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_char2_1 = 225;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_float4_char2_1(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float4_char2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float4 a"
    // ain2 = "char2 b"
    public result_int reduce_my_float4_char2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_char2_1(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "char2 b"
    public result_int reduce_my_float4_char2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_char2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_char4_0 = 226;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_float4_char4_0(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float4_char4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float4 a"
    // ain2 = "char4 b"
    public result_int reduce_my_float4_char4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_char4_0(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "char4 b"
    public result_int reduce_my_float4_char4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_char4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_char4_1 = 227;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_float4_char4_1(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float4_char4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float4 a"
    // ain2 = "char4 b"
    public result_int reduce_my_float4_char4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_char4_1(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "char4 b"
    public result_int reduce_my_float4_char4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_char4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_short_0 = 228;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_float4_short_0(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float4_short_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float4 a"
    // ain2 = "short b"
    public result_int reduce_my_float4_short_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_short_0(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "short b"
    public result_int reduce_my_float4_short_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_short_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_short_1 = 229;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_float4_short_1(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float4_short_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float4 a"
    // ain2 = "short b"
    public result_int reduce_my_float4_short_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_short_1(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "short b"
    public result_int reduce_my_float4_short_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_short_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_short2_0 = 230;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_float4_short2_0(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float4_short2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float4 a"
    // ain2 = "short2 b"
    public result_int reduce_my_float4_short2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_short2_0(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "short2 b"
    public result_int reduce_my_float4_short2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_short2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_short2_1 = 231;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_float4_short2_1(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float4_short2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float4 a"
    // ain2 = "short2 b"
    public result_int reduce_my_float4_short2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_short2_1(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "short2 b"
    public result_int reduce_my_float4_short2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_short2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_short4_0 = 232;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_float4_short4_0(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float4_short4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float4 a"
    // ain2 = "short4 b"
    public result_int reduce_my_float4_short4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_short4_0(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "short4 b"
    public result_int reduce_my_float4_short4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_short4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_short4_1 = 233;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_float4_short4_1(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float4_short4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float4 a"
    // ain2 = "short4 b"
    public result_int reduce_my_float4_short4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_short4_1(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "short4 b"
    public result_int reduce_my_float4_short4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_short4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_uchar_0 = 234;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_float4_uchar_0(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float4_uchar_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float4 a"
    // ain2 = "uchar b"
    public result_int reduce_my_float4_uchar_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_uchar_0(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "uchar b"
    public result_int reduce_my_float4_uchar_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_uchar_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_uchar_1 = 235;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_float4_uchar_1(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float4_uchar_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float4 a"
    // ain2 = "uchar b"
    public result_int reduce_my_float4_uchar_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_uchar_1(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "uchar b"
    public result_int reduce_my_float4_uchar_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_uchar_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_uchar2_0 = 236;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_float4_uchar2_0(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float4_uchar2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float4 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_float4_uchar2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_uchar2_0(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_float4_uchar2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_uchar2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_uchar2_1 = 237;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_float4_uchar2_1(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float4_uchar2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float4 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_float4_uchar2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_uchar2_1(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_float4_uchar2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_uchar2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_uchar4_0 = 238;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_float4_uchar4_0(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float4_uchar4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float4 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_float4_uchar4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_uchar4_0(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_float4_uchar4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_uchar4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_uchar4_1 = 239;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_float4_uchar4_1(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float4_uchar4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float4 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_float4_uchar4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_uchar4_1(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_float4_uchar4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_uchar4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_ushort_0 = 240;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_float4_ushort_0(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float4_ushort_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float4 a"
    // ain2 = "ushort b"
    public result_int reduce_my_float4_ushort_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_ushort_0(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "ushort b"
    public result_int reduce_my_float4_ushort_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_ushort_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_ushort_1 = 241;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_float4_ushort_1(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float4_ushort_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float4 a"
    // ain2 = "ushort b"
    public result_int reduce_my_float4_ushort_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_ushort_1(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "ushort b"
    public result_int reduce_my_float4_ushort_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_ushort_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_ushort2_0 = 242;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_float4_ushort2_0(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float4_ushort2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float4 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_float4_ushort2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_ushort2_0(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_float4_ushort2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_ushort2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_ushort2_1 = 243;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_float4_ushort2_1(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float4_ushort2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float4 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_float4_ushort2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_ushort2_1(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_float4_ushort2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_ushort2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_ushort4_0 = 244;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_float4_ushort4_0(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float4_ushort4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float4 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_float4_ushort4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_ushort4_0(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_float4_ushort4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_ushort4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_ushort4_1 = 245;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_float4_ushort4_1(float[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float4_ushort4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float4 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_float4_ushort4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_ushort4_1(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_float4_ushort4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_ushort4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_bool_0 = 246;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_float4_bool_0(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __BOOLEAN, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float4_bool_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float4 a"
    // ain2 = "bool b"
    public result_int reduce_my_float4_bool_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_bool_0(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "bool b"
    public result_int reduce_my_float4_bool_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_bool_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_bool_1 = 247;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_float4_bool_1(float[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __F32_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __BOOLEAN, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_float4_bool_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "float4 a"
    // ain2 = "bool b"
    public result_int reduce_my_float4_bool_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_bool_1(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "bool b"
    public result_int reduce_my_float4_bool_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_bool_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_rs_matrix2x2_0 = 248;
    // ain1 = "float4 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_float4_rs_matrix2x2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_rs_matrix2x2_0(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_float4_rs_matrix2x2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_rs_matrix2x2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_rs_matrix2x2_1 = 249;
    // ain1 = "float4 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_float4_rs_matrix2x2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_rs_matrix2x2_1(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_float4_rs_matrix2x2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_rs_matrix2x2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_MyStruct_0 = 250;
    // ain1 = "float4 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_float4_MyStruct_0(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_MyStruct_0(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_float4_MyStruct_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_MyStruct_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_float4_MyStruct_1 = 251;
    // ain1 = "float4 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_float4_MyStruct_1(Allocation ain1, Allocation ain2) {
        return reduce_my_float4_MyStruct_1(ain1, ain2, null);
    }

    // ain1 = "float4 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_float4_MyStruct_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_float4_MyStruct_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_half_0 = 252;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_char_half_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char_half_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char a"
    // ain2 = "half b"
    public result_int reduce_my_char_half_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char_half_0(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "half b"
    public result_int reduce_my_char_half_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_half_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_half_1 = 253;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_char_half_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char_half_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char a"
    // ain2 = "half b"
    public result_int reduce_my_char_half_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char_half_1(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "half b"
    public result_int reduce_my_char_half_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_half_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_half2_0 = 254;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_char_half2_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char_half2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char a"
    // ain2 = "half2 b"
    public result_int reduce_my_char_half2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char_half2_0(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "half2 b"
    public result_int reduce_my_char_half2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_half2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_half2_1 = 255;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_char_half2_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char_half2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char a"
    // ain2 = "half2 b"
    public result_int reduce_my_char_half2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char_half2_1(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "half2 b"
    public result_int reduce_my_char_half2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_half2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_half4_0 = 256;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_char_half4_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char_half4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char a"
    // ain2 = "half4 b"
    public result_int reduce_my_char_half4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char_half4_0(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "half4 b"
    public result_int reduce_my_char_half4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_half4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_half4_1 = 257;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_char_half4_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char_half4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char a"
    // ain2 = "half4 b"
    public result_int reduce_my_char_half4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char_half4_1(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "half4 b"
    public result_int reduce_my_char_half4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_half4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_float_0 = 258;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_char_float_0(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char_float_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char a"
    // ain2 = "float b"
    public result_int reduce_my_char_float_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char_float_0(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "float b"
    public result_int reduce_my_char_float_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_float_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_float_1 = 259;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_char_float_1(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char_float_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char a"
    // ain2 = "float b"
    public result_int reduce_my_char_float_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char_float_1(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "float b"
    public result_int reduce_my_char_float_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_float_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_float2_0 = 260;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_char_float2_0(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char_float2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char a"
    // ain2 = "float2 b"
    public result_int reduce_my_char_float2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char_float2_0(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "float2 b"
    public result_int reduce_my_char_float2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_float2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_float2_1 = 261;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_char_float2_1(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char_float2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char a"
    // ain2 = "float2 b"
    public result_int reduce_my_char_float2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char_float2_1(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "float2 b"
    public result_int reduce_my_char_float2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_float2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_float4_0 = 262;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_char_float4_0(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char_float4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char a"
    // ain2 = "float4 b"
    public result_int reduce_my_char_float4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char_float4_0(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "float4 b"
    public result_int reduce_my_char_float4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_float4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_float4_1 = 263;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_char_float4_1(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char_float4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char a"
    // ain2 = "float4 b"
    public result_int reduce_my_char_float4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char_float4_1(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "float4 b"
    public result_int reduce_my_char_float4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_float4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_char_0 = 264;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_char_char_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char_char_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char a"
    // ain2 = "char b"
    public result_int reduce_my_char_char_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char_char_0(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "char b"
    public result_int reduce_my_char_char_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_char_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_char_1 = 265;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_char_char_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char_char_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char a"
    // ain2 = "char b"
    public result_int reduce_my_char_char_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char_char_1(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "char b"
    public result_int reduce_my_char_char_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_char_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_char2_0 = 266;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_char_char2_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char_char2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char a"
    // ain2 = "char2 b"
    public result_int reduce_my_char_char2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char_char2_0(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "char2 b"
    public result_int reduce_my_char_char2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_char2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_char2_1 = 267;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_char_char2_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char_char2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char a"
    // ain2 = "char2 b"
    public result_int reduce_my_char_char2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char_char2_1(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "char2 b"
    public result_int reduce_my_char_char2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_char2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_char4_0 = 268;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_char_char4_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char_char4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char a"
    // ain2 = "char4 b"
    public result_int reduce_my_char_char4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char_char4_0(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "char4 b"
    public result_int reduce_my_char_char4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_char4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_char4_1 = 269;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_char_char4_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char_char4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char a"
    // ain2 = "char4 b"
    public result_int reduce_my_char_char4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char_char4_1(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "char4 b"
    public result_int reduce_my_char_char4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_char4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_short_0 = 270;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_char_short_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char_short_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char a"
    // ain2 = "short b"
    public result_int reduce_my_char_short_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char_short_0(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "short b"
    public result_int reduce_my_char_short_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_short_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_short_1 = 271;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_char_short_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char_short_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char a"
    // ain2 = "short b"
    public result_int reduce_my_char_short_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char_short_1(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "short b"
    public result_int reduce_my_char_short_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_short_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_short2_0 = 272;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_char_short2_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char_short2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char a"
    // ain2 = "short2 b"
    public result_int reduce_my_char_short2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char_short2_0(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "short2 b"
    public result_int reduce_my_char_short2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_short2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_short2_1 = 273;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_char_short2_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char_short2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char a"
    // ain2 = "short2 b"
    public result_int reduce_my_char_short2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char_short2_1(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "short2 b"
    public result_int reduce_my_char_short2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_short2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_short4_0 = 274;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_char_short4_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char_short4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char a"
    // ain2 = "short4 b"
    public result_int reduce_my_char_short4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char_short4_0(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "short4 b"
    public result_int reduce_my_char_short4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_short4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_short4_1 = 275;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_char_short4_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char_short4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char a"
    // ain2 = "short4 b"
    public result_int reduce_my_char_short4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char_short4_1(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "short4 b"
    public result_int reduce_my_char_short4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_short4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_uchar_0 = 276;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_char_uchar_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char_uchar_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char a"
    // ain2 = "uchar b"
    public result_int reduce_my_char_uchar_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char_uchar_0(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "uchar b"
    public result_int reduce_my_char_uchar_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_uchar_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_uchar_1 = 277;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_char_uchar_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char_uchar_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char a"
    // ain2 = "uchar b"
    public result_int reduce_my_char_uchar_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char_uchar_1(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "uchar b"
    public result_int reduce_my_char_uchar_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_uchar_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_uchar2_0 = 278;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_char_uchar2_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char_uchar2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_char_uchar2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char_uchar2_0(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_char_uchar2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_uchar2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_uchar2_1 = 279;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_char_uchar2_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char_uchar2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_char_uchar2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char_uchar2_1(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_char_uchar2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_uchar2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_uchar4_0 = 280;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_char_uchar4_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char_uchar4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_char_uchar4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char_uchar4_0(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_char_uchar4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_uchar4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_uchar4_1 = 281;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_char_uchar4_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char_uchar4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_char_uchar4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char_uchar4_1(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_char_uchar4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_uchar4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_ushort_0 = 282;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_char_ushort_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char_ushort_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char a"
    // ain2 = "ushort b"
    public result_int reduce_my_char_ushort_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char_ushort_0(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "ushort b"
    public result_int reduce_my_char_ushort_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_ushort_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_ushort_1 = 283;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_char_ushort_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char_ushort_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char a"
    // ain2 = "ushort b"
    public result_int reduce_my_char_ushort_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char_ushort_1(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "ushort b"
    public result_int reduce_my_char_ushort_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_ushort_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_ushort2_0 = 284;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_char_ushort2_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char_ushort2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_char_ushort2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char_ushort2_0(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_char_ushort2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_ushort2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_ushort2_1 = 285;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_char_ushort2_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char_ushort2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_char_ushort2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char_ushort2_1(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_char_ushort2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_ushort2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_ushort4_0 = 286;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_char_ushort4_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char_ushort4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_char_ushort4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char_ushort4_0(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_char_ushort4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_ushort4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_ushort4_1 = 287;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_char_ushort4_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char_ushort4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_char_ushort4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char_ushort4_1(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_char_ushort4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_ushort4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_bool_0 = 288;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_char_bool_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __BOOLEAN, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char_bool_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char a"
    // ain2 = "bool b"
    public result_int reduce_my_char_bool_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char_bool_0(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "bool b"
    public result_int reduce_my_char_bool_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_bool_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_bool_1 = 289;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_char_bool_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __BOOLEAN, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char_bool_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char a"
    // ain2 = "bool b"
    public result_int reduce_my_char_bool_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char_bool_1(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "bool b"
    public result_int reduce_my_char_bool_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_bool_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_rs_matrix2x2_0 = 290;
    // ain1 = "char a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_char_rs_matrix2x2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char_rs_matrix2x2_0(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_char_rs_matrix2x2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_rs_matrix2x2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_rs_matrix2x2_1 = 291;
    // ain1 = "char a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_char_rs_matrix2x2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char_rs_matrix2x2_1(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_char_rs_matrix2x2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_rs_matrix2x2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_MyStruct_0 = 292;
    // ain1 = "char a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_char_MyStruct_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char_MyStruct_0(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_char_MyStruct_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_MyStruct_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char_MyStruct_1 = 293;
    // ain1 = "char a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_char_MyStruct_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char_MyStruct_1(ain1, ain2, null);
    }

    // ain1 = "char a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_char_MyStruct_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char_MyStruct_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_half_0 = 294;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_char2_half_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char2_half_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char2 a"
    // ain2 = "half b"
    public result_int reduce_my_char2_half_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_half_0(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "half b"
    public result_int reduce_my_char2_half_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_half_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_half_1 = 295;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_char2_half_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char2_half_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char2 a"
    // ain2 = "half b"
    public result_int reduce_my_char2_half_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_half_1(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "half b"
    public result_int reduce_my_char2_half_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_half_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_half2_0 = 296;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_char2_half2_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char2_half2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char2 a"
    // ain2 = "half2 b"
    public result_int reduce_my_char2_half2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_half2_0(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "half2 b"
    public result_int reduce_my_char2_half2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_half2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_half2_1 = 297;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_char2_half2_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char2_half2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char2 a"
    // ain2 = "half2 b"
    public result_int reduce_my_char2_half2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_half2_1(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "half2 b"
    public result_int reduce_my_char2_half2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_half2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_half4_0 = 298;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_char2_half4_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char2_half4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char2 a"
    // ain2 = "half4 b"
    public result_int reduce_my_char2_half4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_half4_0(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "half4 b"
    public result_int reduce_my_char2_half4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_half4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_half4_1 = 299;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_char2_half4_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char2_half4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char2 a"
    // ain2 = "half4 b"
    public result_int reduce_my_char2_half4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_half4_1(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "half4 b"
    public result_int reduce_my_char2_half4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_half4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_float_0 = 300;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_char2_float_0(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char2_float_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char2 a"
    // ain2 = "float b"
    public result_int reduce_my_char2_float_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_float_0(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "float b"
    public result_int reduce_my_char2_float_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_float_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_float_1 = 301;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_char2_float_1(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char2_float_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char2 a"
    // ain2 = "float b"
    public result_int reduce_my_char2_float_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_float_1(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "float b"
    public result_int reduce_my_char2_float_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_float_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_float2_0 = 302;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_char2_float2_0(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char2_float2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char2 a"
    // ain2 = "float2 b"
    public result_int reduce_my_char2_float2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_float2_0(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "float2 b"
    public result_int reduce_my_char2_float2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_float2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_float2_1 = 303;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_char2_float2_1(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char2_float2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char2 a"
    // ain2 = "float2 b"
    public result_int reduce_my_char2_float2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_float2_1(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "float2 b"
    public result_int reduce_my_char2_float2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_float2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_float4_0 = 304;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_char2_float4_0(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char2_float4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char2 a"
    // ain2 = "float4 b"
    public result_int reduce_my_char2_float4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_float4_0(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "float4 b"
    public result_int reduce_my_char2_float4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_float4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_float4_1 = 305;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_char2_float4_1(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char2_float4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char2 a"
    // ain2 = "float4 b"
    public result_int reduce_my_char2_float4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_float4_1(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "float4 b"
    public result_int reduce_my_char2_float4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_float4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_char_0 = 306;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_char2_char_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char2_char_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char2 a"
    // ain2 = "char b"
    public result_int reduce_my_char2_char_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_char_0(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "char b"
    public result_int reduce_my_char2_char_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_char_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_char_1 = 307;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_char2_char_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char2_char_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char2 a"
    // ain2 = "char b"
    public result_int reduce_my_char2_char_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_char_1(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "char b"
    public result_int reduce_my_char2_char_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_char_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_char2_0 = 308;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_char2_char2_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char2_char2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char2 a"
    // ain2 = "char2 b"
    public result_int reduce_my_char2_char2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_char2_0(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "char2 b"
    public result_int reduce_my_char2_char2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_char2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_char2_1 = 309;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_char2_char2_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char2_char2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char2 a"
    // ain2 = "char2 b"
    public result_int reduce_my_char2_char2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_char2_1(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "char2 b"
    public result_int reduce_my_char2_char2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_char2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_char4_0 = 310;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_char2_char4_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char2_char4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char2 a"
    // ain2 = "char4 b"
    public result_int reduce_my_char2_char4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_char4_0(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "char4 b"
    public result_int reduce_my_char2_char4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_char4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_char4_1 = 311;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_char2_char4_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char2_char4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char2 a"
    // ain2 = "char4 b"
    public result_int reduce_my_char2_char4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_char4_1(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "char4 b"
    public result_int reduce_my_char2_char4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_char4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_short_0 = 312;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_char2_short_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char2_short_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char2 a"
    // ain2 = "short b"
    public result_int reduce_my_char2_short_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_short_0(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "short b"
    public result_int reduce_my_char2_short_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_short_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_short_1 = 313;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_char2_short_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char2_short_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char2 a"
    // ain2 = "short b"
    public result_int reduce_my_char2_short_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_short_1(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "short b"
    public result_int reduce_my_char2_short_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_short_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_short2_0 = 314;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_char2_short2_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char2_short2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char2 a"
    // ain2 = "short2 b"
    public result_int reduce_my_char2_short2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_short2_0(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "short2 b"
    public result_int reduce_my_char2_short2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_short2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_short2_1 = 315;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_char2_short2_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char2_short2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char2 a"
    // ain2 = "short2 b"
    public result_int reduce_my_char2_short2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_short2_1(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "short2 b"
    public result_int reduce_my_char2_short2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_short2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_short4_0 = 316;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_char2_short4_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char2_short4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char2 a"
    // ain2 = "short4 b"
    public result_int reduce_my_char2_short4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_short4_0(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "short4 b"
    public result_int reduce_my_char2_short4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_short4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_short4_1 = 317;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_char2_short4_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char2_short4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char2 a"
    // ain2 = "short4 b"
    public result_int reduce_my_char2_short4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_short4_1(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "short4 b"
    public result_int reduce_my_char2_short4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_short4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_uchar_0 = 318;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_char2_uchar_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char2_uchar_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char2 a"
    // ain2 = "uchar b"
    public result_int reduce_my_char2_uchar_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_uchar_0(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "uchar b"
    public result_int reduce_my_char2_uchar_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_uchar_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_uchar_1 = 319;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_char2_uchar_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char2_uchar_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char2 a"
    // ain2 = "uchar b"
    public result_int reduce_my_char2_uchar_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_uchar_1(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "uchar b"
    public result_int reduce_my_char2_uchar_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_uchar_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_uchar2_0 = 320;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_char2_uchar2_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char2_uchar2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char2 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_char2_uchar2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_uchar2_0(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_char2_uchar2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_uchar2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_uchar2_1 = 321;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_char2_uchar2_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char2_uchar2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char2 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_char2_uchar2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_uchar2_1(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_char2_uchar2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_uchar2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_uchar4_0 = 322;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_char2_uchar4_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char2_uchar4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char2 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_char2_uchar4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_uchar4_0(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_char2_uchar4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_uchar4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_uchar4_1 = 323;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_char2_uchar4_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char2_uchar4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char2 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_char2_uchar4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_uchar4_1(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_char2_uchar4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_uchar4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_ushort_0 = 324;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_char2_ushort_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char2_ushort_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char2 a"
    // ain2 = "ushort b"
    public result_int reduce_my_char2_ushort_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_ushort_0(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "ushort b"
    public result_int reduce_my_char2_ushort_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_ushort_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_ushort_1 = 325;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_char2_ushort_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char2_ushort_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char2 a"
    // ain2 = "ushort b"
    public result_int reduce_my_char2_ushort_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_ushort_1(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "ushort b"
    public result_int reduce_my_char2_ushort_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_ushort_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_ushort2_0 = 326;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_char2_ushort2_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char2_ushort2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char2 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_char2_ushort2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_ushort2_0(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_char2_ushort2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_ushort2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_ushort2_1 = 327;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_char2_ushort2_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char2_ushort2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char2 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_char2_ushort2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_ushort2_1(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_char2_ushort2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_ushort2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_ushort4_0 = 328;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_char2_ushort4_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char2_ushort4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char2 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_char2_ushort4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_ushort4_0(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_char2_ushort4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_ushort4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_ushort4_1 = 329;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_char2_ushort4_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char2_ushort4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char2 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_char2_ushort4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_ushort4_1(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_char2_ushort4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_ushort4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_bool_0 = 330;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_char2_bool_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __BOOLEAN, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char2_bool_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char2 a"
    // ain2 = "bool b"
    public result_int reduce_my_char2_bool_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_bool_0(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "bool b"
    public result_int reduce_my_char2_bool_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_bool_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_bool_1 = 331;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_char2_bool_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __BOOLEAN, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char2_bool_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char2 a"
    // ain2 = "bool b"
    public result_int reduce_my_char2_bool_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_bool_1(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "bool b"
    public result_int reduce_my_char2_bool_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_bool_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_rs_matrix2x2_0 = 332;
    // ain1 = "char2 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_char2_rs_matrix2x2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_rs_matrix2x2_0(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_char2_rs_matrix2x2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_rs_matrix2x2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_rs_matrix2x2_1 = 333;
    // ain1 = "char2 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_char2_rs_matrix2x2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_rs_matrix2x2_1(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_char2_rs_matrix2x2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_rs_matrix2x2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_MyStruct_0 = 334;
    // ain1 = "char2 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_char2_MyStruct_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_MyStruct_0(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_char2_MyStruct_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_MyStruct_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char2_MyStruct_1 = 335;
    // ain1 = "char2 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_char2_MyStruct_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char2_MyStruct_1(ain1, ain2, null);
    }

    // ain1 = "char2 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_char2_MyStruct_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char2_MyStruct_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_half_0 = 336;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_char4_half_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char4_half_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char4 a"
    // ain2 = "half b"
    public result_int reduce_my_char4_half_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_half_0(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "half b"
    public result_int reduce_my_char4_half_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_half_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_half_1 = 337;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_char4_half_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char4_half_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char4 a"
    // ain2 = "half b"
    public result_int reduce_my_char4_half_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_half_1(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "half b"
    public result_int reduce_my_char4_half_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_half_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_half2_0 = 338;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_char4_half2_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char4_half2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char4 a"
    // ain2 = "half2 b"
    public result_int reduce_my_char4_half2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_half2_0(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "half2 b"
    public result_int reduce_my_char4_half2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_half2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_half2_1 = 339;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_char4_half2_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char4_half2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char4 a"
    // ain2 = "half2 b"
    public result_int reduce_my_char4_half2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_half2_1(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "half2 b"
    public result_int reduce_my_char4_half2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_half2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_half4_0 = 340;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_char4_half4_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char4_half4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char4 a"
    // ain2 = "half4 b"
    public result_int reduce_my_char4_half4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_half4_0(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "half4 b"
    public result_int reduce_my_char4_half4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_half4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_half4_1 = 341;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_char4_half4_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char4_half4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char4 a"
    // ain2 = "half4 b"
    public result_int reduce_my_char4_half4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_half4_1(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "half4 b"
    public result_int reduce_my_char4_half4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_half4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_float_0 = 342;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_char4_float_0(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char4_float_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char4 a"
    // ain2 = "float b"
    public result_int reduce_my_char4_float_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_float_0(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "float b"
    public result_int reduce_my_char4_float_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_float_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_float_1 = 343;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_char4_float_1(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char4_float_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char4 a"
    // ain2 = "float b"
    public result_int reduce_my_char4_float_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_float_1(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "float b"
    public result_int reduce_my_char4_float_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_float_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_float2_0 = 344;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_char4_float2_0(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char4_float2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char4 a"
    // ain2 = "float2 b"
    public result_int reduce_my_char4_float2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_float2_0(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "float2 b"
    public result_int reduce_my_char4_float2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_float2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_float2_1 = 345;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_char4_float2_1(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char4_float2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char4 a"
    // ain2 = "float2 b"
    public result_int reduce_my_char4_float2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_float2_1(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "float2 b"
    public result_int reduce_my_char4_float2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_float2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_float4_0 = 346;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_char4_float4_0(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char4_float4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char4 a"
    // ain2 = "float4 b"
    public result_int reduce_my_char4_float4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_float4_0(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "float4 b"
    public result_int reduce_my_char4_float4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_float4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_float4_1 = 347;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_char4_float4_1(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char4_float4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char4 a"
    // ain2 = "float4 b"
    public result_int reduce_my_char4_float4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_float4_1(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "float4 b"
    public result_int reduce_my_char4_float4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_float4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_char_0 = 348;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_char4_char_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char4_char_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char4 a"
    // ain2 = "char b"
    public result_int reduce_my_char4_char_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_char_0(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "char b"
    public result_int reduce_my_char4_char_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_char_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_char_1 = 349;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_char4_char_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char4_char_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char4 a"
    // ain2 = "char b"
    public result_int reduce_my_char4_char_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_char_1(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "char b"
    public result_int reduce_my_char4_char_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_char_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_char2_0 = 350;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_char4_char2_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char4_char2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char4 a"
    // ain2 = "char2 b"
    public result_int reduce_my_char4_char2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_char2_0(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "char2 b"
    public result_int reduce_my_char4_char2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_char2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_char2_1 = 351;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_char4_char2_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char4_char2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char4 a"
    // ain2 = "char2 b"
    public result_int reduce_my_char4_char2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_char2_1(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "char2 b"
    public result_int reduce_my_char4_char2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_char2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_char4_0 = 352;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_char4_char4_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char4_char4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char4 a"
    // ain2 = "char4 b"
    public result_int reduce_my_char4_char4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_char4_0(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "char4 b"
    public result_int reduce_my_char4_char4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_char4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_char4_1 = 353;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_char4_char4_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char4_char4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char4 a"
    // ain2 = "char4 b"
    public result_int reduce_my_char4_char4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_char4_1(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "char4 b"
    public result_int reduce_my_char4_char4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_char4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_short_0 = 354;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_char4_short_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char4_short_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char4 a"
    // ain2 = "short b"
    public result_int reduce_my_char4_short_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_short_0(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "short b"
    public result_int reduce_my_char4_short_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_short_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_short_1 = 355;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_char4_short_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char4_short_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char4 a"
    // ain2 = "short b"
    public result_int reduce_my_char4_short_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_short_1(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "short b"
    public result_int reduce_my_char4_short_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_short_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_short2_0 = 356;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_char4_short2_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char4_short2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char4 a"
    // ain2 = "short2 b"
    public result_int reduce_my_char4_short2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_short2_0(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "short2 b"
    public result_int reduce_my_char4_short2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_short2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_short2_1 = 357;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_char4_short2_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char4_short2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char4 a"
    // ain2 = "short2 b"
    public result_int reduce_my_char4_short2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_short2_1(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "short2 b"
    public result_int reduce_my_char4_short2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_short2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_short4_0 = 358;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_char4_short4_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char4_short4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char4 a"
    // ain2 = "short4 b"
    public result_int reduce_my_char4_short4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_short4_0(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "short4 b"
    public result_int reduce_my_char4_short4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_short4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_short4_1 = 359;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_char4_short4_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char4_short4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char4 a"
    // ain2 = "short4 b"
    public result_int reduce_my_char4_short4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_short4_1(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "short4 b"
    public result_int reduce_my_char4_short4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_short4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_uchar_0 = 360;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_char4_uchar_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char4_uchar_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char4 a"
    // ain2 = "uchar b"
    public result_int reduce_my_char4_uchar_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_uchar_0(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "uchar b"
    public result_int reduce_my_char4_uchar_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_uchar_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_uchar_1 = 361;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_char4_uchar_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char4_uchar_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char4 a"
    // ain2 = "uchar b"
    public result_int reduce_my_char4_uchar_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_uchar_1(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "uchar b"
    public result_int reduce_my_char4_uchar_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_uchar_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_uchar2_0 = 362;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_char4_uchar2_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char4_uchar2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char4 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_char4_uchar2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_uchar2_0(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_char4_uchar2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_uchar2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_uchar2_1 = 363;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_char4_uchar2_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char4_uchar2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char4 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_char4_uchar2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_uchar2_1(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_char4_uchar2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_uchar2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_uchar4_0 = 364;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_char4_uchar4_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char4_uchar4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char4 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_char4_uchar4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_uchar4_0(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_char4_uchar4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_uchar4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_uchar4_1 = 365;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_char4_uchar4_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char4_uchar4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char4 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_char4_uchar4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_uchar4_1(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_char4_uchar4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_uchar4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_ushort_0 = 366;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_char4_ushort_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char4_ushort_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char4 a"
    // ain2 = "ushort b"
    public result_int reduce_my_char4_ushort_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_ushort_0(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "ushort b"
    public result_int reduce_my_char4_ushort_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_ushort_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_ushort_1 = 367;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_char4_ushort_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char4_ushort_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char4 a"
    // ain2 = "ushort b"
    public result_int reduce_my_char4_ushort_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_ushort_1(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "ushort b"
    public result_int reduce_my_char4_ushort_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_ushort_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_ushort2_0 = 368;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_char4_ushort2_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char4_ushort2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char4 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_char4_ushort2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_ushort2_0(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_char4_ushort2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_ushort2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_ushort2_1 = 369;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_char4_ushort2_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char4_ushort2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char4 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_char4_ushort2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_ushort2_1(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_char4_ushort2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_ushort2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_ushort4_0 = 370;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_char4_ushort4_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char4_ushort4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char4 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_char4_ushort4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_ushort4_0(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_char4_ushort4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_ushort4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_ushort4_1 = 371;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_char4_ushort4_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char4_ushort4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char4 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_char4_ushort4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_ushort4_1(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_char4_ushort4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_ushort4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_bool_0 = 372;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_char4_bool_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __BOOLEAN, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char4_bool_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char4 a"
    // ain2 = "bool b"
    public result_int reduce_my_char4_bool_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_bool_0(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "bool b"
    public result_int reduce_my_char4_bool_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_bool_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_bool_1 = 373;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_char4_bool_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __BOOLEAN, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_char4_bool_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "char4 a"
    // ain2 = "bool b"
    public result_int reduce_my_char4_bool_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_bool_1(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "bool b"
    public result_int reduce_my_char4_bool_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_bool_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_rs_matrix2x2_0 = 374;
    // ain1 = "char4 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_char4_rs_matrix2x2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_rs_matrix2x2_0(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_char4_rs_matrix2x2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_rs_matrix2x2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_rs_matrix2x2_1 = 375;
    // ain1 = "char4 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_char4_rs_matrix2x2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_rs_matrix2x2_1(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_char4_rs_matrix2x2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_rs_matrix2x2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_MyStruct_0 = 376;
    // ain1 = "char4 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_char4_MyStruct_0(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_MyStruct_0(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_char4_MyStruct_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_MyStruct_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_char4_MyStruct_1 = 377;
    // ain1 = "char4 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_char4_MyStruct_1(Allocation ain1, Allocation ain2) {
        return reduce_my_char4_MyStruct_1(ain1, ain2, null);
    }

    // ain1 = "char4 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_char4_MyStruct_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_char4_MyStruct_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_half_0 = 378;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_short_half_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short_half_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short a"
    // ain2 = "half b"
    public result_int reduce_my_short_half_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short_half_0(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "half b"
    public result_int reduce_my_short_half_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_half_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_half_1 = 379;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_short_half_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short_half_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short a"
    // ain2 = "half b"
    public result_int reduce_my_short_half_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short_half_1(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "half b"
    public result_int reduce_my_short_half_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_half_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_half2_0 = 380;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_short_half2_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short_half2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short a"
    // ain2 = "half2 b"
    public result_int reduce_my_short_half2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short_half2_0(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "half2 b"
    public result_int reduce_my_short_half2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_half2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_half2_1 = 381;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_short_half2_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short_half2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short a"
    // ain2 = "half2 b"
    public result_int reduce_my_short_half2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short_half2_1(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "half2 b"
    public result_int reduce_my_short_half2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_half2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_half4_0 = 382;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_short_half4_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short_half4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short a"
    // ain2 = "half4 b"
    public result_int reduce_my_short_half4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short_half4_0(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "half4 b"
    public result_int reduce_my_short_half4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_half4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_half4_1 = 383;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_short_half4_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short_half4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short a"
    // ain2 = "half4 b"
    public result_int reduce_my_short_half4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short_half4_1(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "half4 b"
    public result_int reduce_my_short_half4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_half4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_float_0 = 384;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_short_float_0(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short_float_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short a"
    // ain2 = "float b"
    public result_int reduce_my_short_float_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short_float_0(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "float b"
    public result_int reduce_my_short_float_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_float_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_float_1 = 385;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_short_float_1(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short_float_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short a"
    // ain2 = "float b"
    public result_int reduce_my_short_float_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short_float_1(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "float b"
    public result_int reduce_my_short_float_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_float_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_float2_0 = 386;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_short_float2_0(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short_float2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short a"
    // ain2 = "float2 b"
    public result_int reduce_my_short_float2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short_float2_0(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "float2 b"
    public result_int reduce_my_short_float2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_float2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_float2_1 = 387;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_short_float2_1(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short_float2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short a"
    // ain2 = "float2 b"
    public result_int reduce_my_short_float2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short_float2_1(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "float2 b"
    public result_int reduce_my_short_float2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_float2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_float4_0 = 388;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_short_float4_0(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short_float4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short a"
    // ain2 = "float4 b"
    public result_int reduce_my_short_float4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short_float4_0(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "float4 b"
    public result_int reduce_my_short_float4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_float4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_float4_1 = 389;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_short_float4_1(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short_float4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short a"
    // ain2 = "float4 b"
    public result_int reduce_my_short_float4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short_float4_1(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "float4 b"
    public result_int reduce_my_short_float4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_float4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_char_0 = 390;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_short_char_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short_char_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short a"
    // ain2 = "char b"
    public result_int reduce_my_short_char_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short_char_0(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "char b"
    public result_int reduce_my_short_char_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_char_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_char_1 = 391;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_short_char_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short_char_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short a"
    // ain2 = "char b"
    public result_int reduce_my_short_char_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short_char_1(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "char b"
    public result_int reduce_my_short_char_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_char_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_char2_0 = 392;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_short_char2_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short_char2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short a"
    // ain2 = "char2 b"
    public result_int reduce_my_short_char2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short_char2_0(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "char2 b"
    public result_int reduce_my_short_char2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_char2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_char2_1 = 393;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_short_char2_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short_char2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short a"
    // ain2 = "char2 b"
    public result_int reduce_my_short_char2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short_char2_1(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "char2 b"
    public result_int reduce_my_short_char2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_char2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_char4_0 = 394;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_short_char4_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short_char4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short a"
    // ain2 = "char4 b"
    public result_int reduce_my_short_char4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short_char4_0(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "char4 b"
    public result_int reduce_my_short_char4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_char4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_char4_1 = 395;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_short_char4_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short_char4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short a"
    // ain2 = "char4 b"
    public result_int reduce_my_short_char4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short_char4_1(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "char4 b"
    public result_int reduce_my_short_char4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_char4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_short_0 = 396;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_short_short_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short_short_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short a"
    // ain2 = "short b"
    public result_int reduce_my_short_short_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short_short_0(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "short b"
    public result_int reduce_my_short_short_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_short_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_short_1 = 397;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_short_short_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short_short_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short a"
    // ain2 = "short b"
    public result_int reduce_my_short_short_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short_short_1(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "short b"
    public result_int reduce_my_short_short_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_short_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_short2_0 = 398;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_short_short2_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short_short2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short a"
    // ain2 = "short2 b"
    public result_int reduce_my_short_short2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short_short2_0(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "short2 b"
    public result_int reduce_my_short_short2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_short2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_short2_1 = 399;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_short_short2_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short_short2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short a"
    // ain2 = "short2 b"
    public result_int reduce_my_short_short2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short_short2_1(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "short2 b"
    public result_int reduce_my_short_short2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_short2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_short4_0 = 400;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_short_short4_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short_short4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short a"
    // ain2 = "short4 b"
    public result_int reduce_my_short_short4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short_short4_0(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "short4 b"
    public result_int reduce_my_short_short4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_short4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_short4_1 = 401;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_short_short4_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short_short4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short a"
    // ain2 = "short4 b"
    public result_int reduce_my_short_short4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short_short4_1(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "short4 b"
    public result_int reduce_my_short_short4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_short4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_uchar_0 = 402;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_short_uchar_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short_uchar_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short a"
    // ain2 = "uchar b"
    public result_int reduce_my_short_uchar_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short_uchar_0(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "uchar b"
    public result_int reduce_my_short_uchar_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_uchar_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_uchar_1 = 403;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_short_uchar_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short_uchar_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short a"
    // ain2 = "uchar b"
    public result_int reduce_my_short_uchar_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short_uchar_1(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "uchar b"
    public result_int reduce_my_short_uchar_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_uchar_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_uchar2_0 = 404;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_short_uchar2_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short_uchar2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_short_uchar2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short_uchar2_0(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_short_uchar2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_uchar2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_uchar2_1 = 405;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_short_uchar2_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short_uchar2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_short_uchar2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short_uchar2_1(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_short_uchar2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_uchar2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_uchar4_0 = 406;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_short_uchar4_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short_uchar4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_short_uchar4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short_uchar4_0(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_short_uchar4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_uchar4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_uchar4_1 = 407;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_short_uchar4_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short_uchar4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_short_uchar4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short_uchar4_1(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_short_uchar4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_uchar4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_ushort_0 = 408;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_short_ushort_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short_ushort_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short a"
    // ain2 = "ushort b"
    public result_int reduce_my_short_ushort_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short_ushort_0(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "ushort b"
    public result_int reduce_my_short_ushort_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_ushort_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_ushort_1 = 409;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_short_ushort_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short_ushort_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short a"
    // ain2 = "ushort b"
    public result_int reduce_my_short_ushort_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short_ushort_1(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "ushort b"
    public result_int reduce_my_short_ushort_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_ushort_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_ushort2_0 = 410;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_short_ushort2_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short_ushort2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_short_ushort2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short_ushort2_0(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_short_ushort2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_ushort2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_ushort2_1 = 411;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_short_ushort2_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short_ushort2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_short_ushort2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short_ushort2_1(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_short_ushort2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_ushort2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_ushort4_0 = 412;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_short_ushort4_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short_ushort4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_short_ushort4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short_ushort4_0(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_short_ushort4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_ushort4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_ushort4_1 = 413;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_short_ushort4_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short_ushort4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_short_ushort4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short_ushort4_1(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_short_ushort4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_ushort4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_bool_0 = 414;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_short_bool_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __BOOLEAN, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short_bool_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short a"
    // ain2 = "bool b"
    public result_int reduce_my_short_bool_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short_bool_0(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "bool b"
    public result_int reduce_my_short_bool_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_bool_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_bool_1 = 415;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_short_bool_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __BOOLEAN, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short_bool_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short a"
    // ain2 = "bool b"
    public result_int reduce_my_short_bool_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short_bool_1(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "bool b"
    public result_int reduce_my_short_bool_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_bool_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_rs_matrix2x2_0 = 416;
    // ain1 = "short a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_short_rs_matrix2x2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short_rs_matrix2x2_0(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_short_rs_matrix2x2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_rs_matrix2x2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_rs_matrix2x2_1 = 417;
    // ain1 = "short a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_short_rs_matrix2x2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short_rs_matrix2x2_1(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_short_rs_matrix2x2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_rs_matrix2x2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_MyStruct_0 = 418;
    // ain1 = "short a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_short_MyStruct_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short_MyStruct_0(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_short_MyStruct_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_MyStruct_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short_MyStruct_1 = 419;
    // ain1 = "short a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_short_MyStruct_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short_MyStruct_1(ain1, ain2, null);
    }

    // ain1 = "short a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_short_MyStruct_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short_MyStruct_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_half_0 = 420;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_short2_half_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short2_half_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short2 a"
    // ain2 = "half b"
    public result_int reduce_my_short2_half_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_half_0(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "half b"
    public result_int reduce_my_short2_half_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_half_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_half_1 = 421;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_short2_half_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short2_half_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short2 a"
    // ain2 = "half b"
    public result_int reduce_my_short2_half_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_half_1(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "half b"
    public result_int reduce_my_short2_half_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_half_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_half2_0 = 422;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_short2_half2_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short2_half2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short2 a"
    // ain2 = "half2 b"
    public result_int reduce_my_short2_half2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_half2_0(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "half2 b"
    public result_int reduce_my_short2_half2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_half2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_half2_1 = 423;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_short2_half2_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short2_half2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short2 a"
    // ain2 = "half2 b"
    public result_int reduce_my_short2_half2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_half2_1(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "half2 b"
    public result_int reduce_my_short2_half2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_half2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_half4_0 = 424;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_short2_half4_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short2_half4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short2 a"
    // ain2 = "half4 b"
    public result_int reduce_my_short2_half4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_half4_0(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "half4 b"
    public result_int reduce_my_short2_half4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_half4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_half4_1 = 425;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_short2_half4_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short2_half4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short2 a"
    // ain2 = "half4 b"
    public result_int reduce_my_short2_half4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_half4_1(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "half4 b"
    public result_int reduce_my_short2_half4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_half4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_float_0 = 426;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_short2_float_0(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short2_float_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short2 a"
    // ain2 = "float b"
    public result_int reduce_my_short2_float_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_float_0(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "float b"
    public result_int reduce_my_short2_float_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_float_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_float_1 = 427;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_short2_float_1(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short2_float_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short2 a"
    // ain2 = "float b"
    public result_int reduce_my_short2_float_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_float_1(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "float b"
    public result_int reduce_my_short2_float_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_float_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_float2_0 = 428;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_short2_float2_0(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short2_float2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short2 a"
    // ain2 = "float2 b"
    public result_int reduce_my_short2_float2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_float2_0(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "float2 b"
    public result_int reduce_my_short2_float2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_float2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_float2_1 = 429;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_short2_float2_1(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short2_float2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short2 a"
    // ain2 = "float2 b"
    public result_int reduce_my_short2_float2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_float2_1(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "float2 b"
    public result_int reduce_my_short2_float2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_float2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_float4_0 = 430;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_short2_float4_0(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short2_float4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short2 a"
    // ain2 = "float4 b"
    public result_int reduce_my_short2_float4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_float4_0(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "float4 b"
    public result_int reduce_my_short2_float4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_float4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_float4_1 = 431;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_short2_float4_1(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short2_float4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short2 a"
    // ain2 = "float4 b"
    public result_int reduce_my_short2_float4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_float4_1(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "float4 b"
    public result_int reduce_my_short2_float4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_float4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_char_0 = 432;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_short2_char_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short2_char_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short2 a"
    // ain2 = "char b"
    public result_int reduce_my_short2_char_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_char_0(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "char b"
    public result_int reduce_my_short2_char_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_char_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_char_1 = 433;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_short2_char_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short2_char_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short2 a"
    // ain2 = "char b"
    public result_int reduce_my_short2_char_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_char_1(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "char b"
    public result_int reduce_my_short2_char_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_char_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_char2_0 = 434;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_short2_char2_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short2_char2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short2 a"
    // ain2 = "char2 b"
    public result_int reduce_my_short2_char2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_char2_0(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "char2 b"
    public result_int reduce_my_short2_char2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_char2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_char2_1 = 435;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_short2_char2_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short2_char2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short2 a"
    // ain2 = "char2 b"
    public result_int reduce_my_short2_char2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_char2_1(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "char2 b"
    public result_int reduce_my_short2_char2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_char2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_char4_0 = 436;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_short2_char4_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short2_char4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short2 a"
    // ain2 = "char4 b"
    public result_int reduce_my_short2_char4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_char4_0(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "char4 b"
    public result_int reduce_my_short2_char4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_char4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_char4_1 = 437;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_short2_char4_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short2_char4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short2 a"
    // ain2 = "char4 b"
    public result_int reduce_my_short2_char4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_char4_1(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "char4 b"
    public result_int reduce_my_short2_char4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_char4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_short_0 = 438;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_short2_short_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short2_short_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short2 a"
    // ain2 = "short b"
    public result_int reduce_my_short2_short_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_short_0(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "short b"
    public result_int reduce_my_short2_short_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_short_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_short_1 = 439;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_short2_short_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short2_short_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short2 a"
    // ain2 = "short b"
    public result_int reduce_my_short2_short_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_short_1(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "short b"
    public result_int reduce_my_short2_short_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_short_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_short2_0 = 440;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_short2_short2_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short2_short2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short2 a"
    // ain2 = "short2 b"
    public result_int reduce_my_short2_short2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_short2_0(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "short2 b"
    public result_int reduce_my_short2_short2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_short2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_short2_1 = 441;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_short2_short2_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short2_short2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short2 a"
    // ain2 = "short2 b"
    public result_int reduce_my_short2_short2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_short2_1(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "short2 b"
    public result_int reduce_my_short2_short2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_short2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_short4_0 = 442;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_short2_short4_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short2_short4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short2 a"
    // ain2 = "short4 b"
    public result_int reduce_my_short2_short4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_short4_0(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "short4 b"
    public result_int reduce_my_short2_short4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_short4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_short4_1 = 443;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_short2_short4_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short2_short4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short2 a"
    // ain2 = "short4 b"
    public result_int reduce_my_short2_short4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_short4_1(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "short4 b"
    public result_int reduce_my_short2_short4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_short4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_uchar_0 = 444;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_short2_uchar_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short2_uchar_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short2 a"
    // ain2 = "uchar b"
    public result_int reduce_my_short2_uchar_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_uchar_0(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "uchar b"
    public result_int reduce_my_short2_uchar_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_uchar_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_uchar_1 = 445;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_short2_uchar_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short2_uchar_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short2 a"
    // ain2 = "uchar b"
    public result_int reduce_my_short2_uchar_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_uchar_1(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "uchar b"
    public result_int reduce_my_short2_uchar_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_uchar_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_uchar2_0 = 446;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_short2_uchar2_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short2_uchar2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short2 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_short2_uchar2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_uchar2_0(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_short2_uchar2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_uchar2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_uchar2_1 = 447;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_short2_uchar2_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short2_uchar2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short2 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_short2_uchar2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_uchar2_1(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_short2_uchar2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_uchar2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_uchar4_0 = 448;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_short2_uchar4_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short2_uchar4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short2 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_short2_uchar4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_uchar4_0(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_short2_uchar4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_uchar4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_uchar4_1 = 449;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_short2_uchar4_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short2_uchar4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short2 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_short2_uchar4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_uchar4_1(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_short2_uchar4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_uchar4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_ushort_0 = 450;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_short2_ushort_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short2_ushort_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short2 a"
    // ain2 = "ushort b"
    public result_int reduce_my_short2_ushort_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_ushort_0(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "ushort b"
    public result_int reduce_my_short2_ushort_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_ushort_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_ushort_1 = 451;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_short2_ushort_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short2_ushort_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short2 a"
    // ain2 = "ushort b"
    public result_int reduce_my_short2_ushort_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_ushort_1(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "ushort b"
    public result_int reduce_my_short2_ushort_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_ushort_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_ushort2_0 = 452;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_short2_ushort2_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short2_ushort2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short2 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_short2_ushort2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_ushort2_0(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_short2_ushort2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_ushort2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_ushort2_1 = 453;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_short2_ushort2_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short2_ushort2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short2 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_short2_ushort2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_ushort2_1(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_short2_ushort2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_ushort2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_ushort4_0 = 454;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_short2_ushort4_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short2_ushort4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short2 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_short2_ushort4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_ushort4_0(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_short2_ushort4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_ushort4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_ushort4_1 = 455;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_short2_ushort4_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short2_ushort4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short2 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_short2_ushort4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_ushort4_1(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_short2_ushort4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_ushort4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_bool_0 = 456;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_short2_bool_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __BOOLEAN, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short2_bool_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short2 a"
    // ain2 = "bool b"
    public result_int reduce_my_short2_bool_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_bool_0(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "bool b"
    public result_int reduce_my_short2_bool_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_bool_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_bool_1 = 457;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_short2_bool_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __BOOLEAN, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short2_bool_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short2 a"
    // ain2 = "bool b"
    public result_int reduce_my_short2_bool_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_bool_1(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "bool b"
    public result_int reduce_my_short2_bool_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_bool_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_rs_matrix2x2_0 = 458;
    // ain1 = "short2 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_short2_rs_matrix2x2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_rs_matrix2x2_0(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_short2_rs_matrix2x2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_rs_matrix2x2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_rs_matrix2x2_1 = 459;
    // ain1 = "short2 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_short2_rs_matrix2x2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_rs_matrix2x2_1(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_short2_rs_matrix2x2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_rs_matrix2x2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_MyStruct_0 = 460;
    // ain1 = "short2 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_short2_MyStruct_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_MyStruct_0(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_short2_MyStruct_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_MyStruct_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short2_MyStruct_1 = 461;
    // ain1 = "short2 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_short2_MyStruct_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short2_MyStruct_1(ain1, ain2, null);
    }

    // ain1 = "short2 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_short2_MyStruct_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short2_MyStruct_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_half_0 = 462;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_short4_half_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short4_half_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short4 a"
    // ain2 = "half b"
    public result_int reduce_my_short4_half_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_half_0(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "half b"
    public result_int reduce_my_short4_half_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_half_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_half_1 = 463;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_short4_half_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short4_half_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short4 a"
    // ain2 = "half b"
    public result_int reduce_my_short4_half_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_half_1(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "half b"
    public result_int reduce_my_short4_half_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_half_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_half2_0 = 464;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_short4_half2_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short4_half2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short4 a"
    // ain2 = "half2 b"
    public result_int reduce_my_short4_half2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_half2_0(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "half2 b"
    public result_int reduce_my_short4_half2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_half2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_half2_1 = 465;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_short4_half2_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short4_half2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short4 a"
    // ain2 = "half2 b"
    public result_int reduce_my_short4_half2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_half2_1(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "half2 b"
    public result_int reduce_my_short4_half2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_half2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_half4_0 = 466;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_short4_half4_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short4_half4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short4 a"
    // ain2 = "half4 b"
    public result_int reduce_my_short4_half4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_half4_0(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "half4 b"
    public result_int reduce_my_short4_half4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_half4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_half4_1 = 467;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_short4_half4_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short4_half4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short4 a"
    // ain2 = "half4 b"
    public result_int reduce_my_short4_half4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_half4_1(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "half4 b"
    public result_int reduce_my_short4_half4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_half4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_float_0 = 468;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_short4_float_0(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short4_float_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short4 a"
    // ain2 = "float b"
    public result_int reduce_my_short4_float_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_float_0(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "float b"
    public result_int reduce_my_short4_float_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_float_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_float_1 = 469;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_short4_float_1(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short4_float_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short4 a"
    // ain2 = "float b"
    public result_int reduce_my_short4_float_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_float_1(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "float b"
    public result_int reduce_my_short4_float_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_float_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_float2_0 = 470;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_short4_float2_0(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short4_float2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short4 a"
    // ain2 = "float2 b"
    public result_int reduce_my_short4_float2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_float2_0(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "float2 b"
    public result_int reduce_my_short4_float2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_float2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_float2_1 = 471;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_short4_float2_1(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short4_float2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short4 a"
    // ain2 = "float2 b"
    public result_int reduce_my_short4_float2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_float2_1(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "float2 b"
    public result_int reduce_my_short4_float2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_float2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_float4_0 = 472;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_short4_float4_0(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short4_float4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short4 a"
    // ain2 = "float4 b"
    public result_int reduce_my_short4_float4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_float4_0(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "float4 b"
    public result_int reduce_my_short4_float4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_float4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_float4_1 = 473;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_short4_float4_1(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short4_float4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short4 a"
    // ain2 = "float4 b"
    public result_int reduce_my_short4_float4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_float4_1(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "float4 b"
    public result_int reduce_my_short4_float4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_float4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_char_0 = 474;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_short4_char_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short4_char_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short4 a"
    // ain2 = "char b"
    public result_int reduce_my_short4_char_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_char_0(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "char b"
    public result_int reduce_my_short4_char_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_char_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_char_1 = 475;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_short4_char_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short4_char_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short4 a"
    // ain2 = "char b"
    public result_int reduce_my_short4_char_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_char_1(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "char b"
    public result_int reduce_my_short4_char_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_char_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_char2_0 = 476;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_short4_char2_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short4_char2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short4 a"
    // ain2 = "char2 b"
    public result_int reduce_my_short4_char2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_char2_0(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "char2 b"
    public result_int reduce_my_short4_char2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_char2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_char2_1 = 477;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_short4_char2_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short4_char2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short4 a"
    // ain2 = "char2 b"
    public result_int reduce_my_short4_char2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_char2_1(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "char2 b"
    public result_int reduce_my_short4_char2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_char2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_char4_0 = 478;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_short4_char4_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short4_char4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short4 a"
    // ain2 = "char4 b"
    public result_int reduce_my_short4_char4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_char4_0(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "char4 b"
    public result_int reduce_my_short4_char4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_char4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_char4_1 = 479;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_short4_char4_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short4_char4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short4 a"
    // ain2 = "char4 b"
    public result_int reduce_my_short4_char4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_char4_1(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "char4 b"
    public result_int reduce_my_short4_char4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_char4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_short_0 = 480;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_short4_short_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short4_short_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short4 a"
    // ain2 = "short b"
    public result_int reduce_my_short4_short_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_short_0(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "short b"
    public result_int reduce_my_short4_short_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_short_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_short_1 = 481;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_short4_short_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short4_short_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short4 a"
    // ain2 = "short b"
    public result_int reduce_my_short4_short_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_short_1(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "short b"
    public result_int reduce_my_short4_short_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_short_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_short2_0 = 482;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_short4_short2_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short4_short2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short4 a"
    // ain2 = "short2 b"
    public result_int reduce_my_short4_short2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_short2_0(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "short2 b"
    public result_int reduce_my_short4_short2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_short2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_short2_1 = 483;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_short4_short2_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short4_short2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short4 a"
    // ain2 = "short2 b"
    public result_int reduce_my_short4_short2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_short2_1(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "short2 b"
    public result_int reduce_my_short4_short2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_short2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_short4_0 = 484;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_short4_short4_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short4_short4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short4 a"
    // ain2 = "short4 b"
    public result_int reduce_my_short4_short4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_short4_0(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "short4 b"
    public result_int reduce_my_short4_short4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_short4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_short4_1 = 485;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_short4_short4_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short4_short4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short4 a"
    // ain2 = "short4 b"
    public result_int reduce_my_short4_short4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_short4_1(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "short4 b"
    public result_int reduce_my_short4_short4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_short4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_uchar_0 = 486;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_short4_uchar_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short4_uchar_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short4 a"
    // ain2 = "uchar b"
    public result_int reduce_my_short4_uchar_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_uchar_0(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "uchar b"
    public result_int reduce_my_short4_uchar_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_uchar_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_uchar_1 = 487;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_short4_uchar_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short4_uchar_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short4 a"
    // ain2 = "uchar b"
    public result_int reduce_my_short4_uchar_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_uchar_1(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "uchar b"
    public result_int reduce_my_short4_uchar_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_uchar_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_uchar2_0 = 488;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_short4_uchar2_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short4_uchar2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short4 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_short4_uchar2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_uchar2_0(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_short4_uchar2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_uchar2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_uchar2_1 = 489;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_short4_uchar2_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short4_uchar2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short4 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_short4_uchar2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_uchar2_1(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_short4_uchar2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_uchar2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_uchar4_0 = 490;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_short4_uchar4_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short4_uchar4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short4 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_short4_uchar4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_uchar4_0(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_short4_uchar4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_uchar4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_uchar4_1 = 491;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_short4_uchar4_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short4_uchar4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short4 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_short4_uchar4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_uchar4_1(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_short4_uchar4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_uchar4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_ushort_0 = 492;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_short4_ushort_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short4_ushort_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short4 a"
    // ain2 = "ushort b"
    public result_int reduce_my_short4_ushort_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_ushort_0(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "ushort b"
    public result_int reduce_my_short4_ushort_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_ushort_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_ushort_1 = 493;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_short4_ushort_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short4_ushort_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short4 a"
    // ain2 = "ushort b"
    public result_int reduce_my_short4_ushort_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_ushort_1(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "ushort b"
    public result_int reduce_my_short4_ushort_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_ushort_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_ushort2_0 = 494;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_short4_ushort2_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short4_ushort2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short4 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_short4_ushort2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_ushort2_0(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_short4_ushort2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_ushort2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_ushort2_1 = 495;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_short4_ushort2_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short4_ushort2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short4 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_short4_ushort2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_ushort2_1(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_short4_ushort2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_ushort2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_ushort4_0 = 496;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_short4_ushort4_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short4_ushort4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short4 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_short4_ushort4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_ushort4_0(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_short4_ushort4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_ushort4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_ushort4_1 = 497;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_short4_ushort4_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short4_ushort4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short4 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_short4_ushort4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_ushort4_1(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_short4_ushort4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_ushort4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_bool_0 = 498;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_short4_bool_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __BOOLEAN, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short4_bool_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short4 a"
    // ain2 = "bool b"
    public result_int reduce_my_short4_bool_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_bool_0(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "bool b"
    public result_int reduce_my_short4_bool_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_bool_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_bool_1 = 499;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_short4_bool_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __I16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __BOOLEAN, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_short4_bool_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "short4 a"
    // ain2 = "bool b"
    public result_int reduce_my_short4_bool_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_bool_1(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "bool b"
    public result_int reduce_my_short4_bool_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_bool_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_rs_matrix2x2_0 = 500;
    // ain1 = "short4 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_short4_rs_matrix2x2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_rs_matrix2x2_0(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_short4_rs_matrix2x2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_rs_matrix2x2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_rs_matrix2x2_1 = 501;
    // ain1 = "short4 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_short4_rs_matrix2x2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_rs_matrix2x2_1(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_short4_rs_matrix2x2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_rs_matrix2x2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_MyStruct_0 = 502;
    // ain1 = "short4 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_short4_MyStruct_0(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_MyStruct_0(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_short4_MyStruct_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_MyStruct_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_short4_MyStruct_1 = 503;
    // ain1 = "short4 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_short4_MyStruct_1(Allocation ain1, Allocation ain2) {
        return reduce_my_short4_MyStruct_1(ain1, ain2, null);
    }

    // ain1 = "short4 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_short4_MyStruct_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_short4_MyStruct_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_half_0 = 504;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_uchar_half_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar_half_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar a"
    // ain2 = "half b"
    public result_int reduce_my_uchar_half_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_half_0(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "half b"
    public result_int reduce_my_uchar_half_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_half_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_half_1 = 505;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_uchar_half_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar_half_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar a"
    // ain2 = "half b"
    public result_int reduce_my_uchar_half_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_half_1(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "half b"
    public result_int reduce_my_uchar_half_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_half_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_half2_0 = 506;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_uchar_half2_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar_half2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar a"
    // ain2 = "half2 b"
    public result_int reduce_my_uchar_half2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_half2_0(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "half2 b"
    public result_int reduce_my_uchar_half2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_half2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_half2_1 = 507;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_uchar_half2_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar_half2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar a"
    // ain2 = "half2 b"
    public result_int reduce_my_uchar_half2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_half2_1(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "half2 b"
    public result_int reduce_my_uchar_half2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_half2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_half4_0 = 508;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_uchar_half4_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar_half4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar a"
    // ain2 = "half4 b"
    public result_int reduce_my_uchar_half4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_half4_0(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "half4 b"
    public result_int reduce_my_uchar_half4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_half4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_half4_1 = 509;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_uchar_half4_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar_half4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar a"
    // ain2 = "half4 b"
    public result_int reduce_my_uchar_half4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_half4_1(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "half4 b"
    public result_int reduce_my_uchar_half4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_half4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_float_0 = 510;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_uchar_float_0(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar_float_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar a"
    // ain2 = "float b"
    public result_int reduce_my_uchar_float_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_float_0(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "float b"
    public result_int reduce_my_uchar_float_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_float_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_float_1 = 511;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_uchar_float_1(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar_float_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar a"
    // ain2 = "float b"
    public result_int reduce_my_uchar_float_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_float_1(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "float b"
    public result_int reduce_my_uchar_float_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_float_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_float2_0 = 512;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_uchar_float2_0(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar_float2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar a"
    // ain2 = "float2 b"
    public result_int reduce_my_uchar_float2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_float2_0(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "float2 b"
    public result_int reduce_my_uchar_float2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_float2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_float2_1 = 513;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_uchar_float2_1(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar_float2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar a"
    // ain2 = "float2 b"
    public result_int reduce_my_uchar_float2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_float2_1(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "float2 b"
    public result_int reduce_my_uchar_float2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_float2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_float4_0 = 514;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_uchar_float4_0(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar_float4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar a"
    // ain2 = "float4 b"
    public result_int reduce_my_uchar_float4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_float4_0(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "float4 b"
    public result_int reduce_my_uchar_float4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_float4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_float4_1 = 515;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_uchar_float4_1(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar_float4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar a"
    // ain2 = "float4 b"
    public result_int reduce_my_uchar_float4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_float4_1(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "float4 b"
    public result_int reduce_my_uchar_float4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_float4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_char_0 = 516;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_uchar_char_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar_char_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar a"
    // ain2 = "char b"
    public result_int reduce_my_uchar_char_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_char_0(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "char b"
    public result_int reduce_my_uchar_char_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_char_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_char_1 = 517;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_uchar_char_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar_char_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar a"
    // ain2 = "char b"
    public result_int reduce_my_uchar_char_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_char_1(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "char b"
    public result_int reduce_my_uchar_char_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_char_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_char2_0 = 518;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_uchar_char2_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar_char2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar a"
    // ain2 = "char2 b"
    public result_int reduce_my_uchar_char2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_char2_0(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "char2 b"
    public result_int reduce_my_uchar_char2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_char2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_char2_1 = 519;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_uchar_char2_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar_char2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar a"
    // ain2 = "char2 b"
    public result_int reduce_my_uchar_char2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_char2_1(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "char2 b"
    public result_int reduce_my_uchar_char2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_char2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_char4_0 = 520;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_uchar_char4_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar_char4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar a"
    // ain2 = "char4 b"
    public result_int reduce_my_uchar_char4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_char4_0(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "char4 b"
    public result_int reduce_my_uchar_char4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_char4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_char4_1 = 521;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_uchar_char4_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar_char4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar a"
    // ain2 = "char4 b"
    public result_int reduce_my_uchar_char4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_char4_1(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "char4 b"
    public result_int reduce_my_uchar_char4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_char4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_short_0 = 522;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_uchar_short_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar_short_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar a"
    // ain2 = "short b"
    public result_int reduce_my_uchar_short_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_short_0(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "short b"
    public result_int reduce_my_uchar_short_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_short_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_short_1 = 523;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_uchar_short_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar_short_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar a"
    // ain2 = "short b"
    public result_int reduce_my_uchar_short_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_short_1(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "short b"
    public result_int reduce_my_uchar_short_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_short_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_short2_0 = 524;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_uchar_short2_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar_short2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar a"
    // ain2 = "short2 b"
    public result_int reduce_my_uchar_short2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_short2_0(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "short2 b"
    public result_int reduce_my_uchar_short2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_short2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_short2_1 = 525;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_uchar_short2_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar_short2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar a"
    // ain2 = "short2 b"
    public result_int reduce_my_uchar_short2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_short2_1(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "short2 b"
    public result_int reduce_my_uchar_short2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_short2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_short4_0 = 526;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_uchar_short4_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar_short4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar a"
    // ain2 = "short4 b"
    public result_int reduce_my_uchar_short4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_short4_0(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "short4 b"
    public result_int reduce_my_uchar_short4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_short4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_short4_1 = 527;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_uchar_short4_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar_short4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar a"
    // ain2 = "short4 b"
    public result_int reduce_my_uchar_short4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_short4_1(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "short4 b"
    public result_int reduce_my_uchar_short4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_short4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_uchar_0 = 528;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_uchar_uchar_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar_uchar_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar a"
    // ain2 = "uchar b"
    public result_int reduce_my_uchar_uchar_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_uchar_0(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "uchar b"
    public result_int reduce_my_uchar_uchar_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_uchar_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_uchar_1 = 529;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_uchar_uchar_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar_uchar_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar a"
    // ain2 = "uchar b"
    public result_int reduce_my_uchar_uchar_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_uchar_1(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "uchar b"
    public result_int reduce_my_uchar_uchar_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_uchar_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_uchar2_0 = 530;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_uchar_uchar2_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar_uchar2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_uchar_uchar2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_uchar2_0(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_uchar_uchar2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_uchar2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_uchar2_1 = 531;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_uchar_uchar2_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar_uchar2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_uchar_uchar2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_uchar2_1(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_uchar_uchar2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_uchar2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_uchar4_0 = 532;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_uchar_uchar4_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar_uchar4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_uchar_uchar4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_uchar4_0(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_uchar_uchar4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_uchar4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_uchar4_1 = 533;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_uchar_uchar4_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar_uchar4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_uchar_uchar4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_uchar4_1(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_uchar_uchar4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_uchar4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_ushort_0 = 534;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_uchar_ushort_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar_ushort_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar a"
    // ain2 = "ushort b"
    public result_int reduce_my_uchar_ushort_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_ushort_0(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "ushort b"
    public result_int reduce_my_uchar_ushort_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_ushort_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_ushort_1 = 535;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_uchar_ushort_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar_ushort_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar a"
    // ain2 = "ushort b"
    public result_int reduce_my_uchar_ushort_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_ushort_1(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "ushort b"
    public result_int reduce_my_uchar_ushort_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_ushort_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_ushort2_0 = 536;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_uchar_ushort2_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar_ushort2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_uchar_ushort2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_ushort2_0(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_uchar_ushort2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_ushort2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_ushort2_1 = 537;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_uchar_ushort2_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar_ushort2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_uchar_ushort2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_ushort2_1(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_uchar_ushort2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_ushort2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_ushort4_0 = 538;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_uchar_ushort4_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar_ushort4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_uchar_ushort4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_ushort4_0(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_uchar_ushort4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_ushort4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_ushort4_1 = 539;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_uchar_ushort4_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar_ushort4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_uchar_ushort4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_ushort4_1(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_uchar_ushort4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_ushort4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_bool_0 = 540;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_uchar_bool_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __BOOLEAN, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar_bool_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar a"
    // ain2 = "bool b"
    public result_int reduce_my_uchar_bool_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_bool_0(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "bool b"
    public result_int reduce_my_uchar_bool_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_bool_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_bool_1 = 541;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_uchar_bool_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __BOOLEAN, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar_bool_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar a"
    // ain2 = "bool b"
    public result_int reduce_my_uchar_bool_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_bool_1(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "bool b"
    public result_int reduce_my_uchar_bool_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_bool_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_rs_matrix2x2_0 = 542;
    // ain1 = "uchar a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_uchar_rs_matrix2x2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_rs_matrix2x2_0(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_uchar_rs_matrix2x2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_rs_matrix2x2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_rs_matrix2x2_1 = 543;
    // ain1 = "uchar a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_uchar_rs_matrix2x2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_rs_matrix2x2_1(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_uchar_rs_matrix2x2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_rs_matrix2x2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_MyStruct_0 = 544;
    // ain1 = "uchar a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_uchar_MyStruct_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_MyStruct_0(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_uchar_MyStruct_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_MyStruct_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar_MyStruct_1 = 545;
    // ain1 = "uchar a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_uchar_MyStruct_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar_MyStruct_1(ain1, ain2, null);
    }

    // ain1 = "uchar a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_uchar_MyStruct_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar_MyStruct_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_half_0 = 546;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_uchar2_half_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar2_half_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar2 a"
    // ain2 = "half b"
    public result_int reduce_my_uchar2_half_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_half_0(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "half b"
    public result_int reduce_my_uchar2_half_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_half_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_half_1 = 547;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_uchar2_half_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar2_half_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar2 a"
    // ain2 = "half b"
    public result_int reduce_my_uchar2_half_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_half_1(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "half b"
    public result_int reduce_my_uchar2_half_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_half_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_half2_0 = 548;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_uchar2_half2_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar2_half2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar2 a"
    // ain2 = "half2 b"
    public result_int reduce_my_uchar2_half2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_half2_0(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "half2 b"
    public result_int reduce_my_uchar2_half2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_half2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_half2_1 = 549;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_uchar2_half2_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar2_half2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar2 a"
    // ain2 = "half2 b"
    public result_int reduce_my_uchar2_half2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_half2_1(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "half2 b"
    public result_int reduce_my_uchar2_half2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_half2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_half4_0 = 550;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_uchar2_half4_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar2_half4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar2 a"
    // ain2 = "half4 b"
    public result_int reduce_my_uchar2_half4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_half4_0(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "half4 b"
    public result_int reduce_my_uchar2_half4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_half4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_half4_1 = 551;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_uchar2_half4_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar2_half4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar2 a"
    // ain2 = "half4 b"
    public result_int reduce_my_uchar2_half4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_half4_1(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "half4 b"
    public result_int reduce_my_uchar2_half4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_half4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_float_0 = 552;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_uchar2_float_0(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar2_float_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar2 a"
    // ain2 = "float b"
    public result_int reduce_my_uchar2_float_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_float_0(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "float b"
    public result_int reduce_my_uchar2_float_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_float_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_float_1 = 553;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_uchar2_float_1(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar2_float_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar2 a"
    // ain2 = "float b"
    public result_int reduce_my_uchar2_float_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_float_1(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "float b"
    public result_int reduce_my_uchar2_float_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_float_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_float2_0 = 554;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_uchar2_float2_0(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar2_float2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar2 a"
    // ain2 = "float2 b"
    public result_int reduce_my_uchar2_float2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_float2_0(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "float2 b"
    public result_int reduce_my_uchar2_float2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_float2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_float2_1 = 555;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_uchar2_float2_1(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar2_float2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar2 a"
    // ain2 = "float2 b"
    public result_int reduce_my_uchar2_float2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_float2_1(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "float2 b"
    public result_int reduce_my_uchar2_float2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_float2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_float4_0 = 556;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_uchar2_float4_0(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar2_float4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar2 a"
    // ain2 = "float4 b"
    public result_int reduce_my_uchar2_float4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_float4_0(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "float4 b"
    public result_int reduce_my_uchar2_float4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_float4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_float4_1 = 557;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_uchar2_float4_1(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar2_float4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar2 a"
    // ain2 = "float4 b"
    public result_int reduce_my_uchar2_float4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_float4_1(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "float4 b"
    public result_int reduce_my_uchar2_float4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_float4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_char_0 = 558;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_uchar2_char_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar2_char_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar2 a"
    // ain2 = "char b"
    public result_int reduce_my_uchar2_char_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_char_0(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "char b"
    public result_int reduce_my_uchar2_char_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_char_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_char_1 = 559;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_uchar2_char_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar2_char_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar2 a"
    // ain2 = "char b"
    public result_int reduce_my_uchar2_char_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_char_1(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "char b"
    public result_int reduce_my_uchar2_char_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_char_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_char2_0 = 560;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_uchar2_char2_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar2_char2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar2 a"
    // ain2 = "char2 b"
    public result_int reduce_my_uchar2_char2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_char2_0(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "char2 b"
    public result_int reduce_my_uchar2_char2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_char2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_char2_1 = 561;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_uchar2_char2_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar2_char2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar2 a"
    // ain2 = "char2 b"
    public result_int reduce_my_uchar2_char2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_char2_1(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "char2 b"
    public result_int reduce_my_uchar2_char2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_char2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_char4_0 = 562;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_uchar2_char4_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar2_char4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar2 a"
    // ain2 = "char4 b"
    public result_int reduce_my_uchar2_char4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_char4_0(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "char4 b"
    public result_int reduce_my_uchar2_char4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_char4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_char4_1 = 563;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_uchar2_char4_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar2_char4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar2 a"
    // ain2 = "char4 b"
    public result_int reduce_my_uchar2_char4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_char4_1(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "char4 b"
    public result_int reduce_my_uchar2_char4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_char4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_short_0 = 564;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_uchar2_short_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar2_short_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar2 a"
    // ain2 = "short b"
    public result_int reduce_my_uchar2_short_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_short_0(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "short b"
    public result_int reduce_my_uchar2_short_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_short_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_short_1 = 565;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_uchar2_short_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar2_short_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar2 a"
    // ain2 = "short b"
    public result_int reduce_my_uchar2_short_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_short_1(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "short b"
    public result_int reduce_my_uchar2_short_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_short_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_short2_0 = 566;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_uchar2_short2_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar2_short2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar2 a"
    // ain2 = "short2 b"
    public result_int reduce_my_uchar2_short2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_short2_0(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "short2 b"
    public result_int reduce_my_uchar2_short2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_short2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_short2_1 = 567;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_uchar2_short2_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar2_short2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar2 a"
    // ain2 = "short2 b"
    public result_int reduce_my_uchar2_short2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_short2_1(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "short2 b"
    public result_int reduce_my_uchar2_short2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_short2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_short4_0 = 568;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_uchar2_short4_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar2_short4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar2 a"
    // ain2 = "short4 b"
    public result_int reduce_my_uchar2_short4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_short4_0(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "short4 b"
    public result_int reduce_my_uchar2_short4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_short4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_short4_1 = 569;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_uchar2_short4_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar2_short4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar2 a"
    // ain2 = "short4 b"
    public result_int reduce_my_uchar2_short4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_short4_1(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "short4 b"
    public result_int reduce_my_uchar2_short4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_short4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_uchar_0 = 570;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_uchar2_uchar_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar2_uchar_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar2 a"
    // ain2 = "uchar b"
    public result_int reduce_my_uchar2_uchar_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_uchar_0(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "uchar b"
    public result_int reduce_my_uchar2_uchar_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_uchar_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_uchar_1 = 571;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_uchar2_uchar_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar2_uchar_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar2 a"
    // ain2 = "uchar b"
    public result_int reduce_my_uchar2_uchar_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_uchar_1(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "uchar b"
    public result_int reduce_my_uchar2_uchar_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_uchar_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_uchar2_0 = 572;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_uchar2_uchar2_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar2_uchar2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar2 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_uchar2_uchar2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_uchar2_0(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_uchar2_uchar2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_uchar2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_uchar2_1 = 573;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_uchar2_uchar2_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar2_uchar2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar2 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_uchar2_uchar2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_uchar2_1(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_uchar2_uchar2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_uchar2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_uchar4_0 = 574;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_uchar2_uchar4_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar2_uchar4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar2 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_uchar2_uchar4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_uchar4_0(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_uchar2_uchar4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_uchar4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_uchar4_1 = 575;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_uchar2_uchar4_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar2_uchar4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar2 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_uchar2_uchar4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_uchar4_1(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_uchar2_uchar4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_uchar4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_ushort_0 = 576;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_uchar2_ushort_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar2_ushort_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar2 a"
    // ain2 = "ushort b"
    public result_int reduce_my_uchar2_ushort_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_ushort_0(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "ushort b"
    public result_int reduce_my_uchar2_ushort_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_ushort_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_ushort_1 = 577;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_uchar2_ushort_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar2_ushort_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar2 a"
    // ain2 = "ushort b"
    public result_int reduce_my_uchar2_ushort_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_ushort_1(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "ushort b"
    public result_int reduce_my_uchar2_ushort_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_ushort_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_ushort2_0 = 578;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_uchar2_ushort2_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar2_ushort2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar2 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_uchar2_ushort2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_ushort2_0(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_uchar2_ushort2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_ushort2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_ushort2_1 = 579;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_uchar2_ushort2_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar2_ushort2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar2 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_uchar2_ushort2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_ushort2_1(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_uchar2_ushort2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_ushort2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_ushort4_0 = 580;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_uchar2_ushort4_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar2_ushort4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar2 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_uchar2_ushort4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_ushort4_0(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_uchar2_ushort4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_ushort4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_ushort4_1 = 581;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_uchar2_ushort4_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar2_ushort4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar2 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_uchar2_ushort4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_ushort4_1(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_uchar2_ushort4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_ushort4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_bool_0 = 582;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_uchar2_bool_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __BOOLEAN, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar2_bool_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar2 a"
    // ain2 = "bool b"
    public result_int reduce_my_uchar2_bool_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_bool_0(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "bool b"
    public result_int reduce_my_uchar2_bool_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_bool_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_bool_1 = 583;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_uchar2_bool_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __BOOLEAN, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar2_bool_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar2 a"
    // ain2 = "bool b"
    public result_int reduce_my_uchar2_bool_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_bool_1(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "bool b"
    public result_int reduce_my_uchar2_bool_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_bool_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_rs_matrix2x2_0 = 584;
    // ain1 = "uchar2 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_uchar2_rs_matrix2x2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_rs_matrix2x2_0(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_uchar2_rs_matrix2x2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_rs_matrix2x2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_rs_matrix2x2_1 = 585;
    // ain1 = "uchar2 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_uchar2_rs_matrix2x2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_rs_matrix2x2_1(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_uchar2_rs_matrix2x2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_rs_matrix2x2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_MyStruct_0 = 586;
    // ain1 = "uchar2 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_uchar2_MyStruct_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_MyStruct_0(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_uchar2_MyStruct_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_MyStruct_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar2_MyStruct_1 = 587;
    // ain1 = "uchar2 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_uchar2_MyStruct_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar2_MyStruct_1(ain1, ain2, null);
    }

    // ain1 = "uchar2 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_uchar2_MyStruct_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar2_MyStruct_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_half_0 = 588;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_uchar4_half_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar4_half_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar4 a"
    // ain2 = "half b"
    public result_int reduce_my_uchar4_half_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_half_0(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "half b"
    public result_int reduce_my_uchar4_half_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_half_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_half_1 = 589;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_uchar4_half_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar4_half_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar4 a"
    // ain2 = "half b"
    public result_int reduce_my_uchar4_half_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_half_1(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "half b"
    public result_int reduce_my_uchar4_half_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_half_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_half2_0 = 590;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_uchar4_half2_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar4_half2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar4 a"
    // ain2 = "half2 b"
    public result_int reduce_my_uchar4_half2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_half2_0(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "half2 b"
    public result_int reduce_my_uchar4_half2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_half2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_half2_1 = 591;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_uchar4_half2_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar4_half2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar4 a"
    // ain2 = "half2 b"
    public result_int reduce_my_uchar4_half2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_half2_1(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "half2 b"
    public result_int reduce_my_uchar4_half2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_half2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_half4_0 = 592;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_uchar4_half4_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar4_half4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar4 a"
    // ain2 = "half4 b"
    public result_int reduce_my_uchar4_half4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_half4_0(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "half4 b"
    public result_int reduce_my_uchar4_half4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_half4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_half4_1 = 593;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_uchar4_half4_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar4_half4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar4 a"
    // ain2 = "half4 b"
    public result_int reduce_my_uchar4_half4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_half4_1(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "half4 b"
    public result_int reduce_my_uchar4_half4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_half4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_float_0 = 594;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_uchar4_float_0(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar4_float_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar4 a"
    // ain2 = "float b"
    public result_int reduce_my_uchar4_float_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_float_0(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "float b"
    public result_int reduce_my_uchar4_float_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_float_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_float_1 = 595;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_uchar4_float_1(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar4_float_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar4 a"
    // ain2 = "float b"
    public result_int reduce_my_uchar4_float_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_float_1(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "float b"
    public result_int reduce_my_uchar4_float_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_float_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_float2_0 = 596;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_uchar4_float2_0(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar4_float2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar4 a"
    // ain2 = "float2 b"
    public result_int reduce_my_uchar4_float2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_float2_0(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "float2 b"
    public result_int reduce_my_uchar4_float2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_float2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_float2_1 = 597;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_uchar4_float2_1(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar4_float2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar4 a"
    // ain2 = "float2 b"
    public result_int reduce_my_uchar4_float2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_float2_1(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "float2 b"
    public result_int reduce_my_uchar4_float2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_float2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_float4_0 = 598;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_uchar4_float4_0(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar4_float4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar4 a"
    // ain2 = "float4 b"
    public result_int reduce_my_uchar4_float4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_float4_0(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "float4 b"
    public result_int reduce_my_uchar4_float4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_float4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_float4_1 = 599;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_uchar4_float4_1(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar4_float4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar4 a"
    // ain2 = "float4 b"
    public result_int reduce_my_uchar4_float4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_float4_1(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "float4 b"
    public result_int reduce_my_uchar4_float4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_float4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_char_0 = 600;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_uchar4_char_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar4_char_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar4 a"
    // ain2 = "char b"
    public result_int reduce_my_uchar4_char_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_char_0(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "char b"
    public result_int reduce_my_uchar4_char_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_char_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_char_1 = 601;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_uchar4_char_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar4_char_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar4 a"
    // ain2 = "char b"
    public result_int reduce_my_uchar4_char_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_char_1(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "char b"
    public result_int reduce_my_uchar4_char_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_char_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_char2_0 = 602;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_uchar4_char2_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar4_char2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar4 a"
    // ain2 = "char2 b"
    public result_int reduce_my_uchar4_char2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_char2_0(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "char2 b"
    public result_int reduce_my_uchar4_char2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_char2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_char2_1 = 603;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_uchar4_char2_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar4_char2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar4 a"
    // ain2 = "char2 b"
    public result_int reduce_my_uchar4_char2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_char2_1(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "char2 b"
    public result_int reduce_my_uchar4_char2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_char2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_char4_0 = 604;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_uchar4_char4_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar4_char4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar4 a"
    // ain2 = "char4 b"
    public result_int reduce_my_uchar4_char4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_char4_0(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "char4 b"
    public result_int reduce_my_uchar4_char4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_char4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_char4_1 = 605;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_uchar4_char4_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar4_char4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar4 a"
    // ain2 = "char4 b"
    public result_int reduce_my_uchar4_char4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_char4_1(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "char4 b"
    public result_int reduce_my_uchar4_char4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_char4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_short_0 = 606;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_uchar4_short_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar4_short_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar4 a"
    // ain2 = "short b"
    public result_int reduce_my_uchar4_short_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_short_0(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "short b"
    public result_int reduce_my_uchar4_short_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_short_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_short_1 = 607;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_uchar4_short_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar4_short_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar4 a"
    // ain2 = "short b"
    public result_int reduce_my_uchar4_short_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_short_1(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "short b"
    public result_int reduce_my_uchar4_short_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_short_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_short2_0 = 608;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_uchar4_short2_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar4_short2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar4 a"
    // ain2 = "short2 b"
    public result_int reduce_my_uchar4_short2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_short2_0(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "short2 b"
    public result_int reduce_my_uchar4_short2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_short2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_short2_1 = 609;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_uchar4_short2_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar4_short2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar4 a"
    // ain2 = "short2 b"
    public result_int reduce_my_uchar4_short2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_short2_1(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "short2 b"
    public result_int reduce_my_uchar4_short2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_short2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_short4_0 = 610;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_uchar4_short4_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar4_short4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar4 a"
    // ain2 = "short4 b"
    public result_int reduce_my_uchar4_short4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_short4_0(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "short4 b"
    public result_int reduce_my_uchar4_short4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_short4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_short4_1 = 611;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_uchar4_short4_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar4_short4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar4 a"
    // ain2 = "short4 b"
    public result_int reduce_my_uchar4_short4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_short4_1(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "short4 b"
    public result_int reduce_my_uchar4_short4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_short4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_uchar_0 = 612;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_uchar4_uchar_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar4_uchar_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar4 a"
    // ain2 = "uchar b"
    public result_int reduce_my_uchar4_uchar_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_uchar_0(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "uchar b"
    public result_int reduce_my_uchar4_uchar_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_uchar_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_uchar_1 = 613;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_uchar4_uchar_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar4_uchar_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar4 a"
    // ain2 = "uchar b"
    public result_int reduce_my_uchar4_uchar_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_uchar_1(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "uchar b"
    public result_int reduce_my_uchar4_uchar_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_uchar_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_uchar2_0 = 614;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_uchar4_uchar2_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar4_uchar2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar4 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_uchar4_uchar2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_uchar2_0(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_uchar4_uchar2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_uchar2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_uchar2_1 = 615;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_uchar4_uchar2_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar4_uchar2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar4 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_uchar4_uchar2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_uchar2_1(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_uchar4_uchar2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_uchar2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_uchar4_0 = 616;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_uchar4_uchar4_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar4_uchar4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar4 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_uchar4_uchar4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_uchar4_0(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_uchar4_uchar4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_uchar4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_uchar4_1 = 617;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_uchar4_uchar4_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar4_uchar4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar4 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_uchar4_uchar4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_uchar4_1(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_uchar4_uchar4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_uchar4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_ushort_0 = 618;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_uchar4_ushort_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar4_ushort_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar4 a"
    // ain2 = "ushort b"
    public result_int reduce_my_uchar4_ushort_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_ushort_0(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "ushort b"
    public result_int reduce_my_uchar4_ushort_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_ushort_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_ushort_1 = 619;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_uchar4_ushort_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar4_ushort_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar4 a"
    // ain2 = "ushort b"
    public result_int reduce_my_uchar4_ushort_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_ushort_1(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "ushort b"
    public result_int reduce_my_uchar4_ushort_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_ushort_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_ushort2_0 = 620;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_uchar4_ushort2_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar4_ushort2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar4 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_uchar4_ushort2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_ushort2_0(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_uchar4_ushort2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_ushort2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_ushort2_1 = 621;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_uchar4_ushort2_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar4_ushort2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar4 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_uchar4_ushort2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_ushort2_1(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_uchar4_ushort2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_ushort2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_ushort4_0 = 622;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_uchar4_ushort4_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar4_ushort4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar4 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_uchar4_ushort4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_ushort4_0(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_uchar4_ushort4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_ushort4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_ushort4_1 = 623;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_uchar4_ushort4_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar4_ushort4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar4 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_uchar4_ushort4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_ushort4_1(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_uchar4_ushort4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_ushort4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_bool_0 = 624;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_uchar4_bool_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __BOOLEAN, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar4_bool_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar4 a"
    // ain2 = "bool b"
    public result_int reduce_my_uchar4_bool_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_bool_0(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "bool b"
    public result_int reduce_my_uchar4_bool_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_bool_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_bool_1 = 625;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_uchar4_bool_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U8_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __BOOLEAN, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_uchar4_bool_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "uchar4 a"
    // ain2 = "bool b"
    public result_int reduce_my_uchar4_bool_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_bool_1(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "bool b"
    public result_int reduce_my_uchar4_bool_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_bool_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_rs_matrix2x2_0 = 626;
    // ain1 = "uchar4 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_uchar4_rs_matrix2x2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_rs_matrix2x2_0(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_uchar4_rs_matrix2x2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_rs_matrix2x2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_rs_matrix2x2_1 = 627;
    // ain1 = "uchar4 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_uchar4_rs_matrix2x2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_rs_matrix2x2_1(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_uchar4_rs_matrix2x2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_rs_matrix2x2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_MyStruct_0 = 628;
    // ain1 = "uchar4 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_uchar4_MyStruct_0(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_MyStruct_0(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_uchar4_MyStruct_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_MyStruct_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_uchar4_MyStruct_1 = 629;
    // ain1 = "uchar4 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_uchar4_MyStruct_1(Allocation ain1, Allocation ain2) {
        return reduce_my_uchar4_MyStruct_1(ain1, ain2, null);
    }

    // ain1 = "uchar4 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_uchar4_MyStruct_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_uchar4_MyStruct_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_half_0 = 630;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_ushort_half_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort_half_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort a"
    // ain2 = "half b"
    public result_int reduce_my_ushort_half_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_half_0(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "half b"
    public result_int reduce_my_ushort_half_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_half_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_half_1 = 631;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_ushort_half_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort_half_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort a"
    // ain2 = "half b"
    public result_int reduce_my_ushort_half_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_half_1(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "half b"
    public result_int reduce_my_ushort_half_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_half_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_half2_0 = 632;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_ushort_half2_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort_half2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort a"
    // ain2 = "half2 b"
    public result_int reduce_my_ushort_half2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_half2_0(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "half2 b"
    public result_int reduce_my_ushort_half2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_half2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_half2_1 = 633;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_ushort_half2_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort_half2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort a"
    // ain2 = "half2 b"
    public result_int reduce_my_ushort_half2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_half2_1(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "half2 b"
    public result_int reduce_my_ushort_half2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_half2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_half4_0 = 634;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_ushort_half4_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort_half4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort a"
    // ain2 = "half4 b"
    public result_int reduce_my_ushort_half4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_half4_0(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "half4 b"
    public result_int reduce_my_ushort_half4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_half4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_half4_1 = 635;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_ushort_half4_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort_half4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort a"
    // ain2 = "half4 b"
    public result_int reduce_my_ushort_half4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_half4_1(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "half4 b"
    public result_int reduce_my_ushort_half4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_half4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_float_0 = 636;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_ushort_float_0(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort_float_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort a"
    // ain2 = "float b"
    public result_int reduce_my_ushort_float_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_float_0(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "float b"
    public result_int reduce_my_ushort_float_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_float_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_float_1 = 637;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_ushort_float_1(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort_float_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort a"
    // ain2 = "float b"
    public result_int reduce_my_ushort_float_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_float_1(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "float b"
    public result_int reduce_my_ushort_float_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_float_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_float2_0 = 638;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_ushort_float2_0(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort_float2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort a"
    // ain2 = "float2 b"
    public result_int reduce_my_ushort_float2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_float2_0(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "float2 b"
    public result_int reduce_my_ushort_float2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_float2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_float2_1 = 639;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_ushort_float2_1(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort_float2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort a"
    // ain2 = "float2 b"
    public result_int reduce_my_ushort_float2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_float2_1(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "float2 b"
    public result_int reduce_my_ushort_float2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_float2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_float4_0 = 640;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_ushort_float4_0(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort_float4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort a"
    // ain2 = "float4 b"
    public result_int reduce_my_ushort_float4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_float4_0(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "float4 b"
    public result_int reduce_my_ushort_float4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_float4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_float4_1 = 641;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_ushort_float4_1(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort_float4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort a"
    // ain2 = "float4 b"
    public result_int reduce_my_ushort_float4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_float4_1(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "float4 b"
    public result_int reduce_my_ushort_float4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_float4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_char_0 = 642;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_ushort_char_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort_char_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort a"
    // ain2 = "char b"
    public result_int reduce_my_ushort_char_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_char_0(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "char b"
    public result_int reduce_my_ushort_char_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_char_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_char_1 = 643;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_ushort_char_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort_char_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort a"
    // ain2 = "char b"
    public result_int reduce_my_ushort_char_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_char_1(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "char b"
    public result_int reduce_my_ushort_char_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_char_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_char2_0 = 644;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_ushort_char2_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort_char2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort a"
    // ain2 = "char2 b"
    public result_int reduce_my_ushort_char2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_char2_0(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "char2 b"
    public result_int reduce_my_ushort_char2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_char2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_char2_1 = 645;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_ushort_char2_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort_char2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort a"
    // ain2 = "char2 b"
    public result_int reduce_my_ushort_char2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_char2_1(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "char2 b"
    public result_int reduce_my_ushort_char2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_char2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_char4_0 = 646;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_ushort_char4_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort_char4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort a"
    // ain2 = "char4 b"
    public result_int reduce_my_ushort_char4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_char4_0(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "char4 b"
    public result_int reduce_my_ushort_char4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_char4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_char4_1 = 647;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_ushort_char4_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort_char4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort a"
    // ain2 = "char4 b"
    public result_int reduce_my_ushort_char4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_char4_1(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "char4 b"
    public result_int reduce_my_ushort_char4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_char4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_short_0 = 648;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_ushort_short_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort_short_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort a"
    // ain2 = "short b"
    public result_int reduce_my_ushort_short_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_short_0(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "short b"
    public result_int reduce_my_ushort_short_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_short_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_short_1 = 649;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_ushort_short_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort_short_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort a"
    // ain2 = "short b"
    public result_int reduce_my_ushort_short_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_short_1(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "short b"
    public result_int reduce_my_ushort_short_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_short_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_short2_0 = 650;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_ushort_short2_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort_short2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort a"
    // ain2 = "short2 b"
    public result_int reduce_my_ushort_short2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_short2_0(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "short2 b"
    public result_int reduce_my_ushort_short2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_short2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_short2_1 = 651;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_ushort_short2_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort_short2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort a"
    // ain2 = "short2 b"
    public result_int reduce_my_ushort_short2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_short2_1(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "short2 b"
    public result_int reduce_my_ushort_short2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_short2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_short4_0 = 652;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_ushort_short4_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort_short4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort a"
    // ain2 = "short4 b"
    public result_int reduce_my_ushort_short4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_short4_0(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "short4 b"
    public result_int reduce_my_ushort_short4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_short4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_short4_1 = 653;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_ushort_short4_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort_short4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort a"
    // ain2 = "short4 b"
    public result_int reduce_my_ushort_short4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_short4_1(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "short4 b"
    public result_int reduce_my_ushort_short4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_short4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_uchar_0 = 654;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_ushort_uchar_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort_uchar_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort a"
    // ain2 = "uchar b"
    public result_int reduce_my_ushort_uchar_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_uchar_0(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "uchar b"
    public result_int reduce_my_ushort_uchar_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_uchar_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_uchar_1 = 655;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_ushort_uchar_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort_uchar_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort a"
    // ain2 = "uchar b"
    public result_int reduce_my_ushort_uchar_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_uchar_1(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "uchar b"
    public result_int reduce_my_ushort_uchar_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_uchar_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_uchar2_0 = 656;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_ushort_uchar2_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort_uchar2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_ushort_uchar2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_uchar2_0(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_ushort_uchar2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_uchar2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_uchar2_1 = 657;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_ushort_uchar2_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort_uchar2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_ushort_uchar2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_uchar2_1(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_ushort_uchar2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_uchar2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_uchar4_0 = 658;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_ushort_uchar4_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort_uchar4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_ushort_uchar4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_uchar4_0(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_ushort_uchar4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_uchar4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_uchar4_1 = 659;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_ushort_uchar4_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort_uchar4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_ushort_uchar4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_uchar4_1(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_ushort_uchar4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_uchar4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_ushort_0 = 660;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_ushort_ushort_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort_ushort_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort a"
    // ain2 = "ushort b"
    public result_int reduce_my_ushort_ushort_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_ushort_0(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "ushort b"
    public result_int reduce_my_ushort_ushort_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_ushort_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_ushort_1 = 661;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_ushort_ushort_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort_ushort_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort a"
    // ain2 = "ushort b"
    public result_int reduce_my_ushort_ushort_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_ushort_1(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "ushort b"
    public result_int reduce_my_ushort_ushort_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_ushort_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_ushort2_0 = 662;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_ushort_ushort2_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort_ushort2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_ushort_ushort2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_ushort2_0(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_ushort_ushort2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_ushort2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_ushort2_1 = 663;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_ushort_ushort2_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort_ushort2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_ushort_ushort2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_ushort2_1(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_ushort_ushort2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_ushort2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_ushort4_0 = 664;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_ushort_ushort4_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort_ushort4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_ushort_ushort4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_ushort4_0(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_ushort_ushort4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_ushort4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_ushort4_1 = 665;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_ushort_ushort4_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort_ushort4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_ushort_ushort4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_ushort4_1(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_ushort_ushort4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_ushort4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_bool_0 = 666;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_ushort_bool_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __BOOLEAN, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort_bool_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort a"
    // ain2 = "bool b"
    public result_int reduce_my_ushort_bool_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_bool_0(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "bool b"
    public result_int reduce_my_ushort_bool_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_bool_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_bool_1 = 667;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_ushort_bool_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __BOOLEAN, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort_bool_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort a"
    // ain2 = "bool b"
    public result_int reduce_my_ushort_bool_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_bool_1(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "bool b"
    public result_int reduce_my_ushort_bool_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_bool_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_rs_matrix2x2_0 = 668;
    // ain1 = "ushort a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_ushort_rs_matrix2x2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_rs_matrix2x2_0(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_ushort_rs_matrix2x2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_rs_matrix2x2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_rs_matrix2x2_1 = 669;
    // ain1 = "ushort a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_ushort_rs_matrix2x2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_rs_matrix2x2_1(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_ushort_rs_matrix2x2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_rs_matrix2x2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_MyStruct_0 = 670;
    // ain1 = "ushort a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_ushort_MyStruct_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_MyStruct_0(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_ushort_MyStruct_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_MyStruct_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort_MyStruct_1 = 671;
    // ain1 = "ushort a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_ushort_MyStruct_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort_MyStruct_1(ain1, ain2, null);
    }

    // ain1 = "ushort a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_ushort_MyStruct_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort_MyStruct_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_half_0 = 672;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_ushort2_half_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort2_half_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort2 a"
    // ain2 = "half b"
    public result_int reduce_my_ushort2_half_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_half_0(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "half b"
    public result_int reduce_my_ushort2_half_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_half_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_half_1 = 673;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_ushort2_half_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort2_half_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort2 a"
    // ain2 = "half b"
    public result_int reduce_my_ushort2_half_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_half_1(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "half b"
    public result_int reduce_my_ushort2_half_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_half_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_half2_0 = 674;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_ushort2_half2_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort2_half2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort2 a"
    // ain2 = "half2 b"
    public result_int reduce_my_ushort2_half2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_half2_0(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "half2 b"
    public result_int reduce_my_ushort2_half2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_half2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_half2_1 = 675;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_ushort2_half2_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort2_half2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort2 a"
    // ain2 = "half2 b"
    public result_int reduce_my_ushort2_half2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_half2_1(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "half2 b"
    public result_int reduce_my_ushort2_half2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_half2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_half4_0 = 676;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_ushort2_half4_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort2_half4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort2 a"
    // ain2 = "half4 b"
    public result_int reduce_my_ushort2_half4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_half4_0(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "half4 b"
    public result_int reduce_my_ushort2_half4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_half4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_half4_1 = 677;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_ushort2_half4_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort2_half4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort2 a"
    // ain2 = "half4 b"
    public result_int reduce_my_ushort2_half4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_half4_1(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "half4 b"
    public result_int reduce_my_ushort2_half4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_half4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_float_0 = 678;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_ushort2_float_0(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort2_float_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort2 a"
    // ain2 = "float b"
    public result_int reduce_my_ushort2_float_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_float_0(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "float b"
    public result_int reduce_my_ushort2_float_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_float_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_float_1 = 679;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_ushort2_float_1(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort2_float_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort2 a"
    // ain2 = "float b"
    public result_int reduce_my_ushort2_float_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_float_1(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "float b"
    public result_int reduce_my_ushort2_float_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_float_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_float2_0 = 680;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_ushort2_float2_0(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort2_float2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort2 a"
    // ain2 = "float2 b"
    public result_int reduce_my_ushort2_float2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_float2_0(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "float2 b"
    public result_int reduce_my_ushort2_float2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_float2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_float2_1 = 681;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_ushort2_float2_1(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort2_float2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort2 a"
    // ain2 = "float2 b"
    public result_int reduce_my_ushort2_float2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_float2_1(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "float2 b"
    public result_int reduce_my_ushort2_float2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_float2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_float4_0 = 682;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_ushort2_float4_0(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort2_float4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort2 a"
    // ain2 = "float4 b"
    public result_int reduce_my_ushort2_float4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_float4_0(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "float4 b"
    public result_int reduce_my_ushort2_float4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_float4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_float4_1 = 683;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_ushort2_float4_1(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort2_float4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort2 a"
    // ain2 = "float4 b"
    public result_int reduce_my_ushort2_float4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_float4_1(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "float4 b"
    public result_int reduce_my_ushort2_float4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_float4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_char_0 = 684;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_ushort2_char_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort2_char_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort2 a"
    // ain2 = "char b"
    public result_int reduce_my_ushort2_char_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_char_0(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "char b"
    public result_int reduce_my_ushort2_char_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_char_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_char_1 = 685;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_ushort2_char_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort2_char_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort2 a"
    // ain2 = "char b"
    public result_int reduce_my_ushort2_char_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_char_1(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "char b"
    public result_int reduce_my_ushort2_char_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_char_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_char2_0 = 686;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_ushort2_char2_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort2_char2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort2 a"
    // ain2 = "char2 b"
    public result_int reduce_my_ushort2_char2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_char2_0(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "char2 b"
    public result_int reduce_my_ushort2_char2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_char2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_char2_1 = 687;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_ushort2_char2_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort2_char2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort2 a"
    // ain2 = "char2 b"
    public result_int reduce_my_ushort2_char2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_char2_1(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "char2 b"
    public result_int reduce_my_ushort2_char2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_char2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_char4_0 = 688;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_ushort2_char4_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort2_char4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort2 a"
    // ain2 = "char4 b"
    public result_int reduce_my_ushort2_char4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_char4_0(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "char4 b"
    public result_int reduce_my_ushort2_char4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_char4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_char4_1 = 689;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_ushort2_char4_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort2_char4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort2 a"
    // ain2 = "char4 b"
    public result_int reduce_my_ushort2_char4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_char4_1(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "char4 b"
    public result_int reduce_my_ushort2_char4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_char4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_short_0 = 690;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_ushort2_short_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort2_short_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort2 a"
    // ain2 = "short b"
    public result_int reduce_my_ushort2_short_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_short_0(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "short b"
    public result_int reduce_my_ushort2_short_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_short_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_short_1 = 691;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_ushort2_short_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort2_short_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort2 a"
    // ain2 = "short b"
    public result_int reduce_my_ushort2_short_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_short_1(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "short b"
    public result_int reduce_my_ushort2_short_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_short_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_short2_0 = 692;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_ushort2_short2_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort2_short2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort2 a"
    // ain2 = "short2 b"
    public result_int reduce_my_ushort2_short2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_short2_0(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "short2 b"
    public result_int reduce_my_ushort2_short2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_short2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_short2_1 = 693;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_ushort2_short2_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort2_short2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort2 a"
    // ain2 = "short2 b"
    public result_int reduce_my_ushort2_short2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_short2_1(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "short2 b"
    public result_int reduce_my_ushort2_short2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_short2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_short4_0 = 694;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_ushort2_short4_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort2_short4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort2 a"
    // ain2 = "short4 b"
    public result_int reduce_my_ushort2_short4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_short4_0(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "short4 b"
    public result_int reduce_my_ushort2_short4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_short4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_short4_1 = 695;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_ushort2_short4_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort2_short4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort2 a"
    // ain2 = "short4 b"
    public result_int reduce_my_ushort2_short4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_short4_1(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "short4 b"
    public result_int reduce_my_ushort2_short4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_short4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_uchar_0 = 696;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_ushort2_uchar_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort2_uchar_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort2 a"
    // ain2 = "uchar b"
    public result_int reduce_my_ushort2_uchar_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_uchar_0(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "uchar b"
    public result_int reduce_my_ushort2_uchar_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_uchar_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_uchar_1 = 697;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_ushort2_uchar_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort2_uchar_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort2 a"
    // ain2 = "uchar b"
    public result_int reduce_my_ushort2_uchar_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_uchar_1(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "uchar b"
    public result_int reduce_my_ushort2_uchar_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_uchar_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_uchar2_0 = 698;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_ushort2_uchar2_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort2_uchar2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort2 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_ushort2_uchar2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_uchar2_0(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_ushort2_uchar2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_uchar2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_uchar2_1 = 699;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_ushort2_uchar2_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort2_uchar2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort2 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_ushort2_uchar2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_uchar2_1(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_ushort2_uchar2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_uchar2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_uchar4_0 = 700;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_ushort2_uchar4_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort2_uchar4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort2 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_ushort2_uchar4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_uchar4_0(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_ushort2_uchar4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_uchar4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_uchar4_1 = 701;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_ushort2_uchar4_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort2_uchar4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort2 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_ushort2_uchar4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_uchar4_1(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_ushort2_uchar4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_uchar4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_ushort_0 = 702;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_ushort2_ushort_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort2_ushort_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort2 a"
    // ain2 = "ushort b"
    public result_int reduce_my_ushort2_ushort_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_ushort_0(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "ushort b"
    public result_int reduce_my_ushort2_ushort_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_ushort_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_ushort_1 = 703;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_ushort2_ushort_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort2_ushort_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort2 a"
    // ain2 = "ushort b"
    public result_int reduce_my_ushort2_ushort_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_ushort_1(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "ushort b"
    public result_int reduce_my_ushort2_ushort_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_ushort_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_ushort2_0 = 704;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_ushort2_ushort2_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort2_ushort2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort2 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_ushort2_ushort2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_ushort2_0(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_ushort2_ushort2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_ushort2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_ushort2_1 = 705;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_ushort2_ushort2_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort2_ushort2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort2 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_ushort2_ushort2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_ushort2_1(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_ushort2_ushort2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_ushort2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_ushort4_0 = 706;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_ushort2_ushort4_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort2_ushort4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort2 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_ushort2_ushort4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_ushort4_0(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_ushort2_ushort4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_ushort4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_ushort4_1 = 707;
    // in1 = "a", flattened 2-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_ushort2_ushort4_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort2_ushort4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort2 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_ushort2_ushort4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_ushort4_1(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_ushort2_ushort4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_ushort4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_bool_0 = 708;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_ushort2_bool_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __BOOLEAN, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort2_bool_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort2 a"
    // ain2 = "bool b"
    public result_int reduce_my_ushort2_bool_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_bool_0(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "bool b"
    public result_int reduce_my_ushort2_bool_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_bool_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_bool_1 = 709;
    // in1 = "a", flattened 2-vectors
    // in2 = "b"
    public result_int reduce_my_ushort2_bool_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 2 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_2, in1.length / 2);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 2 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __BOOLEAN, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort2_bool_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort2 a"
    // ain2 = "bool b"
    public result_int reduce_my_ushort2_bool_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_bool_1(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "bool b"
    public result_int reduce_my_ushort2_bool_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_bool_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_rs_matrix2x2_0 = 710;
    // ain1 = "ushort2 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_ushort2_rs_matrix2x2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_rs_matrix2x2_0(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_ushort2_rs_matrix2x2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_rs_matrix2x2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_rs_matrix2x2_1 = 711;
    // ain1 = "ushort2 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_ushort2_rs_matrix2x2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_rs_matrix2x2_1(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_ushort2_rs_matrix2x2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_rs_matrix2x2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_MyStruct_0 = 712;
    // ain1 = "ushort2 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_ushort2_MyStruct_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_MyStruct_0(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_ushort2_MyStruct_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_MyStruct_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort2_MyStruct_1 = 713;
    // ain1 = "ushort2 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_ushort2_MyStruct_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort2_MyStruct_1(ain1, ain2, null);
    }

    // ain1 = "ushort2 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_ushort2_MyStruct_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort2_MyStruct_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_half_0 = 714;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_ushort4_half_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort4_half_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort4 a"
    // ain2 = "half b"
    public result_int reduce_my_ushort4_half_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_half_0(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "half b"
    public result_int reduce_my_ushort4_half_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_half_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_half_1 = 715;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_ushort4_half_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort4_half_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort4 a"
    // ain2 = "half b"
    public result_int reduce_my_ushort4_half_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_half_1(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "half b"
    public result_int reduce_my_ushort4_half_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_half_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_half2_0 = 716;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_ushort4_half2_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort4_half2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort4 a"
    // ain2 = "half2 b"
    public result_int reduce_my_ushort4_half2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_half2_0(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "half2 b"
    public result_int reduce_my_ushort4_half2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_half2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_half2_1 = 717;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_ushort4_half2_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort4_half2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort4 a"
    // ain2 = "half2 b"
    public result_int reduce_my_ushort4_half2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_half2_1(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "half2 b"
    public result_int reduce_my_ushort4_half2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_half2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_half4_0 = 718;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_ushort4_half4_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort4_half4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort4 a"
    // ain2 = "half4 b"
    public result_int reduce_my_ushort4_half4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_half4_0(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "half4 b"
    public result_int reduce_my_ushort4_half4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_half4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_half4_1 = 719;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_ushort4_half4_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort4_half4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort4 a"
    // ain2 = "half4 b"
    public result_int reduce_my_ushort4_half4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_half4_1(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "half4 b"
    public result_int reduce_my_ushort4_half4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_half4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_float_0 = 720;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_ushort4_float_0(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort4_float_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort4 a"
    // ain2 = "float b"
    public result_int reduce_my_ushort4_float_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_float_0(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "float b"
    public result_int reduce_my_ushort4_float_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_float_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_float_1 = 721;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_ushort4_float_1(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort4_float_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort4 a"
    // ain2 = "float b"
    public result_int reduce_my_ushort4_float_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_float_1(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "float b"
    public result_int reduce_my_ushort4_float_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_float_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_float2_0 = 722;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_ushort4_float2_0(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort4_float2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort4 a"
    // ain2 = "float2 b"
    public result_int reduce_my_ushort4_float2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_float2_0(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "float2 b"
    public result_int reduce_my_ushort4_float2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_float2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_float2_1 = 723;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_ushort4_float2_1(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort4_float2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort4 a"
    // ain2 = "float2 b"
    public result_int reduce_my_ushort4_float2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_float2_1(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "float2 b"
    public result_int reduce_my_ushort4_float2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_float2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_float4_0 = 724;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_ushort4_float4_0(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort4_float4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort4 a"
    // ain2 = "float4 b"
    public result_int reduce_my_ushort4_float4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_float4_0(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "float4 b"
    public result_int reduce_my_ushort4_float4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_float4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_float4_1 = 725;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_ushort4_float4_1(short[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort4_float4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort4 a"
    // ain2 = "float4 b"
    public result_int reduce_my_ushort4_float4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_float4_1(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "float4 b"
    public result_int reduce_my_ushort4_float4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_float4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_char_0 = 726;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_ushort4_char_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort4_char_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort4 a"
    // ain2 = "char b"
    public result_int reduce_my_ushort4_char_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_char_0(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "char b"
    public result_int reduce_my_ushort4_char_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_char_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_char_1 = 727;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_ushort4_char_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort4_char_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort4 a"
    // ain2 = "char b"
    public result_int reduce_my_ushort4_char_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_char_1(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "char b"
    public result_int reduce_my_ushort4_char_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_char_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_char2_0 = 728;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_ushort4_char2_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort4_char2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort4 a"
    // ain2 = "char2 b"
    public result_int reduce_my_ushort4_char2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_char2_0(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "char2 b"
    public result_int reduce_my_ushort4_char2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_char2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_char2_1 = 729;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_ushort4_char2_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort4_char2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort4 a"
    // ain2 = "char2 b"
    public result_int reduce_my_ushort4_char2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_char2_1(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "char2 b"
    public result_int reduce_my_ushort4_char2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_char2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_char4_0 = 730;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_ushort4_char4_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort4_char4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort4 a"
    // ain2 = "char4 b"
    public result_int reduce_my_ushort4_char4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_char4_0(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "char4 b"
    public result_int reduce_my_ushort4_char4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_char4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_char4_1 = 731;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_ushort4_char4_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort4_char4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort4 a"
    // ain2 = "char4 b"
    public result_int reduce_my_ushort4_char4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_char4_1(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "char4 b"
    public result_int reduce_my_ushort4_char4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_char4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_short_0 = 732;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_ushort4_short_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort4_short_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort4 a"
    // ain2 = "short b"
    public result_int reduce_my_ushort4_short_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_short_0(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "short b"
    public result_int reduce_my_ushort4_short_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_short_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_short_1 = 733;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_ushort4_short_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort4_short_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort4 a"
    // ain2 = "short b"
    public result_int reduce_my_ushort4_short_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_short_1(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "short b"
    public result_int reduce_my_ushort4_short_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_short_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_short2_0 = 734;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_ushort4_short2_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort4_short2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort4 a"
    // ain2 = "short2 b"
    public result_int reduce_my_ushort4_short2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_short2_0(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "short2 b"
    public result_int reduce_my_ushort4_short2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_short2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_short2_1 = 735;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_ushort4_short2_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort4_short2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort4 a"
    // ain2 = "short2 b"
    public result_int reduce_my_ushort4_short2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_short2_1(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "short2 b"
    public result_int reduce_my_ushort4_short2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_short2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_short4_0 = 736;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_ushort4_short4_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort4_short4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort4 a"
    // ain2 = "short4 b"
    public result_int reduce_my_ushort4_short4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_short4_0(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "short4 b"
    public result_int reduce_my_ushort4_short4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_short4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_short4_1 = 737;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_ushort4_short4_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort4_short4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort4 a"
    // ain2 = "short4 b"
    public result_int reduce_my_ushort4_short4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_short4_1(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "short4 b"
    public result_int reduce_my_ushort4_short4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_short4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_uchar_0 = 738;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_ushort4_uchar_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort4_uchar_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort4 a"
    // ain2 = "uchar b"
    public result_int reduce_my_ushort4_uchar_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_uchar_0(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "uchar b"
    public result_int reduce_my_ushort4_uchar_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_uchar_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_uchar_1 = 739;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_ushort4_uchar_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort4_uchar_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort4 a"
    // ain2 = "uchar b"
    public result_int reduce_my_ushort4_uchar_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_uchar_1(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "uchar b"
    public result_int reduce_my_ushort4_uchar_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_uchar_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_uchar2_0 = 740;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_ushort4_uchar2_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort4_uchar2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort4 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_ushort4_uchar2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_uchar2_0(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_ushort4_uchar2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_uchar2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_uchar2_1 = 741;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_ushort4_uchar2_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort4_uchar2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort4 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_ushort4_uchar2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_uchar2_1(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_ushort4_uchar2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_uchar2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_uchar4_0 = 742;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_ushort4_uchar4_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort4_uchar4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort4 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_ushort4_uchar4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_uchar4_0(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_ushort4_uchar4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_uchar4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_uchar4_1 = 743;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_ushort4_uchar4_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort4_uchar4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort4 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_ushort4_uchar4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_uchar4_1(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_ushort4_uchar4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_uchar4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_ushort_0 = 744;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_ushort4_ushort_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort4_ushort_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort4 a"
    // ain2 = "ushort b"
    public result_int reduce_my_ushort4_ushort_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_ushort_0(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "ushort b"
    public result_int reduce_my_ushort4_ushort_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_ushort_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_ushort_1 = 745;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_ushort4_ushort_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort4_ushort_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort4 a"
    // ain2 = "ushort b"
    public result_int reduce_my_ushort4_ushort_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_ushort_1(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "ushort b"
    public result_int reduce_my_ushort4_ushort_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_ushort_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_ushort2_0 = 746;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_ushort4_ushort2_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort4_ushort2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort4 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_ushort4_ushort2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_ushort2_0(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_ushort4_ushort2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_ushort2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_ushort2_1 = 747;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_ushort4_ushort2_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort4_ushort2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort4 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_ushort4_ushort2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_ushort2_1(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_ushort4_ushort2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_ushort2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_ushort4_0 = 748;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_ushort4_ushort4_0(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort4_ushort4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort4 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_ushort4_ushort4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_ushort4_0(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_ushort4_ushort4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_ushort4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_ushort4_1 = 749;
    // in1 = "a", flattened 4-vectors
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_ushort4_ushort4_1(short[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort4_ushort4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort4 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_ushort4_ushort4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_ushort4_1(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_ushort4_ushort4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_ushort4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_bool_0 = 750;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_ushort4_bool_0(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __BOOLEAN, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort4_bool_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort4 a"
    // ain2 = "bool b"
    public result_int reduce_my_ushort4_bool_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_bool_0(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "bool b"
    public result_int reduce_my_ushort4_bool_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_bool_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_bool_1 = 751;
    // in1 = "a", flattened 4-vectors
    // in2 = "b"
    public result_int reduce_my_ushort4_bool_1(short[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in1.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in1\" is not a multiple of 4 in length!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __U16_4, in1.length / 4);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length / 4 != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __BOOLEAN, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_ushort4_bool_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "ushort4 a"
    // ain2 = "bool b"
    public result_int reduce_my_ushort4_bool_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_bool_1(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "bool b"
    public result_int reduce_my_ushort4_bool_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_bool_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_rs_matrix2x2_0 = 752;
    // ain1 = "ushort4 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_ushort4_rs_matrix2x2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_rs_matrix2x2_0(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_ushort4_rs_matrix2x2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_rs_matrix2x2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_rs_matrix2x2_1 = 753;
    // ain1 = "ushort4 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_ushort4_rs_matrix2x2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_rs_matrix2x2_1(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_ushort4_rs_matrix2x2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_rs_matrix2x2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_MyStruct_0 = 754;
    // ain1 = "ushort4 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_ushort4_MyStruct_0(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_MyStruct_0(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_ushort4_MyStruct_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_MyStruct_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_ushort4_MyStruct_1 = 755;
    // ain1 = "ushort4 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_ushort4_MyStruct_1(Allocation ain1, Allocation ain2) {
        return reduce_my_ushort4_MyStruct_1(ain1, ain2, null);
    }

    // ain1 = "ushort4 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_ushort4_MyStruct_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_ushort4_MyStruct_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_half_0 = 756;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_bool_half_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __BOOLEAN, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_bool_half_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "bool a"
    // ain2 = "half b"
    public result_int reduce_my_bool_half_0(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_half_0(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "half b"
    public result_int reduce_my_bool_half_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_half_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_half_1 = 757;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_bool_half_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __BOOLEAN, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_bool_half_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "bool a"
    // ain2 = "half b"
    public result_int reduce_my_bool_half_1(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_half_1(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "half b"
    public result_int reduce_my_bool_half_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_half_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_half2_0 = 758;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_bool_half2_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __BOOLEAN, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_bool_half2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "bool a"
    // ain2 = "half2 b"
    public result_int reduce_my_bool_half2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_half2_0(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "half2 b"
    public result_int reduce_my_bool_half2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_half2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_half2_1 = 759;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_bool_half2_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __BOOLEAN, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_bool_half2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "bool a"
    // ain2 = "half2 b"
    public result_int reduce_my_bool_half2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_half2_1(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "half2 b"
    public result_int reduce_my_bool_half2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_half2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_half4_0 = 760;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_bool_half4_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __BOOLEAN, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_bool_half4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "bool a"
    // ain2 = "half4 b"
    public result_int reduce_my_bool_half4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_half4_0(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "half4 b"
    public result_int reduce_my_bool_half4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_half4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_half4_1 = 761;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_bool_half4_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __BOOLEAN, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_bool_half4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "bool a"
    // ain2 = "half4 b"
    public result_int reduce_my_bool_half4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_half4_1(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "half4 b"
    public result_int reduce_my_bool_half4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_half4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_float_0 = 762;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_bool_float_0(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __BOOLEAN, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_bool_float_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "bool a"
    // ain2 = "float b"
    public result_int reduce_my_bool_float_0(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_float_0(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "float b"
    public result_int reduce_my_bool_float_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_float_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_float_1 = 763;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_bool_float_1(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __BOOLEAN, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_bool_float_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "bool a"
    // ain2 = "float b"
    public result_int reduce_my_bool_float_1(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_float_1(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "float b"
    public result_int reduce_my_bool_float_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_float_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_float2_0 = 764;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_bool_float2_0(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __BOOLEAN, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_bool_float2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "bool a"
    // ain2 = "float2 b"
    public result_int reduce_my_bool_float2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_float2_0(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "float2 b"
    public result_int reduce_my_bool_float2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_float2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_float2_1 = 765;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_bool_float2_1(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __BOOLEAN, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_bool_float2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "bool a"
    // ain2 = "float2 b"
    public result_int reduce_my_bool_float2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_float2_1(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "float2 b"
    public result_int reduce_my_bool_float2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_float2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_float4_0 = 766;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_bool_float4_0(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __BOOLEAN, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_bool_float4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "bool a"
    // ain2 = "float4 b"
    public result_int reduce_my_bool_float4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_float4_0(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "float4 b"
    public result_int reduce_my_bool_float4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_float4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_float4_1 = 767;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_bool_float4_1(byte[] in1, float[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __BOOLEAN, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __F32_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_bool_float4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "bool a"
    // ain2 = "float4 b"
    public result_int reduce_my_bool_float4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_float4_1(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "float4 b"
    public result_int reduce_my_bool_float4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_float4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_char_0 = 768;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_bool_char_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __BOOLEAN, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_bool_char_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "bool a"
    // ain2 = "char b"
    public result_int reduce_my_bool_char_0(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_char_0(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "char b"
    public result_int reduce_my_bool_char_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_char_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_char_1 = 769;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_bool_char_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __BOOLEAN, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_bool_char_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "bool a"
    // ain2 = "char b"
    public result_int reduce_my_bool_char_1(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_char_1(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "char b"
    public result_int reduce_my_bool_char_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_char_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_char2_0 = 770;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_bool_char2_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __BOOLEAN, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_bool_char2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "bool a"
    // ain2 = "char2 b"
    public result_int reduce_my_bool_char2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_char2_0(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "char2 b"
    public result_int reduce_my_bool_char2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_char2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_char2_1 = 771;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_bool_char2_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __BOOLEAN, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_bool_char2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "bool a"
    // ain2 = "char2 b"
    public result_int reduce_my_bool_char2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_char2_1(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "char2 b"
    public result_int reduce_my_bool_char2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_char2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_char4_0 = 772;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_bool_char4_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __BOOLEAN, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_bool_char4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "bool a"
    // ain2 = "char4 b"
    public result_int reduce_my_bool_char4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_char4_0(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "char4 b"
    public result_int reduce_my_bool_char4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_char4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_char4_1 = 773;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_bool_char4_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __BOOLEAN, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_bool_char4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "bool a"
    // ain2 = "char4 b"
    public result_int reduce_my_bool_char4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_char4_1(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "char4 b"
    public result_int reduce_my_bool_char4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_char4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_short_0 = 774;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_bool_short_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __BOOLEAN, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_bool_short_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "bool a"
    // ain2 = "short b"
    public result_int reduce_my_bool_short_0(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_short_0(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "short b"
    public result_int reduce_my_bool_short_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_short_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_short_1 = 775;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_bool_short_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __BOOLEAN, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_bool_short_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "bool a"
    // ain2 = "short b"
    public result_int reduce_my_bool_short_1(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_short_1(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "short b"
    public result_int reduce_my_bool_short_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_short_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_short2_0 = 776;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_bool_short2_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __BOOLEAN, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_bool_short2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "bool a"
    // ain2 = "short2 b"
    public result_int reduce_my_bool_short2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_short2_0(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "short2 b"
    public result_int reduce_my_bool_short2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_short2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_short2_1 = 777;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_bool_short2_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __BOOLEAN, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_bool_short2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "bool a"
    // ain2 = "short2 b"
    public result_int reduce_my_bool_short2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_short2_1(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "short2 b"
    public result_int reduce_my_bool_short2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_short2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_short4_0 = 778;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_bool_short4_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __BOOLEAN, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_bool_short4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "bool a"
    // ain2 = "short4 b"
    public result_int reduce_my_bool_short4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_short4_0(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "short4 b"
    public result_int reduce_my_bool_short4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_short4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_short4_1 = 779;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_bool_short4_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __BOOLEAN, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __I16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_bool_short4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "bool a"
    // ain2 = "short4 b"
    public result_int reduce_my_bool_short4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_short4_1(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "short4 b"
    public result_int reduce_my_bool_short4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_short4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_uchar_0 = 780;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_bool_uchar_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __BOOLEAN, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_bool_uchar_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "bool a"
    // ain2 = "uchar b"
    public result_int reduce_my_bool_uchar_0(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_uchar_0(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "uchar b"
    public result_int reduce_my_bool_uchar_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_uchar_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_uchar_1 = 781;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_bool_uchar_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __BOOLEAN, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_bool_uchar_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "bool a"
    // ain2 = "uchar b"
    public result_int reduce_my_bool_uchar_1(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_uchar_1(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "uchar b"
    public result_int reduce_my_bool_uchar_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_uchar_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_uchar2_0 = 782;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_bool_uchar2_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __BOOLEAN, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_bool_uchar2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "bool a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_bool_uchar2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_uchar2_0(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_bool_uchar2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_uchar2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_uchar2_1 = 783;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_bool_uchar2_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __BOOLEAN, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_bool_uchar2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "bool a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_bool_uchar2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_uchar2_1(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_bool_uchar2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_uchar2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_uchar4_0 = 784;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_bool_uchar4_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __BOOLEAN, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_bool_uchar4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "bool a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_bool_uchar4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_uchar4_0(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_bool_uchar4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_uchar4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_uchar4_1 = 785;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_bool_uchar4_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __BOOLEAN, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U8_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_bool_uchar4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "bool a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_bool_uchar4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_uchar4_1(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_bool_uchar4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_uchar4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_ushort_0 = 786;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_bool_ushort_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __BOOLEAN, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_bool_ushort_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "bool a"
    // ain2 = "ushort b"
    public result_int reduce_my_bool_ushort_0(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_ushort_0(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "ushort b"
    public result_int reduce_my_bool_ushort_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_ushort_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_ushort_1 = 787;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_bool_ushort_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __BOOLEAN, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_bool_ushort_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "bool a"
    // ain2 = "ushort b"
    public result_int reduce_my_bool_ushort_1(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_ushort_1(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "ushort b"
    public result_int reduce_my_bool_ushort_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_ushort_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_ushort2_0 = 788;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_bool_ushort2_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __BOOLEAN, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_bool_ushort2_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "bool a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_bool_ushort2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_ushort2_0(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_bool_ushort2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_ushort2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_ushort2_1 = 789;
    // in1 = "a"
    // in2 = "b", flattened 2-vectors
    public result_int reduce_my_bool_ushort2_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __BOOLEAN, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 2 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 2 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 2) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_2, in2.length / 2);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_bool_ushort2_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "bool a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_bool_ushort2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_ushort2_1(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_bool_ushort2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_ushort2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_ushort4_0 = 790;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_bool_ushort4_0(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __BOOLEAN, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_bool_ushort4_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "bool a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_bool_ushort4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_ushort4_0(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_bool_ushort4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_ushort4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_ushort4_1 = 791;
    // in1 = "a"
    // in2 = "b", flattened 4-vectors
    public result_int reduce_my_bool_ushort4_1(byte[] in1, short[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __BOOLEAN, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that the array length is a multiple of the vector size.
        if (in2.length % 4 != 0) {
            throw new RSIllegalArgumentException("Array \"in2\" is not a multiple of 4 in length!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length / 4) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __U16_4, in2.length / 4);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_bool_ushort4_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "bool a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_bool_ushort4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_ushort4_1(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_bool_ushort4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_ushort4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_bool_0 = 792;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_bool_bool_0(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __BOOLEAN, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __BOOLEAN, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_bool_bool_0(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "bool a"
    // ain2 = "bool b"
    public result_int reduce_my_bool_bool_0(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_bool_0(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "bool b"
    public result_int reduce_my_bool_bool_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_bool_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_bool_1 = 793;
    // in1 = "a"
    // in2 = "b"
    public result_int reduce_my_bool_bool_1(byte[] in1, byte[] in2) {
        // Verify that "in1" is non-null.
        if (in1 == null) {
            throw new RSIllegalArgumentException("Array \"in1\" is null!");
        }
        Allocation ain1 = Allocation.createSized(mRSLocal, __BOOLEAN, in1.length);
        ain1.setAutoPadding(true);
        ain1.copyFrom(in1);
        // Verify that "in2" is non-null.
        if (in2 == null) {
            throw new RSIllegalArgumentException("Array \"in2\" is null!");
        }
        // Verify that input array lengths are the same.
        if (in1.length != in2.length) {
            throw new RSRuntimeException("Array length mismatch between parameters \"in1\" and \"in2\"!");
        }
        Allocation ain2 = Allocation.createSized(mRSLocal, __BOOLEAN, in2.length);
        ain2.setAutoPadding(true);
        ain2.copyFrom(in2);

        result_int result = reduce_my_bool_bool_1(ain1, ain2, null);
        result.mTempIns = new Allocation[]{ain1, ain2};
        return result;
    }

    // ain1 = "bool a"
    // ain2 = "bool b"
    public result_int reduce_my_bool_bool_1(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_bool_1(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "bool b"
    public result_int reduce_my_bool_bool_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_bool_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_rs_matrix2x2_0 = 794;
    // ain1 = "bool a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_bool_rs_matrix2x2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_rs_matrix2x2_0(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_bool_rs_matrix2x2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_rs_matrix2x2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_rs_matrix2x2_1 = 795;
    // ain1 = "bool a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_bool_rs_matrix2x2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_rs_matrix2x2_1(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_bool_rs_matrix2x2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_rs_matrix2x2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_MyStruct_0 = 796;
    // ain1 = "bool a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_bool_MyStruct_0(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_MyStruct_0(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_bool_MyStruct_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_MyStruct_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_bool_MyStruct_1 = 797;
    // ain1 = "bool a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_bool_MyStruct_1(Allocation ain1, Allocation ain2) {
        return reduce_my_bool_MyStruct_1(ain1, ain2, null);
    }

    // ain1 = "bool a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_bool_MyStruct_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_bool_MyStruct_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_half_0 = 798;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "half b"
    public result_int reduce_my_rs_matrix2x2_half_0(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_half_0(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "half b"
    public result_int reduce_my_rs_matrix2x2_half_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_half_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_half_1 = 799;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "half b"
    public result_int reduce_my_rs_matrix2x2_half_1(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_half_1(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "half b"
    public result_int reduce_my_rs_matrix2x2_half_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_half_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_half2_0 = 800;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "half2 b"
    public result_int reduce_my_rs_matrix2x2_half2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_half2_0(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "half2 b"
    public result_int reduce_my_rs_matrix2x2_half2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_half2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_half2_1 = 801;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "half2 b"
    public result_int reduce_my_rs_matrix2x2_half2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_half2_1(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "half2 b"
    public result_int reduce_my_rs_matrix2x2_half2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_half2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_half4_0 = 802;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "half4 b"
    public result_int reduce_my_rs_matrix2x2_half4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_half4_0(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "half4 b"
    public result_int reduce_my_rs_matrix2x2_half4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_half4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_half4_1 = 803;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "half4 b"
    public result_int reduce_my_rs_matrix2x2_half4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_half4_1(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "half4 b"
    public result_int reduce_my_rs_matrix2x2_half4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_half4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_float_0 = 804;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "float b"
    public result_int reduce_my_rs_matrix2x2_float_0(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_float_0(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "float b"
    public result_int reduce_my_rs_matrix2x2_float_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_float_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_float_1 = 805;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "float b"
    public result_int reduce_my_rs_matrix2x2_float_1(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_float_1(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "float b"
    public result_int reduce_my_rs_matrix2x2_float_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_float_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_float2_0 = 806;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "float2 b"
    public result_int reduce_my_rs_matrix2x2_float2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_float2_0(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "float2 b"
    public result_int reduce_my_rs_matrix2x2_float2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_float2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_float2_1 = 807;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "float2 b"
    public result_int reduce_my_rs_matrix2x2_float2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_float2_1(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "float2 b"
    public result_int reduce_my_rs_matrix2x2_float2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_float2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_float4_0 = 808;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "float4 b"
    public result_int reduce_my_rs_matrix2x2_float4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_float4_0(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "float4 b"
    public result_int reduce_my_rs_matrix2x2_float4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_float4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_float4_1 = 809;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "float4 b"
    public result_int reduce_my_rs_matrix2x2_float4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_float4_1(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "float4 b"
    public result_int reduce_my_rs_matrix2x2_float4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_float4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_char_0 = 810;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "char b"
    public result_int reduce_my_rs_matrix2x2_char_0(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_char_0(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "char b"
    public result_int reduce_my_rs_matrix2x2_char_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_char_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_char_1 = 811;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "char b"
    public result_int reduce_my_rs_matrix2x2_char_1(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_char_1(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "char b"
    public result_int reduce_my_rs_matrix2x2_char_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_char_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_char2_0 = 812;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "char2 b"
    public result_int reduce_my_rs_matrix2x2_char2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_char2_0(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "char2 b"
    public result_int reduce_my_rs_matrix2x2_char2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_char2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_char2_1 = 813;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "char2 b"
    public result_int reduce_my_rs_matrix2x2_char2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_char2_1(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "char2 b"
    public result_int reduce_my_rs_matrix2x2_char2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_char2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_char4_0 = 814;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "char4 b"
    public result_int reduce_my_rs_matrix2x2_char4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_char4_0(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "char4 b"
    public result_int reduce_my_rs_matrix2x2_char4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_char4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_char4_1 = 815;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "char4 b"
    public result_int reduce_my_rs_matrix2x2_char4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_char4_1(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "char4 b"
    public result_int reduce_my_rs_matrix2x2_char4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_char4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_short_0 = 816;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "short b"
    public result_int reduce_my_rs_matrix2x2_short_0(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_short_0(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "short b"
    public result_int reduce_my_rs_matrix2x2_short_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_short_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_short_1 = 817;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "short b"
    public result_int reduce_my_rs_matrix2x2_short_1(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_short_1(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "short b"
    public result_int reduce_my_rs_matrix2x2_short_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_short_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_short2_0 = 818;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "short2 b"
    public result_int reduce_my_rs_matrix2x2_short2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_short2_0(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "short2 b"
    public result_int reduce_my_rs_matrix2x2_short2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_short2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_short2_1 = 819;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "short2 b"
    public result_int reduce_my_rs_matrix2x2_short2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_short2_1(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "short2 b"
    public result_int reduce_my_rs_matrix2x2_short2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_short2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_short4_0 = 820;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "short4 b"
    public result_int reduce_my_rs_matrix2x2_short4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_short4_0(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "short4 b"
    public result_int reduce_my_rs_matrix2x2_short4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_short4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_short4_1 = 821;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "short4 b"
    public result_int reduce_my_rs_matrix2x2_short4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_short4_1(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "short4 b"
    public result_int reduce_my_rs_matrix2x2_short4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_short4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_uchar_0 = 822;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "uchar b"
    public result_int reduce_my_rs_matrix2x2_uchar_0(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_uchar_0(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "uchar b"
    public result_int reduce_my_rs_matrix2x2_uchar_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_uchar_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_uchar_1 = 823;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "uchar b"
    public result_int reduce_my_rs_matrix2x2_uchar_1(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_uchar_1(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "uchar b"
    public result_int reduce_my_rs_matrix2x2_uchar_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_uchar_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_uchar2_0 = 824;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_rs_matrix2x2_uchar2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_uchar2_0(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_rs_matrix2x2_uchar2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_uchar2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_uchar2_1 = 825;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_rs_matrix2x2_uchar2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_uchar2_1(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_rs_matrix2x2_uchar2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_uchar2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_uchar4_0 = 826;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_rs_matrix2x2_uchar4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_uchar4_0(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_rs_matrix2x2_uchar4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_uchar4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_uchar4_1 = 827;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_rs_matrix2x2_uchar4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_uchar4_1(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_rs_matrix2x2_uchar4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_uchar4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_ushort_0 = 828;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "ushort b"
    public result_int reduce_my_rs_matrix2x2_ushort_0(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_ushort_0(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "ushort b"
    public result_int reduce_my_rs_matrix2x2_ushort_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_ushort_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_ushort_1 = 829;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "ushort b"
    public result_int reduce_my_rs_matrix2x2_ushort_1(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_ushort_1(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "ushort b"
    public result_int reduce_my_rs_matrix2x2_ushort_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_ushort_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_ushort2_0 = 830;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_rs_matrix2x2_ushort2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_ushort2_0(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_rs_matrix2x2_ushort2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_ushort2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_ushort2_1 = 831;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_rs_matrix2x2_ushort2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_ushort2_1(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_rs_matrix2x2_ushort2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_ushort2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_ushort4_0 = 832;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_rs_matrix2x2_ushort4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_ushort4_0(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_rs_matrix2x2_ushort4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_ushort4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_ushort4_1 = 833;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_rs_matrix2x2_ushort4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_ushort4_1(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_rs_matrix2x2_ushort4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_ushort4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_bool_0 = 834;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "bool b"
    public result_int reduce_my_rs_matrix2x2_bool_0(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_bool_0(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "bool b"
    public result_int reduce_my_rs_matrix2x2_bool_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_bool_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_bool_1 = 835;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "bool b"
    public result_int reduce_my_rs_matrix2x2_bool_1(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_bool_1(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "bool b"
    public result_int reduce_my_rs_matrix2x2_bool_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_bool_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_rs_matrix2x2_0 = 836;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_rs_matrix2x2_rs_matrix2x2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_rs_matrix2x2_0(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_rs_matrix2x2_rs_matrix2x2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_rs_matrix2x2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_rs_matrix2x2_1 = 837;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_rs_matrix2x2_rs_matrix2x2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_rs_matrix2x2_1(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_rs_matrix2x2_rs_matrix2x2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_rs_matrix2x2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_MyStruct_0 = 838;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_rs_matrix2x2_MyStruct_0(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_MyStruct_0(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_rs_matrix2x2_MyStruct_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_MyStruct_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_rs_matrix2x2_MyStruct_1 = 839;
    // ain1 = "rs_matrix2x2 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_rs_matrix2x2_MyStruct_1(Allocation ain1, Allocation ain2) {
        return reduce_my_rs_matrix2x2_MyStruct_1(ain1, ain2, null);
    }

    // ain1 = "rs_matrix2x2 a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_rs_matrix2x2_MyStruct_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_rs_matrix2x2_MyStruct_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_half_0 = 840;
    // ain1 = "/* struct <> */ a"
    // ain2 = "half b"
    public result_int reduce_my_MyStruct_half_0(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_half_0(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "half b"
    public result_int reduce_my_MyStruct_half_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_half_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_half_1 = 841;
    // ain1 = "/* struct <> */ a"
    // ain2 = "half b"
    public result_int reduce_my_MyStruct_half_1(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_half_1(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "half b"
    public result_int reduce_my_MyStruct_half_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16)) {
            throw new RSRuntimeException("Type mismatch with F16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_half_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_half2_0 = 842;
    // ain1 = "/* struct <> */ a"
    // ain2 = "half2 b"
    public result_int reduce_my_MyStruct_half2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_half2_0(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "half2 b"
    public result_int reduce_my_MyStruct_half2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_half2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_half2_1 = 843;
    // ain1 = "/* struct <> */ a"
    // ain2 = "half2 b"
    public result_int reduce_my_MyStruct_half2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_half2_1(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "half2 b"
    public result_int reduce_my_MyStruct_half2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_2)) {
            throw new RSRuntimeException("Type mismatch with F16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_half2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_half4_0 = 844;
    // ain1 = "/* struct <> */ a"
    // ain2 = "half4 b"
    public result_int reduce_my_MyStruct_half4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_half4_0(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "half4 b"
    public result_int reduce_my_MyStruct_half4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_half4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_half4_1 = 845;
    // ain1 = "/* struct <> */ a"
    // ain2 = "half4 b"
    public result_int reduce_my_MyStruct_half4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_half4_1(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "half4 b"
    public result_int reduce_my_MyStruct_half4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F16_4)) {
            throw new RSRuntimeException("Type mismatch with F16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_half4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_float_0 = 846;
    // ain1 = "/* struct <> */ a"
    // ain2 = "float b"
    public result_int reduce_my_MyStruct_float_0(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_float_0(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "float b"
    public result_int reduce_my_MyStruct_float_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_float_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_float_1 = 847;
    // ain1 = "/* struct <> */ a"
    // ain2 = "float b"
    public result_int reduce_my_MyStruct_float_1(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_float_1(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "float b"
    public result_int reduce_my_MyStruct_float_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32)) {
            throw new RSRuntimeException("Type mismatch with F32!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_float_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_float2_0 = 848;
    // ain1 = "/* struct <> */ a"
    // ain2 = "float2 b"
    public result_int reduce_my_MyStruct_float2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_float2_0(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "float2 b"
    public result_int reduce_my_MyStruct_float2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_float2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_float2_1 = 849;
    // ain1 = "/* struct <> */ a"
    // ain2 = "float2 b"
    public result_int reduce_my_MyStruct_float2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_float2_1(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "float2 b"
    public result_int reduce_my_MyStruct_float2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_2)) {
            throw new RSRuntimeException("Type mismatch with F32_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_float2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_float4_0 = 850;
    // ain1 = "/* struct <> */ a"
    // ain2 = "float4 b"
    public result_int reduce_my_MyStruct_float4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_float4_0(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "float4 b"
    public result_int reduce_my_MyStruct_float4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_float4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_float4_1 = 851;
    // ain1 = "/* struct <> */ a"
    // ain2 = "float4 b"
    public result_int reduce_my_MyStruct_float4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_float4_1(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "float4 b"
    public result_int reduce_my_MyStruct_float4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__F32_4)) {
            throw new RSRuntimeException("Type mismatch with F32_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_float4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_char_0 = 852;
    // ain1 = "/* struct <> */ a"
    // ain2 = "char b"
    public result_int reduce_my_MyStruct_char_0(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_char_0(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "char b"
    public result_int reduce_my_MyStruct_char_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_char_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_char_1 = 853;
    // ain1 = "/* struct <> */ a"
    // ain2 = "char b"
    public result_int reduce_my_MyStruct_char_1(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_char_1(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "char b"
    public result_int reduce_my_MyStruct_char_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8)) {
            throw new RSRuntimeException("Type mismatch with I8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_char_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_char2_0 = 854;
    // ain1 = "/* struct <> */ a"
    // ain2 = "char2 b"
    public result_int reduce_my_MyStruct_char2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_char2_0(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "char2 b"
    public result_int reduce_my_MyStruct_char2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_char2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_char2_1 = 855;
    // ain1 = "/* struct <> */ a"
    // ain2 = "char2 b"
    public result_int reduce_my_MyStruct_char2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_char2_1(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "char2 b"
    public result_int reduce_my_MyStruct_char2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_2)) {
            throw new RSRuntimeException("Type mismatch with I8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_char2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_char4_0 = 856;
    // ain1 = "/* struct <> */ a"
    // ain2 = "char4 b"
    public result_int reduce_my_MyStruct_char4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_char4_0(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "char4 b"
    public result_int reduce_my_MyStruct_char4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_char4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_char4_1 = 857;
    // ain1 = "/* struct <> */ a"
    // ain2 = "char4 b"
    public result_int reduce_my_MyStruct_char4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_char4_1(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "char4 b"
    public result_int reduce_my_MyStruct_char4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I8_4)) {
            throw new RSRuntimeException("Type mismatch with I8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_char4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_short_0 = 858;
    // ain1 = "/* struct <> */ a"
    // ain2 = "short b"
    public result_int reduce_my_MyStruct_short_0(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_short_0(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "short b"
    public result_int reduce_my_MyStruct_short_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_short_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_short_1 = 859;
    // ain1 = "/* struct <> */ a"
    // ain2 = "short b"
    public result_int reduce_my_MyStruct_short_1(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_short_1(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "short b"
    public result_int reduce_my_MyStruct_short_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16)) {
            throw new RSRuntimeException("Type mismatch with I16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_short_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_short2_0 = 860;
    // ain1 = "/* struct <> */ a"
    // ain2 = "short2 b"
    public result_int reduce_my_MyStruct_short2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_short2_0(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "short2 b"
    public result_int reduce_my_MyStruct_short2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_short2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_short2_1 = 861;
    // ain1 = "/* struct <> */ a"
    // ain2 = "short2 b"
    public result_int reduce_my_MyStruct_short2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_short2_1(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "short2 b"
    public result_int reduce_my_MyStruct_short2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_2)) {
            throw new RSRuntimeException("Type mismatch with I16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_short2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_short4_0 = 862;
    // ain1 = "/* struct <> */ a"
    // ain2 = "short4 b"
    public result_int reduce_my_MyStruct_short4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_short4_0(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "short4 b"
    public result_int reduce_my_MyStruct_short4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_short4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_short4_1 = 863;
    // ain1 = "/* struct <> */ a"
    // ain2 = "short4 b"
    public result_int reduce_my_MyStruct_short4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_short4_1(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "short4 b"
    public result_int reduce_my_MyStruct_short4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__I16_4)) {
            throw new RSRuntimeException("Type mismatch with I16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_short4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_uchar_0 = 864;
    // ain1 = "/* struct <> */ a"
    // ain2 = "uchar b"
    public result_int reduce_my_MyStruct_uchar_0(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_uchar_0(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "uchar b"
    public result_int reduce_my_MyStruct_uchar_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_uchar_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_uchar_1 = 865;
    // ain1 = "/* struct <> */ a"
    // ain2 = "uchar b"
    public result_int reduce_my_MyStruct_uchar_1(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_uchar_1(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "uchar b"
    public result_int reduce_my_MyStruct_uchar_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8)) {
            throw new RSRuntimeException("Type mismatch with U8!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_uchar_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_uchar2_0 = 866;
    // ain1 = "/* struct <> */ a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_MyStruct_uchar2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_uchar2_0(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_MyStruct_uchar2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_uchar2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_uchar2_1 = 867;
    // ain1 = "/* struct <> */ a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_MyStruct_uchar2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_uchar2_1(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "uchar2 b"
    public result_int reduce_my_MyStruct_uchar2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_2)) {
            throw new RSRuntimeException("Type mismatch with U8_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_uchar2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_uchar4_0 = 868;
    // ain1 = "/* struct <> */ a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_MyStruct_uchar4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_uchar4_0(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_MyStruct_uchar4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_uchar4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_uchar4_1 = 869;
    // ain1 = "/* struct <> */ a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_MyStruct_uchar4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_uchar4_1(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "uchar4 b"
    public result_int reduce_my_MyStruct_uchar4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U8_4)) {
            throw new RSRuntimeException("Type mismatch with U8_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_uchar4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_ushort_0 = 870;
    // ain1 = "/* struct <> */ a"
    // ain2 = "ushort b"
    public result_int reduce_my_MyStruct_ushort_0(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_ushort_0(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "ushort b"
    public result_int reduce_my_MyStruct_ushort_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_ushort_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_ushort_1 = 871;
    // ain1 = "/* struct <> */ a"
    // ain2 = "ushort b"
    public result_int reduce_my_MyStruct_ushort_1(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_ushort_1(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "ushort b"
    public result_int reduce_my_MyStruct_ushort_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16)) {
            throw new RSRuntimeException("Type mismatch with U16!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_ushort_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_ushort2_0 = 872;
    // ain1 = "/* struct <> */ a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_MyStruct_ushort2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_ushort2_0(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_MyStruct_ushort2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_ushort2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_ushort2_1 = 873;
    // ain1 = "/* struct <> */ a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_MyStruct_ushort2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_ushort2_1(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "ushort2 b"
    public result_int reduce_my_MyStruct_ushort2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_2)) {
            throw new RSRuntimeException("Type mismatch with U16_2!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_ushort2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_ushort4_0 = 874;
    // ain1 = "/* struct <> */ a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_MyStruct_ushort4_0(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_ushort4_0(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_MyStruct_ushort4_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_ushort4_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_ushort4_1 = 875;
    // ain1 = "/* struct <> */ a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_MyStruct_ushort4_1(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_ushort4_1(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "ushort4 b"
    public result_int reduce_my_MyStruct_ushort4_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__U16_4)) {
            throw new RSRuntimeException("Type mismatch with U16_4!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_ushort4_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_bool_0 = 876;
    // ain1 = "/* struct <> */ a"
    // ain2 = "bool b"
    public result_int reduce_my_MyStruct_bool_0(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_bool_0(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "bool b"
    public result_int reduce_my_MyStruct_bool_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_bool_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_bool_1 = 877;
    // ain1 = "/* struct <> */ a"
    // ain2 = "bool b"
    public result_int reduce_my_MyStruct_bool_1(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_bool_1(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "bool b"
    public result_int reduce_my_MyStruct_bool_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__BOOLEAN)) {
            throw new RSRuntimeException("Type mismatch with BOOLEAN!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_bool_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_rs_matrix2x2_0 = 878;
    // ain1 = "/* struct <> */ a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_MyStruct_rs_matrix2x2_0(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_rs_matrix2x2_0(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_MyStruct_rs_matrix2x2_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_rs_matrix2x2_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_rs_matrix2x2_1 = 879;
    // ain1 = "/* struct <> */ a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_MyStruct_rs_matrix2x2_1(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_rs_matrix2x2_1(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "rs_matrix2x2 b"
    public result_int reduce_my_MyStruct_rs_matrix2x2_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_rs_matrix2x2_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_MyStruct_0 = 880;
    // ain1 = "/* struct <> */ a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_MyStruct_MyStruct_0(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_MyStruct_0(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_MyStruct_MyStruct_0(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_MyStruct_0, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

    private final static int mExportReduceIdx_my_MyStruct_MyStruct_1 = 881;
    // ain1 = "/* struct <> */ a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_MyStruct_MyStruct_1(Allocation ain1, Allocation ain2) {
        return reduce_my_MyStruct_MyStruct_1(ain1, ain2, null);
    }

    // ain1 = "/* struct <> */ a"
    // ain2 = "/* struct <> */ b"
    public result_int reduce_my_MyStruct_MyStruct_1(Allocation ain1, Allocation ain2, Script.LaunchOptions sc) {
        Type t0, t1;
        // check ain1
        if (!ain1.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // check ain2
        if (!ain2.getType().getElement().isCompatible(__ScriptField_MyStruct)) {
            throw new RSRuntimeException("Type mismatch with ScriptField_MyStruct!");
        }
        // Verify dimensions
        t0 = ain1.getType();
        t1 = ain2.getType();
        if ((t0.getCount() != t1.getCount()) ||
            (t0.getX() != t1.getX()) ||
            (t0.getY() != t1.getY()) ||
            (t0.getZ() != t1.getZ()) ||
            (t0.hasFaces()   != t1.hasFaces()) ||
            (t0.hasMipmaps() != t1.hasMipmaps())) {
            throw new RSRuntimeException("Dimension mismatch between parameters ain1 and ain2!");
        }

        Allocation aout = Allocation.createSized(mRSLocal, __I32, 1);
        aout.setAutoPadding(true);
        reduce(mExportReduceIdx_my_MyStruct_MyStruct_1, new Allocation[]{ain1, ain2}, aout, sc);
        return new result_int(aout);
    }

}

