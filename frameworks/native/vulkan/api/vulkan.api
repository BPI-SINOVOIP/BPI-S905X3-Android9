// Copyright (c) 2015 The Khronos Group Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and/or associated documentation files (the
// "Materials"), to deal in the Materials without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Materials, and to
// permit persons to whom the Materials are furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Materials.
//
// THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.

import platform "platform.api"

///////////////
// Constants //
///////////////

// API version (major.minor.patch)
define VERSION_MAJOR 1
define VERSION_MINOR 1
define VERSION_PATCH 68

// API limits
define VK_MAX_PHYSICAL_DEVICE_NAME_SIZE 256
define VK_UUID_SIZE                     16
define VK_MAX_EXTENSION_NAME_SIZE       256
define VK_MAX_DESCRIPTION_SIZE          256
define VK_MAX_MEMORY_TYPES              32
define VK_MAX_MEMORY_HEAPS              16    /// The maximum number of unique memory heaps, each of which supporting 1 or more memory types.
@vulkan1_1
define VK_MAX_DEVICE_GROUP_SIZE         32
@vulkan1_1
define VK_LUID_SIZE                     8
@vulkan1_1
define VK_QUEUE_FAMILY_EXTERNAL         -2
@extension("VK_EXT_queue_family_foreign")
define VK_QUEUE_FAMILY_FOREIGN_EXT      -3

// API keywords
define VK_TRUE        1
define VK_FALSE       0

// API keyword, but needs special handling by some templates
define NULL_HANDLE 0

// 1
@extension("VK_KHR_surface") define VK_KHR_SURFACE_SPEC_VERSION                 25
@extension("VK_KHR_surface") define VK_KHR_SURFACE_EXTENSION_NAME               "VK_KHR_surface"

// 2
@extension("VK_KHR_swapchain") define VK_KHR_SWAPCHAIN_SPEC_VERSION             70
@extension("VK_KHR_swapchain") define VK_KHR_SWAPCHAIN_EXTENSION_NAME           "VK_KHR_swapchain"

// 3
@extension("VK_KHR_display") define VK_KHR_DISPLAY_SPEC_VERSION                 21
@extension("VK_KHR_display") define VK_KHR_DISPLAY_EXTENSION_NAME               "VK_KHR_display"

// 4
@extension("VK_KHR_display_swapchain") define VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION     9
@extension("VK_KHR_display_swapchain") define VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME   "VK_KHR_display_swapchain"

// 5
@extension("VK_KHR_xlib_surface") define VK_KHR_XLIB_SURFACE_SPEC_VERSION       6
@extension("VK_KHR_xlib_surface") define VK_KHR_XLIB_SURFACE_NAME               "VK_KHR_xlib_surface"

// 6
@extension("VK_KHR_xcb_surface") define VK_KHR_XCB_SURFACE_SPEC_VERSION         6
@extension("VK_KHR_xcb_surface") define VK_KHR_XCB_SURFACE_NAME                 "VK_KHR_xcb_surface"

// 7
@extension("VK_KHR_wayland_surface") define VK_KHR_WAYLAND_SURFACE_SPEC_VERSION 6
@extension("VK_KHR_wayland_surface") define VK_KHR_WAYLAND_SURFACE_NAME         "VK_KHR_wayland_surface"

// 8
@extension("VK_KHR_mir_surface") define VK_KHR_MIR_SURFACE_SPEC_VERSION         4
@extension("VK_KHR_mir_surface") define VK_KHR_MIR_SURFACE_NAME                 "VK_KHR_mir_surface"

// 9
@extension("VK_KHR_android_surface") define VK_KHR_ANDROID_SURFACE_SPEC_VERSION 6
@extension("VK_KHR_android_surface") define VK_KHR_ANDROID_SURFACE_NAME         "VK_KHR_android_surface"

// 10
@extension("VK_KHR_win32_surface") define VK_KHR_WIN32_SURFACE_SPEC_VERSION     6
@extension("VK_KHR_win32_surface") define VK_KHR_WIN32_SURFACE_NAME             "VK_KHR_win32_surface"

// 11
@extension("VK_ANDROID_native_buffer") define VK_ANDROID_NATIVE_BUFFER_SPEC_VERSION     7
@extension("VK_ANDROID_native_buffer") define VK_ANDROID_NATIVE_BUFFER_NAME             "VK_ANDROID_native_buffer"

// 12
@extension("VK_EXT_debug_report") define VK_EXT_DEBUG_REPORT_SPEC_VERSION       9
@extension("VK_EXT_debug_report") define VK_EXT_DEBUG_REPORT_NAME               "VK_EXT_debug_report"

// 13
@extension("VK_NV_glsl_shader") define VK_NV_GLSL_SHADER_SPEC_VERSION           1
@extension("VK_NV_glsl_shader") define VK_NV_GLSL_SHADER_NAME                   "VK_NV_glsl_shader"

// 14
@extension("VK_EXT_depth_range_unrestricted") define VK_EXT_DEPTH_RANGE_UNRESTRICTED_SPEC_VERSION   1
@extension("VK_EXT_depth_range_unrestricted") define VK_EXT_DEPTH_RANGE_UNRESTRICTED_NAME           "VK_EXT_depth_range_unrestricted"

// 15
@extension("VK_KHR_sampler_mirror_clamp_to_edge") define VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION   1
@extension("VK_KHR_sampler_mirror_clamp_to_edge") define VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_NAME           "VK_KHR_sampler_mirror_clamp_to_edge"

// 16
@extension("VK_IMG_filter_cubic") define VK_IMG_FILTER_CUBIC_SPEC_VERSION       1
@extension("VK_IMG_filter_cubic") define VK_IMG_FILTER_CUBIC_NAME               "VK_IMG_filter_cubic"

// 19
@extension("VK_AMD_rasterization_order") define VK_AMD_RASTERIZATION_ORDER_SPEC_VERSION   1
@extension("VK_AMD_rasterization_order") define VK_AMD_RASTERIZATION_ORDER_NAME           "VK_AMD_rasterization_order"

// 21
@extension("VK_AMD_shader_trinary_minmax") define VK_AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION 1
@extension("VK_AMD_shader_trinary_minmax") define VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME "VK_AMD_shader_trinary_minmax"

// 22
@extension("VK_AMD_shader_explicit_vertex_parameter") define VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION 1
@extension("VK_AMD_shader_explicit_vertex_parameter") define VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME "VK_AMD_shader_explicit_vertex_parameter"

// 23
@extension("VK_EXT_debug_marker") define VK_EXT_DEBUG_MARKER_SPEC_VERSION       4
@extension("VK_EXT_debug_marker") define VK_EXT_DEBUG_MARKER_NAME               "VK_EXT_debug_marker"

// 26
@extension("VK_AMD_gcn_shader") define VK_AMD_GCN_SHADER_SPEC_VERSION 1
@extension("VK_AMD_gcn_shader") define VK_AMD_GCN_SHADER_EXTENSION_NAME "VK_AMD_gcn_shader"

// 27
@extension("VK_NV_dedicated_allocation") define VK_NV_DEDICATED_ALLOCATION_SPEC_VERSION 1
@extension("VK_NV_dedicated_allocation") define VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME "VK_NV_dedicated_allocation"

// 28
@extension("VK_IMG_format_pvrtc") define VK_IMG_FORMAT_PVRTC_SPEC_VERSION 1
@extension("VK_IMG_format_pvrtc") define VK_IMG_FORMAT_PVRTC_EXTENSION_NAME "VK_IMG_format_pvrtc"

// 34
@extension("VK_AMD_draw_indirect_count") define VK_AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION 1
@extension("VK_AMD_draw_indirect_count") define VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME "VK_AMD_draw_indirect_count"

// 36
@extension("VK_AMD_negative_viewport_height") define VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_SPEC_VERSION 1
@extension("VK_AMD_negative_viewport_height") define VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME "VK_AMD_negative_viewport_height"

// 37
@extension("VK_AMD_gpu_shader_half_float") define VK_AMD_GPU_SHADER_HALF_FLOAT_SPEC_VERSION 1
@extension("VK_AMD_gpu_shader_half_float") define VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME "VK_AMD_gpu_shader_half_float"

// 38
@extension("VK_AMD_shader_ballot") define VK_AMD_SHADER_BALLOT_SPEC_VERSION 1
@extension("VK_AMD_shader_ballot") define VK_AMD_SHADER_BALLOT_EXTENSION_NAME "VK_AMD_shader_ballot"

// 42
@extension("VK_AMD_texture_gather_bias_lod") define VK_AMD_TEXTURE_GATHER_BIAS_LOD_SPEC_VERSION 1
@extension("VK_AMD_texture_gather_bias_lod") define VK_AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME "VK_AMD_texture_gather_bias_lod"

// 43
@extension("VK_AMD_shader_info") define VK_AMD_SHADER_INFO_SPEC_VERSION 1
@extension("VK_AMD_shader_info") define VK_AMD_SHADER_INFO_EXTENSION_NAME "VK_AMD_shader_info"

// 47
@extension("VK_AMD_shader_image_load_store_lod") define VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_SPEC_VERSION 1
@extension("VK_AMD_shader_image_load_store_lod") define VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME "VK_AMD_shader_image_load_store_lod"

// 54
@extension("VK_KHR_multiview") define VK_KHR_MULTIVIEW_SPEC_VERSION 1
@extension("VK_KHR_multiview") define VK_KHR_MULTIVIEW_EXTENSION_NAME "VK_KHR_multiview"

// 56
@extension("VK_NV_external_memory_capabilities") define VK_NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION 1
@extension("VK_NV_external_memory_capabilities") define VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME "VK_NV_external_memory_capabilities"

// 57
@extension("VK_NV_external_memory") define VK_NV_EXTERNAL_MEMORY_SPEC_VERSION 1
@extension("VK_NV_external_memory") define VK_NV_EXTERNAL_MEMORY_EXTENSION_NAME "VK_NV_external_memory"

// 58
@extension("VK_NV_external_memory_win32") define VK_NV_EXTERNAL_MEMORY_WIN32_SPEC_VERSION 1
@extension("VK_NV_external_memory_win32") define VK_NV_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME "VK_NV_external_memory_win32"

// 59
@extension("VK_NV_win32_keyed_mutex") define VK_NV_WIN32_KEYED_MUTEX_SPEC_VERSION 1
@extension("VK_NV_win32_keyed_mutex") define VK_NV_WIN32_KEYED_MUTEX_EXTENSION_NAME "VK_NV_win32_keyed_mutex"

// 60
@extension("VK_KHR_get_physical_device_properties2") define VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_SPEC_VERSION 1
@extension("VK_KHR_get_physical_device_properties2") define VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME "VK_KHR_get_physical_device_properties2"

// 61
@extension("VK_KHR_device_group") define VK_KHR_DEVICE_GROUP_SPEC_VERSION 3
@extension("VK_KHR_device_group") define VK_KHR_DEVICE_GROUP_EXTENSION_NAME "VK_KHR_device_group"

// 62
@extension("VK_EXT_validation_flags") define VK_EXT_VALIDATION_FLAGS_SPEC_VERSION 1
@extension("VK_EXT_validation_flags") define VK_EXT_VALIDATION_FLAGS_EXTENSION_NAME "VK_EXT_validation_flags"

// 63
@extension("VK_NN_vi_surface") define VK_NN_VI_SURFACE_SPEC_VERSION 1
@extension("VK_NN_vi_surface") define VK_NN_VI_SURFACE_EXTENSION_NAME "VK_NN_vi_surface"

// 64
@extension("VK_KHR_shader_draw_parameters") define VK_KHR_SHADER_DRAW_PARAMETERS_SPEC_VERSION 1
@extension("VK_KHR_shader_draw_parameters") define VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME "VK_KHR_shader_draw_parameters"

// 65
@extension("VK_EXT_shader_subgroup_ballot") define VK_EXT_SHADER_SUBGROUP_BALLOT_SPEC_VERSION 1
@extension("VK_EXT_shader_subgroup_ballot") define VK_EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME "VK_EXT_shader_subgroup_ballot"

// 66
@extension("VK_EXT_shader_subgroup_vote") define VK_EXT_SHADER_SUBGROUP_VOTE_SPEC_VERSION 1
@extension("VK_EXT_shader_subgroup_vote") define VK_EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME "VK_EXT_shader_subgroup_vote"

// 70
@extension("VK_KHR_maintenance1") define VK_KHR_MAINTENANCE1_SPEC_VERSION 1
@extension("VK_KHR_maintenance1") define VK_KHR_MAINTENANCE1_EXTENSION_NAME "VK_KHR_maintenance1"

// 71
@extension("VK_KHR_device_group_creation") define VK_KHR_DEVICE_GROUP_CREATION_SPEC_VERSION 1
@extension("VK_KHR_device_group_creation") define VK_KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME "VK_KHR_device_group_creation"

// 72
@extension("VK_KHR_external_memory_capabilities") define VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION 1
@extension("VK_KHR_external_memory_capabilities") define VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME "VK_KHR_external_memory_capabilities"

// 73
@extension("VK_KHR_external_memory") define VK_KHR_EXTERNAL_MEMORY_SPEC_VERSION 1
@extension("VK_KHR_external_memory") define VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME "VK_KHR_external_memory"

// 74
@extension("VK_KHR_external_memory_win32") define VK_KHR_EXTERNAL_MEMORY_WIN32_SPEC_VERSION 1
@extension("VK_KHR_external_memory_win32") define VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME "VK_KHR_external_memory_win32"

// 75
@extension("VK_KHR_external_memory_fd") define VK_KHR_EXTERNAL_MEMORY_FD_SPEC_VERSION 1
@extension("VK_KHR_external_memory_fd") define VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME "VK_KHR_external_memory_fd"

// 76
@extension("VK_KHR_win32_keyed_mutex") define VK_KHR_WIN32_KEYED_MUTEX_SPEC_VERSION 1
@extension("VK_KHR_win32_keyed_mutex") define VK_KHR_WIN32_KEYED_MUTEX_EXTENSION_NAME "VK_KHR_win32_keyed_mutex"

// 77
@extension("VK_KHR_external_semaphore_capabilities") define VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION 1
@extension("VK_KHR_external_semaphore_capabilities") define VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME "VK_KHR_external_semaphore_capabilities"

// 78
@extension("VK_KHR_external_semaphore") define VK_KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION 1
@extension("VK_KHR_external_semaphore") define VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME "VK_KHR_external_semaphore"

// 79
@extension("VK_KHR_external_semaphore_win32") define VK_KHR_EXTERNAL_SEMAPHORE_WIN32_SPEC_VERSION 1
@extension("VK_KHR_external_semaphore_win32") define VK_KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME "VK_KHR_external_semaphore_win32"

// 80
@extension("VK_KHR_external_semaphore_fd") define VK_KHR_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION 1
@extension("VK_KHR_external_semaphore_fd") define VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME "VK_KHR_external_semaphore_fd"

// 81
@extension("VK_KHR_push_descriptor") define VK_KHR_PUSH_DESCRIPTOR_SPEC_VERSION 2
@extension("VK_KHR_push_descriptor") define VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME "VK_KHR_push_descriptor"

// 84
@extension("VK_KHR_16bit_storage") define VK_KHR_16BIT_STORAGE_SPEC_VERSION 1
@extension("VK_KHR_16bit_storage") define VK_KHR_16BIT_STORAGE_EXTENSION_NAME "VK_KHR_16bit_storage"

// 85
@extension("VK_KHR_incremental_present") define VK_KHR_INCREMENTAL_PRESENT_SPEC_VERSION 1
@extension("VK_KHR_incremental_present") define VK_KHR_INCREMENTAL_PRESENT_EXTENSION_NAME "VK_KHR_incremental_present"

// 86
@extension("VK_KHR_descriptor_update_template") define VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_SPEC_VERSION 1
@extension("VK_KHR_descriptor_update_template") define VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME "VK_KHR_descriptor_update_template"

// 87
@extension("VK_NVX_device_generated_commands") define VK_NVX_DEVICE_GENERATED_COMMANDS_SPEC_VERSION 3
@extension("VK_NVX_device_generated_commands") define VK_NVX_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME "VK_NVX_device_generated_commands"

// 88
@extension("VK_NV_clip_space_w_scaling") define VK_NV_CLIP_SPACE_W_SCALING_SPEC_VERSION 1
@extension("VK_NV_clip_space_w_scaling") define VK_NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME "VK_NV_clip_space_w_scaling"

// 89
@extension("VK_EXT_direct_mode_display") define VK_EXT_DIRECT_MODE_DISPLAY_SPEC_VERSION 1
@extension("VK_EXT_direct_mode_display") define VK_EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME "VK_EXT_direct_mode_display"

// 90
@extension("VK_EXT_acquire_xlib_display") define VK_EXT_ACQUIRE_XLIB_DISPLAY_SPEC_VERSION 1
@extension("VK_EXT_acquire_xlib_display") define VK_EXT_ACQUIRE_XLIB_DISPLAY_EXTENSION_NAME "VK_EXT_acquire_xlib_display"

// 91
@extension("VK_EXT_display_surface_counter") define VK_EXT_DISPLAY_SURFACE_COUNTER_SPEC_VERSION 1
@extension("VK_EXT_display_surface_counter") define VK_EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME "VK_EXT_display_surface_counter"

// 92
@extension("VK_EXT_display_control") define VK_EXT_DISPLAY_CONTROL_SPEC_VERSION 1
@extension("VK_EXT_display_control") define VK_EXT_DISPLAY_CONTROL_COUNTER_EXTENSION_NAME "VK_EXT_display_control"

// 93
@extension("VK_GOOGLE_display_timing") define VK_GOOGLE_DISPLAY_TIMING_SPEC_VERSION 1
@extension("VK_GOOGLE_display_timing") define VK_GOOGLE_DISPLAY_TIMING_EXTENSION_NAME "VK_GOOGLE_display_timing"

// 95
@extension("VK_NV_sample_mask_override_coverage") define VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_SPEC_VERSION 1
@extension("VK_NV_sample_mask_override_coverage") define VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME "VK_NV_sample_mask_override_coverage"

// 96
@extension("VK_NV_geometry_shader_passthrough") define VK_NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION 1
@extension("VK_NV_geometry_shader_passthrough") define VK_NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME "VK_NV_geometry_shader_passthrough"

// 97
@extension("VK_NV_viewport_array2") define VK_NV_VIEWPORT_ARRAY2_SPEC_VERSION 1
@extension("VK_NV_viewport_array2") define VK_NV_VIEWPORT_ARRAY2_EXTENSION_NAME "VK_NV_viewport_array2"

// 98
@extension("VK_NVX_multiview_per_view_attributes") define VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_SPEC_VERSION 1
@extension("VK_NVX_multiview_per_view_attributes") define VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME "VK_NVX_multiview_per_view_attributes"

// 99
@extension("VK_NV_viewport_swizzle") define VK_NV_VIEWPORT_SWIZZLE_SPEC_VERSION 1
@extension("VK_NV_viewport_swizzle") define VK_NV_VIEWPORT_SWIZZLE_EXTENSION_NAME "VK_NV_viewport_swizzle"

// 100
@extension("VK_EXT_discard_rectangles") define VK_EXT_DISCARD_RECTANGLES_SPEC_VERSION 1
@extension("VK_EXT_discard_rectangles") define VK_EXT_DISCARD_RECTANGLES_EXTENSION_NAME "VK_EXT_discard_rectangles"

// 102
@extension("VK_EXT_conservative_rasterization") define VK_EXT_CONSERVATIVE_RASTERIZATION_SPEC_VERSION 1
@extension("VK_EXT_conservative_rasterization") define VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME "VK_EXT_conservative_rasterization"

// 105
@extension("VK_EXT_swapchain_colorspace") define VK_EXT_SWAPCHAIN_COLORSPACE_SPEC_VERSION 3
@extension("VK_EXT_swapchain_colorspace") define VK_EXT_SWAPCHAIN_COLORSPACE_EXTENSION_NAME "VK_EXT_swapchain_colorspace"

// 106
@extension("VK_EXT_hdr_metadata") define VK_EXT_HDR_METADATA_SPEC_VERSION 1
@extension("VK_EXT_hdr_metadata") define VK_EXT_HDR_METADATA_EXTENSION_NAME "VK_EXT_hdr_metadata"

// 112
@extension("VK_KHR_shared_presentable_image") define VK_KHR_SHARED_PRESENTABLE_IMAGE_SPEC_VERSION 1
@extension("VK_KHR_shared_presentable_image") define VK_KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME "VK_KHR_shared_presentable_image"

// 113
@extension("VK_KHR_external_fence_capabilities") define VK_KHR_EXTERNAL_FENCE_CAPABILITIES_SPEC_VERSION 1
@extension("VK_KHR_external_fence_capabilities") define VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME "VK_KHR_external_fence_capabilities"

// 114
@extension("VK_KHR_external_fence") define VK_KHR_EXTERNAL_FENCE_SPEC_VERSION 1
@extension("VK_KHR_external_fence") define VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME "VK_KHR_external_fence"

// 115
@extension("VK_KHR_external_fence_win32") define VK_KHR_EXTERNAL_FENCE_WIN32_SPEC_VERSION 1
@extension("VK_KHR_external_fence_win32") define VK_KHR_EXTERNAL_FENCE_WIN32_EXTENSION_NAME "VK_KHR_external_fence_win32"

// 116
@extension("VK_KHR_external_fence_fd") define VK_KHR_EXTERNAL_FENCE_FD_SPEC_VERSION 1
@extension("VK_KHR_external_fence_fd") define VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME "VK_KHR_external_fence_fd"

// 118
@extension("VK_KHR_maintenance2") define VK_KHR_MAINTENANCE2_SPEC_VERSION 1
@extension("VK_KHR_maintenance2") define VK_KHR_MAINTENANCE2_EXTENSION_NAME "VK_KHR_maintenance2"

// 120
@extension("VK_KHR_get_surface_capabilities2") define VK_KHR_GET_SURFACE_CAPABILITIES_2_SPEC_VERSION 1
@extension("VK_KHR_get_surface_capabilities2") define VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME "VK_KHR_get_surface_capabilities2"

// 121
@extension("VK_KHR_variable_pointers") define VK_KHR_VARIABLE_POINTERS_SPEC_VERSION 1
@extension("VK_KHR_variable_pointers") define VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME "VK_KHR_variable_pointers"

// 123
@extension("VK_MVK_ios_surface") define VK_MVK_IOS_SURFACE_SPEC_VERSION 1
@extension("VK_MVK_ios_surface") define VK_MVK_IOS_SURFACE_EXTENSION_NAME "VK_MVK_ios_surface"

// 124
@extension("VK_MVK_macos_surface") define VK_MVK_MACOS_SURFACE_SPEC_VERSION 1
@extension("VK_MVK_macos_surface") define VK_MVK_MACOS_SURFACE_EXTENSION_NAME "VK_MVK_macos_surface"

// 126
@extension("VK_EXT_external_memory_dma_buf") define VK_EXT_EXTERNAL_MEMORY_DMA_BUF_SPEC_VERSION 1
@extension("VK_EXT_external_memory_dma_buf") define VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME "VK_EXT_external_memory_dma_buf"

// 127
@extension("VK_EXT_queue_family_foreign") define VK_EXT_QUEUE_FAMILY_FOREIGN_SPEC_VERSION 1
@extension("VK_EXT_queue_family_foreign") define VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME "VK_EXT_queue_family_foreign"

// 128
@extension("VK_KHR_dedicated_allocation") define VK_KHR_DEDICATED_ALLOCATION_SPEC_VERSION 3
@extension("VK_KHR_dedicated_allocation") define VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME "VK_KHR_dedicated_allocation"

// 128
@extension("VK_EXT_debug_utils") define VK_EXT_DEBUG_UTILS_SPEC_VERSION 1
@extension("VK_EXT_debug_utils") define VK_EXT_DEBUG_UTILS_EXTENSION_NAME "VK_EXT_debug_utils"

// 130
@extension("VK_ANDROID_external_memory_android_hardware_buffer") define VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION 2
@extension("VK_ANDROID_external_memory_android_hardware_buffer") define VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME "VK_ANDROID_external_memory_android_hardware_buffer"

// 131
@extension("VK_EXT_sampler_filter_minmax") define VK_EXT_SAMPLER_FILTER_MINMAX_SPEC_VERSION 1
@extension("VK_EXT_sampler_filter_minmax") define VK_EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME "VK_EXT_sampler_filter_minmax"

// 132
@extension("VK_KHR_storage_buffer_storage_class") define VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_SPEC_VERSION 1
@extension("VK_KHR_storage_buffer_storage_class") define VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME "VK_KHR_storage_buffer_storage_class"

// 133
@extension("VK_AMD_gpu_shader_int16") define VK_AMD_GPU_SHADER_INT16_SPEC_VERSION 1
@extension("VK_AMD_gpu_shader_int16") define VK_AMD_GPU_SHADER_INT16_EXTENSION_NAME "VK_AMD_gpu_shader_int16"

// 137
@extension("VK_AMD_mixed_attachment_samples") define VK_AMD_MIXED_ATTACHMENT_SAMPLES_SPEC_VERSION 1
@extension("VK_AMD_mixed_attachment_samples") define VK_AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION_NAME "VK_AMD_mixed_attachment_samples"

// 138
@extension("VK_AMD_shader_fragment_mask") define VK_AMD_SHADER_FRAGMENT_MASK_SPEC_VERSION 1
@extension("VK_AMD_shader_fragment_mask") define VK_AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME "VK_AMD_shader_fragment_mask"

// 141
@extension("VK_EXT_shader_stencil_export") define VK_EXT_SHADER_STENCIL_EXPORT_SPEC_VERSION 1
@extension("VK_EXT_shader_stencil_export") define VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME "VK_EXT_shader_stencil_export"

// 144
@extension("VK_EXT_sample_locations") define VK_EXT_SAMPLE_LOCATIONS_SPEC_VERSION 1
@extension("VK_EXT_sample_locations") define VK_EXT_SAMPLE_LOCATIONS_EXTENSION_NAME "VK_EXT_sample_locations"

// 145
@extension("VK_KHR_relaxed_block_layout") define VK_KHR_RELAXED_BLOCK_LAYOUT_SPEC_VERSION 1
@extension("VK_KHR_relaxed_block_layout") define VK_KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME "VK_KHR_relaxed_block_layout"

// 147
@extension("VK_KHR_get_memory_requirements2") define VK_KHR_GET_MEMORY_REQUIREMENTS2_SPEC_VERSION 1
@extension("VK_KHR_get_memory_requirements2") define VK_KHR_GET_MEMORY_REQUIREMENTS2_EXTENSION_NAME "VK_KHR_get_memory_requirements2"

// 148
@extension("VK_KHR_image_format_list") define VK_KHR_IMAGE_FORMAT_LIST_SPEC_VERSION 1
@extension("VK_KHR_image_format_list") define VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME "VK_KHR_image_format_list"

// 149
@extension("VK_EXT_blend_operation_advanced") define VK_EXT_BLEND_OPERATION_ADVANCED_SPEC_VERSION 2
@extension("VK_EXT_blend_operation_advanced") define VK_EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME "VK_EXT_blend_operation_advanced"

// 150
@extension("VK_NV_fragment_coverage_to_color") define VK_NV_FRAGMENT_COVERAGE_TO_COLOR_SPEC_VERSION 1
@extension("VK_NV_fragment_coverage_to_color") define VK_NV_FRAGMENT_COVERAGE_TO_COLOR_EXTENSION_NAME "VK_NV_fragment_coverage_to_color"

// 153
@extension("VK_NV_framebuffer_mixed_samples") define VK_NV_FRAMEBUFFER_MIXED_SAMPLES_SPEC_VERSION 1
@extension("VK_NV_framebuffer_mixed_samples") define VK_NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION_NAME "VK_NV_framebuffer_mixed_samples"

// 154
@extension("VK_NV_fill_rectangle") define VK_NV_FILL_RECTANGLE_SPEC_VERSION 1
@extension("VK_NV_fill_rectangle") define VK_NV_FILL_RECTANGLE_EXTENSION_NAME "VK_NV_fill_rectangle"

// 156
@extension("VK_EXT_post_depth_coverage") define VK_EXT_POST_DEPTH_COVERAGE_SPEC_VERSION 1
@extension("VK_EXT_post_depth_coverage") define VK_EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME "VK_EXT_post_depth_coverage"

// 157
@extension("VK_KHR_sampler_ycbcr_conversion") define VK_KHR_SAMPLER_YCBCR_CONVERSION_SPEC_VERSION 1
@extension("VK_KHR_sampler_ycbcr_conversion") define VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME "VK_KHR_sampler_ycbcr_conversion"

// 158
@extension("VK_KHR_bind_memory2") define VK_KHR_BIND_MEMORY2_SPEC_VERSION 1
@extension("VK_KHR_bind_memory2") define VK_KHR_BIND_MEMORY2_EXTENSION_NAME "VK_KHR_bind_memory2"

// 161
@extension("VK_EXT_validation_cache") define VK_EXT_VALIDATION_CACHE_SPEC_VERSION 1
@extension("VK_EXT_validation_cache") define VK_EXT_VALIDATION_CACHE_EXTENSION_NAME "VK_EXT_validation_cache"

// 165
@extension("VK_EXT_shader_viewport_index_layer") define VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_SPEC_VERSION 1
@extension("VK_EXT_shader_viewport_index_layer") define VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME "VK_EXT_shader_viewport_index_layer"

// 169
@extension("VK_KHR_maintenance3") define VK_KHR_MAINTENANCE3_SPEC_VERSION 1
@extension("VK_KHR_maintenance3") define VK_KHR_MAINTENANCE3_EXTENSION_NAME "VK_KHR_maintenance3"

// 175
@extension("VK_EXT_global_priority") define VK_EXT_GLOBAL_PRIORITY_SPEC_VERSION 1
@extension("VK_EXT_global_priority") define VK_EXT_GLOBAL_PRIORITY_EXTENSION_NAME "VK_EXT_global_priority"

// 179
@extension("VK_EXT_external_memory_host") define VK_EXT_EXTERNAL_MEMORY_HOST_SPEC_VERSION 1
@extension("VK_EXT_external_memory_host") define VK_EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME "VK_EXT_external_memory_host"

/////////////
//  Types  //
/////////////

type u32 VkBool32
type u32 VkFlags
type u64 VkDeviceSize
type u32 VkSampleMask

/// Dispatchable handle types.
@dispatchHandle type u64 VkInstance
@dispatchHandle type u64 VkPhysicalDevice
@dispatchHandle type u64 VkDevice
@dispatchHandle type u64 VkQueue
@dispatchHandle type u64 VkCommandBuffer

/// Non dispatchable handle types.
@nonDispatchHandle type u64 VkDeviceMemory
@nonDispatchHandle type u64 VkCommandPool
@nonDispatchHandle type u64 VkBuffer
@nonDispatchHandle type u64 VkBufferView
@nonDispatchHandle type u64 VkImage
@nonDispatchHandle type u64 VkImageView
@nonDispatchHandle type u64 VkShaderModule
@nonDispatchHandle type u64 VkPipeline
@nonDispatchHandle type u64 VkPipelineLayout
@nonDispatchHandle type u64 VkSampler
@nonDispatchHandle type u64 VkDescriptorSet
@nonDispatchHandle type u64 VkDescriptorSetLayout
@nonDispatchHandle type u64 VkDescriptorPool
@nonDispatchHandle type u64 VkFence
@nonDispatchHandle type u64 VkSemaphore
@nonDispatchHandle type u64 VkEvent
@nonDispatchHandle type u64 VkQueryPool
@nonDispatchHandle type u64 VkFramebuffer
@nonDispatchHandle type u64 VkRenderPass
@nonDispatchHandle type u64 VkPipelineCache

@vulkan1_1
@nonDispatchHandle type u64 VkSamplerYcbcrConversion
@nonDispatchHandle type u64 VkDescriptorUpdateTemplate

// 1
@extension("VK_KHR_surface")    @nonDispatchHandle type u64 VkSurfaceKHR

// 2
@extension("VK_KHR_swapchain")  @nonDispatchHandle type u64 VkSwapchainKHR

// 3
@extension("VK_KHR_display")    @nonDispatchHandle type u64 VkDisplayKHR
@extension("VK_KHR_display")    @nonDispatchHandle type u64 VkDisplayModeKHR

// 12
@extension("VK_EXT_debug_report") @nonDispatchHandle type u64 VkDebugReportCallbackEXT

// 86
@extension("VK_KHR_descriptor_update_template") @nonDispatchHandle type u64 VkDescriptorUpdateTemplateKHR

// 87
@extension("VK_NVX_device_generated_commands") @nonDispatchHandle type u64 VkObjectTableNVX
@extension("VK_NVX_device_generated_commands") @nonDispatchHandle type u64 VkIndirectCommandsLayoutNVX

// 129
@extension("VK_EXT_debug_utils") @nonDispatchHandle type u64 VkDebugUtilsMessengerEXT

// 157
@extension("VK_KHR_sampler_ycbcr_conversion") @nonDispatchHandle type u64 VkSamplerYcbcrConversionKHR

// 161
@extension("VK_EXT_validation_cache") @nonDispatchHandle type u64 VkValidationCacheEXT

/////////////
//  Enums  //
/////////////

enum VkImageLayout {
    VK_IMAGE_LAYOUT_UNDEFINED                               = 0x00000000,   /// Implicit layout an image is when its contents are undefined due to various reasons (e.g. right after creation)
    VK_IMAGE_LAYOUT_GENERAL                                 = 0x00000001,   /// General layout when image can be used for any kind of access
    VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL                = 0x00000002,   /// Optimal layout when image is only used for color attachment read/write
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL        = 0x00000003,   /// Optimal layout when image is only used for depth/stencil attachment read/write
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL         = 0x00000004,   /// Optimal layout when image is used for read only depth/stencil attachment and shader access
    VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL                = 0x00000005,   /// Optimal layout when image is used for read only shader access
    VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL                    = 0x00000006,   /// Optimal layout when image is used only as source of transfer operations
    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL                    = 0x00000007,   /// Optimal layout when image is used only as destination of transfer operations
    VK_IMAGE_LAYOUT_PREINITIALIZED                          = 0x00000008,   /// Initial layout used when the data is populated by the CPU

    //@vulkan1_1
    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL = 1000117000,
    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL = 1000117001,

    //@extension("VK_KHR_swapchain") // 2
    VK_IMAGE_LAYOUT_PRESENT_SRC_KHR                         = 1000001002,

    //@extension("VK_KHR_shared_presentable_image") // 112
    VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR                      = 1000111000,

    //@extension("VK_KHR_maintenance2") // 118
    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR  = 1000117000,
    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR  = 1000117001,
}

enum VkAttachmentLoadOp {
    VK_ATTACHMENT_LOAD_OP_LOAD                              = 0x00000000,
    VK_ATTACHMENT_LOAD_OP_CLEAR                             = 0x00000001,
    VK_ATTACHMENT_LOAD_OP_DONT_CARE                         = 0x00000002,
}

enum VkAttachmentStoreOp {
    VK_ATTACHMENT_STORE_OP_STORE                            = 0x00000000,
    VK_ATTACHMENT_STORE_OP_DONT_CARE                        = 0x00000001,
}

enum VkImageType {
    VK_IMAGE_TYPE_1D                                        = 0x00000000,
    VK_IMAGE_TYPE_2D                                        = 0x00000001,
    VK_IMAGE_TYPE_3D                                        = 0x00000002,
}

enum VkImageTiling {
    VK_IMAGE_TILING_OPTIMAL                                 = 0x00000000,
    VK_IMAGE_TILING_LINEAR                                  = 0x00000001,
}

enum VkImageViewType {
    VK_IMAGE_VIEW_TYPE_1D                                   = 0x00000000,
    VK_IMAGE_VIEW_TYPE_2D                                   = 0x00000001,
    VK_IMAGE_VIEW_TYPE_3D                                   = 0x00000002,
    VK_IMAGE_VIEW_TYPE_CUBE                                 = 0x00000003,
    VK_IMAGE_VIEW_TYPE_1D_ARRAY                             = 0x00000004,
    VK_IMAGE_VIEW_TYPE_2D_ARRAY                             = 0x00000005,
    VK_IMAGE_VIEW_TYPE_CUBE_ARRAY                           = 0x00000006,
}

enum VkCommandBufferLevel {
    VK_COMMAND_BUFFER_LEVEL_PRIMARY                         = 0x00000000,
    VK_COMMAND_BUFFER_LEVEL_SECONDARY                       = 0x00000001,
}

enum VkComponentSwizzle {
    VK_COMPONENT_SWIZZLE_IDENTITY                           = 0x00000000,
    VK_COMPONENT_SWIZZLE_ZERO                               = 0x00000001,
    VK_COMPONENT_SWIZZLE_ONE                                = 0x00000002,
    VK_COMPONENT_SWIZZLE_R                                  = 0x00000003,
    VK_COMPONENT_SWIZZLE_G                                  = 0x00000004,
    VK_COMPONENT_SWIZZLE_B                                  = 0x00000005,
    VK_COMPONENT_SWIZZLE_A                                  = 0x00000006,
}

enum VkDescriptorType {
    VK_DESCRIPTOR_TYPE_SAMPLER                              = 0x00000000,
    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER               = 0x00000001,
    VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE                        = 0x00000002,
    VK_DESCRIPTOR_TYPE_STORAGE_IMAGE                        = 0x00000003,
    VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER                 = 0x00000004,
    VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER                 = 0x00000005,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER                       = 0x00000006,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER                       = 0x00000007,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC               = 0x00000008,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC               = 0x00000009,
    VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT                     = 0x0000000a,
}

enum VkQueryType {
    VK_QUERY_TYPE_OCCLUSION                                 = 0x00000000,
    VK_QUERY_TYPE_PIPELINE_STATISTICS                       = 0x00000001, /// Optional
    VK_QUERY_TYPE_TIMESTAMP                                 = 0x00000002,
}

enum VkBorderColor {
    VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK                 = 0x00000000,
    VK_BORDER_COLOR_INT_TRANSPARENT_BLACK                   = 0x00000001,
    VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK                      = 0x00000002,
    VK_BORDER_COLOR_INT_OPAQUE_BLACK                        = 0x00000003,
    VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE                      = 0x00000004,
    VK_BORDER_COLOR_INT_OPAQUE_WHITE                        = 0x00000005,
}

enum VkPipelineBindPoint {
    VK_PIPELINE_BIND_POINT_GRAPHICS                         = 0x00000000,
    VK_PIPELINE_BIND_POINT_COMPUTE                          = 0x00000001,
}

enum VkPrimitiveTopology {
    VK_PRIMITIVE_TOPOLOGY_POINT_LIST                        = 0x00000000,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST                         = 0x00000001,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP                        = 0x00000002,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST                     = 0x00000003,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP                    = 0x00000004,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN                      = 0x00000005,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY          = 0x00000006,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY         = 0x00000007,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY      = 0x00000008,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY     = 0x00000009,
    VK_PRIMITIVE_TOPOLOGY_PATCH_LIST                        = 0x0000000a,
}

enum VkSharingMode {
    VK_SHARING_MODE_EXCLUSIVE                               = 0x00000000,
    VK_SHARING_MODE_CONCURRENT                              = 0x00000001,
}

enum VkIndexType {
    VK_INDEX_TYPE_UINT16                                    = 0x00000000,
    VK_INDEX_TYPE_UINT32                                    = 0x00000001,
}

enum VkFilter {
    VK_FILTER_NEAREST                                       = 0x00000000,
    VK_FILTER_LINEAR                                        = 0x00000001,

    //@extension("VK_IMG_filter_cubic") // 16
    VK_FILTER_CUBIC_IMG                                     = 1000015000,
}

enum VkSamplerMipmapMode {
    VK_SAMPLER_MIPMAP_MODE_NEAREST                          = 0x00000001,   /// Choose nearest mip level
    VK_SAMPLER_MIPMAP_MODE_LINEAR                           = 0x00000002,   /// Linear filter between mip levels
}

enum VkSamplerAddressMode {
    VK_SAMPLER_ADDRESS_MODE_REPEAT                          = 0x00000000,
    VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT                 = 0x00000001,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE                   = 0x00000002,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER                 = 0x00000003,
    VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE            = 0x00000004,
}

enum VkCompareOp {
    VK_COMPARE_OP_NEVER                                     = 0x00000000,
    VK_COMPARE_OP_LESS                                      = 0x00000001,
    VK_COMPARE_OP_EQUAL                                     = 0x00000002,
    VK_COMPARE_OP_LESS_OR_EQUAL                             = 0x00000003,
    VK_COMPARE_OP_GREATER                                   = 0x00000004,
    VK_COMPARE_OP_NOT_EQUAL                                 = 0x00000005,
    VK_COMPARE_OP_GREATER_OR_EQUAL                          = 0x00000006,
    VK_COMPARE_OP_ALWAYS                                    = 0x00000007,
}

enum VkPolygonMode {
    VK_POLYGON_MODE_FILL                                    = 0x00000000,
    VK_POLYGON_MODE_LINE                                    = 0x00000001,
    VK_POLYGON_MODE_POINT                                   = 0x00000002,

    //@extension("VK_NV_fill_rectangle") // 154
    VK_POLYGON_MODE_FILL_RECTANGLE_NV                       = 1000153000,
}

enum VkFrontFace {
    VK_FRONT_FACE_COUNTER_CLOCKWISE                         = 0x00000000,
    VK_FRONT_FACE_CLOCKWISE                                 = 0x00000001,
}

enum VkBlendFactor {
    VK_BLEND_FACTOR_ZERO                                    = 0x00000000,
    VK_BLEND_FACTOR_ONE                                     = 0x00000001,
    VK_BLEND_FACTOR_SRC_COLOR                               = 0x00000002,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR                     = 0x00000003,
    VK_BLEND_FACTOR_DST_COLOR                               = 0x00000004,
    VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR                     = 0x00000005,
    VK_BLEND_FACTOR_SRC_ALPHA                               = 0x00000006,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA                     = 0x00000007,
    VK_BLEND_FACTOR_DST_ALPHA                               = 0x00000008,
    VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA                     = 0x00000009,
    VK_BLEND_FACTOR_CONSTANT_COLOR                          = 0x0000000a,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR                = 0x0000000b,
    VK_BLEND_FACTOR_CONSTANT_ALPHA                          = 0x0000000c,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA                = 0x0000000d,
    VK_BLEND_FACTOR_SRC_ALPHA_SATURATE                      = 0x0000000e,
    VK_BLEND_FACTOR_SRC1_COLOR                              = 0x0000000f,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR                    = 0x00000010,
    VK_BLEND_FACTOR_SRC1_ALPHA                              = 0x00000011,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA                    = 0x00000012,
}

enum VkBlendOp {
    VK_BLEND_OP_ADD                                         = 0x00000000,
    VK_BLEND_OP_SUBTRACT                                    = 0x00000001,
    VK_BLEND_OP_REVERSE_SUBTRACT                            = 0x00000002,
    VK_BLEND_OP_MIN                                         = 0x00000003,
    VK_BLEND_OP_MAX                                         = 0x00000004,

    //@extension("VK_EXT_blend_operation_advanced") // 149
    VK_BLEND_OP_ZERO_EXT                                    = 1000148000,
    VK_BLEND_OP_SRC_EXT                                     = 1000148001,
    VK_BLEND_OP_DST_EXT                                     = 1000148002,
    VK_BLEND_OP_SRC_OVER_EXT                                = 1000148003,
    VK_BLEND_OP_DST_OVER_EXT                                = 1000148004,
    VK_BLEND_OP_SRC_IN_EXT                                  = 1000148005,
    VK_BLEND_OP_DST_IN_EXT                                  = 1000148006,
    VK_BLEND_OP_SRC_OUT_EXT                                 = 1000148007,
    VK_BLEND_OP_DST_OUT_EXT                                 = 1000148008,
    VK_BLEND_OP_SRC_ATOP_EXT                                = 1000148009,
    VK_BLEND_OP_DST_ATOP_EXT                                = 1000148010,
    VK_BLEND_OP_XOR_EXT                                     = 1000148011,
    VK_BLEND_OP_MULTIPLY_EXT                                = 1000148012,
    VK_BLEND_OP_SCREEN_EXT                                  = 1000148013,
    VK_BLEND_OP_OVERLAY_EXT                                 = 1000148014,
    VK_BLEND_OP_DARKEN_EXT                                  = 1000148015,
    VK_BLEND_OP_LIGHTEN_EXT                                 = 1000148016,
    VK_BLEND_OP_COLORDODGE_EXT                              = 1000148017,
    VK_BLEND_OP_COLORBURN_EXT                               = 1000148018,
    VK_BLEND_OP_HARDLIGHT_EXT                               = 1000148019,
    VK_BLEND_OP_SOFTLIGHT_EXT                               = 1000148020,
    VK_BLEND_OP_DIFFERENCE_EXT                              = 1000148021,
    VK_BLEND_OP_EXCLUSION_EXT                               = 1000148022,
    VK_BLEND_OP_INVERT_EXT                                  = 1000148023,
    VK_BLEND_OP_INVERT_RGB_EXT                              = 1000148024,
    VK_BLEND_OP_LINEARDODGE_EXT                             = 1000148025,
    VK_BLEND_OP_LINEARBURN_EXT                              = 1000148026,
    VK_BLEND_OP_VIVIDLIGHT_EXT                              = 1000148027,
    VK_BLEND_OP_LINEARLIGHT_EXT                             = 1000148028,
    VK_BLEND_OP_PINLIGHT_EXT                                = 1000148029,
    VK_BLEND_OP_HARDMIX_EXT                                 = 1000148030,
    VK_BLEND_OP_HSL_HUE_EXT                                 = 1000148031,
    VK_BLEND_OP_HSL_SATURATION_EXT                          = 1000148032,
    VK_BLEND_OP_HSL_COLOR_EXT                               = 1000148033,
    VK_BLEND_OP_HSL_LUMINOSITY_EXT                          = 1000148034,
    VK_BLEND_OP_PLUS_EXT                                    = 1000148035,
    VK_BLEND_OP_PLUS_CLAMPED_EXT                            = 1000148036,
    VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT                      = 1000148037,
    VK_BLEND_OP_PLUS_DARKER_EXT                             = 1000148038,
    VK_BLEND_OP_MINUS_EXT                                   = 1000148039,
    VK_BLEND_OP_MINUS_CLAMPED_EXT                           = 1000148040,
    VK_BLEND_OP_CONTRAST_EXT                                = 1000148041,
    VK_BLEND_OP_INVERT_OVG_EXT                              = 1000148042,
    VK_BLEND_OP_RED_EXT                                     = 1000148043,
    VK_BLEND_OP_GREEN_EXT                                   = 1000148044,
    VK_BLEND_OP_BLUE_EXT                                    = 1000148045,
}

enum VkStencilOp {
    VK_STENCIL_OP_KEEP                                      = 0x00000000,
    VK_STENCIL_OP_ZERO                                      = 0x00000001,
    VK_STENCIL_OP_REPLACE                                   = 0x00000002,
    VK_STENCIL_OP_INCREMENT_AND_CLAMP                       = 0x00000003,
    VK_STENCIL_OP_DECREMENT_AND_CLAMP                       = 0x00000004,
    VK_STENCIL_OP_INVERT                                    = 0x00000005,
    VK_STENCIL_OP_INCREMENT_AND_WRAP                        = 0x00000006,
    VK_STENCIL_OP_DECREMENT_AND_WRAP                        = 0x00000007,
}

enum VkLogicOp {
    VK_LOGIC_OP_CLEAR                                       = 0x00000000,
    VK_LOGIC_OP_AND                                         = 0x00000001,
    VK_LOGIC_OP_AND_REVERSE                                 = 0x00000002,
    VK_LOGIC_OP_COPY                                        = 0x00000003,
    VK_LOGIC_OP_AND_INVERTED                                = 0x00000004,
    VK_LOGIC_OP_NO_OP                                       = 0x00000005,
    VK_LOGIC_OP_XOR                                         = 0x00000006,
    VK_LOGIC_OP_OR                                          = 0x00000007,
    VK_LOGIC_OP_NOR                                         = 0x00000008,
    VK_LOGIC_OP_EQUIVALENT                                  = 0x00000009,
    VK_LOGIC_OP_INVERT                                      = 0x0000000a,
    VK_LOGIC_OP_OR_REVERSE                                  = 0x0000000b,
    VK_LOGIC_OP_COPY_INVERTED                               = 0x0000000c,
    VK_LOGIC_OP_OR_INVERTED                                 = 0x0000000d,
    VK_LOGIC_OP_NAND                                        = 0x0000000e,
    VK_LOGIC_OP_SET                                         = 0x0000000f,
}

enum VkSystemAllocationScope {
    VK_SYSTEM_ALLOCATION_SCOPE_COMMAND                      = 0x00000000,
    VK_SYSTEM_ALLOCATION_SCOPE_OBJECT                       = 0x00000001,
    VK_SYSTEM_ALLOCATION_SCOPE_CACHE                        = 0x00000002,
    VK_SYSTEM_ALLOCATION_SCOPE_DEVICE                       = 0x00000003,
    VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE                     = 0x00000004,
}

enum VkInternalAllocationType {
    VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE                  = 0x00000000,
}

enum VkPhysicalDeviceType {
    VK_PHYSICAL_DEVICE_TYPE_OTHER                           = 0x00000000,
    VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU                  = 0x00000001,
    VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU                    = 0x00000002,
    VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU                     = 0x00000003,
    VK_PHYSICAL_DEVICE_TYPE_CPU                             = 0x00000004,
}

enum VkVertexInputRate {
    VK_VERTEX_INPUT_RATE_VERTEX                             = 0x00000000,
    VK_VERTEX_INPUT_RATE_INSTANCE                           = 0x00000001,
}

/// Vulkan format definitions
enum VkFormat {
    VK_FORMAT_UNDEFINED                                     = 0,
    VK_FORMAT_R4G4_UNORM_PACK8                              = 1,
    VK_FORMAT_R4G4B4A4_UNORM_PACK16                         = 2,
    VK_FORMAT_B4G4R4A4_UNORM_PACK16                         = 3,
    VK_FORMAT_R5G6B5_UNORM_PACK16                           = 4,
    VK_FORMAT_B5G6R5_UNORM_PACK16                           = 5,
    VK_FORMAT_R5G5B5A1_UNORM_PACK16                         = 6,
    VK_FORMAT_B5G5R5A1_UNORM_PACK16                         = 7,
    VK_FORMAT_A1R5G5B5_UNORM_PACK16                         = 8,
    VK_FORMAT_R8_UNORM                                      = 9,
    VK_FORMAT_R8_SNORM                                      = 10,
    VK_FORMAT_R8_USCALED                                    = 11,
    VK_FORMAT_R8_SSCALED                                    = 12,
    VK_FORMAT_R8_UINT                                       = 13,
    VK_FORMAT_R8_SINT                                       = 14,
    VK_FORMAT_R8_SRGB                                       = 15,
    VK_FORMAT_R8G8_UNORM                                    = 16,
    VK_FORMAT_R8G8_SNORM                                    = 17,
    VK_FORMAT_R8G8_USCALED                                  = 18,
    VK_FORMAT_R8G8_SSCALED                                  = 19,
    VK_FORMAT_R8G8_UINT                                     = 20,
    VK_FORMAT_R8G8_SINT                                     = 21,
    VK_FORMAT_R8G8_SRGB                                     = 22,
    VK_FORMAT_R8G8B8_UNORM                                  = 23,
    VK_FORMAT_R8G8B8_SNORM                                  = 24,
    VK_FORMAT_R8G8B8_USCALED                                = 25,
    VK_FORMAT_R8G8B8_SSCALED                                = 26,
    VK_FORMAT_R8G8B8_UINT                                   = 27,
    VK_FORMAT_R8G8B8_SINT                                   = 28,
    VK_FORMAT_R8G8B8_SRGB                                   = 29,
    VK_FORMAT_B8G8R8_UNORM                                  = 30,
    VK_FORMAT_B8G8R8_SNORM                                  = 31,
    VK_FORMAT_B8G8R8_USCALED                                = 32,
    VK_FORMAT_B8G8R8_SSCALED                                = 33,
    VK_FORMAT_B8G8R8_UINT                                   = 34,
    VK_FORMAT_B8G8R8_SINT                                   = 35,
    VK_FORMAT_B8G8R8_SRGB                                   = 36,
    VK_FORMAT_R8G8B8A8_UNORM                                = 37,
    VK_FORMAT_R8G8B8A8_SNORM                                = 38,
    VK_FORMAT_R8G8B8A8_USCALED                              = 39,
    VK_FORMAT_R8G8B8A8_SSCALED                              = 40,
    VK_FORMAT_R8G8B8A8_UINT                                 = 41,
    VK_FORMAT_R8G8B8A8_SINT                                 = 42,
    VK_FORMAT_R8G8B8A8_SRGB                                 = 43,
    VK_FORMAT_B8G8R8A8_UNORM                                = 44,
    VK_FORMAT_B8G8R8A8_SNORM                                = 45,
    VK_FORMAT_B8G8R8A8_USCALED                              = 46,
    VK_FORMAT_B8G8R8A8_SSCALED                              = 47,
    VK_FORMAT_B8G8R8A8_UINT                                 = 48,
    VK_FORMAT_B8G8R8A8_SINT                                 = 49,
    VK_FORMAT_B8G8R8A8_SRGB                                 = 50,
    VK_FORMAT_A8B8G8R8_UNORM_PACK32                         = 51,
    VK_FORMAT_A8B8G8R8_SNORM_PACK32                         = 52,
    VK_FORMAT_A8B8G8R8_USCALED_PACK32                       = 53,
    VK_FORMAT_A8B8G8R8_SSCALED_PACK32                       = 54,
    VK_FORMAT_A8B8G8R8_UINT_PACK32                          = 55,
    VK_FORMAT_A8B8G8R8_SINT_PACK32                          = 56,
    VK_FORMAT_A8B8G8R8_SRGB_PACK32                          = 57,
    VK_FORMAT_A2R10G10B10_UNORM_PACK32                      = 58,
    VK_FORMAT_A2R10G10B10_SNORM_PACK32                      = 59,
    VK_FORMAT_A2R10G10B10_USCALED_PACK32                    = 60,
    VK_FORMAT_A2R10G10B10_SSCALED_PACK32                    = 61,
    VK_FORMAT_A2R10G10B10_UINT_PACK32                       = 62,
    VK_FORMAT_A2R10G10B10_SINT_PACK32                       = 63,
    VK_FORMAT_A2B10G10R10_UNORM_PACK32                      = 64,
    VK_FORMAT_A2B10G10R10_SNORM_PACK32                      = 65,
    VK_FORMAT_A2B10G10R10_USCALED_PACK32                    = 66,
    VK_FORMAT_A2B10G10R10_SSCALED_PACK32                    = 67,
    VK_FORMAT_A2B10G10R10_UINT_PACK32                       = 68,
    VK_FORMAT_A2B10G10R10_SINT_PACK32                       = 69,
    VK_FORMAT_R16_UNORM                                     = 70,
    VK_FORMAT_R16_SNORM                                     = 71,
    VK_FORMAT_R16_USCALED                                   = 72,
    VK_FORMAT_R16_SSCALED                                   = 73,
    VK_FORMAT_R16_UINT                                      = 74,
    VK_FORMAT_R16_SINT                                      = 75,
    VK_FORMAT_R16_SFLOAT                                    = 76,
    VK_FORMAT_R16G16_UNORM                                  = 77,
    VK_FORMAT_R16G16_SNORM                                  = 78,
    VK_FORMAT_R16G16_USCALED                                = 79,
    VK_FORMAT_R16G16_SSCALED                                = 80,
    VK_FORMAT_R16G16_UINT                                   = 81,
    VK_FORMAT_R16G16_SINT                                   = 82,
    VK_FORMAT_R16G16_SFLOAT                                 = 83,
    VK_FORMAT_R16G16B16_UNORM                               = 84,
    VK_FORMAT_R16G16B16_SNORM                               = 85,
    VK_FORMAT_R16G16B16_USCALED                             = 86,
    VK_FORMAT_R16G16B16_SSCALED                             = 87,
    VK_FORMAT_R16G16B16_UINT                                = 88,
    VK_FORMAT_R16G16B16_SINT                                = 89,
    VK_FORMAT_R16G16B16_SFLOAT                              = 90,
    VK_FORMAT_R16G16B16A16_UNORM                            = 91,
    VK_FORMAT_R16G16B16A16_SNORM                            = 92,
    VK_FORMAT_R16G16B16A16_USCALED                          = 93,
    VK_FORMAT_R16G16B16A16_SSCALED                          = 94,
    VK_FORMAT_R16G16B16A16_UINT                             = 95,
    VK_FORMAT_R16G16B16A16_SINT                             = 96,
    VK_FORMAT_R16G16B16A16_SFLOAT                           = 97,
    VK_FORMAT_R32_UINT                                      = 98,
    VK_FORMAT_R32_SINT                                      = 99,
    VK_FORMAT_R32_SFLOAT                                    = 100,
    VK_FORMAT_R32G32_UINT                                   = 101,
    VK_FORMAT_R32G32_SINT                                   = 102,
    VK_FORMAT_R32G32_SFLOAT                                 = 103,
    VK_FORMAT_R32G32B32_UINT                                = 104,
    VK_FORMAT_R32G32B32_SINT                                = 105,
    VK_FORMAT_R32G32B32_SFLOAT                              = 106,
    VK_FORMAT_R32G32B32A32_UINT                             = 107,
    VK_FORMAT_R32G32B32A32_SINT                             = 108,
    VK_FORMAT_R32G32B32A32_SFLOAT                           = 109,
    VK_FORMAT_R64_UINT                                      = 110,
    VK_FORMAT_R64_SINT                                      = 111,
    VK_FORMAT_R64_SFLOAT                                    = 112,
    VK_FORMAT_R64G64_UINT                                   = 113,
    VK_FORMAT_R64G64_SINT                                   = 114,
    VK_FORMAT_R64G64_SFLOAT                                 = 115,
    VK_FORMAT_R64G64B64_UINT                                = 116,
    VK_FORMAT_R64G64B64_SINT                                = 117,
    VK_FORMAT_R64G64B64_SFLOAT                              = 118,
    VK_FORMAT_R64G64B64A64_UINT                             = 119,
    VK_FORMAT_R64G64B64A64_SINT                             = 120,
    VK_FORMAT_R64G64B64A64_SFLOAT                           = 121,
    VK_FORMAT_B10G11R11_UFLOAT_PACK32                       = 122,
    VK_FORMAT_E5B9G9R9_UFLOAT_PACK32                        = 123,
    VK_FORMAT_D16_UNORM                                     = 124,
    VK_FORMAT_X8_D24_UNORM_PACK32                           = 125,
    VK_FORMAT_D32_SFLOAT                                    = 126,
    VK_FORMAT_S8_UINT                                       = 127,
    VK_FORMAT_D16_UNORM_S8_UINT                             = 128,
    VK_FORMAT_D24_UNORM_S8_UINT                             = 129,
    VK_FORMAT_D32_SFLOAT_S8_UINT                            = 130,
    VK_FORMAT_BC1_RGB_UNORM_BLOCK                           = 131,
    VK_FORMAT_BC1_RGB_SRGB_BLOCK                            = 132,
    VK_FORMAT_BC1_RGBA_UNORM_BLOCK                          = 133,
    VK_FORMAT_BC1_RGBA_SRGB_BLOCK                           = 134,
    VK_FORMAT_BC2_UNORM_BLOCK                               = 135,
    VK_FORMAT_BC2_SRGB_BLOCK                                = 136,
    VK_FORMAT_BC3_UNORM_BLOCK                               = 137,
    VK_FORMAT_BC3_SRGB_BLOCK                                = 138,
    VK_FORMAT_BC4_UNORM_BLOCK                               = 139,
    VK_FORMAT_BC4_SNORM_BLOCK                               = 140,
    VK_FORMAT_BC5_UNORM_BLOCK                               = 141,
    VK_FORMAT_BC5_SNORM_BLOCK                               = 142,
    VK_FORMAT_BC6H_UFLOAT_BLOCK                             = 143,
    VK_FORMAT_BC6H_SFLOAT_BLOCK                             = 144,
    VK_FORMAT_BC7_UNORM_BLOCK                               = 145,
    VK_FORMAT_BC7_SRGB_BLOCK                                = 146,
    VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK                       = 147,
    VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK                        = 148,
    VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK                     = 149,
    VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK                      = 150,
    VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK                     = 151,
    VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK                      = 152,
    VK_FORMAT_EAC_R11_UNORM_BLOCK                           = 153,
    VK_FORMAT_EAC_R11_SNORM_BLOCK                           = 154,
    VK_FORMAT_EAC_R11G11_UNORM_BLOCK                        = 155,
    VK_FORMAT_EAC_R11G11_SNORM_BLOCK                        = 156,
    VK_FORMAT_ASTC_4x4_UNORM_BLOCK                          = 157,
    VK_FORMAT_ASTC_4x4_SRGB_BLOCK                           = 158,
    VK_FORMAT_ASTC_5x4_UNORM_BLOCK                          = 159,
    VK_FORMAT_ASTC_5x4_SRGB_BLOCK                           = 160,
    VK_FORMAT_ASTC_5x5_UNORM_BLOCK                          = 161,
    VK_FORMAT_ASTC_5x5_SRGB_BLOCK                           = 162,
    VK_FORMAT_ASTC_6x5_UNORM_BLOCK                          = 163,
    VK_FORMAT_ASTC_6x5_SRGB_BLOCK                           = 164,
    VK_FORMAT_ASTC_6x6_UNORM_BLOCK                          = 165,
    VK_FORMAT_ASTC_6x6_SRGB_BLOCK                           = 166,
    VK_FORMAT_ASTC_8x5_UNORM_BLOCK                          = 167,
    VK_FORMAT_ASTC_8x5_SRGB_BLOCK                           = 168,
    VK_FORMAT_ASTC_8x6_UNORM_BLOCK                          = 169,
    VK_FORMAT_ASTC_8x6_SRGB_BLOCK                           = 170,
    VK_FORMAT_ASTC_8x8_UNORM_BLOCK                          = 171,
    VK_FORMAT_ASTC_8x8_SRGB_BLOCK                           = 172,
    VK_FORMAT_ASTC_10x5_UNORM_BLOCK                         = 173,
    VK_FORMAT_ASTC_10x5_SRGB_BLOCK                          = 174,
    VK_FORMAT_ASTC_10x6_UNORM_BLOCK                         = 175,
    VK_FORMAT_ASTC_10x6_SRGB_BLOCK                          = 176,
    VK_FORMAT_ASTC_10x8_UNORM_BLOCK                         = 177,
    VK_FORMAT_ASTC_10x8_SRGB_BLOCK                          = 178,
    VK_FORMAT_ASTC_10x10_UNORM_BLOCK                        = 179,
    VK_FORMAT_ASTC_10x10_SRGB_BLOCK                         = 180,
    VK_FORMAT_ASTC_12x10_UNORM_BLOCK                        = 181,
    VK_FORMAT_ASTC_12x10_SRGB_BLOCK                         = 182,
    VK_FORMAT_ASTC_12x12_UNORM_BLOCK                        = 183,
    VK_FORMAT_ASTC_12x12_SRGB_BLOCK                         = 184,

    //@vulkan1_1
    VK_FORMAT_G8B8G8R8_422_UNORM                            = 1000156000,
    VK_FORMAT_B8G8R8G8_422_UNORM                            = 1000156001,
    VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM                     = 1000156002,
    VK_FORMAT_G8_B8R8_2PLANE_420_UNORM                      = 1000156003,
    VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM                     = 1000156004,
    VK_FORMAT_G8_B8R8_2PLANE_422_UNORM                      = 1000156005,
    VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM                     = 1000156006,
    VK_FORMAT_R10X6_UNORM_PACK16                            = 1000156007,
    VK_FORMAT_R10X6G10X6_UNORM_2PACK16                      = 1000156008,
    VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16            = 1000156009,
    VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16        = 1000156010,
    VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16        = 1000156011,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16    = 1000156012,
    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16     = 1000156013,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16    = 1000156014,
    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16     = 1000156015,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16    = 1000156016,
    VK_FORMAT_R12X4_UNORM_PACK16                            = 1000156017,
    VK_FORMAT_R12X4G12X4_UNORM_2PACK16                      = 1000156018,
    VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16            = 1000156019,
    VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16        = 1000156020,
    VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16        = 1000156021,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16    = 1000156022,
    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16     = 1000156023,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16    = 1000156024,
    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16     = 1000156025,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16    = 1000156026,
    VK_FORMAT_G16B16G16R16_422_UNORM                        = 1000156027,
    VK_FORMAT_B16G16R16G16_422_UNORM                        = 1000156028,
    VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM                  = 1000156029,
    VK_FORMAT_G16_B16R16_2PLANE_420_UNORM                   = 1000156030,
    VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM                  = 1000156031,
    VK_FORMAT_G16_B16R16_2PLANE_422_UNORM                   = 1000156032,
    VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM                  = 1000156033,

    //@extension("VK_IMG_format_pvrtc") // 28
    VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG                   = 1000054000,
    VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG                   = 1000054001,
    VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG                   = 1000054002,
    VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG                   = 1000054003,
    VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG                    = 1000054004,
    VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG                    = 1000054005,
    VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG                    = 1000054006,
    VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG                    = 1000054007,

    //@extension("VK_KHR_sampler_ycbcr_conversion") // 157
    VK_FORMAT_G8B8G8R8_422_UNORM_KHR                            = 1000156000,
    VK_FORMAT_B8G8R8G8_422_UNORM_KHR                            = 1000156001,
    VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR                     = 1000156002,
    VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR                      = 1000156003,
    VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR                     = 1000156004,
    VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR                      = 1000156005,
    VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR                     = 1000156006,
    VK_FORMAT_R10X6_UNORM_PACK16_KHR                            = 1000156007,
    VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR                      = 1000156008,
    VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR            = 1000156009,
    VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR        = 1000156010,
    VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR        = 1000156011,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR    = 1000156012,
    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR     = 1000156013,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR    = 1000156014,
    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR     = 1000156015,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR    = 1000156016,
    VK_FORMAT_R12X4_UNORM_PACK16_KHR                            = 1000156017,
    VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR                      = 1000156018,
    VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR            = 1000156019,
    VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR        = 1000156020,
    VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR        = 1000156021,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR    = 1000156022,
    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR     = 1000156023,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR    = 1000156024,
    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR     = 1000156025,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR    = 1000156026,
    VK_FORMAT_G16B16G16R16_422_UNORM_KHR                        = 1000156027,
    VK_FORMAT_B16G16R16G16_422_UNORM_KHR                        = 1000156028,
    VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR                  = 1000156029,
    VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR                   = 1000156030,
    VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR                  = 1000156031,
    VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR                   = 1000156032,
    VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR                  = 1000156033,
}

/// Structure type enumerant
enum VkStructureType {
    VK_STRUCTURE_TYPE_APPLICATION_INFO                          = 0,
    VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO                      = 1,
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO                  = 2,
    VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO                        = 3,
    VK_STRUCTURE_TYPE_SUBMIT_INFO                               = 4,
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO                      = 5,
    VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE                       = 6,
    VK_STRUCTURE_TYPE_BIND_SPARSE_INFO                          = 7,
    VK_STRUCTURE_TYPE_FENCE_CREATE_INFO                         = 8,
    VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO                     = 9,
    VK_STRUCTURE_TYPE_EVENT_CREATE_INFO                         = 10,
    VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO                    = 11,
    VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO                        = 12,
    VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO                   = 13,
    VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO                         = 14,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO                    = 15,
    VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO                 = 16,
    VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO                = 17,
    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO         = 18,
    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO   = 19,
    VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO   = 21,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO       = 22,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO  = 23,
    VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO    = 24,
    VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO  = 25,
    VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO    = 26,
    VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO        = 27,
    VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO             = 28,
    VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO              = 29,
    VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO               = 30,
    VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO                       = 31,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO         = 32,
    VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO               = 33,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO              = 34,
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET                      = 35,
    VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET                       = 36,
    VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO                   = 37,
    VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO                   = 38,
    VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO                  = 39,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO              = 40,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO           = 41,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO                 = 42,
    VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO                    = 43,
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER                     = 44,
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER                      = 45,
    VK_STRUCTURE_TYPE_MEMORY_BARRIER                            = 46,
    VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO               = 47,
    VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO                 = 48,

    //@vulkan1_1
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES       = 1000094000,
    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO                   = 1000157000,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO                    = 1000157001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES    = 1000083000,
    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS             = 1000127000,
    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO            = 1000127001,
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO                = 1000060000,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO       = 1000060003,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO    = 1000060004,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO                  = 1000060005,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO             = 1000060006,
    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO      = 1000060013,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO       = 1000060014,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES          = 1000070000,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO           = 1000070001,
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2         = 1000146000,
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2          = 1000146001,
    VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2   = 1000146002,
    VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2                     = 1000146003,
    VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2        = 1000146004,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2                = 1000059000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2              = 1000059001,
    VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2                       = 1000059002,
    VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2                 = 1000059003,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2       = 1000059004,
    VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2                 = 1000059005,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2       = 1000059006,
    VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2          = 1000059007,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2            = 1000059008,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES             = 1000117000,
    VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO       = 1000117001,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO                          = 1000117002,
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO = 1000117003,
    VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO                 = 1000053000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES                = 1000053001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES              = 1000053002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES         = 1000120000,
    VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO                             = 1000145000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES         = 1000145001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES       = 1000145002,
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2                               = 1000145003,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO              = 1000156000,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO                     = 1000156001,
    VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO                      = 1000156002,
    VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO              = 1000156003,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES = 1000156004,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES  = 1000156005,
    VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO            = 1000085000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO        = 1000071000,
    VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES                  = 1000071001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO              = 1000071002,
    VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES                        = 1000071003,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES                     = 1000071004,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO                = 1000072000,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO                 = 1000072001,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO                       = 1000072002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO               = 1000112000,
    VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES                         = 1000112001,
    VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO                          = 1000113000,
    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO                      = 1000077000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO           = 1000076000,
    VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES                     = 1000076001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES          = 1000168000,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT                     = 1000168001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES    = 1000063000,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR             = 1000060007,

    //@extension("VK_KHR_swapchain") // 2
    VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR                 = 1000001000,
    VK_STRUCTURE_TYPE_PRESENT_INFO_KHR                          = 1000001001,
    // added as interaction from VK_KHR_device_group / VK 1.1
    VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR           = 1000060008,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR      = 1000060009,
    VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR               = 1000060010,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR             = 1000060011,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR    = 1000060012,

    //@extension("VK_KHR_display") // 3
    VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR              = 1000002000,
    VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR           = 1000002001,

    //@extension("VK_KHR_display_swapchain") // 4
    VK_STRUCTURE_TYPE_DISPLAY_DISPLAY_PRESENT_INFO_KHR          = 1000003000,

    //@extension("VK_KHR_xlib_surface") // 5
    VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR              = 1000004000,

    //@extension("VK_KHR_xcb_surface") // 6
    VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR               = 1000005000,

    //@extension("VK_KHR_wayland_surface") // 7
    VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR           = 1000006000,

    //@extension("VK_KHR_mir_surface") // 8
    VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR               = 1000007000,

    //@extension("VK_KHR_android_surface") // 9
    VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR           = 1000008000,

    //@extension("VK_KHR_win32_surface") // 10
    VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR             = 1000009000,

    //@extension("VK_ANDROID_native_buffer") // 11
    VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID                     = 1000010000,
    VK_STRUCTURE_TYPE_SWAPCHAIN_IMAGE_CREATE_INFO_ANDROID       = 1000010001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_ANDROID = 1000010002,

    //@extension("VK_EXT_debug_report") // 12
    VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT     = 1000011000,

    //@extension("VK_AMD_rasterization_order") // 19
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD = 1000018000,

    //@extension("VK_EXT_debug_marker") // 23
    VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT         = 1000022000,
    VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT          = 1000022001,
    VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT              = 1000022002,

    //@extension("VK_NV_dedicated_allocation") // 27
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV = 1000026000,
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV = 1000026001,
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = 1000026002,

    //@extension("VK_AMD_texture_gather_bias_lod") // 42
    VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD  = 1000041000,

    //@extension("VK_KHR_multiview") // 54
    VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR     = 1000053000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR    = 1000053001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR  = 1000053002,

    //@extension("VK_NV_external_memory") // 57
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV      = 1000056000,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV            = 1000056001,

    //@extension("VK_NV_external_memory_win32") // 58
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV        = 1000057000,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV        = 1000057001,

    //@extension("VK_NV_win32_keyed_mutex") // 59
    VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV = 1000058000,

    //@extension("VK_KHR_get_physical_device_properties2") // 60
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR            = 1000059000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR          = 1000059001,
    VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR                   = 1000059002,
    VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR             = 1000059003,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR   = 1000059004,
    VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR             = 1000059005,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR   = 1000059006,
    VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR      = 1000059007,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR = 1000059008,

    //@extension("VK_KHR_device_group") // 61
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR            = 1000060000,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR   = 1000060003,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR = 1000060004,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR              = 1000060005,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR         = 1000060006,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR     = 1000060007,
    // tokens 08-12 are listed with VK_KHR_swapchain
    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR  = 1000060013,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR   = 1000060014,

    //@extension("VK_EXT_validation_flags") // 62
    VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT                      = 1000061000,

    //@extension("VK_NN_vi_surface") // 63
    VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN                 = 1000062000,

    //@extension("VK_KHR_device_group_creation") // 71
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR      = 1000070000,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR       = 1000070001,

    //@extension("VK_KHR_external_memory_capabilities") // 72
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR    = 1000071000,
    VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR      = 1000071001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR  = 1000071002,
    VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR            = 1000071003,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR         = 1000071004,

    //@extension("VK_KHR_external_memory") // 73
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR    = 1000072000,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR     = 1000072001,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR           = 1000072002,

    //@extension("VK_KHR_external_memory_win32") // 74
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR       = 1000073000,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR       = 1000073001,
    VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR        = 1000073002,

    //@extension("VK_KHR_external_memory_fd") // 75
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR                 = 1000074000,
    VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR                  = 1000074001,

    //@extension("VK_KHR_win32_keyed_mutex") // 76
    VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR    = 1000075000,

    //@extension("VK_KHR_external_semaphore_capabilities") // 77
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR   = 1000076000,
    VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR         = 1000076001,

    //@extension("VK_KHR_external_semaphore") // 78
    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR          = 1000077000,

    //@extension("VK_KHR_external_semaphore_win32") // 79
    VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR    = 1000078000,
    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR    = 1000078001,
    VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR               = 1000078002,

    //@extension("VK_KHR_external_semaphore_fd") // 80
    VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR              = 1000079000,
    VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR                 = 1000079001,

    //@extension("VK_KHR_push_descriptor") // 81
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR    = 1000080000,

    //@extension("VK_KHR_16bit_storage") // 84
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR    = 1000083000,

    //@extension("VK_KHR_incremental_present") // 85
    VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR                       = 1000084000,

    //@extension("VK_KHR_descriptor_update_template") // 86
    VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR    = 1000085000,

    //@extension("VK_NVX_device_generated_commands") // 87
    VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX              = 1000086000,
    VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX  = 1000086001,
    VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX             = 1000086002,
    VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX   = 1000086003,
    VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX      = 1000086004,
    VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX    = 1000086005,

    //@extension("VK_NV_clip_space_w_scaling") // 88
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV  = 1000087000,

    //@extension("VK_EXT_display_surface_counter") // 91
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT                = 1000090000,

    //@extension("VK_EXT_display_control") // 92
    VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT                    = 1000091000,
    VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT                     = 1000091001,
    VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT                    = 1000091002,
    VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT         = 1000091003,

    //@extension("VK_GOOGLE_display_timing") // 93
    VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE                 = 1000092000,

    //@extension("VK_NVX_multiview_per_view_attributes") // 98
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX  = 1000097000,

    //@extension("VK_NV_viewport_swizzle") // 99
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV    = 1000098000,

    //@extension("VK_EXT_discard_rectangles") // 100
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT  = 1000099000,
    VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT  = 1000099001,

    //@extension("VK_EXT_conservative_rasterization") // 102
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT = 1000101000,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT = 1000101001,

    //@extension("VK_EXT_hdr_metadata") // 106
    VK_STRUCTURE_TYPE_HDR_METADATA_EXT                          = 1000105000,

    //@extension("VK_KHR_shared_presentable_image") // 112
    VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR   = 1000111000,

    //@extension("VK_KHR_external_fence_capabilities") // 113
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR   = 1000112000,
    VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR             = 1000112001,

    //@extension("VK_KHR_external_fence") // 114
    VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR              = 1000113000,

    //@extension("VK_KHR_external_fence_win32") // 115
    VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR        = 1000114000,
    VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR        = 1000114001,
    VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR           = 1000114002,

    //@extension("VK_KHR_external_fence_fd") // 117
    VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR                  = 1000115000,
    VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR                     = 1000115001,

    //@extension("VK_KHR_maintenance2") // 118
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR             = 1000117000,
    VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR       = 1000117001,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR                          = 1000117002,
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR = 1000117003,

    //@extension("VK_KHR_get_surface_capabilities2") // 120
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR        = 1000119000,
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR                = 1000119001,
    VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR                      = 1000119002,

    //@extension("VK_KHR_variable_pointers") // 121
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR = 1000120000,

    //@extension("VK_MVK_ios_surface") // 123
    VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK               = 1000122000,

    //@extension("VK_MVK_macos_surface") // 124
    VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK             = 1000123000,

    //@extension("VK_KHR_dedicated_allocation") // 128
    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR         = 1000127000,
    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR        = 1000127001,

    //@extension("VK_EXT_debug_utils") // 129
    VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT          = 1000128000,
    VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT           = 1000128001,
    VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT                     = 1000128002,
    VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT   = 1000128003,
    VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT     = 1000128004,

    //@extension("VK_ANDROID_external_memory_android_hardware_buffer") // 130
    VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID             = 1000129000,
    VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID        = 1000129001,
    VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID = 1000129002,
    VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID       = 1000129003,
    VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID   = 1000129004,
    VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID                           = 1000129005,

    //@extension("VK_EXT_sampler_filter_minmax") // 131
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT = 1000130000,
    VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT = 1000130001,

    //@extension("VK_EXT_sample_locations") // 144
    VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT                         = 1000143000,
    VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT       = 1000143001,
    VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT   = 1000143002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT   = 1000143003,
    VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT                        = 1000143004,

    //@extension("VK_KHR_get_memory_requirements2") // 147
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR         = 1000146000,
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR          = 1000146001,
    VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR   = 1000146002,
    VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR                     = 1000146003,
    VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR        = 1000146004,

    //@extension("VK_KHR_image_format_list") // 148
    VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR             = 1000147000,

    //@extension("VK_EXT_blend_operation_advanced") // 149
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT = 1000148000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT = 1000148001,
    VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT = 1000148002,

    //@extension("VK_NV_fragment_coverage_to_color") // 150
    VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV = 1000149000,

    //@extension("VK_NV_framebuffer_mixed_samples") // 153
    VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV = 1000152000,

    //@extension("VK_KHR_sampler_ycbcr_conversion") // 157
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR              = 1000156000,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR                     = 1000156001,
    VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR                      = 1000156002,
    VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR              = 1000156003,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR = 1000156004,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR  = 1000156005,

    //@extension("VK_KHR_bind_memory2") // 158
    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR                       = 1000157000,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR                        = 1000157001,

    //@extension("VK_EXT_validation_cache") // 161
    VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT                  = 1000160000,
    VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT    = 1000160001,

    //@extension("VK_KHR_maintenance3") // 169
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR      = 1000168000,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR                 = 1000168001,

    //@extension("VK_EXT_global_priority") // 175
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT      = 1000174000,

    //@extension("VK_EXT_external_memory_host") // 179
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT                   = 1000178000,
    VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT                    = 1000178001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT   = 1000178002,
}

enum VkSubpassContents {
    VK_SUBPASS_CONTENTS_INLINE                              = 0x00000000,
    VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS           = 0x00000001,
}

enum VkPipelineCacheHeaderVersion {
    VK_PIPELINE_CACHE_HEADER_VERSION_ONE                    = 1,
}

@lastUnused(-11)
/// Error and return codes
enum VkResult {
    // Return codes for successful operation execution (positive values)
    VK_SUCCESS                                              = 0,
    VK_NOT_READY                                            = 1,
    VK_TIMEOUT                                              = 2,
    VK_EVENT_SET                                            = 3,
    VK_EVENT_RESET                                          = 4,
    VK_INCOMPLETE                                           = 5,

    //@extension("VK_KHR_swapchain") // 2
    VK_SUBOPTIMAL_KHR                                       = 1000001003,

    // Error codes (negative values)
    VK_ERROR_OUT_OF_HOST_MEMORY                             = 0xFFFFFFFF, // -1
    VK_ERROR_OUT_OF_DEVICE_MEMORY                           = 0xFFFFFFFE, // -2
    VK_ERROR_INITIALIZATION_FAILED                          = 0xFFFFFFFD, // -3
    VK_ERROR_DEVICE_LOST                                    = 0xFFFFFFFC, // -4
    VK_ERROR_MEMORY_MAP_FAILED                              = 0xFFFFFFFB, // -5
    VK_ERROR_LAYER_NOT_PRESENT                              = 0xFFFFFFFA, // -6
    VK_ERROR_EXTENSION_NOT_PRESENT                          = 0xFFFFFFF9, // -7
    VK_ERROR_FEATURE_NOT_PRESENT                            = 0xFFFFFFF8, // -8
    VK_ERROR_INCOMPATIBLE_DRIVER                            = 0xFFFFFFF7, // -9
    VK_ERROR_TOO_MANY_OBJECTS                               = 0xFFFFFFF6, // -10
    VK_ERROR_FORMAT_NOT_SUPPORTED                           = 0xFFFFFFF5, // -11
    VK_ERROR_FRAGMENTED_POOL                                = 0xFFFFFFF4, // -12

    //@vulkan1_1
    VK_ERROR_OUT_OF_POOL_MEMORY                             = 0xC4642878, // -1000069000
    VK_ERROR_INVALID_EXTERNAL_HANDLE                        = 0xC4641CBD, // -1000072003

    //@extension("VK_KHR_surface") // 1
    VK_ERROR_SURFACE_LOST_KHR                               = 0xC4653600, // -1000000000
    VK_ERROR_NATIVE_WINDOW_IN_USE_KHR                       = 0xC46535FF, // -1000000001

    //@extension("VK_KHR_swapchain") // 2
    VK_ERROR_OUT_OF_DATE_KHR                                = 0xC4653214, // -1000001004

    //@extension("VK_KHR_display_swapchain") // 4
    VK_ERROR_INCOMPATIBLE_DISPLAY_KHR                       = 0xC4652A47, // -1000003001

    //@extension("VK_EXT_debug_report") // 12
    VK_ERROR_VALIDATION_FAILED_EXT                          = 0xC4650B07, // -1000011001

    //@extension("VK_NV_glsl_shader") // 13
    VK_ERROR_INVALID_SHADER_NV                              = 0xC4650720, // -1000012000

    //@extension("VK_KHR_maintenance1") // 70
    VK_ERROR_OUT_OF_POOL_MEMORY_KHR                         = 0xC4642878, // -1000069000

    //@extension("VK_EXT_global_priority") // 175
    VK_ERROR_NOT_PERMITTED_EXT                              = 0xC4628E4F, // -1000174001

    //@extension("VK_KHR_external_memory") // 73
    VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR                    = 0xC4641CBD, // -1000072003
}

enum VkDynamicState {
    VK_DYNAMIC_STATE_VIEWPORT                               = 0x00000000,
    VK_DYNAMIC_STATE_SCISSOR                                = 0x00000001,
    VK_DYNAMIC_STATE_LINE_WIDTH                             = 0x00000002,
    VK_DYNAMIC_STATE_DEPTH_BIAS                             = 0x00000003,
    VK_DYNAMIC_STATE_BLEND_CONSTANTS                        = 0x00000004,
    VK_DYNAMIC_STATE_DEPTH_BOUNDS                           = 0x00000005,
    VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK                   = 0x00000006,
    VK_DYNAMIC_STATE_STENCIL_WRITE_MASK                     = 0x00000007,
    VK_DYNAMIC_STATE_STENCIL_REFERENCE                      = 0x00000008,

    //@extension("VK_NV_clip_space_w_scaling") // 88
    VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV                  = 1000087000,

    //@extension("VK_EXT_discard_rectangles") // 100
    VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT                  = 1000099000,

    //@extension("VK_EXT_sample_locations") // 144
    VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT                   = 1000143000,
}

enum VkObjectType {
    VK_OBJECT_TYPE_UNKNOWN                                  = 0,
    VK_OBJECT_TYPE_INSTANCE                                 = 1,
    VK_OBJECT_TYPE_PHYSICAL_DEVICE                          = 2,
    VK_OBJECT_TYPE_DEVICE                                   = 3,
    VK_OBJECT_TYPE_QUEUE                                    = 4,
    VK_OBJECT_TYPE_SEMAPHORE                                = 5,
    VK_OBJECT_TYPE_COMMAND_BUFFER                           = 6,
    VK_OBJECT_TYPE_FENCE                                    = 7,
    VK_OBJECT_TYPE_DEVICE_MEMORY                            = 8,
    VK_OBJECT_TYPE_BUFFER                                   = 9,
    VK_OBJECT_TYPE_IMAGE                                    = 10,
    VK_OBJECT_TYPE_EVENT                                    = 11,
    VK_OBJECT_TYPE_QUERY_POOL                               = 12,
    VK_OBJECT_TYPE_BUFFER_VIEW                              = 13,
    VK_OBJECT_TYPE_IMAGE_VIEW                               = 14,
    VK_OBJECT_TYPE_SHADER_MODULE                            = 15,
    VK_OBJECT_TYPE_PIPELINE_CACHE                           = 16,
    VK_OBJECT_TYPE_PIPELINE_LAYOUT                          = 17,
    VK_OBJECT_TYPE_RENDER_PASS                              = 18,
    VK_OBJECT_TYPE_PIPELINE                                 = 19,
    VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT                    = 20,
    VK_OBJECT_TYPE_SAMPLER                                  = 21,
    VK_OBJECT_TYPE_DESCRIPTOR_POOL                          = 22,
    VK_OBJECT_TYPE_DESCRIPTOR_SET                           = 23,
    VK_OBJECT_TYPE_FRAMEBUFFER                              = 24,
    VK_OBJECT_TYPE_COMMAND_POOL                             = 25,

    //@vulkan1_1
    VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION                 = 1000156000,
    VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE               = 1000085000,

    //@extension("VK_KHR_surface") // 1
    VK_OBJECT_TYPE_SURFACE_KHR                              = 1000000000,

    //@extension("VK_KHR_swapchain") // 2
    VK_OBJECT_TYPE_SWAPCHAIN_KHR                            = 1000001000,

    //@extension("VK_KHR_display") // 3
    VK_OBJECT_TYPE_DISPLAY_KHR                              = 1000002000,
    VK_OBJECT_TYPE_DISPLAY_MODE_KHR                         = 1000002001,

    //@extension("VK_KHR_debug_report") // 12
    VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT                = 1000011000,

    //@extension("VK_KHR_descriptor_update_template") // 86
    VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR           = 1000085000,

    //@extension("VK_NVX_device_generated_commands") // 87
    VK_OBJECT_TYPE_OBJECT_TABLE_NVX                         = 1000086000,
    VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX             = 1000086001,

    //@extension("VK_EXT_debug_utils") // 129
    VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT                = 1000128000,

    //@extension("VK_KHR_sampler_ycbcr_conversion") // 157
    VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR             = 1000156000,

    //@extension("VK_EXT_validation_cache") // 161
    VK_OBJECT_TYPE_VALIDATION_CACHE_EXT                     = 1000160000,
}


//@vulkan1_1 enums

enum VkPointClippingBehavior {
    VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES              = 0,
    VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY        = 1,
}

enum VkTessellationDomainOrigin {
    VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT                = 0,
    VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT                = 1,
}

enum VkSamplerYcbcrModelConversion {
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY          = 0,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY        = 1,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709             = 2,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601             = 3,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020            = 4,
}

enum VkSamplerYcbcrRange {
    VK_SAMPLER_YCBCR_RANGE_ITU_FULL = 0,
    VK_SAMPLER_YCBCR_RANGE_ITU_NARROW = 1,
}

enum VkChromaLocation {
    VK_CHROMA_LOCATION_COSITED_EVEN = 0,
    VK_CHROMA_LOCATION_MIDPOINT = 1,
}

enum VkDescriptorUpdateTemplateType {
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET = 0,
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR = 1,
}

@extension("VK_KHR_surface") // 1
enum VkPresentModeKHR {
    VK_PRESENT_MODE_IMMEDIATE_KHR                           = 0x00000000,
    VK_PRESENT_MODE_MAILBOX_KHR                             = 0x00000001,
    VK_PRESENT_MODE_FIFO_KHR                                = 0x00000002,
    VK_PRESENT_MODE_FIFO_RELAXED_KHR                        = 0x00000003,

    //@extension("VK_KHR_shared_presentable_image") // 112
    VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR               = 1000111000,
    VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR           = 1000111001,
}

@extension("VK_KHR_surface") // 1
enum VkColorSpaceKHR {
    VK_COLOR_SPACE_SRGB_NONLINEAR_KHR                       = 0x00000000,

    //@extension("VK_EXT_swapchain_colorspace") // 105
    VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT                 = 1000104001,
    VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT                 = 1000104002,
    VK_COLOR_SPACE_DCI_P3_LINEAR_EXT                        = 1000104003,
    VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT                     = 1000104004,
    VK_COLOR_SPACE_BT709_LINEAR_EXT                         = 1000104005,
    VK_COLOR_SPACE_BT709_NONLINEAR_EXT                      = 1000104006,
    VK_COLOR_SPACE_BT2020_LINEAR_EXT                        = 1000104007,
    VK_COLOR_SPACE_HDR10_ST2084_EXT                         = 1000104008,
    VK_COLOR_SPACE_DOLBYVISION_EXT                          = 1000104009,
    VK_COLOR_SPACE_HDR10_HLG_EXT                            = 1000104010,
    VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT                      = 1000104011,
    VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT                   = 1000104012,
    VK_COLOR_SPACE_PASS_THROUGH_EXT                         = 1000104013,
    VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT              = 1000104014,
}

@extension("VK_EXT_debug_report") // 12
enum VkDebugReportObjectTypeEXT {
    VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT                 = 0,
    VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT                = 1,
    VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT         = 2,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT                  = 3,
    VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT                   = 4,
    VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT               = 5,
    VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT          = 6,
    VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT                   = 7,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT           = 8,
    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT                  = 9,
    VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT                   = 10,
    VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT                   = 11,
    VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT              = 12,
    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT             = 13,
    VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT              = 14,
    VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT           = 15,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT          = 16,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT         = 17,
    VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT             = 18,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT                = 19,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT   = 20,
    VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT                 = 21,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT         = 22,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT          = 23,
    VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT             = 24,
    VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT            = 25,
    VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT             = 26,
    VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT           = 27,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT = 28,
    VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT             = 29,
    VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT        = 30,
    VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT        = 31,
    VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT = 32,

    //extension("VK_EXT_validation_cache") // 161
    VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT    = 33,

    //extension("VK_KHR_descriptor_update_template") // 86
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT = 1000085000,

    //@extension("VK_KHR_sampler_ycbcr_conversion") // 157
    VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT = 1000156000,
}

@extension("VK_AMD_rasterization_order") // 19
enum VkRasterizationOrderAMD {
    VK_RASTERIZATION_ORDER_STRICT_AMD                       = 0,
    VK_RASTERIZATION_ORDER_RELAXED_AMD                      = 1,
}

@extension("VK_AMD_shader_info") // 43
enum VkShaderInfoTypeAMD {
    VK_SHADER_INFO_TYPE_STATISTICS_AMD                      = 0,
    VK_SHADER_INFO_TYPE_BINARY_AMD                          = 1,
    VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD                     = 2,
}

@extension("VK_EXT_validation_flags") // 62
enum VkValidationCheckEXT {
    VK_VALIDATION_CHECK_ALL_EXT                             = 0,
    VK_VALIDATION_CHECK_SHADERS_EXT                         = 1,
}

@extension("VK_KHR_descriptor_update_template") // 86
enum VkDescriptorUpdateTemplateTypeKHR {
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR   = 0,
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR = 1,
}

@extension("VK_NVX_device_generated_commands") // 87
enum VkIndirectCommandsTokenTypeNVX {
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX            = 0,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DESCRIPTOR_SET_NVX      = 1,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NVX        = 2,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NVX       = 3,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NVX       = 4,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX        = 5,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX                = 6,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX            = 7,
}

@extension("VK_NVX_device_generated_commands") // 87
enum VkObjectEntryTypeNVX {
    VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX                 = 0,
    VK_OBJECT_ENTRY_TYPE_PIPELINE_NVX                       = 1,
    VK_OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX                   = 2,
    VK_OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX                  = 3,
    VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX                  = 4,
}

@extension("VK_EXT_display_control") // 92
enum VkDisplayPowerStateEXT {
    VK_DISPLAY_POWER_STATE_OFF_EXT                          = 0,
    VK_DISPLAY_POWER_STATE_SUSPEND_EXT                      = 1,
    VK_DISPLAY_POWER_STATE_ON_EXT                           = 2,
}

@extension("VK_EXT_display_control") // 92
enum VkDeviceEventTypeEXT {
    VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT                = 0,
}

@extension("VK_EXT_display_control") // 92
enum VkDisplayEventTypeEXT {
    VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT               = 0,
}

@extension("VK_NV_viewport_swizzle") // 99
enum VkViewportCoordinateSwizzleNV {
    VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV            = 0,
    VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV            = 1,
    VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV            = 2,
    VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV            = 3,
    VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV            = 4,
    VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV            = 5,
    VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV            = 6,
    VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV            = 7,
}

@extension("VK_EXT_discard_rectangles") // 100
enum VkDiscardRectangleModeEXT {
    VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT = 0,
    VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT = 1,
}

@extension("VK_EXT_conservative_rasterization") // 102
enum VkConservativeRasterizationModeEXT {
    VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT         = 0,
    VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT     = 1,
    VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT    = 2,
}

@extension("VK_KHR_maintenance2") // 118
enum VkPointClippingBehaviorKHR {
    VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR          = 0,
    VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR    = 1,
}

@extension("VK_KHR_maintenance2") // 118
enum VkTessellationDomainOriginKHR {
    VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR            = 0,
    VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR            = 1,
}

@extension("VK_EXT_sampler_filter_minmax") // 131
enum VkSamplerReductionModeEXT {
    VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT          = 0,
    VK_SAMPLER_REDUCTION_MODE_MIN_EXT                       = 1,
    VK_SAMPLER_REDUCTION_MODE_MAX_EXT                       = 2,
}

@extension("VK_EXT_blend_operation_advanced") // 149
enum VkBlendOverlapEXT {
    VK_BLEND_OVERLAP_UNCORRELATED_EXT                       = 0,
    VK_BLEND_OVERLAP_DISJOINT_EXT                           = 1,
    VK_BLEND_OVERLAP_CONJOINT_EXT                           = 2,
}

@extension("VK_NV_framebuffer_mixed_samples") // 153
enum VkCoverageModulationModeNV {
    VK_COVERAGE_MODULATION_MODE_NONE_NV                     = 0,
    VK_COVERAGE_MODULATION_MODE_RGB_NV                      = 1,
    VK_COVERAGE_MODULATION_MODE_ALPHA_NV                    = 2,
    VK_COVERAGE_MODULATION_MODE_RGBA_NV                     = 3,
}

@extension("VK_KHR_sampler_ycbcr_conversion") // 157
enum VkSamplerYcbcrModelConversionKHR {
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR      = 0,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR    = 1,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR         = 2,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR         = 3,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR        = 4,
}

@extension("VK_KHR_sampler_ycbcr_conversion") // 157
enum VkSamplerYcbcrRangeKHR {
    VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR                     = 0,
    VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR                   = 1,
}

@extension("VK_KHR_sampler_ycbcr_conversion") // 157
enum VkChromaLocationKHR {
    VK_CHROMA_LOCATION_COSITED_EVEN_KHR                     = 0,
    VK_CHROMA_LOCATION_MIDPOINT_KHR                         = 1,
}

@extension("VK_EXT_validation_cache") // 161
enum VkValidationCacheHeaderVersionEXT {
    VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT              = 1,
}

@extension("VK_EXT_global_priority") // 175
enum VkQueueGlobalPriorityEXT {
    VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT                        = 128,
    VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT                     = 256,
    VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT                       = 512,
    VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT                   = 1024,
}

/////////////////
//  Bitfields  //
/////////////////

/// Queue capabilities
type VkFlags VkQueueFlags
bitfield VkQueueFlagBits {
    VK_QUEUE_GRAPHICS_BIT                                   = 0x00000001,    /// Queue supports graphics operations
    VK_QUEUE_COMPUTE_BIT                                    = 0x00000002,    /// Queue supports compute operations
    VK_QUEUE_TRANSFER_BIT                                   = 0x00000004,    /// Queue supports transfer operations
    VK_QUEUE_SPARSE_BINDING_BIT                             = 0x00000008,    /// Queue supports sparse resource memory management operations

    //@vulkan1_1
    VK_QUEUE_PROTECTED_BIT                                  = 0x00000010,
}

/// Memory properties passed into vkAllocMemory().
type VkFlags VkMemoryPropertyFlags
bitfield VkMemoryPropertyFlagBits {
    VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT                     = 0x00000001,
    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT                     = 0x00000002,
    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT                    = 0x00000004,
    VK_MEMORY_PROPERTY_HOST_CACHED_BIT                      = 0x00000008,
    VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT                 = 0x00000010,

    //@vulkan1_1
    VK_MEMORY_PROPERTY_PROTECTED_BIT                        = 0x00000020,
}

/// Memory heap flags
type VkFlags VkMemoryHeapFlags
bitfield VkMemoryHeapFlagBits {
    VK_MEMORY_HEAP_DEVICE_LOCAL_BIT                         = 0x00000001,

    //@vulkan1_1
    VK_MEMORY_HEAP_MULTI_INSTANCE_BIT                       = 0x00000002,

    //@extension("VK_KHR_device_group_creation") // 71
    VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR                   = 0x00000002,
}

/// Access flags
type VkFlags VkAccessFlags
bitfield VkAccessFlagBits {
    VK_ACCESS_INDIRECT_COMMAND_READ_BIT                     = 0x00000001,
    VK_ACCESS_INDEX_READ_BIT                                = 0x00000002,
    VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT                     = 0x00000004,
    VK_ACCESS_UNIFORM_READ_BIT                              = 0x00000008,
    VK_ACCESS_INPUT_ATTACHMENT_READ_BIT                     = 0x00000010,
    VK_ACCESS_SHADER_READ_BIT                               = 0x00000020,
    VK_ACCESS_SHADER_WRITE_BIT                              = 0x00000040,
    VK_ACCESS_COLOR_ATTACHMENT_READ_BIT                     = 0x00000080,
    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT                    = 0x00000100,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT             = 0x00000200,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT            = 0x00000400,
    VK_ACCESS_TRANSFER_READ_BIT                             = 0x00000800,
    VK_ACCESS_TRANSFER_WRITE_BIT                            = 0x00001000,
    VK_ACCESS_HOST_READ_BIT                                 = 0x00002000,
    VK_ACCESS_HOST_WRITE_BIT                                = 0x00004000,
    VK_ACCESS_MEMORY_READ_BIT                               = 0x00008000,
    VK_ACCESS_MEMORY_WRITE_BIT                              = 0x00010000,

    //@extension("VK_NVX_device_generated_commands") // 87
    VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX                  = 0x00020000,
    VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX                 = 0x00040000,

    //@extension("VK_EXT_blend_operation_advanced") // 149
    VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT     = 0x00080000,
}

/// Buffer usage flags
type VkFlags VkBufferUsageFlags
bitfield VkBufferUsageFlagBits {
    VK_BUFFER_USAGE_TRANSFER_SRC_BIT                        = 0x00000001,    /// Can be used as a source of transfer operations
    VK_BUFFER_USAGE_TRANSFER_DST_BIT                        = 0x00000002,    /// Can be used as a destination of transfer operations
    VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT                = 0x00000004,    /// Can be used as TBO
    VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT                = 0x00000008,    /// Can be used as IBO
    VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT                      = 0x00000010,    /// Can be used as UBO
    VK_BUFFER_USAGE_STORAGE_BUFFER_BIT                      = 0x00000020,    /// Can be used as SSBO
    VK_BUFFER_USAGE_INDEX_BUFFER_BIT                        = 0x00000040,    /// Can be used as source of fixed function index fetch (index buffer)
    VK_BUFFER_USAGE_VERTEX_BUFFER_BIT                       = 0x00000080,    /// Can be used as source of fixed function vertex fetch (VBO)
    VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT                     = 0x00000100,    /// Can be the source of indirect parameters (e.g. indirect buffer, parameter buffer)
}

/// Buffer creation flags
type VkFlags VkBufferCreateFlags
bitfield VkBufferCreateFlagBits {
    VK_BUFFER_CREATE_SPARSE_BINDING_BIT                     = 0x00000001,    /// Buffer should support sparse backing
    VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT                   = 0x00000002,    /// Buffer should support sparse backing with partial residency
    VK_BUFFER_CREATE_SPARSE_ALIASED_BIT                     = 0x00000004,    /// Buffer should support constent data access to physical memory blocks mapped into multiple locations of sparse buffers

    //@vulkan1_1
    VK_BUFFER_CREATE_PROTECTED_BIT                          = 0x00000008,
}

/// Shader stage flags
type VkFlags VkShaderStageFlags
bitfield VkShaderStageFlagBits {
    VK_SHADER_STAGE_VERTEX_BIT                              = 0x00000001,
    VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT                = 0x00000002,
    VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT             = 0x00000004,
    VK_SHADER_STAGE_GEOMETRY_BIT                            = 0x00000008,
    VK_SHADER_STAGE_FRAGMENT_BIT                            = 0x00000010,
    VK_SHADER_STAGE_COMPUTE_BIT                             = 0x00000020,
    VK_SHADER_STAGE_ALL_GRAPHICS                            = 0x0000001F,

    VK_SHADER_STAGE_ALL                                     = 0x7FFFFFFF,
}

/// Descriptor pool create flags
type VkFlags VkDescriptorPoolCreateFlags
bitfield VkDescriptorPoolCreateFlagBits {
    VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT       = 0x00000001,
}

/// Descriptor pool reset flags
type VkFlags VkDescriptorPoolResetFlags
//bitfield VkDescriptorPoolResetFlagBits {
//}

/// Image usage flags
type VkFlags VkImageUsageFlags
bitfield VkImageUsageFlagBits {
    VK_IMAGE_USAGE_TRANSFER_SRC_BIT                         = 0x00000001,    /// Can be used as a source of transfer operations
    VK_IMAGE_USAGE_TRANSFER_DST_BIT                         = 0x00000002,    /// Can be used as a destination of transfer operations
    VK_IMAGE_USAGE_SAMPLED_BIT                              = 0x00000004,    /// Can be sampled from (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)
    VK_IMAGE_USAGE_STORAGE_BIT                              = 0x00000008,    /// Can be used as storage image (STORAGE_IMAGE descriptor type)
    VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT                     = 0x00000010,    /// Can be used as framebuffer color attachment
    VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT             = 0x00000020,    /// Can be used as framebuffer depth/stencil attachment
    VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT                 = 0x00000040,    /// Image data not needed outside of rendering
    VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT                     = 0x00000080,    /// Can be used as framebuffer input attachment
}

/// Image creation flags
type VkFlags VkImageCreateFlags
bitfield VkImageCreateFlagBits {
    VK_IMAGE_CREATE_SPARSE_BINDING_BIT                      = 0x00000001,    /// Image should support sparse backing
    VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT                    = 0x00000002,    /// Image should support sparse backing with partial residency
    VK_IMAGE_CREATE_SPARSE_ALIASED_BIT                      = 0x00000004,    /// Image should support constent data access to physical memory blocks mapped into multiple locations of sparse images
    VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT                      = 0x00000008,    /// Allows image views to have different format than the base image
    VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT                     = 0x00000010,    /// Allows creating image views with cube type from the created image

    //@vulkan1_1
    VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT                 = 0x00000020,
    VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT         = 0x00000040,
    VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT         = 0x00000080,
    VK_IMAGE_CREATE_EXTENDED_USAGE_BIT                      = 0x00000100,
    VK_IMAGE_CREATE_DISJOINT_BIT                            = 0x00000200,
    VK_IMAGE_CREATE_ALIAS_BIT                               = 0x00000400,
    VK_IMAGE_CREATE_PROTECTED_BIT                           = 0x00000800,

    //@extension("VK_KHR_maintenance1") // 70
    VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR             = 0x00000020,

    //@extension("VK_KHR_device_group") // 61
    VK_IMAGE_CREATE_BIND_SFR_BIT_KHR                        = 0x00000040,

    //@extension("VK_KHR_maintenance2") // 118
    VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR     = 0x00000080,
    VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR                  = 0x00000100,

    //@extension("VK_KHR_sampler_ycbcr_conversion") // 157
    VK_IMAGE_CREATE_DISJOINT_BIT_KHR                        = 0x00000200,

    //@extension("VK_KHR_bind_memory2") // 158
    VK_IMAGE_CREATE_ALIAS_BIT_KHR                           = 0x00000400,

    //@extension("VK_EXT_sample_locations") // 144
    VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT = 0x00001000,
}

/// Image view creation flags
type VkFlags VkImageViewCreateFlags
//bitfield VkImageViewCreateFlagBits {
//}

/// Pipeline creation flags
type VkFlags VkPipelineCreateFlags
bitfield VkPipelineCreateFlagBits {
    VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT             = 0x00000001,
    VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT                = 0x00000002,
    VK_PIPELINE_CREATE_DERIVATIVE_BIT                       = 0x00000004,

    //@vulkan1_1
    VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT     = 0x00000008,
    VK_PIPELINE_CREATE_DISPATCH_BASE                        = 0x00000010,

    //@extension("VK_KHR_device_group") // 61
    VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR = 0x00000008,
    VK_PIPELINE_CREATE_DISPATCH_BASE_KHR                    = 0x00000010,
}

/// Color component flags
type VkFlags VkColorComponentFlags
bitfield VkColorComponentFlagBits {
    VK_COLOR_COMPONENT_R_BIT                                = 0x00000001,
    VK_COLOR_COMPONENT_G_BIT                                = 0x00000002,
    VK_COLOR_COMPONENT_B_BIT                                = 0x00000004,
    VK_COLOR_COMPONENT_A_BIT                                = 0x00000008,
}

/// Fence creation flags
type VkFlags VkFenceCreateFlags
bitfield VkFenceCreateFlagBits {
    VK_FENCE_CREATE_SIGNALED_BIT                            = 0x00000001,
}

/// Semaphore creation flags
type VkFlags VkSemaphoreCreateFlags
//bitfield VkSemaphoreCreateFlagBits {
//}

/// Format capability flags
type VkFlags VkFormatFeatureFlags
bitfield VkFormatFeatureFlagBits {
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT                     = 0x00000001,    /// Format can be used for sampled images (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)
    VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT                     = 0x00000002,    /// Format can be used for storage images (STORAGE_IMAGE descriptor type)
    VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT              = 0x00000004,    /// Format supports atomic operations in case it's used for storage images
    VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT              = 0x00000008,    /// Format can be used for uniform texel buffers (TBOs)
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT              = 0x00000010,    /// Format can be used for storage texel buffers (IBOs)
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT       = 0x00000020,    /// Format supports atomic operations in case it's used for storage texel buffers
    VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT                     = 0x00000040,    /// Format can be used for vertex buffers (VBOs)
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT                  = 0x00000080,    /// Format can be used for color attachment images
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT            = 0x00000100,    /// Format supports blending in case it's used for color attachment images
    VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT          = 0x00000200,    /// Format can be used for depth/stencil attachment images
    VK_FORMAT_FEATURE_BLIT_SRC_BIT                          = 0x00000400,    /// Format can be used as the source image of blits with vkCommandBlitImage
    VK_FORMAT_FEATURE_BLIT_DST_BIT                          = 0x00000800,    /// Format can be used as the destination image of blits with vkCommandBlitImage
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT       = 0x00001000,

    //@vulkan1_1
    VK_FORMAT_FEATURE_TRANSFER_SRC_BIT                      = 0x00004000,
    VK_FORMAT_FEATURE_TRANSFER_DST_BIT                      = 0x00008000,
    VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT                                                   = 0x00020000,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT                              = 0x00040000,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT             = 0x00080000,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT             = 0x00100000,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT   = 0x00200000,
    VK_FORMAT_FEATURE_DISJOINT_BIT                                                                  = 0x00400000,
    VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT                                                    = 0x00800000,

    //@extension("VK_IMG_filter_cubic") // 16
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG    = 0x00002000,

    //@extension("VK_KHR_maintenance1") // 70
    VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR                  = 0x00004000,
    VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR                  = 0x00008000,

    //@extension("VK_EXT_sampler_filter_minmax") // 131
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT   = 0x00010000,

    //@extension("VK_KHR_sampler_ycbcr_conversion") // 157
    VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR                                                   = 0x00020000,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR                              = 0x00040000,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR             = 0x00080000,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR             = 0x00100000,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR   = 0x00200000,
    VK_FORMAT_FEATURE_DISJOINT_BIT_KHR                                                                  = 0x00400000,
    VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR                                                    = 0x00800000,
}

/// Query control flags
type VkFlags VkQueryControlFlags
bitfield VkQueryControlFlagBits {
    VK_QUERY_CONTROL_PRECISE_BIT                            = 0x00000001,
}

/// Query result flags
type VkFlags VkQueryResultFlags
bitfield VkQueryResultFlagBits {
    VK_QUERY_RESULT_64_BIT                                  = 0x00000001,   /// Results of the queries are written to the destination buffer as 64-bit values
    VK_QUERY_RESULT_WAIT_BIT                                = 0x00000002,   /// Results of the queries are waited on before proceeding with the result copy
    VK_QUERY_RESULT_WITH_AVAILABILITY_BIT                   = 0x00000004,   /// Besides the results of the query, the availability of the results is also written
    VK_QUERY_RESULT_PARTIAL_BIT                             = 0x00000008,   /// Copy the partial results of the query even if the final results aren't available
}

/// Shader module creation flags
type VkFlags VkShaderModuleCreateFlags
//bitfield VkShaderModuleCreateFlagBits {
//}

/// Event creation flags
type VkFlags VkEventCreateFlags
//bitfield VkEventCreateFlagBits {
//}

/// Command buffer usage flags
type VkFlags VkCommandBufferUsageFlags
bitfield VkCommandBufferUsageFlagBits {
    VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT             = 0x00000001,
    VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT        = 0x00000002,
    VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT            = 0x00000004,
}

/// Pipeline statistics flags
type VkFlags VkQueryPipelineStatisticFlags
bitfield VkQueryPipelineStatisticFlagBits {
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT                     = 0x00000001,  /// Optional
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT                   = 0x00000002,  /// Optional
    VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT                   = 0x00000004,  /// Optional
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT                 = 0x00000008,  /// Optional
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT                  = 0x00000010,  /// Optional
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT                        = 0x00000020,  /// Optional
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT                         = 0x00000040,  /// Optional
    VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT                 = 0x00000080,  /// Optional
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT         = 0x00000100,  /// Optional
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT  = 0x00000200,  /// Optional
    VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT                  = 0x00000400,  /// Optional
}

/// Memory mapping flags
type VkFlags VkMemoryMapFlags
//bitfield VkMemoryMapFlagBits {
//}

/// Bitfield of image aspects
type VkFlags VkImageAspectFlags
bitfield VkImageAspectFlagBits {
    VK_IMAGE_ASPECT_COLOR_BIT                               = 0x00000001,
    VK_IMAGE_ASPECT_DEPTH_BIT                               = 0x00000002,
    VK_IMAGE_ASPECT_STENCIL_BIT                             = 0x00000004,
    VK_IMAGE_ASPECT_METADATA_BIT                            = 0x00000008,

    //@vulkan1_1
    VK_IMAGE_ASPECT_PLANE_0_BIT                             = 0x00000010,
    VK_IMAGE_ASPECT_PLANE_1_BIT                             = 0x00000020,
    VK_IMAGE_ASPECT_PLANE_2_BIT                             = 0x00000040,

    //@extension("VK_KHR_sampler_ycbcr_conversion") // 157
    VK_IMAGE_ASPECT_PLANE_0_BIT_KHR                         = 0x00000010,
    VK_IMAGE_ASPECT_PLANE_1_BIT_KHR                         = 0x00000020,
    VK_IMAGE_ASPECT_PLANE_2_BIT_KHR                         = 0x00000040,
}

/// Sparse memory bind flags
type VkFlags VkSparseMemoryBindFlags
bitfield VkSparseMemoryBindFlagBits {
    VK_SPARSE_MEMORY_BIND_METADATA_BIT                      = 0x00000001,
}

/// Sparse image memory requirements flags
type VkFlags VkSparseImageFormatFlags
bitfield VkSparseImageFormatFlagBits {
    VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT                  = 0x00000001,  /// Image uses a single miptail region for all array slices
    VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT                = 0x00000002,  /// Image requires mip levels to be an exact multiple of the sparse iamge block size for non-mip-tail levels.
    VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT          = 0x00000004,  /// Image uses a non-standard sparse block size
}

/// Pipeline stages
type VkFlags VkPipelineStageFlags
bitfield VkPipelineStageFlagBits {
    VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT                       = 0x00000001,  /// Before subsequent commands are processed
    VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT                     = 0x00000002,  /// Draw/DispatchIndirect command fetch
    VK_PIPELINE_STAGE_VERTEX_INPUT_BIT                      = 0x00000004,  /// Vertex/index fetch
    VK_PIPELINE_STAGE_VERTEX_SHADER_BIT                     = 0x00000008,  /// Vertex shading
    VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT       = 0x00000010,  /// Tessellation control shading
    VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT    = 0x00000020,  /// Tessellation evaluation shading
    VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT                   = 0x00000040,  /// Geometry shading
    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT                   = 0x00000080,  /// Fragment shading
    VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT              = 0x00000100,  /// Early fragment (depth/stencil) tests
    VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT               = 0x00000200,  /// Late fragment (depth/stencil) tests
    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT           = 0x00000400,  /// Color attachment writes
    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT                    = 0x00000800,  /// Compute shading
    VK_PIPELINE_STAGE_TRANSFER_BIT                          = 0x00001000,  /// Transfer/copy operations
    VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT                    = 0x00002000,
    VK_PIPELINE_STAGE_HOST_BIT                              = 0x00004000,  /// Indicates host (CPU) is a source/sink of the dependency

    VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT                      = 0x00008000,  /// All stages of the graphics pipeline
    VK_PIPELINE_STAGE_ALL_COMMANDS_BIT                      = 0x00010000,  /// All graphics, compute, copy, and transition commands

    //@extension("VK_NVX_device_generated_commands") // 87
    VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX               = 0x00020000,
}

/// Render pass attachment description flags
type VkFlags VkAttachmentDescriptionFlags
bitfield VkAttachmentDescriptionFlagBits {
    VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT                 = 0x00000001,  /// The attachment may alias physical memory of another attachment in the same renderpass
}

/// Subpass description flags
type VkFlags VkSubpassDescriptionFlags
bitfield VkSubpassDescriptionFlagBits {
    //@extension("VK_NVX_multiview_per_view_attributes") // 98
    VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX      = 0x00000001,
    VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX = 0x00000002,
}

/// Command pool creation flags
type VkFlags VkCommandPoolCreateFlags
bitfield VkCommandPoolCreateFlagBits {
    VK_COMMAND_POOL_CREATE_TRANSIENT_BIT                    = 0x00000001,  /// Command buffers have a short lifetime
    VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT         = 0x00000002,  /// Command buffers may release their memory individually

    //@vulkan1_1
    VK_COMMAND_POOL_CREATE_PROTECTED_BIT                    = 0x00000004,
}

/// Command pool reset flags
type VkFlags VkCommandPoolResetFlags
bitfield VkCommandPoolResetFlagBits {
    VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT             = 0x00000001,  /// Release resources owned by the pool
}

type VkFlags VkCommandBufferResetFlags
bitfield VkCommandBufferResetFlagBits {
    VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT           = 0x00000001,  /// Release resources owned by the buffer
}

type VkFlags VkSampleCountFlags
bitfield VkSampleCountFlagBits {
    VK_SAMPLE_COUNT_1_BIT                                   = 0x00000001,
    VK_SAMPLE_COUNT_2_BIT                                   = 0x00000002,
    VK_SAMPLE_COUNT_4_BIT                                   = 0x00000004,
    VK_SAMPLE_COUNT_8_BIT                                   = 0x00000008,
    VK_SAMPLE_COUNT_16_BIT                                  = 0x00000010,
    VK_SAMPLE_COUNT_32_BIT                                  = 0x00000020,
    VK_SAMPLE_COUNT_64_BIT                                  = 0x00000040,
}

type VkFlags VkStencilFaceFlags
bitfield VkStencilFaceFlagBits {
    VK_STENCIL_FACE_FRONT_BIT                               = 0x00000001,   /// Front face
    VK_STENCIL_FACE_BACK_BIT                                = 0x00000002,   /// Back face
    VK_STENCIL_FRONT_AND_BACK                               = 0x00000003,
}

/// Instance creation flags
type VkFlags VkInstanceCreateFlags
//bitfield VkInstanceCreateFlagBits {
//}

/// Device creation flags
type VkFlags VkDeviceCreateFlags
//bitfield VkDeviceCreateFlagBits {
//}

/// Device queue creation flags
type VkFlags VkDeviceQueueCreateFlags
@vulkan1_1
bitfield VkDeviceQueueCreateFlagBits {
    VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT                    = 0x00000001,
}

/// Query pool creation flags
type VkFlags VkQueryPoolCreateFlags
//bitfield VkQueryPoolCreateFlagBits {
//}

/// Buffer view creation flags
type VkFlags VkBufferViewCreateFlags
//bitfield VkBufferViewCreateFlagBits {
//}

/// Pipeline cache creation flags
type VkFlags VkPipelineCacheCreateFlags
//bitfield VkPipelineCacheCreateFlagBits {
//}

/// Pipeline shader stage creation flags
type VkFlags VkPipelineShaderStageCreateFlags
//bitfield VkPipelineShaderStageCreateFlagBits {
//}

/// Descriptor set layout creation flags
type VkFlags VkDescriptorSetLayoutCreateFlags
bitfield VkDescriptorSetLayoutCreateFlagBits {
    //@extension("VK_KHR_push_descriptor") // 81
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR     = 0x00000001,
}

/// Pipeline vertex input state creation flags
type VkFlags VkPipelineVertexInputStateCreateFlags
//bitfield VkPipelineVertexInputStateCreateFlagBits {
//}

/// Pipeline input assembly state creation flags
type VkFlags VkPipelineInputAssemblyStateCreateFlags
//bitfield VkPipelineInputAssemblyStateCreateFlagBits {
//}

/// Tessellation state creation flags
type VkFlags VkPipelineTessellationStateCreateFlags
//bitfield VkPipelineTessellationStateCreateFlagBits {
//}

/// Viewport state creation flags
type VkFlags VkPipelineViewportStateCreateFlags
//bitfield VkPipelineViewportStateCreateFlagBits {
//}

/// Rasterization state creation flags
type VkFlags VkPipelineRasterizationStateCreateFlags
//bitfield VkPipelineRasterizationStateCreateFlagBits {
//}

/// Multisample state creation flags
type VkFlags VkPipelineMultisampleStateCreateFlags
//bitfield VkPipelineMultisampleStateCreateFlagBits {
//}

/// Color blend state creation flags
type VkFlags VkPipelineColorBlendStateCreateFlags
//bitfield VkPipelineColorBlendStateCreateFlagBits {
//}

/// Depth/stencil state creation flags
type VkFlags VkPipelineDepthStencilStateCreateFlags
//bitfield VkPipelineDepthStencilStateCreateFlagBits {
//}

/// Dynamic state creation flags
type VkFlags VkPipelineDynamicStateCreateFlags
//bitfield VkPipelineDynamicStateCreateFlagBits {
//}

/// Pipeline layout creation flags
type VkFlags VkPipelineLayoutCreateFlags
//bitfield VkPipelineLayoutCreateFlagBits {
//}

/// Sampler creation flags
type VkFlags VkSamplerCreateFlags
//bitfield VkSamplerCreateFlagBits {
//}

/// Render pass creation flags
type VkFlags VkRenderPassCreateFlags
//bitfield VkRenderPassCreateFlagBits {
//}

/// Framebuffer creation flags
type VkFlags VkFramebufferCreateFlags
//bitfield VkFramebufferCreateFlagBits {
//}

/// Dependency flags
type VkFlags VkDependencyFlags
bitfield VkDependencyFlagBits {
    VK_DEPENDENCY_BY_REGION_BIT                             = 0x00000001,

    //@vulkan1_1
    VK_DEPENDENCY_DEVICE_GROUP_BIT                          = 0x00000004,
    VK_DEPENDENCY_VIEW_LOCAL_BIT                            = 0x00000002,

    //@extension("VK_KHR_multiview") // 54
    VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR                        = 0x00000002,

    //@extension("VK_KHR_device_group") // 61
    VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR                      = 0x00000004,
}

/// Cull mode flags
type VkFlags VkCullModeFlags
bitfield VkCullModeFlagBits {
    VK_CULL_MODE_NONE                                       = 0x00000000,
    VK_CULL_MODE_FRONT_BIT                                  = 0x00000001,
    VK_CULL_MODE_BACK_BIT                                   = 0x00000002,
    VK_CULL_MODE_FRONT_AND_BACK                             = 0x00000003,
}

//@vulkan1_1 flags

/// Subgroup feature flags
type VkFlags VkSubgroupFeatureFlags
bitfield VkSubgroupFeatureFlagBits {
    VK_SUBGROUP_FEATURE_BASIC_BIT                           = 0x00000001,
    VK_SUBGROUP_FEATURE_VOTE_BIT                            = 0x00000002,
    VK_SUBGROUP_FEATURE_ARITHMETIC_BIT                      = 0x00000004,
    VK_SUBGROUP_FEATURE_BALLOT_BIT                          = 0x00000008,
    VK_SUBGROUP_FEATURE_SHUFFLE_BIT                         = 0x00000010,
    VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT                = 0x00000020,
    VK_SUBGROUP_FEATURE_CLUSTERED_BIT                       = 0x00000040,
    VK_SUBGROUP_FEATURE_QUAD_BIT                            = 0x00000080,
}

/// Peer memory feature flags
type VkFlags VkPeerMemoryFeatureFlags
bitfield VkPeerMemoryFeatureFlagBits {
    VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT                     = 0x00000001,
    VK_PEER_MEMORY_FEATURE_COPY_DST_BIT                     = 0x00000002,
    VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT                  = 0x00000004,
    VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT                  = 0x00000008,
}

/// Memory allocation flags
type VkFlags VkMemoryAllocateFlags
bitfield VkMemoryAllocateFlagBits {
    VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT                      = 0x00000001,
}

type VkFlags VkCommandPoolTrimFlags
//bitfield VkCommandPoolTrimFlagBits {
//}

type VkFlags VkDescriptorUpdateTemplateCreateFlags
//bitfield VkDescriptorUpdateTemplateCreateFlagBits {
//}

/// External memory handle type flags
type VkFlags VkExternalMemoryHandleTypeFlags
bitfield VkExternalMemoryHandleTypeFlagBits {
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT            = 0x00000001,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT         = 0x00000002,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT     = 0x00000004,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT        = 0x00000008,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT    = 0x00000010,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT           = 0x00000020,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT       = 0x00000040,

    //@extension("VK_EXT_external_memory_host") // 179
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT              = 0x00000080,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT   = 0x00000100,

    //@extension("VK_EXT_external_memory_dma_buf") // 126
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT                      = 0x00000200,

    //@extension("VK_ANDROID_external_memory_android_hardware_buffer") // 130
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID  = 0x00000400,
}

/// External memory feature flags
type VkFlags VkExternalMemoryFeatureFlags
bitfield VkExternalMemoryFeatureFlagBits {
    VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT           = 0x00000001,
    VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT               = 0x00000002,
    VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT               = 0x00000004,
}

/// External fence handle type flags
type VkFlags VkExternalFenceHandleTypeFlags
bitfield VkExternalFenceHandleTypeFlagBits {
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT             = 0x00000001,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT          = 0x00000002,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT      = 0x00000004,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT               = 0x00000008,
}

/// External fence feature flags
type VkFlags VkExternalFenceFeatureFlags
bitfield VkExternalFenceFeatureFlagBits {
    VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT                = 0x00000001,
    VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT                = 0x00000002,
}

/// Fence import flags
type VkFlags VkFenceImportFlags
bitfield VkFenceImportFlagBits {
    VK_FENCE_IMPORT_TEMPORARY_BIT                           = 0x00000001,
}

/// Semaphore import flags
type VkFlags VkSemaphoreImportFlags
bitfield VkSemaphoreImportFlagBits {
    VK_SEMAPHORE_IMPORT_TEMPORARY_BIT                       = 0x00000001,
}

/// External semaphore handle type flags
type VkFlags VkExternalSemaphoreHandleTypeFlags
bitfield VkExternalSemaphoreHandleTypeFlagBits {
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT         = 0x00000001,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT      = 0x00000002,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT  = 0x00000004,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT       = 0x00000008,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT           = 0x00000010,
}

/// External semaphore feature flags
type VkFlags VkExternalSemaphoreFeatureFlags
bitfield VkExternalSemaphoreFeatureFlagBits {
    VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT            = 0x00000001,
    VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT            = 0x00000002,
}

@extension("VK_KHR_surface") // 1
type VkFlags VkSurfaceTransformFlagsKHR
@extension("VK_KHR_surface") // 1
bitfield VkSurfaceTransformFlagBitsKHR {
    VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR                       = 0x00000001,
    VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR                      = 0x00000002,
    VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR                     = 0x00000004,
    VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR                     = 0x00000008,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR              = 0x00000010,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR    = 0x00000020,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR   = 0x00000040,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR   = 0x00000080,
    VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR                        = 0x00000100,
}

@extension("VK_KHR_surface") // 1
type VkFlags VkCompositeAlphaFlagsKHR
@extension("VK_KHR_surface") // 1
bitfield VkCompositeAlphaFlagBitsKHR {
    VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR                       = 0x00000001,
    VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR               = 0x00000002,
    VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR              = 0x00000004,
    VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR                      = 0x00000008,
}

@extension("VK_KHR_swapchain") // 2
type VkFlags VkSwapchainCreateFlagsKHR
@extension("VK_KHR_swapchain") // 2
bitfield VkSwapchainCreateFlagBitsKHR {
    //@vulkan1_1
    VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = 0x00000001,
    VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR                   = 0x00000002,
}

@vulkan1_1
@extension("VK_KHR_swapchain") // 2
type VkFlags VkDeviceGroupPresentModeFlagsKHR
@vulkan1_1
@extension("VK_KHR_swapchain") // 2
bitfield VkDeviceGroupPresentModeFlagBitsKHR {
    VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR              = 0x00000001,
    VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR             = 0x00000002,
    VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR                = 0x00000004,
    VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR = 0x00000008,
}

@extension("VK_KHR_display") // 3
type VkFlags VkDisplayPlaneAlphaFlagsKHR
@extension("VK_KHR_display") // 3
bitfield VkDisplayPlaneAlphaFlagBitsKHR {
    VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR                   = 0x00000001,
    VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR                   = 0x00000002,
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR                = 0x00000004,
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR  = 0x00000008,
}

@extension("VK_KHR_display") // 3
type VkFlags VkDisplaySurfaceCreateFlagsKHR
//@extension("VK_KHR_display") // 3
//bitfield VkDisplaySurfaceCreateFlagBitsKHR {
//}

@extension("VK_KHR_display") // 3
type VkFlags VkDisplayModeCreateFlagsKHR
//@extension("VK_KHR_display") // 3
//bitfield VkDisplayModeCreateFlagBitsKHR {
//}

@extension("VK_KHR_xlib_surface") // 5
type VkFlags VkXlibSurfaceCreateFlagsKHR
//@extension("VK_KHR_xlib_surface") // 5
//bitfield VkXlibSurfaceCreateFlagBitsKHR {
//}

@extension("VK_KHR_xcb_surface") // 6
type VkFlags VkXcbSurfaceCreateFlagsKHR
//@extension("VK_KHR_xcb_surface") // 6
//bitfield VkXcbSurfaceCreateFlagBitsKHR {
//}

@extension("VK_KHR_wayland_surface") // 7
type VkFlags VkWaylandSurfaceCreateFlagsKHR
//@extension("VK_KHR_wayland_surface") // 7
//bitfield VkWaylandSurfaceCreateFlagBitsKHR {
//}

@extension("VK_KHR_mir_surface") // 8
type VkFlags VkMirSurfaceCreateFlagsKHR
//@extension("VK_KHR_mir_surface") // 8
//bitfield VkMirSurfaceCreateFlagBitsKHR {
//}

@extension("VK_KHR_android_surface") // 9
type VkFlags VkAndroidSurfaceCreateFlagsKHR
//@extension("VK_KHR_android_surface") // 9
//bitfield VkAndroidSurfaceCreateFlagBitsKHR {
//}

@extension("VK_KHR_win32_surface") // 10
type VkFlags VkWin32SurfaceCreateFlagsKHR
//@extension("VK_KHR_win32_surface") // 10
//bitfield VkWin32SurfaceCreateFlagBitsKHR {
//}

@extension("VK_ANDROID_native_buffer") // 11
type VkFlags VkSwapchainImageUsageFlagsANDROID
@extension("VK_ANDROID_native_buffer") // 11
bitfield VkSwapchainImageUsageFlagBitsANDROID {
    VK_SWAPCHAIN_IMAGE_USAGE_FLAGS_SHARED_BIT_ANDROID = 0x00000001,
}

@extension("VK_EXT_debug_report") // 12
type VkFlags VkDebugReportFlagsEXT
@extension("VK_EXT_debug_report") // 12
bitfield VkDebugReportFlagBitsEXT {
    VK_DEBUG_REPORT_INFORMATION_BIT_EXT                     = 0x00000001,
    VK_DEBUG_REPORT_WARNING_BIT_EXT                         = 0x00000002,
    VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT             = 0x00000004,
    VK_DEBUG_REPORT_ERROR_BIT_EXT                           = 0x00000008,
    VK_DEBUG_REPORT_DEBUG_BIT_EXT                           = 0x00000010,
}

@extension("VK_NV_external_memory_capabilities") // 56
type VkFlags VkExternalMemoryHandleTypeFlagsNV
@extension("VK_NV_external_memory_capabilities") // 56
bitfield VkExternalMemoryHandleTypeFlagBitsNV {
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV      = 0x00000001,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV  = 0x00000002,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV       = 0x00000004,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV   = 0x00000008,
}

@extension("VK_NV_external_memory_capabilities") // 56
type VkFlags VkExternalMemoryFeatureFlagsNV
@extension("VK_NV_external_memory_capabilities") // 56
bitfield VkExternalMemoryFeatureFlagBitsNV {
    VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV        = 0x00000001,
    VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV            = 0x00000002,
    VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV            = 0x00000004,
}

@extension("VK_KHR_device_group") // 61
type VkFlags VkPeerMemoryFeatureFlagsKHR
@extension("VK_KHR_device_group") // 61
bitfield VkPeerMemoryFeatureFlagBitsKHR {
    VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR                 = 0x00000001,
    VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR                 = 0x00000002,
    VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR              = 0x00000004,
    VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR              = 0x00000008,
}

@extension("VK_KHR_device_group") // 61
type VkFlags VkMemoryAllocateFlagsKHR
@extension("VK_KHR_device_group") // 61
bitfield VkMemoryAllocateFlagBitsKHR {
    VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR                  = 0x00000001,
}

@extension("VK_NN_vi_surface") // 63
type VkFlags VkViSurfaceCreateFlagsNN
//@extension("VK_NN_vi_surface") // 63
//bitfield VkViSurfaceCreateFlagBitsNN {
//}

@extension("VK_KHR_maintenance1") // 70
type VkFlags VkCommandPoolTrimFlagsKHR
//@extension("VK_KHR_maintenance1") // 70
//bitfield VkCommandPoolTrimFlagBitsKHR {
//}

@extension("VK_KHR_external_memory_capabilities") // 72
type VkFlags VkExternalMemoryHandleTypeFlagsKHR
@extension("VK_KHR_external_memory_capabilities") // 72
bitfield VkExternalMemoryHandleTypeFlagBitsKHR {
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR            = 0x00000001,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR         = 0x00000002,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR     = 0x00000004,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR        = 0x00000008,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR    = 0x00000010,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR           = 0x00000020,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR       = 0x00000040,
}

@extension("VK_KHR_external_memory_capabilities") // 72
type VkFlags VkExternalMemoryFeatureFlagsKHR
@extension("VK_KHR_external_memory_capabilities") // 72
bitfield VkExternalMemoryFeatureFlagBitsKHR {
    VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR           = 0x00000001,
    VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR               = 0x00000002,
    VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR               = 0x00000004,
}

@extension("VK_KHR_external_semaphore_capabilities") // 77
type VkFlags VkExternalSemaphoreHandleTypeFlagsKHR
@extension("VK_KHR_external_semaphore_capabilities") // 77
bitfield VkExternalSemaphoreHandleTypeFlagBitsKHR {
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR         = 0x00000001
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR      = 0x00000002
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR  = 0x00000004
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR       = 0x00000008
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_FENCE_FD_BIT_KHR          = 0x00000010
}

@extension("VK_KHR_external_semaphore_capabilities") // 77
type VkFlags VkExternalSemaphoreFeatureFlagsKHR
@extension("VK_KHR_external_semaphore_capabilities") // 77
bitfield VkExternalSemaphoreFeatureFlagBitsKHR {
    VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR            = 0x00000001,
    VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR            = 0x00000002,
}

@extension("VK_KHR_external_semaphore") // 78
type VkFlags VkSemaphoreImportFlagsKHR
@extension("VK_KHR_external_semaphore") // 78
bitfield VkSemaphoreImportFlagBitsKHR {
    VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR                       = 0x00000001,
}

@extension("VK_KHR_descriptor_update_template") // 86
type VkFlags VkDescriptorUpdateTemplateCreateFlagsKHR
//@extension("VK_KHR_descriptor_update_template") // 86
//bitfield VkDescriptorUpdateTemplateCreateFlagBitsKHR {
//}

@extension("VK_NVX_device_generated_commands") // 87
type VkFlags VkIndirectCommandsLayoutUsageFlagsNVX
@extension("VK_NVX_device_generated_commands") // 87
bitfield VkIndirectCommandsLayoutUsageFlagBitsNVX {
    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX   = 0x00000001,
    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX      = 0x00000002,
    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX      = 0x00000004,
    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX     = 0x00000008,
}

@extension("VK_NVX_device_generated_commands") // 87
type VkFlags VkObjectEntryUsageFlagsNVX
@extension("VK_NVX_device_generated_commands") // 87
bitfield VkObjectEntryUsageFlagBitsNVX {
    VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX                  = 0x00000001,
    VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX                   = 0x00000002,
}

@extension("VK_EXT_display_surface_counter") // 91
type VkFlags VkSurfaceCounterFlagsEXT
@extension("VK_EXT_display_surface_counter") // 91
bitfield VkSurfaceCounterFlagBitsEXT {
    VK_SURFACE_COUNTER_VBLANK_EXT                           = 0x00000001,
}

@extension("VK_NV_viewport_swizzle") // 99
type VkFlags VkPipelineViewportSwizzleStateCreateFlagsNV
//@extension("VK_NV_viewport_swizzle") // 99
//bitfield VkPipelineViewportSwizzleStateCreateFlagBitsNV {
//}

@extension("VK_EXT_discard_rectangles") // 100
type VkFlags VkPipelineDiscardRectangleStateCreateFlagsEXT
//@extension("VK_EXT_discard_rectangles") // 100
//bitfield VkPipelineDiscardRectangleStateCreateFlagBitsEXT {
//}

@extension("VK_EXT_conservative_rasterization") // 102
type VkFlags VkPipelineRasterizationConservativeStateCreateFlagsEXT
//@extension("VK_EXT_conservative_rasterization") // 102
//bitfield VkPipelineRasterizationConservativeStateCreateFlagBitsEXT {
//}

@extension("VK_KHR_external_fence_capabilities") // 113
type VkFlags VkExternalFenceHandleTypeFlagsKHR
@extension("VK_KHR_external_fence_capabilities") // 113
bitfield VkExternalFenceHandleTypeFlagBitsKHR {
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR         = 0x00000001,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR      = 0x00000002,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR  = 0x00000004,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR           = 0x00000008,
}

@extension("VK_KHR_external_fence_capabilities") // 113
type VkFlags VkExternalFenceFeatureFlagsKHR
@extension("VK_KHR_external_fence_capabilities") // 113
bitfield VkExternalFenceFeatureFlagBitsKHR {
    VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR            = 0x00000001,
    VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR            = 0x00000002,
}

@extension("VK_KHR_external_fence") // 114
type VkFlags VkFenceImportFlagsKHR
@extension("VK_KHR_external_fence") // 114
bitfield VkFenceImportFlagBitsKHR {
    VK_FENCE_IMPORT_TEMPORARY_BIT_KHR                       = 0x00000001,
}

@extension("VK_MVK_ios_surface") // 123
type VkFlags VkIOSSurfaceCreateFlagsMVK
//@extension("VK_MVK_ios_surface") // 123
//bitfield VkIOSSurfaceCreateFlagBitsMVK {
//}

@extension("VK_MVK_macos_surface") // 124
type VkFlags VkMacOSSurfaceCreateFlagsMVK
//@extension("VK_MVK_macos_surface") // 124
//bitfield VkMacOSSurfaceCreateFlagBitsMVK {
//}

@extension("VK_EXT_debug_utils") // 129
type VkFlags VkDebugUtilsMessengerCallbackDataFlagsEXT
//@extension("VK_EXT_debug_utils") // 129
//bitfield VkDebugUtilsMessengerCallbackDataFlagBitsEXT {
//}

@extension("VK_EXT_debug_utils") // 129
type VkFlags VkDebugUtilsMessengerCreateFlagsEXT
//@extension("VK_EXT_debug_utils") // 129
//bitfield VkDebugUtilsMessengerCreateFlagBitsEXT {
//}

@extension("VK_EXT_debug_utils") // 129
type VkFlags VkDebugUtilsMessageSeverityFlagsEXT
@extension("VK_EXT_debug_utils") // 129
bitfield VkDebugUtilsMessageSeverityFlagBitsEXT {
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT = 0x00000001,
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT    = 0x00000010,
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT = 0x00000100,
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT   = 0x00001000,
}

@extension("VK_EXT_debug_utils") // 129
type VkFlags VkDebugUtilsMessageTypeFlagsEXT
@extension("VK_EXT_debug_utils") // 129
bitfield VkDebugUtilsMessageTypeFlagBitsEXT {
    VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT     = 0x00000001,
    VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT  = 0x00000002,
    VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT = 0x00000004,
}

@extension("VK_NV_fragment_coverage_to_color") // 150
type VkFlags VkPipelineCoverageToColorStateCreateFlagsNV
@extension("VK_NV_fragment_coverage_to_color") // 150
//bitfield VkPipelineCoverageToColorStateCreateFlagBitsNV {
//}

@extension("VK_NV_framebuffer_mixed_samples") // 153
type VkFlags VkPipelineCoverageModulationStateCreateFlagsNV
@extension("VK_NV_framebuffer_mixed_samples") // 153
//bitfield VkPipelineCoverageModulationStateCreateFlagBitsNV {
//}

@extension("VK_EXT_validation_cache") // 161
type VkFlags VkValidationCacheCreateFlagsEXT
@extension("VK_EXT_validation_cache") // 161
//bitfield VkValidationCacheCreateFlagBitsEXT {
//}

//////////////////
//  Structures  //
//////////////////

class VkOffset2D {
    s32                                         x
    s32                                         y
}

class VkOffset3D {
    s32                                         x
    s32                                         y
    s32                                         z
}

class VkExtent2D {
    u32                                         width
    u32                                         height
}

class VkExtent3D {
    u32                                         width
    u32                                         height
    u32                                         depth
}

class VkViewport {
    f32                                         x
    f32                                         y
    f32                                         width
    f32                                         height
    f32                                         minDepth
    f32                                         maxDepth
}

class VkRect2D {
    VkOffset2D                                  offset
    VkExtent2D                                  extent
}

class VkClearRect {
    VkRect2D                                    rect
    u32                                         baseArrayLayer
    u32                                         layerCount
}

class VkComponentMapping {
    VkComponentSwizzle                          r
    VkComponentSwizzle                          g
    VkComponentSwizzle                          b
    VkComponentSwizzle                          a
}

class VkPhysicalDeviceProperties {
    u32                                         apiVersion
    u32                                         driverVersion
    u32                                         vendorID
    u32                                         deviceID
    VkPhysicalDeviceType                        deviceType
    char[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE]      deviceName
    u8[VK_UUID_SIZE]                            pipelineCacheUUID
    VkPhysicalDeviceLimits                      limits
    VkPhysicalDeviceSparseProperties            sparseProperties
}

class VkExtensionProperties {
    char[VK_MAX_EXTENSION_NAME_SIZE]            extensionName      /// extension name
    u32                                         specVersion        /// version of the extension specification implemented
}

class VkLayerProperties {
    char[VK_MAX_EXTENSION_NAME_SIZE]            layerName               /// layer name
    u32                                         specVersion             /// version of the layer specification implemented
    u32                                         implementationVersion   /// build or release version of the layer's library
    char[VK_MAX_DESCRIPTION_SIZE]               description             /// Free-form description of the layer
}

class VkSubmitInfo {
    VkStructureType                             sType              /// Type of structure. Should be VK_STRUCTURE_TYPE_SUBMIT_INFO
    const void*                                 pNext              /// Next structure in chain
    u32                                         waitSemaphoreCount
    const VkSemaphore*                          pWaitSemaphores
    const VkPipelineStageFlags*                 pWaitDstStageMask
    u32                                         commandBufferCount
    const VkCommandBuffer*                      pCommandBuffers
    u32                                         signalSemaphoreCount
    const VkSemaphore*                          pSignalSemaphores
}

class VkApplicationInfo {
    VkStructureType                             sType              /// Type of structure. Should be VK_STRUCTURE_TYPE_APPLICATION_INFO
    const void*                                 pNext              /// Next structure in chain
    const char*                                 pApplicationName
    u32                                         applicationVersion
    const char*                                 pEngineName
    u32                                         engineVersion
    u32                                         apiVersion
}

class VkAllocationCallbacks {
    void*                                       pUserData
    PFN_vkAllocationFunction                    pfnAllocation
    PFN_vkReallocationFunction                  pfnReallocation
    PFN_vkFreeFunction                          pfnFree
    PFN_vkInternalAllocationNotification        pfnInternalAllocation
    PFN_vkInternalFreeNotification              pfnInternalFree
}

class VkDeviceQueueCreateInfo {
    VkStructureType                             sStype                    /// Should be VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO
    const void*                                 pNext                     /// Pointer to next structure
    VkDeviceQueueCreateFlags                    flags
    u32                                         queueFamilyIndex
    u32                                         queueCount
    const f32*                                  pQueuePriorities
}

class VkDeviceCreateInfo {
    VkStructureType                             sType                      /// Should be VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO
    const void*                                 pNext                      /// Pointer to next structure
    VkDeviceCreateFlags                         flags
    u32                                         queueCreateInfoCount
    const VkDeviceQueueCreateInfo*              pQueueCreateInfos
    u32                                         enabledLayerCount
    const char* const*                          ppEnabledLayerNames        /// Ordered list of layer names to be enabled
    u32                                         enabledExtensionCount
    const char* const*                          ppEnabledExtensionNames
    const VkPhysicalDeviceFeatures*             pEnabledFeatures
}

class VkInstanceCreateInfo {
    VkStructureType                             sType                      /// Should be VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO
    const void*                                 pNext                      /// Pointer to next structure
    VkInstanceCreateFlags                       flags
    const VkApplicationInfo*                    pApplicationInfo
    u32                                         enabledLayerCount
    const char* const*                          ppEnabledLayerNames        /// Ordered list of layer names to be enabled
    u32                                         enabledExtensionCount
    const char* const*                          ppEnabledExtensionNames    /// Extension names to be enabled
}

class VkQueueFamilyProperties {
    VkQueueFlags                                queueFlags                 /// Queue flags
    u32                                         queueCount
    u32                                         timestampValidBits
    VkExtent3D                                  minImageTransferGranularity
}

class VkPhysicalDeviceMemoryProperties {
    u32                                         memoryTypeCount
    VkMemoryType[VK_MAX_MEMORY_TYPES]           memoryTypes
    u32                                         memoryHeapCount
    VkMemoryHeap[VK_MAX_MEMORY_HEAPS]           memoryHeaps
}

class VkMemoryAllocateInfo {
    VkStructureType                             sType                      /// Must be VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO
    const void*                                 pNext                      /// Pointer to next structure
    VkDeviceSize                                allocationSize             /// Size of memory allocation
    u32                                         memoryTypeIndex            /// Index of the of the memory type to allocate from
}

class VkMemoryRequirements {
    VkDeviceSize                                size                       /// Specified in bytes
    VkDeviceSize                                alignment                  /// Specified in bytes
    u32                                         memoryTypeBits             /// Bitfield of the allowed memory type indices into memoryTypes[] for this object
}

class VkSparseImageFormatProperties {
    VkImageAspectFlagBits                       aspectMask
    VkExtent3D                                  imageGranularity
    VkSparseImageFormatFlags                    flags
}

class VkSparseImageMemoryRequirements {
    VkSparseImageFormatProperties               formatProperties
    u32                                         imageMipTailFirstLod
    VkDeviceSize                                imageMipTailSize           /// Specified in bytes, must be a multiple of image block size / alignment
    VkDeviceSize                                imageMipTailOffset         /// Specified in bytes, must be a multiple of image block size / alignment
    VkDeviceSize                                imageMipTailStride         /// Specified in bytes, must be a multiple of image block size / alignment
}

class VkMemoryType {
    VkMemoryPropertyFlags                       propertyFlags              /// Memory properties of this memory type
    u32                                         heapIndex                  /// Index of the memory heap allocations of this memory type are taken from
}

class VkMemoryHeap {
    VkDeviceSize                                size                       /// Available memory in the heap
    VkMemoryHeapFlags                           flags                      /// Flags for the heap
}

class VkMappedMemoryRange {
    VkStructureType                             sType                      /// Must be VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE
    const void*                                 pNext                      /// Pointer to next structure
    VkDeviceMemory                              memory                     /// Mapped memory object
    VkDeviceSize                                offset                     /// Offset within the mapped memory the range starts from
    VkDeviceSize                                size                       /// Size of the range within the mapped memory
}

class VkFormatProperties {
    VkFormatFeatureFlags                        linearTilingFeatures       /// Format features in case of linear tiling
    VkFormatFeatureFlags                        optimalTilingFeatures      /// Format features in case of optimal tiling
    VkFormatFeatureFlags                        bufferFeatures             /// Format features supported by buffers
}

class VkImageFormatProperties {
    VkExtent3D                                  maxExtent                  /// max image dimensions for this resource type
    u32                                         maxMipLevels               /// max number of mipmap levels for this resource type
    u32                                         maxArrayLayers             /// max array layers for this resource type
    VkSampleCountFlags                          sampleCounts               /// supported sample counts for this resource type
    VkDeviceSize                                maxResourceSize            /// max size (in bytes) of this resource type
}

class VkDescriptorImageInfo {
    VkSampler                                   sampler
    VkImageView                                 imageView
    VkImageLayout                               imageLayout
}

class VkDescriptorBufferInfo {
    VkBuffer                                    buffer                     /// Buffer used for this descriptor when the descriptor is UNIFORM_BUFFER[_DYNAMIC]
    VkDeviceSize                                offset                     /// Base offset from buffer start in bytes to update in the descriptor set.
    VkDeviceSize                                range                      /// Size in bytes of the buffer resource for this descriptor update.
}

class VkWriteDescriptorSet {
    VkStructureType                             sType                      /// Must be VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET
    const void*                                 pNext                      /// Pointer to next structure
    VkDescriptorSet                             dstSet                     /// Destination descriptor set
    u32                                         dstBinding                 /// Binding within the destination descriptor set to write
    u32                                         dstArrayElement            /// Array element within the destination binding to write
    u32                                         descriptorCount            /// Number of descriptors to write (determines the size of the array pointed by <pDescriptors>)
    VkDescriptorType                            descriptorType             /// Descriptor type to write (determines which fields of the array pointed by <pDescriptors> are going to be used)
    const VkDescriptorImageInfo*                pImageInfo
    const VkDescriptorBufferInfo*               pBufferInfo
    const VkBufferView*                         pTexelBufferView
}

class VkCopyDescriptorSet {
    VkStructureType                             sType                      /// Must be VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET
    const void*                                 pNext                      /// Pointer to next structure
    VkDescriptorSet                             srcSet                     /// Source descriptor set
    u32                                         srcBinding                 /// Binding within the source descriptor set to copy from
    u32                                         srcArrayElement            /// Array element within the source binding to copy from
    VkDescriptorSet                             dstSet                     /// Destination descriptor set
    u32                                         dstBinding                 /// Binding within the destination descriptor set to copy to
    u32                                         dstArrayElement            /// Array element within the destination binding to copy to
    u32                                         descriptorCount            /// Number of descriptors to copy
}

class VkBufferCreateInfo {
    VkStructureType                             sType                      /// Must be VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO
    const void*                                 pNext                      /// Pointer to next structure.
    VkBufferCreateFlags                         flags                      /// Buffer creation flags
    VkDeviceSize                                size                       /// Specified in bytes
    VkBufferUsageFlags                          usage                      /// Buffer usage flags
    VkSharingMode                               sharingMode
    u32                                         queueFamilyIndexCount
    const u32*                                  pQueueFamilyIndices
}

class VkBufferViewCreateInfo {
    VkStructureType                             sType                      /// Must be VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO
    const void*                                 pNext                      /// Pointer to next structure.
    VkBufferViewCreateFlags                     flags
    VkBuffer                                    buffer
    VkFormat                                    format                     /// Optionally specifies format of elements
    VkDeviceSize                                offset                     /// Specified in bytes
    VkDeviceSize                                range                      /// View size specified in bytes
}

class VkImageSubresource {
    VkImageAspectFlagBits                       aspectMask
    u32                                         mipLevel
    u32                                         arrayLayer
}

class VkImageSubresourceRange {
    VkImageAspectFlags                          aspectMask
    u32                                         baseMipLevel
    u32                                         levelCount
    u32                                         baseArrayLayer
    u32                                         layerCount
}

class VkMemoryBarrier {
    VkStructureType                             sType                      /// Must be VK_STRUCTURE_TYPE_MEMORY_BARRIER
    const void*                                 pNext                      /// Pointer to next structure.
    VkAccessFlags                               srcAccessMask
    VkAccessFlags                               dstAccessMask
}

class VkBufferMemoryBarrier {
    VkStructureType                             sType                      /// Must be VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER
    const void*                                 pNext                      /// Pointer to next structure.
    VkAccessFlags                               srcAccessMask
    VkAccessFlags                               dstAccessMask
    u32                                         srcQueueFamilyIndex        /// Queue family to transition ownership from
    u32                                         dstQueueFamilyIndex        /// Queue family to transition ownership to
    VkBuffer                                    buffer                     /// Buffer to sync
    VkDeviceSize                                offset                     /// Offset within the buffer to sync
    VkDeviceSize                                size                       /// Amount of bytes to sync
}

class VkImageMemoryBarrier {
    VkStructureType                             sType                      /// Must be VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER
    const void*                                 pNext                      /// Pointer to next structure.
    VkAccessFlags                               srcAccessMask
    VkAccessFlags                               dstAccessMask
    VkImageLayout                               oldLayout                  /// Current layout of the image
    VkImageLayout                               newLayout                  /// New layout to transition the image to
    u32                                         srcQueueFamilyIndex        /// Queue family to transition ownership from
    u32                                         dstQueueFamilyIndex        /// Queue family to transition ownership to
    VkImage                                     image                      /// Image to sync
    VkImageSubresourceRange                     subresourceRange           /// Subresource range to sync
}

class VkImageCreateInfo {
    VkStructureType                             sType                      /// Must be VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO
    const void*                                 pNext                      /// Pointer to next structure.
    VkImageCreateFlags                          flags                      /// Image creation flags
    VkImageType                                 imageType
    VkFormat                                    format
    VkExtent3D                                  extent
    u32                                         mipLevels
    u32                                         arrayLayers
    VkSampleCountFlagBits                       samples
    VkImageTiling                               tiling
    VkImageUsageFlags                           usage                      /// Image usage flags
    VkSharingMode                               sharingMode                /// Cross-queue-family sharing mode
    u32                                         queueFamilyIndexCount      /// Number of queue families to share across
    const u32*                                  pQueueFamilyIndices        /// Array of queue family indices to share across
    VkImageLayout                               initialLayout              /// Initial image layout for all subresources
}

class VkSubresourceLayout {
    VkDeviceSize                                offset                 /// Specified in bytes
    VkDeviceSize                                size                   /// Specified in bytes
    VkDeviceSize                                rowPitch               /// Specified in bytes
    VkDeviceSize                                arrayPitch             /// Specified in bytes
    VkDeviceSize                                depthPitch             /// Specified in bytes
}

class VkImageViewCreateInfo {
    VkStructureType                             sType                  /// Must be VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO
    const void*                                 pNext                  /// Pointer to next structure
    VkImageViewCreateFlags                      flags
    VkImage                                     image
    VkImageViewType                             viewType
    VkFormat                                    format
    VkComponentMapping                          components
    VkImageSubresourceRange                     subresourceRange
}

class VkBufferCopy {
    VkDeviceSize                                srcOffset              /// Specified in bytes
    VkDeviceSize                                dstOffset              /// Specified in bytes
    VkDeviceSize                                size                   /// Specified in bytes
}

class VkSparseMemoryBind {
    VkDeviceSize                                resourceOffset        /// Specified in bytes
    VkDeviceSize                                size                  /// Specified in bytes
    VkDeviceMemory                              memory
    VkDeviceSize                                memoryOffset          /// Specified in bytes
    VkSparseMemoryBindFlags                     flags
}

class VkSparseImageMemoryBind {
    VkImageSubresource                          subresource
    VkOffset3D                                  offset
    VkExtent3D                                  extent
    VkDeviceMemory                              memory
    VkDeviceSize                                memoryOffset          /// Specified in bytes
    VkSparseMemoryBindFlags                     flags
}

class VkSparseBufferMemoryBindInfo {
    VkBuffer                                    buffer
    u32                                         bindCount
    const VkSparseMemoryBind*                   pBinds
}

class VkSparseImageOpaqueMemoryBindInfo {
    VkImage                                     image
    u32                                         bindCount
    const VkSparseMemoryBind*                   pBinds
}

class VkSparseImageMemoryBindInfo {
    VkImage                                     image
    u32                                         bindCount
    const VkSparseMemoryBind*                   pBinds
}

class VkBindSparseInfo {
    VkStructureType                             sType                 /// Must be VK_STRUCTURE_TYPE_BIND_SPARSE_INFO
    const void*                                 pNext
    u32                                         waitSemaphoreCount
    const VkSemaphore*                          pWaitSemaphores
    u32                                         numBufferBinds
    const VkSparseBufferMemoryBindInfo*         pBufferBinds
    u32                                         numImageOpaqueBinds
    const VkSparseImageOpaqueMemoryBindInfo*    pImageOpaqueBinds
    u32                                         numImageBinds
    const VkSparseImageMemoryBindInfo*          pImageBinds
    u32                                         signalSemaphoreCount
    const VkSemaphore*                          pSignalSemaphores
}

class VkImageSubresourceLayers {
    VkImageAspectFlags                          aspectMask
    u32                                         mipLevel
    u32                                         baseArrayLayer
    u32                                         layerCount
}

class VkImageCopy {
    VkImageSubresourceLayers                    srcSubresource
    VkOffset3D                                  srcOffset             /// Specified in pixels for both compressed and uncompressed images
    VkImageSubresourceLayers                    dstSubresource
    VkOffset3D                                  dstOffset             /// Specified in pixels for both compressed and uncompressed images
    VkExtent3D                                  extent                /// Specified in pixels for both compressed and uncompressed images
}

class VkImageBlit {
    VkImageSubresourceLayers                    srcSubresource
    VkOffset3D[2]                               srcOffsets
    VkImageSubresourceLayers                    dstSubresource
    VkOffset3D[2]                               dstOffsets
}

class VkBufferImageCopy {
    VkDeviceSize                                bufferOffset           /// Specified in bytes
    u32                                         bufferRowLength        /// Specified in texels
    u32                                         bufferImageHeight
    VkImageSubresourceLayers                    imageSubresource
    VkOffset3D                                  imageOffset            /// Specified in pixels for both compressed and uncompressed images
    VkExtent3D                                  imageExtent            /// Specified in pixels for both compressed and uncompressed images
}

class VkImageResolve {
    VkImageSubresourceLayers                    srcSubresource
    VkOffset3D                                  srcOffset
    VkImageSubresourceLayers                    dstSubresource
    VkOffset3D                                  dstOffset
    VkExtent3D                                  extent
}

class VkShaderModuleCreateInfo {
    VkStructureType                             sType                  /// Must be VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO
    const void*                                 pNext                  /// Pointer to next structure
    VkShaderModuleCreateFlags                   flags                  /// Reserved
    platform.size_t                             codeSize               /// Specified in bytes
    const u32*                                  pCode                  /// Binary code of size codeSize
}

class VkDescriptorSetLayoutBinding {
    u32                                         binding
    VkDescriptorType                            descriptorType     /// Type of the descriptors in this binding
    u32                                         descriptorCount    /// Number of descriptors in this binding
    VkShaderStageFlags                          stageFlags         /// Shader stages this binding is visible to
    const VkSampler*                            pImmutableSamplers /// Immutable samplers (used if descriptor type is SAMPLER or COMBINED_IMAGE_SAMPLER, is either NULL or contains <count> number of elements)
}

class VkDescriptorSetLayoutCreateInfo {
    VkStructureType                             sType              /// Must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO
    const void*                                 pNext              /// Pointer to next structure
    VkDescriptorSetLayoutCreateFlags            flags
    u32                                         bindingCount       /// Number of bindings in the descriptor set layout
    const VkDescriptorSetLayoutBinding*         pBindings          /// Array of descriptor set layout bindings
}

class VkDescriptorPoolSize {
    VkDescriptorType                            type
    u32                                         descriptorCount
}

class VkDescriptorPoolCreateInfo {
    VkStructureType                             sType              /// Must be VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO
    const void*                                 pNext              /// Pointer to next structure
    VkDescriptorPoolCreateFlags                 flags
    u32                                         maxSets
    u32                                         poolSizeCount
    const VkDescriptorPoolSize*                 pPoolSizes
}

class VkDescriptorSetAllocateInfo {
    VkStructureType                             sType              /// Must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO
    const void*                                 pNext              /// Pointer to next structure
    VkDescriptorPool                            descriptorPool
    u32                                         setCount
    const VkDescriptorSetLayout*                pSetLayouts
}

class VkSpecializationMapEntry {
    u32                                         constantID         /// The SpecConstant ID specified in the BIL
    u32                                         offset             /// Offset of the value in the data block
    platform.size_t                             size               /// Size in bytes of the SpecConstant
}

class VkSpecializationInfo {
    u32                                         mapEntryCount      /// Number of entries in the map
    const VkSpecializationMapEntry*             pMapEntries        /// Array of map entries
    platform.size_t                             dataSize           /// Size in bytes of pData
    const void*                                 pData              /// Pointer to SpecConstant data
}

class VkPipelineShaderStageCreateInfo {
    VkStructureType                             sType              /// Must be VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO
    const void*                                 pNext              /// Pointer to next structure
    VkPipelineShaderStageCreateFlags            flags
    VkShaderStageFlagBits                       stage
    VkShaderModule                              module
    const char*                                 pName
    const VkSpecializationInfo*                 pSpecializationInfo
}

class VkComputePipelineCreateInfo {
    VkStructureType                             sType              /// Must be VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO
    const void*                                 pNext              /// Pointer to next structure
    VkPipelineCreateFlags                       flags              /// Pipeline creation flags
    VkPipelineShaderStageCreateInfo             stage
    VkPipelineLayout                            layout             /// Interface layout of the pipeline
    VkPipeline                                  basePipelineHandle /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
    s32                                         basePipelineIndex  /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
}

class VkVertexInputBindingDescription {
    u32                                         binding               /// Vertex buffer binding id
    u32                                         stride                /// Distance between vertices in bytes (0 = no advancement)
    VkVertexInputRate                           inputRate             /// Rate at which binding is incremented
}

class VkVertexInputAttributeDescription {
    u32                                         location              /// location of the shader vertex attrib
    u32                                         binding               /// Vertex buffer binding id
    VkFormat                                    format                /// format of source data
    u32                                         offset                /// Offset of first element in bytes from base of vertex
}

class VkPipelineVertexInputStateCreateInfo {
    VkStructureType                             sType                           /// Should be VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO
    const void*                                 pNext                           /// Pointer to next structure
    VkPipelineVertexInputStateCreateFlags       flags
    u32                                         vertexBindingDescriptionCount   /// number of bindings
    const VkVertexInputBindingDescription*      pVertexBindingDescriptions
    u32                                         vertexAttributeDescriptionCount /// number of attributes
    const VkVertexInputAttributeDescription*    pVertexAttributeDescriptions
}

class VkPipelineInputAssemblyStateCreateInfo {
    VkStructureType                             sType      /// Must be VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO
    const void*                                 pNext      /// Pointer to next structure
    VkPipelineInputAssemblyStateCreateFlags     flags
    VkPrimitiveTopology                         topology
    VkBool32                                    primitiveRestartEnable
}

class VkPipelineTessellationStateCreateInfo {
    VkStructureType                             sType      /// Must be VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO
    const void*                                 pNext      /// Pointer to next structure
    VkPipelineTessellationStateCreateFlags      flags
    u32                                         patchControlPoints
}

class VkPipelineViewportStateCreateInfo {
    VkStructureType                             sType      /// Must be VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO
    const void*                                 pNext      /// Pointer to next structure
    VkPipelineViewportStateCreateFlags          flags
    u32                                         viewportCount
    const VkViewport*                           pViewports
    u32                                         scissorCount
    const VkRect2D*                             pScissors
}

class VkPipelineRasterizationStateCreateInfo {
    VkStructureType                             sType      /// Must be VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO
    const void*                                 pNext      /// Pointer to next structure
    VkPipelineRasterizationStateCreateFlags     flags
    VkBool32                                    depthClampEnable
    VkBool32                                    rasterizerDiscardEnable
    VkPolygonMode                               polygonMode                   /// optional (GL45)
    VkCullModeFlags                             cullMode
    VkFrontFace                                 frontFace
    VkBool32                                    depthBiasEnable
    f32                                         depthBiasConstantFactor
    f32                                         depthBiasClamp
    f32                                         depthBiasSlopeFactor
    f32                                         lineWidth
}

class VkPipelineMultisampleStateCreateInfo {
    VkStructureType                             sType      /// Must be VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO
    const void*                                 pNext      /// Pointer to next structure
    VkPipelineMultisampleStateCreateFlags       flags
    VkSampleCountFlagBits                       rasterizationSamples       /// Number of samples used for rasterization
    VkBool32                                    sampleShadingEnable        /// optional (GL45)
    f32                                         minSampleShading           /// optional (GL45)
    const VkSampleMask*                         pSampleMask
    VkBool32                                    alphaToCoverageEnable
    VkBool32                                    alphaToOneEnable
}

class VkPipelineColorBlendAttachmentState {
    VkBool32                                    blendEnable
    VkBlendFactor                               srcColorBlendFactor
    VkBlendFactor                               dstColorBlendFactor
    VkBlendOp                                   colorBlendOp
    VkBlendFactor                               srcAlphaBlendFactor
    VkBlendFactor                               dstAlphaBlendFactor
    VkBlendOp                                   alphaBlendOp
    VkColorComponentFlags                       colorWriteMask
}

class VkPipelineColorBlendStateCreateInfo {
    VkStructureType                             sType      /// Must be VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO
    const void*                                 pNext      /// Pointer to next structure
    VkPipelineColorBlendStateCreateFlags        flags
    VkBool32                                    logicOpEnable
    VkLogicOp                                   logicOp
    u32                                         attachmentCount    /// # of pAttachments
    const VkPipelineColorBlendAttachmentState*  pAttachments
    f32[4]                                      blendConstants
}

class VkStencilOpState {
    VkStencilOp                                 failOp
    VkStencilOp                                 passOp
    VkStencilOp                                 depthFailOp
    VkCompareOp                                 compareOp
    u32                                         compareMask
    u32                                         writeMask
    u32                                         reference
}

class VkPipelineDepthStencilStateCreateInfo {
    VkStructureType                             sType      /// Must be VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO
    const void*                                 pNext      /// Pointer to next structure
    VkPipelineDepthStencilStateCreateFlags      flags
    VkBool32                                    depthTestEnable
    VkBool32                                    depthWriteEnable
    VkCompareOp                                 depthCompareOp
    VkBool32                                    depthBoundsTestEnable  /// optional (depth_bounds_test)
    VkBool32                                    stencilTestEnable
    VkStencilOpState                            front
    VkStencilOpState                            back
    f32                                         minDepthBounds
    f32                                         maxDepthBounds
}

class VkPipelineDynamicStateCreateInfo {
    VkStructureType                             sType      /// Must be VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO
    const void*                                 pNext      /// Pointer to next structure
    VkPipelineDynamicStateCreateFlags           flags
    u32                                         dynamicStateCount
    const VkDynamicState*                       pDynamicStates
}

class VkGraphicsPipelineCreateInfo {
    VkStructureType                                 sType               /// Must be VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO
    const void*                                     pNext               /// Pointer to next structure
    VkPipelineCreateFlags                           flags               /// Pipeline creation flags
    u32                                             stageCount
    const VkPipelineShaderStageCreateInfo*          pStages             /// One entry for each active shader stage
    const VkPipelineVertexInputStateCreateInfo*     pVertexInputState
    const VkPipelineInputAssemblyStateCreateInfo*   pInputAssemblyState
    const VkPipelineTessellationStateCreateInfo*    pTessellationState
    const VkPipelineViewportStateCreateInfo*        pViewportState
    const VkPipelineRasterizationStateCreateInfo*   pRasterizationState
    const VkPipelineMultisampleStateCreateInfo*     pMultisampleState
    const VkPipelineDepthStencilStateCreateInfo*    pDepthStencilState
    const VkPipelineColorBlendStateCreateInfo*      pColorBlendState
    const VkPipelineDynamicStateCreateInfo*         pDynamicState
    VkPipelineLayout                                layout              /// Interface layout of the pipeline
    VkRenderPass                                    renderPass
    u32                                             subpass
    VkPipeline                                      basePipelineHandle  /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
    s32                                             basePipelineIndex   /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
}

class VkPipelineCacheCreateInfo {
    VkStructureType                             sType                 /// Must be VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO
    const void*                                 pNext                 /// Pointer to next structure
    VkPipelineCacheCreateFlags                  flags
    platform.size_t                             initialDataSize       /// Size of initial data to populate cache, in bytes
    const void*                                 pInitialData          /// Initial data to populate cache
}

class VkPushConstantRange {
    VkShaderStageFlags                          stageFlags   /// Which stages use the range
    u32                                         offset       /// Start of the range, in bytes
    u32                                         size        /// Length of the range, in bytes
}

class VkPipelineLayoutCreateInfo {
    VkStructureType                             sType                   /// Must be VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO
    const void*                                 pNext                   /// Pointer to next structure
    VkPipelineLayoutCreateFlags                 flags
    u32                                         descriptorSetCount      /// Number of descriptor sets interfaced by the pipeline
    const VkDescriptorSetLayout*                pSetLayouts             /// Array of <setCount> number of descriptor set layout objects defining the layout of the
    u32                                         pushConstantRangeCount  /// Number of push-constant ranges used by the pipeline
    const VkPushConstantRange*                  pPushConstantRanges     /// Array of pushConstantRangeCount number of ranges used by various shader stages
}

class VkSamplerCreateInfo {
    VkStructureType                             sType          /// Must be VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO
    const void*                                 pNext          /// Pointer to next structure
    VkSamplerCreateFlags                        flags
    VkFilter                                    magFilter      /// Filter mode for magnification
    VkFilter                                    minFilter      /// Filter mode for minifiation
    VkSamplerMipmapMode                         mipmapMode     /// Mipmap selection mode
    VkSamplerAddressMode                        addressModeU
    VkSamplerAddressMode                        addressModeV
    VkSamplerAddressMode                        addressModeW
    f32                                         mipLodBias
    VkBool32                                    anisotropyEnable
    f32                                         maxAnisotropy
    VkBool32                                    compareEnable
    VkCompareOp                                 compareOp
    f32                                         minLod
    f32                                         maxLod
    VkBorderColor                               borderColor
    VkBool32                                    unnormalizedCoordinates
}

class VkCommandPoolCreateInfo {
    VkStructureType                             sType            /// Must be VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO
    const void*                                 pNext            /// Pointer to next structure
    VkCommandPoolCreateFlags                    flags            /// Command pool creation flags
    u32                                         queueFamilyIndex
}

class VkCommandBufferAllocateInfo {
    VkStructureType                             sType      /// Must be VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO
    const void*                                 pNext      /// Pointer to next structure
    VkCommandPool                               commandPool
    VkCommandBufferLevel                        level
    u32                                         commandBufferCount
}

class VkCommandBufferInheritanceInfo {
    VkStructureType                             sType       /// Must be VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO
    const void*                                 pNext       /// Pointer to next structure
    VkRenderPass                                renderPass  /// Render pass for secondary command buffers
    u32                                         subpass
    VkFramebuffer                               framebuffer /// Framebuffer for secondary command buffers
    VkBool32                                    occlusionQueryEnable
    VkQueryControlFlags                         queryFlags
    VkQueryPipelineStatisticFlags               pipelineStatistics
}

class VkCommandBufferBeginInfo {
    VkStructureType                             sType       /// Must be VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO
    const void*                                 pNext       /// Pointer to next structure
    VkCommandBufferUsageFlags                   flags       /// Command buffer usage flags
    const VkCommandBufferInheritanceInfo*       pInheritanceInfo
}

class VkRenderPassBeginInfo {
    VkStructureType                             sType       /// Must be VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO
    const void*                                 pNext       /// Pointer to next structure
    VkRenderPass                                renderPass
    VkFramebuffer                               framebuffer
    VkRect2D                                    renderArea
    u32                                         clearValueCount
    const VkClearValue*                         pClearValues
}

@union
/// Union allowing specification of floating point, integer, or unsigned integer color data. Actual value selected is based on image/attachment being cleared.
class VkClearColorValue {
    f32[4]                                      float32
    s32[4]                                      int32
    u32[4]                                      uint32
}

class VkClearDepthStencilValue {
    f32                                         depth
    u32                                         stencil
}

@union
/// Union allowing specification of color, depth, and stencil color values. Actual value selected is based on attachment being cleared.
class VkClearValue {
    VkClearColorValue                           color
    VkClearDepthStencilValue                    depthStencil
}

class VkClearAttachment {
    VkImageAspectFlags                          aspectMask
    u32                                         colorAttachment
    VkClearValue                                clearValue
}

class VkAttachmentDescription {
    VkAttachmentDescriptionFlags                flags
    VkFormat                                    format
    VkSampleCountFlagBits                       samples
    VkAttachmentLoadOp                          loadOp          /// Load op for color or depth data
    VkAttachmentStoreOp                         storeOp         /// Store op for color or depth data
    VkAttachmentLoadOp                          stencilLoadOp   /// Load op for stencil data
    VkAttachmentStoreOp                         stencilStoreOp  /// Store op for stencil data
    VkImageLayout                               initialLayout
    VkImageLayout                               finalLayout
}

class VkAttachmentReference {
    u32                                         attachment
    VkImageLayout                               layout
}

class VkSubpassDescription {
    VkSubpassDescriptionFlags                   flags
    VkPipelineBindPoint                         pipelineBindPoint  /// Must be VK_PIPELINE_BIND_POINT_GRAPHICS for now
    u32                                         inputAttachmentCount
    const VkAttachmentReference*                pInputAttachments
    u32                                         colorAttachmentCount
    const VkAttachmentReference*                pColorAttachments
    const VkAttachmentReference*                pResolveAttachments
    const VkAttachmentReference*                pDepthStencilAttachment
    u32                                         preserveAttachmentCount
    const u32*                                  pPreserveAttachments
}

class VkSubpassDependency {
    u32                                         srcSubpass
    u32                                         dstSubpass
    VkPipelineStageFlags                        srcStageMask
    VkPipelineStageFlags                        dstStageMask
    VkAccessFlags                               srcAccessMask
    VkAccessFlags                               dstAccessMask
    VkDependencyFlags                           dependencyFlags
}

class VkRenderPassCreateInfo {
    VkStructureType                             sType      /// Must be VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO
    const void*                                 pNext      /// Pointer to next structure
    VkRenderPassCreateFlags                     flags
    u32                                         attachmentCount
    const VkAttachmentDescription*              pAttachments
    u32                                         subpassCount
    const VkSubpassDescription*                 pSubpasses
    u32                                         dependencyCount
    const VkSubpassDependency*                  pDependencies
}

class VkEventCreateInfo {
    VkStructureType                             sType      /// Must be VK_STRUCTURE_TYPE_EVENT_CREATE_INFO
    const void*                                 pNext      /// Pointer to next structure
    VkEventCreateFlags                          flags      /// Event creation flags
}

class VkFenceCreateInfo {
    VkStructureType                             sType      /// Must be VK_STRUCTURE_TYPE_FENCE_CREATE_INFO
    const void*                                 pNext      /// Pointer to next structure
    VkFenceCreateFlags                          flags      /// Fence creation flags
}

class VkPhysicalDeviceFeatures {
    VkBool32                                    robustBufferAccess                        /// out of bounds buffer accesses are well defined
    VkBool32                                    fullDrawIndexUint32                       /// full 32-bit range of indices for indexed draw calls
    VkBool32                                    imageCubeArray                            /// image views which are arrays of cube maps
    VkBool32                                    independentBlend                          /// blending operations are controlled per-attachment
    VkBool32                                    geometryShader                            /// geometry stage
    VkBool32                                    tessellationShader                        /// tessellation control and evaluation stage
    VkBool32                                    sampleRateShading                         /// per-sample shading and interpolation
    VkBool32                                    dualSrcBlend                              /// blend operations which take two sources
    VkBool32                                    logicOp                                   /// logic operations
    VkBool32                                    multiDrawIndirect                         /// multi draw indirect
    VkBool32                                    drawIndirectFirstInstance
    VkBool32                                    depthClamp                                /// depth clamping
    VkBool32                                    depthBiasClamp                            /// depth bias clamping
    VkBool32                                    fillModeNonSolid                          /// point and wireframe fill modes
    VkBool32                                    depthBounds                               /// depth bounds test
    VkBool32                                    wideLines                                 /// lines with width greater than 1
    VkBool32                                    largePoints                               /// points with size greater than 1
    VkBool32                                    alphaToOne                                /// The fragment alpha channel can be forced to maximum representable alpha value
    VkBool32                                    multiViewport
    VkBool32                                    samplerAnisotropy
    VkBool32                                    textureCompressionETC2                    /// ETC texture compression formats
    VkBool32                                    textureCompressionASTC_LDR                /// ASTC LDR texture compression formats
    VkBool32                                    textureCompressionBC                      /// BC1-7 texture compressed formats
    VkBool32                                    occlusionQueryPrecise
    VkBool32                                    pipelineStatisticsQuery                   /// pipeline statistics query
    VkBool32                                    vertexPipelineStoresAndAtomics
    VkBool32                                    fragmentStoresAndAtomics
    VkBool32                                    shaderTessellationAndGeometryPointSize
    VkBool32                                    shaderImageGatherExtended                 /// texture gather with run-time values and independent offsets
    VkBool32                                    shaderStorageImageExtendedFormats         /// the extended set of formats can be used for storage images
    VkBool32                                    shaderStorageImageMultisample             /// multisample images can be used for storage images
    VkBool32                                    shaderStorageImageReadWithoutFormat
    VkBool32                                    shaderStorageImageWriteWithoutFormat
    VkBool32                                    shaderUniformBufferArrayDynamicIndexing   /// arrays of uniform buffers can be accessed with dynamically uniform indices
    VkBool32                                    shaderSampledImageArrayDynamicIndexing    /// arrays of sampled images can be accessed with dynamically uniform indices
    VkBool32                                    shaderStorageBufferArrayDynamicIndexing   /// arrays of storage buffers can be accessed with dynamically uniform indices
    VkBool32                                    shaderStorageImageArrayDynamicIndexing    /// arrays of storage images can be accessed with dynamically uniform indices
    VkBool32                                    shaderClipDistance                        /// clip distance in shaders
    VkBool32                                    shaderCullDistance                        /// cull distance in shaders
    VkBool32                                    shaderFloat64                             /// 64-bit floats (doubles) in shaders
    VkBool32                                    shaderInt64                               /// 64-bit integers in shaders
    VkBool32                                    shaderInt16                               /// 16-bit integers in shaders
    VkBool32                                    shaderResourceResidency                   /// shader can use texture operations that return resource residency information (requires sparseNonResident support)
    VkBool32                                    shaderResourceMinLod                      /// shader can use texture operations that specify minimum resource LOD
    VkBool32                                    sparseBinding                             /// Sparse resources support: Resource memory can be managed at opaque page level rather than object level
    VkBool32                                    sparseResidencyBuffer                     /// Sparse resources support: GPU can access partially resident buffers
    VkBool32                                    sparseResidencyImage2D                    /// Sparse resources support: GPU can access partially resident 2D (non-MSAA non-DepthStencil) images
    VkBool32                                    sparseResidencyImage3D                    /// Sparse resources support: GPU can access partially resident 3D images
    VkBool32                                    sparseResidency2Samples                   /// Sparse resources support: GPU can access partially resident MSAA 2D images with 2 samples
    VkBool32                                    sparseResidency4Samples                   /// Sparse resources support: GPU can access partially resident MSAA 2D images with 4 samples
    VkBool32                                    sparseResidency8Samples                   /// Sparse resources support: GPU can access partially resident MSAA 2D images with 8 samples
    VkBool32                                    sparseResidency16Samples                  /// Sparse resources support: GPU can access partially resident MSAA 2D images with 16 samples
    VkBool32                                    sparseResidencyAliased                    /// Sparse resources support: GPU can correctly access data aliased into multiple locations (opt-in)
    VkBool32                                    variableMultisampleRate
    VkBool32                                    inheritedQueries
}

class VkPhysicalDeviceLimits {
    /// resource maximum sizes
    u32                                         maxImageDimension1D                       /// max 1D image dimension
    u32                                         maxImageDimension2D                       /// max 2D image dimension
    u32                                         maxImageDimension3D                       /// max 3D image dimension
    u32                                         maxImageDimensionCube                     /// max cubemap image dimension
    u32                                         maxImageArrayLayers                       /// max layers for image arrays
    u32                                         maxTexelBufferElements
    u32                                         maxUniformBufferRange                     /// max uniform buffer size (bytes)
    u32                                         maxStorageBufferRange                     /// max storage buffer size (bytes)
    u32                                         maxPushConstantsSize                      /// max size of the push constants pool (bytes)
    /// memory limits
    u32                                         maxMemoryAllocationCount                  /// max number of device memory allocations supported
    u32                                         maxSamplerAllocationCount
    VkDeviceSize                                bufferImageGranularity                    /// Granularity (in bytes) at which buffers and images can be bound to adjacent memory for simultaneous usage
    VkDeviceSize                                sparseAddressSpaceSize                    /// Total address space available for sparse allocations (bytes)
    /// descriptor set limits
    u32                                         maxBoundDescriptorSets                    /// max number of descriptors sets that can be bound to a pipeline
    u32                                         maxPerStageDescriptorSamplers             /// max num of samplers allowed per-stage in a descriptor set
    u32                                         maxPerStageDescriptorUniformBuffers       /// max num of uniform buffers allowed per-stage in a descriptor set
    u32                                         maxPerStageDescriptorStorageBuffers       /// max num of storage buffers allowed per-stage in a descriptor set
    u32                                         maxPerStageDescriptorSampledImages        /// max num of sampled images allowed per-stage in a descriptor set
    u32                                         maxPerStageDescriptorStorageImages        /// max num of storage images allowed per-stage in a descriptor set
    u32                                         maxPerStageDescriptorInputAttachments
    u32                                         maxPerStageResources
    u32                                         maxDescriptorSetSamplers                  /// max num of samplers allowed in all stages in a descriptor set
    u32                                         maxDescriptorSetUniformBuffers            /// max num of uniform buffers allowed in all stages in a descriptor set
    u32                                         maxDescriptorSetUniformBuffersDynamic     /// max num of dynamic uniform buffers allowed in all stages in a descriptor set
    u32                                         maxDescriptorSetStorageBuffers            /// max num of storage buffers allowed in all stages in a descriptor set
    u32                                         maxDescriptorSetStorageBuffersDynamic     /// max num of dynamic storage buffers allowed in all stages in a descriptor set
    u32                                         maxDescriptorSetSampledImages             /// max num of sampled images allowed in all stages in a descriptor set
    u32                                         maxDescriptorSetStorageImages             /// max num of storage images allowed in all stages in a descriptor set
    u32                                         maxDescriptorSetInputAttachments
    /// vertex stage limits
    u32                                         maxVertexInputAttributes                  /// max num of vertex input attribute slots
    u32                                         maxVertexInputBindings                    /// max num of vertex input binding slots
    u32                                         maxVertexInputAttributeOffset             /// max vertex input attribute offset added to vertex buffer offset
    u32                                         maxVertexInputBindingStride               /// max vertex input binding stride
    u32                                         maxVertexOutputComponents                 /// max num of output components written by vertex shader
    /// tessellation control stage limits
    u32                                         maxTessellationGenerationLevel                  /// max level supported by tess primitive generator
    u32                                         maxTessellationPatchSize                        /// max patch size (vertices)
    u32                                         maxTessellationControlPerVertexInputComponents  /// max num of input components per-vertex in TCS
    u32                                         maxTessellationControlPerVertexOutputComponents /// max num of output components per-vertex in TCS
    u32                                         maxTessellationControlPerPatchOutputComponents  /// max num of output components per-patch in TCS
    u32                                         maxTessellationControlTotalOutputComponents     /// max total num of per-vertex and per-patch output components in TCS
    u32                                         maxTessellationEvaluationInputComponents        /// max num of input components per vertex in TES
    u32                                         maxTessellationEvaluationOutputComponents       /// max num of output components per vertex in TES
    /// geometry stage limits
    u32                                         maxGeometryShaderInvocations              /// max invocation count supported in geometry shader
    u32                                         maxGeometryInputComponents                /// max num of input components read in geometry stage
    u32                                         maxGeometryOutputComponents               /// max num of output components written in geometry stage
    u32                                         maxGeometryOutputVertices                 /// max num of vertices that can be emitted in geometry stage
    u32                                         maxGeometryTotalOutputComponents          /// max total num of components (all vertices) written in geometry stage
    /// fragment stage limits
    u32                                         maxFragmentInputComponents                /// max num of input compontents read in fragment stage
    u32                                         maxFragmentOutputAttachments              /// max num of output attachments written in fragment stage
    u32                                         maxFragmentDualSrcAttachments             /// max num of output attachments written when using dual source blending
    u32                                         maxFragmentCombinedOutputResources        /// max total num of storage buffers, storage images and output buffers
    /// compute stage limits
    u32                                         maxComputeSharedMemorySize                /// max total storage size of work group local storage (bytes)
    u32[3]                                      maxComputeWorkGroupCount                  /// max num of compute work groups that may be dispatched by a single command (x,y,z)
    u32                                         maxComputeWorkGroupInvocations            /// max total compute invocations in a single local work group
    u32[3]                                      maxComputeWorkGroupSize                   /// max local size of a compute work group (x,y,z)

    u32                                         subPixelPrecisionBits                     /// num bits of subpixel precision in screen x and y
    u32                                         subTexelPrecisionBits                     /// num bits of subtexel precision
    u32                                         mipmapPrecisionBits                       /// num bits of mipmap precision

    u32                                         maxDrawIndexedIndexValue                  /// max index value for indexed draw calls (for 32-bit indices)
    u32                                         maxDrawIndirectCount

    f32                                         maxSamplerLodBias                         /// max absolute sampler level of detail bias
    f32                                         maxSamplerAnisotropy                      /// max degree of sampler anisotropy

    u32                                         maxViewports                              /// max number of active viewports
    u32[2]                                      maxViewportDimensions                     /// max viewport dimensions (x,y)
    f32[2]                                      viewportBoundsRange                       /// viewport bounds range (min,max)
    u32                                         viewportSubPixelBits                      /// num bits of subpixel precision for viewport

    platform.size_t                             minMemoryMapAlignment                     /// min required alignment of pointers returned by MapMemory (bytes)
    VkDeviceSize                                minTexelBufferOffsetAlignment             /// min required alignment for texel buffer offsets (bytes)
    VkDeviceSize                                minUniformBufferOffsetAlignment           /// min required alignment for uniform buffer sizes and offsets (bytes)
    VkDeviceSize                                minStorageBufferOffsetAlignment           /// min required alignment for storage buffer offsets (bytes)

    s32                                         minTexelOffset                            /// min texel offset for OpTextureSampleOffset
    u32                                         maxTexelOffset                            /// max texel offset for OpTextureSampleOffset
    s32                                         minTexelGatherOffset                      /// min texel offset for OpTextureGatherOffset
    u32                                         maxTexelGatherOffset                      /// max texel offset for OpTextureGatherOffset
    f32                                         minInterpolationOffset                    /// furthest negative offset for interpolateAtOffset
    f32                                         maxInterpolationOffset                    /// furthest positive offset for interpolateAtOffset
    u32                                         subPixelInterpolationOffsetBits           /// num of subpixel bits for interpolateAtOffset

    u32                                         maxFramebufferWidth                       /// max width for a framebuffer
    u32                                         maxFramebufferHeight                      /// max height for a framebuffer
    u32                                         maxFramebufferLayers                      /// max layer count for a layered framebuffer
    VkSampleCountFlags                          framebufferColorSampleCounts
    VkSampleCountFlags                          framebufferDepthSampleCounts
    VkSampleCountFlags                          framebufferStencilSampleCounts
    VkSampleCountFlags                          framebufferNoAttachmentSampleCounts
    u32                                         maxColorAttachments                       /// max num of framebuffer color attachments

    VkSampleCountFlags                          sampledImageColorSampleCounts
    VkSampleCountFlags                          sampledImageIntegerSampleCounts
    VkSampleCountFlags                          sampledImageDepthSampleCounts
    VkSampleCountFlags                          sampledImageStencilSampleCounts
    VkSampleCountFlags                          storageImageSampleCounts
    u32                                         maxSampleMaskWords                        /// max num of sample mask words
    VkBool32                                    timestampComputeAndGraphics

    f32                                         timestampPeriod

    u32                                         maxClipDistances                          /// max number of clip distances
    u32                                         maxCullDistances                          /// max number of cull distances
    u32                                         maxCombinedClipAndCullDistances           /// max combined number of user clipping

    u32                                         discreteQueuePriorities

    f32[2]                                      pointSizeRange                            /// range (min,max) of supported point sizes
    f32[2]                                      lineWidthRange                            /// range (min,max) of supported line widths
    f32                                         pointSizeGranularity                      /// granularity of supported point sizes
    f32                                         lineWidthGranularity                      /// granularity of supported line widths
    VkBool32                                    strictLines
    VkBool32                                    standardSampleLocations

    VkDeviceSize                                optimalBufferCopyOffsetAlignment
    VkDeviceSize                                optimalBufferCopyRowPitchAlignment
    VkDeviceSize                                nonCoherentAtomSize
}

class VkPhysicalDeviceSparseProperties {
    VkBool32                                    residencyStandard2DBlockShape             /// Sparse resources support: GPU will access all 2D (single sample) sparse resources using the standard block shapes (based on pixel format)
    VkBool32                                    residencyStandard2DMultisampleBlockShape  /// Sparse resources support: GPU will access all 2D (multisample) sparse resources using the standard block shapes (based on pixel format)
    VkBool32                                    residencyStandard3DBlockShape             /// Sparse resources support: GPU will access all 3D sparse resources using the standard block shapes (based on pixel format)
    VkBool32                                    residencyAlignedMipSize                   /// Sparse resources support: Images with mip-level dimensions that are NOT a multiple of the block size will be placed in the mip tail
    VkBool32                                    residencyNonResidentStrict                /// Sparse resources support: GPU can safely access non-resident regions of a resource, all reads return as if data is 0, writes are discarded
}

class VkSemaphoreCreateInfo {
    VkStructureType                             sType      /// Must be VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO
    const void*                                 pNext      /// Pointer to next structure
    VkSemaphoreCreateFlags                      flags      /// Semaphore creation flags
}

class VkQueryPoolCreateInfo {
    VkStructureType                             sType              /// Must be VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO
    const void*                                 pNext              /// Pointer to next structure
    VkQueryPoolCreateFlags                      flags
    VkQueryType                                 queryType
    u32                                         queryCount
    VkQueryPipelineStatisticFlags               pipelineStatistics /// Optional
}

class VkFramebufferCreateInfo {
    VkStructureType                             sType  /// Must be VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO
    const void*                                 pNext  /// Pointer to next structure
    VkFramebufferCreateFlags                    flags
    VkRenderPass                                renderPass
    u32                                         attachmentCount
    const VkImageView*                          pAttachments
    u32                                         width
    u32                                         height
    u32                                         layers
}

class VkDrawIndirectCommand {
    u32                                         vertexCount
    u32                                         instanceCount
    u32                                         firstVertex
    u32                                         firstInstance
}

class VkDrawIndexedIndirectCommand {
    u32                                         indexCount
    u32                                         instanceCount
    u32                                         firstIndex
    s32                                         vertexOffset
    u32                                         firstInstance
}

class VkDispatchIndirectCommand {
    u32                                         x
    u32                                         y
    u32                                         z
}

//@vulkan1_1 structures

class VkPhysicalDeviceSubgroupProperties {
    VkStructureType                             sType
    void*                                       pNext
    u32                                         subgroupSize
    VkShaderStageFlags                          supportedStages
    VkSubgroupFeatureFlags                      supportedOperations
    VkBool32                                    quadOperationsInAllStages
}

class VkBindBufferMemoryInfo {
    VkStructureType    sType
    const void*        pNext
    VkBuffer           buffer
    VkDeviceMemory     memory
    VkDeviceSize       memoryOffset
}

class VkBindImageMemoryInfo {
    VkStructureType    sType
    const void*        pNext
    VkImage            image
    VkDeviceMemory     memory
    VkDeviceSize       memoryOffset
}

class VkPhysicalDevice16BitStorageFeatures {
    VkStructureType    sType
    void*              pNext
    VkBool32           storageBuffer16BitAccess
    VkBool32           uniformAndStorageBuffer16BitAccess
    VkBool32           storagePushConstant16
    VkBool32           storageInputOutput16
}

class VkMemoryDedicatedRequirements {
    VkStructureType    sType
    void*              pNext
    VkBool32           prefersDedicatedAllocation
    VkBool32           requiresDedicatedAllocation
}

class VkMemoryDedicatedAllocateInfo {
    VkStructureType    sType
    const void*        pNext
    VkImage            image
    VkBuffer           buffer
}

class VkMemoryAllocateFlagsInfo {
    VkStructureType          sType
    const void*              pNext
    VkMemoryAllocateFlags    flags
    u32                      deviceMask
}

class VkDeviceGroupRenderPassBeginInfo {
    VkStructureType    sType
    const void*        pNext
    u32                deviceMask
    u32                deviceRenderAreaCount
    const VkRect2D*    pDeviceRenderAreas
}

class VkDeviceGroupCommandBufferBeginInfo {
    VkStructureType    sType
    const void*        pNext
    u32                deviceMask
}

class VkDeviceGroupSubmitInfo {
    VkStructureType             sType
    const void*                 pNext
    u32                         waitSemaphoreCount
    const u32*                  pWaitSemaphoreDeviceIndices
    u32                         commandBufferCount
    const u32*                  pCommandBufferDeviceMasks
    u32                         signalSemaphoreCount
    const u32*                  pSignalSemaphoreDeviceIndices
}

class VkDeviceGroupBindSparseInfo {
    VkStructureType    sType
    const void*        pNext
    u32                resourceDeviceIndex
    u32                memoryDeviceIndex
}

class VkBindBufferMemoryDeviceGroupInfo {
    VkStructureType                     sType
    const void*                         pNext
    u32                                 deviceIndexCount
    const u32*                          pDeviceIndices
}

class VkBindImageMemoryDeviceGroupInfo {
    VkStructureType                     sType
    const void*                         pNext
    u32                                 deviceIndexCount
    const u32*                          pDeviceIndices
    u32                                 splitInstanceBindRegionCount
    const VkRect2D*                     pSplitInstanceBindRegions
}

class VkPhysicalDeviceGroupProperties {
    VkStructureType                             sType
    void*                                       pNext
    u32                                         physicalDeviceCount
    VkPhysicalDevice[VK_MAX_DEVICE_GROUP_SIZE]  physicalDevices
    VkBool32                                    subsetAllocation
}

class VkDeviceGroupDeviceCreateInfo {
    VkStructureType            sType
    const void*                pNext
    u32                        physicalDeviceCount
    const VkPhysicalDevice*    pPhysicalDevices
}

class VkBufferMemoryRequirementsInfo2 {
    VkStructureType    sType
    const void*        pNext
    VkBuffer           buffer
}

class VkImageMemoryRequirementsInfo2 {
    VkStructureType    sType
    const void*        pNext
    VkImage            image
}

class VkImageSparseMemoryRequirementsInfo2 {
    VkStructureType    sType
    const void*        pNext
    VkImage            image
}

class VkMemoryRequirements2 {
    VkStructureType         sType
    void*                   pNext
    VkMemoryRequirements    memoryRequirements
}

class VkSparseImageMemoryRequirements2 {
    VkStructureType                    sType
    void*                              pNext
    VkSparseImageMemoryRequirements    memoryRequirements
}

class VkPhysicalDeviceFeatures2 {
    VkStructureType             sType
    void*                       pNext
    VkPhysicalDeviceFeatures    features
}

class VkPhysicalDeviceProperties2 {
    VkStructureType               sType
    void*                         pNext
    VkPhysicalDeviceProperties    properties
}

class VkFormatProperties2 {
    VkStructureType       sType
    void*                 pNext
    VkFormatProperties    formatProperties
}

class VkImageFormatProperties2 {
    VkStructureType            sType
    void*                      pNext
    VkImageFormatProperties    imageFormatProperties
}

class VkPhysicalDeviceImageFormatInfo2 {
    VkStructureType       sType
    const void*           pNext
    VkFormat              format
    VkImageType           type
    VkImageTiling         tiling
    VkImageUsageFlags     usage
    VkImageCreateFlags    flags
}

class VkQueueFamilyProperties2 {
    VkStructureType            sType
    void*                      pNext
    VkQueueFamilyProperties    queueFamilyProperties
}

class VkPhysicalDeviceMemoryProperties2 {
    VkStructureType                     sType
    void*                               pNext
    VkPhysicalDeviceMemoryProperties    memoryProperties
}

class VkSparseImageFormatProperties2 {
    VkStructureType                  sType
    void*                            pNext
    VkSparseImageFormatProperties    properties
}

class VkPhysicalDeviceSparseImageFormatInfo2 {
    VkStructureType          sType
    const void*              pNext
    VkFormat                 format
    VkImageType              type
    VkSampleCountFlagBits    samples
    VkImageUsageFlags        usage
    VkImageTiling            tiling
}

class VkPhysicalDevicePointClippingProperties {
    VkStructureType            sType
    void*                      pNext
    VkPointClippingBehavior    pointClippingBehavior
}

class VkInputAttachmentAspectReference {
    u32                   subpass
    u32                   inputAttachmentIndex
    VkImageAspectFlags    aspectMask
}

class VkRenderPassInputAttachmentAspectCreateInfo {
    VkStructureType                            sType
    const void*                                pNext
    u32                                        aspectReferenceCount
    const VkInputAttachmentAspectReference*    pAspectReferences
}

class VkImageViewUsageCreateInfo {
    VkStructureType      sType
    const void*          pNext
    VkImageUsageFlags    usage
}

class VkPipelineTessellationDomainOriginStateCreateInfo {
    VkStructureType               sType
    const void*                   pNext
    VkTessellationDomainOrigin    domainOrigin
}

class VkRenderPassMultiviewCreateInfo {
    VkStructureType    sType
    const void*        pNext
    u32                subpassCount
    const u32*         pViewMasks
    u32                dependencyCount
    const s32*         pViewOffsets
    u32                correlationMaskCount
    const u32*         pCorrelationMasks
}

class VkPhysicalDeviceMultiviewFeatures {
    VkStructureType    sType
    void*              pNext
    VkBool32           multiview
    VkBool32           multiviewGeometryShader
    VkBool32           multiviewTessellationShader
}

class VkPhysicalDeviceMultiviewProperties {
    VkStructureType    sType
    void*              pNext
    u32                maxMultiviewViewCount
    u32                maxMultiviewInstanceIndex
}

class VkPhysicalDeviceVariablePointerFeatures {
    VkStructureType    sType
    void*              pNext
    VkBool32           variablePointersStorageBuffer
    VkBool32           variablePointers
}

class VkPhysicalDeviceProtectedMemoryFeatures {
    VkStructureType    sType
    void*              pNext
    VkBool32           protectedMemory
}

class VkPhysicalDeviceProtectedMemoryProperties {
    VkStructureType    sType
    void*              pNext
    VkBool32           protectedNoFault
}

class VkDeviceQueueInfo2 {
    VkStructureType             sType
    const void*                 pNext
    VkDeviceQueueCreateFlags    flags
    u32                         queueFamilyIndex
    u32                         queueIndex
}

class VkProtectedSubmitInfo {
    VkStructureType    sType
    const void*        pNext
    VkBool32           protectedSubmit
}

class VkSamplerYcbcrConversionCreateInfo {
    VkStructureType                  sType
    const void*                      pNext
    VkFormat                         format
    VkSamplerYcbcrModelConversion    ycbcrModel
    VkSamplerYcbcrRange              ycbcrRange
    VkComponentMapping               components
    VkChromaLocation                 xChromaOffset
    VkChromaLocation                 yChromaOffset
    VkFilter                         chromaFilter
    VkBool32                         forceExplicitReconstruction
}

class VkSamplerYcbcrConversionInfo {
    VkStructureType             sType
    const void*                 pNext
    VkSamplerYcbcrConversion    conversion
}

class VkBindImagePlaneMemoryInfo {
    VkStructureType          sType
    const void*              pNext
    VkImageAspectFlagBits    planeAspect
}

class VkImagePlaneMemoryRequirementsInfo {
    VkStructureType          sType
    const void*              pNext
    VkImageAspectFlagBits    planeAspect
}

class VkPhysicalDeviceSamplerYcbcrConversionFeatures {
    VkStructureType    sType
    void*              pNext
    VkBool32           samplerYcbcrConversion
}

class VkSamplerYcbcrConversionImageFormatProperties {
    VkStructureType    sType
    void*              pNext
    u32                combinedImageSamplerDescriptorCount
}

class VkDescriptorUpdateTemplateEntry {
    u32                                 dstBinding
    u32                                 dstArrayElement
    u32                                 descriptorCount
    VkDescriptorType                    descriptorType
    platform.size_t                     offset
    platform.size_t                     stride
}

class VkDescriptorUpdateTemplateCreateInfo {
    VkStructureType                           sType
    void*                                     pNext
    VkDescriptorUpdateTemplateCreateFlags     flags
    u32                                       descriptorUpdateEntryCount
    const VkDescriptorUpdateTemplateEntry*    pDescriptorUpdateEntries
    VkDescriptorUpdateTemplateType            templateType
    VkDescriptorSetLayout                     descriptorSetLayout
    VkPipelineBindPoint                       pipelineBindPoint
    VkPipelineLayout                          pipelineLayout
    u32                                       set
}

class VkExternalMemoryProperties {
    VkExternalMemoryFeatureFlags       externalMemoryFeatures
    VkExternalMemoryHandleTypeFlags    exportFromImportedHandleTypes
    VkExternalMemoryHandleTypeFlags    compatibleHandleTypes
}

class VkPhysicalDeviceExternalImageFormatInfo {
    VkStructureType                       sType
    const void*                           pNext
    VkExternalMemoryHandleTypeFlagBits    handleType
}

class VkExternalImageFormatProperties {
    VkStructureType               sType
    void*                         pNext
    VkExternalMemoryProperties    externalMemoryProperties
}

class VkPhysicalDeviceExternalBufferInfo {
    VkStructureType                       sType
    const void*                           pNext
    VkBufferCreateFlags                   flags
    VkBufferUsageFlags                    usage
    VkExternalMemoryHandleTypeFlagBits    handleType
}

class VkExternalBufferProperties {
    VkStructureType               sType
    void*                         pNext
    VkExternalMemoryProperties    externalMemoryProperties
}

class VkPhysicalDeviceIDProperties {
    VkStructureType    sType
    void*              pNext
    u8[VK_UUID_SIZE]   deviceUUID
    u8[VK_UUID_SIZE]   driverUUID
    u8[VK_LUID_SIZE]   deviceLUID
    u32                deviceNodeMask
    VkBool32           deviceLUIDValid
}

class VkExternalMemoryImageCreateInfo {
    VkStructureType                    sType
    const void*                        pNext
    VkExternalMemoryHandleTypeFlags    handleTypes
}

class VkExternalMemoryBufferCreateInfo {
    VkStructureType                    sType
    const void*                        pNext
    VkExternalMemoryHandleTypeFlags    handleTypes
}

class VkExportMemoryAllocateInfo {
    VkStructureType                    sType
    const void*                        pNext
    VkExternalMemoryHandleTypeFlags    handleTypes
}

class VkPhysicalDeviceExternalFenceInfo {
    VkStructureType                      sType
    const void*                          pNext
    VkExternalFenceHandleTypeFlagBits    handleType
}

class VkExternalFenceProperties {
    VkStructureType                   sType
    void*                             pNext
    VkExternalFenceHandleTypeFlags    exportFromImportedHandleTypes
    VkExternalFenceHandleTypeFlags    compatibleHandleTypes
    VkExternalFenceFeatureFlags       externalFenceFeatures
}

class VkExportFenceCreateInfo {
    VkStructureType                   sType
    const void*                       pNext
    VkExternalFenceHandleTypeFlags    handleTypes
}

class VkExportSemaphoreCreateInfo {
    VkStructureType                       sType
    const void*                           pNext
    VkExternalSemaphoreHandleTypeFlags    handleTypes
}

class VkPhysicalDeviceExternalSemaphoreInfo {
    VkStructureType                          sType
    const void*                              pNext
    VkExternalSemaphoreHandleTypeFlagBits    handleType
}

class VkExternalSemaphoreProperties {
    VkStructureType                       sType
    void*                                 pNext
    VkExternalSemaphoreHandleTypeFlags    exportFromImportedHandleTypes
    VkExternalSemaphoreHandleTypeFlags    compatibleHandleTypes
    VkExternalSemaphoreFeatureFlags       externalSemaphoreFeatures
}

class VkPhysicalDeviceMaintenance3Properties {
    VkStructureType    sType
    void*              pNext
    u32                maxPerSetDescriptors
    VkDeviceSize       maxMemoryAllocationSize
}

class VkDescriptorSetLayoutSupport {
    VkStructureType    sType
    void*              pNext
    VkBool32           supported
}

class VkPhysicalDeviceShaderDrawParameterFeatures {
    VkStructureType    sType
    void*              pNext
    VkBool32           shaderDrawParameters
}


@extension("VK_KHR_surface") // 1
class VkSurfaceCapabilitiesKHR {
    u32                                         minImageCount
    u32                                         maxImageCount
    VkExtent2D                                  currentExtent
    VkExtent2D                                  minImageExtent
    VkExtent2D                                  maxImageExtent
    u32                                         maxImageArrayLayers
    VkSurfaceTransformFlagsKHR                  supportedTransforms
    VkSurfaceTransformFlagBitsKHR               currentTransform
    VkCompositeAlphaFlagsKHR                    supportedCompositeAlpha
    VkImageUsageFlags                           supportedUsageFlags
}

@extension("VK_KHR_surface") // 1
class VkSurfaceFormatKHR {
    VkFormat                                    format
    VkColorSpaceKHR                             colorSpace
}

@extension("VK_KHR_swapchain") // 2
class VkSwapchainCreateInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    VkSwapchainCreateFlagsKHR                   flags
    VkSurfaceKHR                                surface
    u32                                         minImageCount
    VkFormat                                    imageFormat
    VkColorSpaceKHR                             imageColorSpace
    VkExtent2D                                  imageExtent
    u32                                         imageArrayLayers
    VkImageUsageFlags                           imageUsage
    VkSharingMode                               sharingMode
    u32                                         queueFamilyIndexCount
    const u32*                                  pQueueFamilyIndices
    VkSurfaceTransformFlagBitsKHR               preTransform
    VkCompositeAlphaFlagBitsKHR                 compositeAlpha
    VkPresentModeKHR                            presentMode
    VkBool32                                    clipped
    VkSwapchainKHR                              oldSwapchain
}

@extension("VK_KHR_swapchain") // 2
class VkPresentInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    u32                                         waitSemaphoreCount
    const VkSemaphore*                          pWaitSemaphores
    u32                                         swapchainCount
    const VkSwapchainKHR*                       pSwapchains
    const u32*                                  pImageIndices
    VkResult*                                   pResults
}

@vulkan1_1
@extension("VK_KHR_swapchain") // 2
class VkImageSwapchainCreateInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    VkSwapchainKHR                              swapchain
}

@vulkan1_1
@extension("VK_KHR_swapchain") // 2
class VkBindImageMemorySwapchainInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    VkSwapchainKHR                              swapchain
    u32                                         imageIndex
}

@vulkan1_1
@extension("VK_KHR_swapchain") // 2
class VkAcquireNextImageInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    VkSwapchainKHR                              swapchain
    u64                                         timeout
    VkSemaphore                                 semaphore
    VkFence                                     fence
    u32                                         deviceMask
}

@vulkan1_1
@extension("VK_KHR_swapchain") // 2
class VkDeviceGroupPresentCapabilitiesKHR {
    VkStructureType                             sType
    const void*                                 pNext
    u32[VK_MAX_DEVICE_GROUP_SIZE]               presentMask
    VkDeviceGroupPresentModeFlagsKHR            modes
}

@vulkan1_1
@extension("VK_KHR_swapchain") // 2
class VkDeviceGroupPresentInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    u32                                         swapchainCount
    const u32*                                  pDeviceMasks
    VkDeviceGroupPresentModeFlagBitsKHR         mode
}

@vulkan1_1
@extension("VK_KHR_swapchain") // 2
class VkDeviceGroupSwapchainCreateInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    VkDeviceGroupPresentModeFlagsKHR            modes
}

@extension("VK_KHR_display") // 3
class VkDisplayPropertiesKHR {
    VkDisplayKHR                                display
    const char*                                 displayName
    VkExtent2D                                  physicalDimensions
    VkExtent2D                                  physicalResolution
    VkSurfaceTransformFlagsKHR                  supportedTransforms
    VkBool32                                    planeReorderPossible
    VkBool32                                    persistentContent
}

@extension("VK_KHR_display") // 3
class VkDisplayModeParametersKHR {
    VkExtent2D                                  visibleRegion
    u32                                         refreshRate
}

@extension("VK_KHR_display") // 3
class VkDisplayModePropertiesKHR {
    VkDisplayModeKHR                            displayMode
    VkDisplayModeParametersKHR                  parameters
}

@extension("VK_KHR_display") // 3
class VkDisplayModeCreateInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    VkDisplayModeCreateFlagsKHR                 flags
    VkDisplayModeParametersKHR                  parameters
}

@extension("VK_KHR_display") // 3
class VkDisplayPlanePropertiesKHR {
    VkDisplayKHR                                currentDisplay
    u32                                         currentStackIndex
}

@extension("VK_KHR_display") // 3
class VkDisplayPlaneCapabilitiesKHR {
    VkDisplayPlaneAlphaFlagsKHR                 supportedAlpha
    VkOffset2D                                  minSrcPosition
    VkOffset2D                                  maxSrcPosition
    VkExtent2D                                  minSrcExtent
    VkExtent2D                                  maxSrcExtent
    VkOffset2D                                  minDstPosition
    VkOffset2D                                  maxDstPosition
    VkExtent2D                                  minDstExtent
    VkExtent2D                                  maxDstExtent
}

@extension("VK_KHR_display") // 3
class VkDisplaySurfaceCreateInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    VkDisplaySurfaceCreateFlagsKHR              flags
    VkDisplayModeKHR                            displayMode
    u32                                         planeIndex
    u32                                         planeStackIndex
    VkSurfaceTransformFlagBitsKHR               transform
    f32                                         globalAlpha
    VkDisplayPlaneAlphaFlagBitsKHR              alphaMode
    VkExtent2D                                  imageExtent
}

@extension("VK_KHR_display_swapchain") // 4
class VkDisplayPresentInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    VkRect2D                                    srcRect
    VkRect2D                                    dstRect
    VkBool32                                    persistent
}

@extension("VK_KHR_xlib_surface") // 5
class VkXlibSurfaceCreateInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    VkXlibSurfaceCreateFlagsKHR                 flags
    platform.Display*                           dpy
    platform.Window                             window
}

@extension("VK_KHR_xcb_surface") // 6
class VkXcbSurfaceCreateInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    VkXcbSurfaceCreateFlagsKHR                  flags
    platform.xcb_connection_t*                  connection
    platform.xcb_window_t                       window
}

@extension("VK_KHR_wayland_surface") // 7
class VkWaylandSurfaceCreateInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    VkWaylandSurfaceCreateFlagsKHR              flags
    platform.wl_display*                        display
    platform.wl_surface*                        surface
}

@extension("VK_KHR_mir_surface") // 8
class VkMirSurfaceCreateInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    VkMirSurfaceCreateFlagsKHR                  flags
    platform.MirConnection*                     connection
    platform.MirSurface*                        mirSurface
}

@extension("VK_KHR_android_surface") // 9
class VkAndroidSurfaceCreateInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    VkAndroidSurfaceCreateFlagsKHR              flags
    platform.ANativeWindow*                     window
}

@extension("VK_KHR_win32_surface") // 10
class VkWin32SurfaceCreateInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    VkWin32SurfaceCreateFlagsKHR                flags
    platform.HINSTANCE                          hinstance
    platform.HWND                               hwnd
}

@extension("VK_ANDROID_native_buffer") // 11
@internal class Gralloc1Usage {
    u64                                         consumer
    u64                                         producer
}

@extension("VK_ANDROID_native_buffer") // 11
class VkNativeBufferANDROID {
    VkStructureType                             sType
    const void*                                 pNext
    platform.buffer_handle_t                    handle
    s32                                         stride
    s32                                         format
    s32                                         usage
    Gralloc1Usage                               usage2
}

@extension("VK_ANDROID_native_buffer") // 11
class VkSwapchainImageCreateInfoANDROID {
    VkStructureType                             sType
    const void*                                 pNext
    VkSwapchainImageUsageFlagsANDROID           flags
}

@extension("VK_ANDROID_native_buffer") // 11
class VkPhysicalDevicePresentationPropertiesANDROID {
    VkStructureType                             sType
    void*                                       pNext
    VkBool32                                    sharedImage
}

@extension("VK_EXT_debug_report") // 12
class VkDebugReportCallbackCreateInfoEXT {
    VkStructureType                             sType
    const void*                                 pNext
    VkDebugReportFlagsEXT                       flags
    PFN_vkDebugReportCallbackEXT                pfnCallback
    void*                                       pUserData
}

@extension("VK_AMD_rasterization_order") // 19
class VkPipelineRasterizationStateRasterizationOrderAMD {
    VkStructureType                             sType
    const void*                                 pNext
    VkRasterizationOrderAMD                     rasterizationOrder
}

@extension("VK_EXT_debug_marker") // 23
class VkDebugMarkerObjectNameInfoEXT {
    VkStructureType                             sType
    const void*                                 pNext
    VkDebugReportObjectTypeEXT                  objectType
    u64                                         object
    const char*                                 pObjectName
}

@extension("VK_EXT_debug_marker") // 23
class VkDebugMarkerObjectTagInfoEXT {
    VkStructureType                             sType
    const void*                                 pNext
    VkDebugReportObjectTypeEXT                  objectType
    u64                                         object
    u64                                         tagName
    platform.size_t                             tagSize
    const void*                                 pTag
}

@extension("VK_EXT_debug_marker") // 23
class VkDebugMarkerMarkerInfoEXT {
    VkStructureType                             sType
    const void*                                 pNext
    const char*                                 pMarkerName
    f32[4]                                      color
}

@extension("VK_NV_dedicated_allocation") // 27
class VkDedicatedAllocationImageCreateInfoNV {
    VkStructureType                             sType
    const void*                                 pNext
    VkBool32                                    dedicatedAllocation
}

@extension("VK_NV_dedicated_allocation") // 27
class VkDedicatedAllocationBufferCreateInfoNV {
    VkStructureType                             sType
    const void*                                 pNext
    VkBool32                                    dedicatedAllocation
}

@extension("VK_NV_dedicated_allocation") // 27
class VkDedicatedAllocationMemoryAllocateInfoNV {
    VkStructureType                             sType
    const void*                                 pNext
    VkImage                                     image
    VkBuffer                                    buffer
}

@extension("VK_AMD_texture_gather_bias_lod") // 42
class VkTextureLODGatherFormatPropertiesAMD {
    VkStructureType                             sType
    void*                                       pNext
    VkBool32                                    supportsTextureGatherLODBiasAMD
}

@extension("VK_AMD_shader_info") // 43
class VkShaderResourceUsageAMD {
    u32                                         numUsedVgprs
    u32                                         numUsedSgprs
    u32                                         ldsSizePerLocalWorkGroup
    platform.size_t                             ldsUsageSizeInBytes
    platform.size_t                             scratchMemUsageInBytes
}

@extension("VK_AMD_shader_info") // 43
class VkShaderStatisticsInfoAMD {
    VkShaderStageFlags                          shaderStageMask
    VkShaderResourceUsageAMD                    resourceUsage
    u32                                         numPhysicalVgprs
    u32                                         numPhysicalSgprs
    u32                                         numAvailableVgprs
    u32                                         numAvailableSgprs
    u32[3]                                      computeWorkGroupSize
}

@extension("VK_KHR_multiview") // 54
class VkRenderPassMultiviewCreateInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    u32                                         subpassCount
    const u32*                                  pViewMasks
    u32                                         dependencyCount
    const s32*                                  pViewOffsets
    u32                                         correlationMaskCount
    const u32*                                  pCorrelationMasks
}

@extension("VK_KHR_multiview") // 54
class VkPhysicalDeviceMultiviewFeaturesKHR {
    VkStructureType                             sType
    void*                                       pNext
    VkBool32                                    multiview
    VkBool32                                    multiviewGeometryShader
    VkBool32                                    multiviewTessellationShader
}

@extension("VK_KHR_multiview") // 54
class VkPhysicalDeviceMultiviewPropertiesKHR {
    VkStructureType                             sType
    void*                                       pNext
    u32                                         maxMultiviewViewCount
    u32                                         maxMultiviewInstanceIndex
}

@extension("VK_NV_external_memory_capabilities") // 56
class VkExternalImageFormatPropertiesNV {
    VkImageFormatProperties                     imageFormatProperties
    VkExternalMemoryFeatureFlagsNV              externalMemoryFeatures
    VkExternalMemoryHandleTypeFlagsNV           exportFromImportedHandleTypes
    VkExternalMemoryHandleTypeFlagsNV           compatibleHandleTypes
}

@extension("VK_NV_external_memory") // 57
class VkExternalMemoryImageCreateInfoNV {
    VkStructureType                             sType
    const void*                                 pNext
    VkExternalMemoryHandleTypeFlagsNV           handleTypes
}

@extension("VK_NV_external_memory") // 57
class VkExportMemoryAllocateInfoNV {
    VkStructureType                             sType
    const void*                                 pNext
    VkExternalMemoryHandleTypeFlagsNV           handleTypes
}

@extension("VK_NV_external_memory_win32") // 58
class VkImportMemoryWin32HandleInfoNV {
    VkStructureType                             sType
    const void*                                 pNext
    VkExternalMemoryHandleTypeFlagsNV           handleType
    platform.HANDLE                             handle
}

@extension("VK_NV_external_memory_win32") // 58
class VkExportMemoryWin32HandleInfoNV {
    VkStructureType                             sType
    const void*                                 pNext
    const platform.SECURITY_ATTRIBUTES*         pAttributes
    platform.DWORD                              dwAccess
}

@extension("VK_NV_win32_keyed_mutex") // 59
class VkWin32KeyedMutexAcquireReleaseInfoNV {
    VkStructureType                             sType
    const void*                                 pNext
    u32                                         acquireCount
    const VkDeviceMemory*                       pAcquireSyncs
    const u64*                                  pAcquireKeys
    const u32*                                  pAcquireTimeoutMilliseconds
    u32                                         releaseCount
    const VkDeviceMemory*                       pReleaseSyncs
    const u64*                                  pReleaseKeys
}

@extension("VK_KHR_get_physical_device_properties2") // 60
class VkPhysicalDeviceFeatures2KHR {
    VkStructureType                             sType
    void*                                       pNext
    VkPhysicalDeviceFeatures                    features
}

@extension("VK_KHR_get_physical_device_properties2") // 60
class VkPhysicalDeviceProperties2KHR {
    VkStructureType                             sType
    void*                                       pNext
    VkPhysicalDeviceProperties                  properties
}

@extension("VK_KHR_get_physical_device_properties2") // 60
class VkFormatProperties2KHR {
    VkStructureType                             sType
    void*                                       pNext
    VkFormatProperties                          formatProperties
}

@extension("VK_KHR_get_physical_device_properties2") // 60
class VkImageFormatProperties2KHR {
    VkStructureType                             sType
    void*                                       pNext
    VkImageFormatProperties                     imageFormatProperties
}

@extension("VK_KHR_get_physical_device_properties2") // 60
class VkPhysicalDeviceImageFormatInfo2KHR {
    VkStructureType                             sType
    const void*                                 pNext
    VkFormat                                    format
    VkImageType                                 type
    VkImageTiling                               tiling
    VkImageUsageFlags                           usage
    VkImageCreateFlags                          flags
}

@extension("VK_KHR_get_physical_device_properties2") // 60
class VkQueueFamilyProperties2KHR {
    VkStructureType                             sType
    void*                                       pNext
    VkQueueFamilyProperties                     queueFamilyProperties
}

@extension("VK_KHR_get_physical_device_properties2") // 60
class VkPhysicalDeviceMemoryProperties2KHR {
    VkStructureType                             sType
    void*                                       pNext
    VkPhysicalDeviceMemoryProperties            memoryProperties
}

@extension("VK_KHR_get_physical_device_properties2") // 60
class VkSparseImageFormatProperties2KHR {
    VkStructureType                             sType
    void*                                       pNext
    VkSparseImageFormatProperties               properties
}

@extension("VK_KHR_get_physical_device_properties2") // 60
class VkPhysicalDeviceSparseImageFormatInfo2KHR {
    VkStructureType                             sType
    const void*                                 pNext
    VkFormat                                    format
    VkImageType                                 type
    VkSampleCountFlagBits                       samples
    VkImageUsageFlags                           usage
    VkImageTiling                               tiling
}

@extension("VK_KHR_device_group") // 61
class VkMemoryAllocateFlagsInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    VkMemoryAllocateFlagsKHR                    flags
    u32                                         deviceMask
}

@extension("VK_KHR_device_group") // 61
class VkBindBufferMemoryDeviceGroupInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    u32                                         deviceIndexCount
    const u32*                                  pDeviceIndices
}

@extension("VK_KHR_device_group") // 61
class VkBindImageMemoryDeviceGroupInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    u32                                         deviceIndexCount
    const u32*                                  pDeviceIndices
    u32                                         SFRRectCount
    const VkRect2D*                             pSFRRects
}

@extension("VK_KHR_device_group") // 61
class VkDeviceGroupRenderPassBeginInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    u32                                         deviceMask
    u32                                         deviceRenderAreaCount
    const VkRect2D*                             pDeviceRenderAreas
}

@extension("VK_KHR_device_group") // 61
class VkDeviceGroupCommandBufferBeginInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    u32                                         deviceMask
}

@extension("VK_KHR_device_group") // 61
class VkDeviceGroupSubmitInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    u32                                         waitSemaphoreCount
    const u32*                                  pWaitSemaphoreDeviceIndices
    u32                                         commandBufferCount
    const u32*                                  pCommandBufferDeviceMasks
    u32                                         signalSemaphoreCount
    const u32*                                  pSignalSemaphoreDeviceIndices
}

@extension("VK_KHR_device_group") // 61
class VkDeviceGroupBindSparseInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    u32                                         resourceDeviceIndex
    u32                                         memoryDeviceIndex
}

@extension("VK_EXT_validation_flags") // 62
class VkValidationFlagsEXT {
    VkStructureType                             sType
    const void*                                 pNext
    u32                                         disabledValidationCheckCount
    VkValidationCheckEXT*                       pDisabledValidationChecks
}

@extension("VK_NN_vi_surface") // 63
class VkViSurfaceCreateInfoNN {
    VkStructureType                             sType
    const void*                                 pNext
    VkViSurfaceCreateFlagsNN                    flags
    void*                                       window
}

@extension("VK_KHR_device_group_creation") // 71
class VkPhysicalDeviceGroupPropertiesKHR {
    VkStructureType                                 sType
    void*                                           pNext
    u32                                             physicalDeviceCount
    VkPhysicalDevice[VK_MAX_DEVICE_GROUP_SIZE]      physicalDevices
    VkBool32                                        subsetAllocation
}

@extension("VK_KHR_device_group_creation") // 71
class VkDeviceGroupDeviceCreateInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    u32                                         physicalDeviceCount
    const VkPhysicalDevice*                     pPhysicalDevices
}

@extension("VK_KHR_external_memory_capabilities") // 72
class VkExternalMemoryPropertiesKHR {
    VkExternalMemoryFeatureFlagsKHR             externalMemoryFeatures
    VkExternalMemoryHandleTypeFlagsKHR          exportFromImportedHandleTypes
    VkExternalMemoryHandleTypeFlagsKHR          compatibleHandleTypes
}

@extension("VK_KHR_external_memory_capabilities") // 72
class VkPhysicalDeviceExternalImageFormatInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    VkExternalMemoryHandleTypeFlagBitsKHR       handleType
}

@extension("VK_KHR_external_memory_capabilities") // 72
class VkExternalImageFormatPropertiesKHR {
    VkStructureType                             sType
    void*                                       pNext
    VkExternalMemoryPropertiesKHR               externalMemoryProperties
}

@extension("VK_KHR_external_memory_capabilities") // 72
class VkPhysicalDeviceExternalBufferInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    VkBufferCreateFlags                         flags
    VkBufferUsageFlags                          usage
    VkExternalMemoryHandleTypeFlagBitsKHR       handleType
}

@extension("VK_KHR_external_memory_capabilities") // 72
class VkExternalBufferPropertiesKHR {
    VkStructureType                             sType
    void*                                       pNext
    VkExternalMemoryPropertiesKHR               externalMemoryProperties
}

@extension("VK_KHR_external_memory_capabilities") // 72
class VkPhysicalDeviceIDPropertiesKHR {
    VkStructureType                             sType
    void*                                       pNext
    u8[VK_UUID_SIZE]                            deviceUUID
    u8[VK_UUID_SIZE]                            driverUUID
    u8[VK_LUID_SIZE]                            deviceLUID
    u32                                         deviceNodeMask
    VkBool32                                    deviceLUIDValid
}

@extension("VK_KHR_external_memory") // 73
class VkExternalMemoryImageCreateInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    VkExternalMemoryHandleTypeFlagsKHR          handleTypes
}

@extension("VK_KHR_external_memory") // 73
class VkExternalMemoryBufferCreateInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    VkExternalMemoryHandleTypeFlagsKHR          handleTypes
}

@extension("VK_KHR_external_memory") // 73
class VkExportMemoryAllocateInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    VkExternalMemoryHandleTypeFlagsKHR          handleTypes
}

@extension("VK_KHR_external_memory_win32") // 74
class VkImportMemoryWin32HandleInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    VkExternalMemoryHandleTypeFlagBitsKHR       handleType
    platform.HANDLE                             handle
    platform.LPCWSTR                            name
}

@extension("VK_KHR_external_memory_win32") // 74
class VkExportMemoryWin32HandleInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    const platform.SECURITY_ATTRIBUTES*         pAttributes
    platform.DWORD                              dwAccess
    platform.LPCWSTR                            name
}

@extension("VK_KHR_external_memory_win32") // 74
class VkMemoryWin32HandlePropertiesKHR {
    VkStructureType                             sType
    void*                                       pNext
    u32                                         memoryTypeBits
}

@extension("VK_KHR_external_memory_win32") // 74
class VkMemoryGetWin32HandleInfoKHR {
    VkStructureType                             sType
    void*                                       pNext
    VkDeviceMemory                              memory
    VkExternalMemoryHandleTypeFlagBitsKHR       handleType
}

@extension("VK_KHR_external_memory_fd") // 75
class VkImportMemoryFdInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    VkExternalMemoryHandleTypeFlagBitsKHR       handleType
    int                                         fd
}

@extension("VK_KHR_external_memory_fd") // 75
class VkMemoryFdPropertiesKHR {
    VkStructureType                             sType
    void*                                       pNext
    u32                                         memoryTypeBits
}

@extension("VK_KHR_external_memory_fd") // 75
class VkMemoryGetFdInfoKHR {
    VkStructureType                             sType
    void*                                       pNext
    VkDeviceMemory                              memory
    VkExternalMemoryHandleTypeFlagBitsKHR       handleType
}

@extension("VK_KHR_win32_keyed_mutex") // 76
class VkWin32KeyedMutexAcquireReleaseInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    u32                                         acquireCount
    const VkDeviceMemory*                       pAcquireSyncs
    const u64*                                  pAcquireKeys
    const u32*                                  pAcquireTimeouts
    u32                                         releaseCount
    const VkDeviceMemory*                       pReleaseSyncs
    const u64*                                  pReleaseKeys
}

@extension("VK_KHR_external_semaphore_capabilities") // 77
class VkPhysicalDeviceExternalSemaphoreInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    VkExternalSemaphoreHandleTypeFlagBitsKHR    handleType
}

@extension("VK_KHR_external_semaphore_capabilities") // 77
class VkExternalSemaphorePropertiesKHR {
    VkStructureType                             sType
    void*                                       pNext
    VkExternalSemaphoreHandleTypeFlagsKHR       exportFromImportedHandleTypes
    VkExternalSemaphoreHandleTypeFlagsKHR       compatibleHandleTypes
    VkExternalSemaphoreFeatureFlagsKHR          externalSemaphoreFeatures
}

@extension("VK_KHR_external_semaphore") // 78
class VkExportSemaphoreCreateInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    VkExternalSemaphoreHandleTypeFlagsKHR       handleTypes
}

@extension("VK_KHR_external_semaphore_win32") // 79
class VkImportSemaphoreWin32HandleInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    VkSemaphore                                 semaphore
    VkSemaphoreImportFlagsKHR                   flags
    VkExternalSemaphoreHandleTypeFlagsKHR       handleType
    platform.HANDLE                             handle
    platform.LPCWSTR                            name
}

@extension("VK_KHR_external_semaphore_win32") // 79
class VkExportSemaphoreWin32HandleInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    const platform.SECURITY_ATTRIBUTES*         pAttributes
    platform.DWORD                              dwAccess
    platform.LPCWSTR                            name
}

@extension("VK_KHR_external_semaphore_win32") // 79
class VkD3D12FenceSubmitInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    u32                                         waitSemaphoreValuesCount
    const u64*                                  pWaitSemaphoreValues
    u32                                         signalSemaphoreValuesCount
    const u64*                                  pSignalSemaphoreValues
}

@extension("VK_KHR_external_semaphore_win32") // 79
class VkSemaphoreGetWin32HandleInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    VkSemaphore                                 semaphore
    VkExternalSemaphoreHandleTypeFlagBitsKHR    handleType
}

@extension("VK_KHR_external_semaphore_fd") // 80
class VkImportSemaphoreFdInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    VkSemaphore                                 semaphore
    VkSemaphoreImportFlagsKHR                   flags
    VkExternalSemaphoreHandleTypeFlagBitsKHR    handleType
    s32                                         fd
}

@extension("VK_KHR_external_semaphore_fd") // 80
class VkSemaphoreGetFdInfoKHR {
    VkStructureType                             sType
    const void*                                 pNext
    VkSemaphore                                 semaphore
    VkExternalSemaphoreHandleTypeFlagBitsKHR    handleType
}

@extension("VK_KHR_push_descriptor") // 81
class VkPhysicalDevicePushDescriptorPropertiesKHR {
    VkStructureType                             sType
    void*                                       pNext
    u32                                         maxPushDescriptors
}

@extension("VK_KHR_16bit_storage") // 84
class VkPhysicalDevice16BitStorageFeaturesKHR {
    VkStructureType                             sType
    void*                                       pNext
    VkBool32                                    storageBuffer16BitAccess
    VkBool32                                    uniformAndStorageBuffer16BitAccess
    VkBool32                                    storagePushConstant16
    VkBool32                                    storageInputOutput16
}

@extension("VK_KHR_incremental_present") // 85
class VkRectLayerKHR {
    VkOffset2D                                  offset
    VkExtent2D                                  extent
    u32                                         layer
}

@extension("VK_KHR_incremental_present") // 85
class VkPresentRegionKHR {
    u32                                         rectangleCount
    const VkRectLayerKHR*                       pRectangles
}

@extension("VK_KHR_incremental_present") // 85
class VkPresentRegionsKHR {
    VkStructureType                             sType
    const void*                                 pNext
    u32                                         swapchainCount
    const VkPresentRegionKHR*                   pRegions
}

@extension("VK_KHR_descriptor_update_template") // 86
class VkDescriptorUpdateTemplateEntryKHR {
    u32                                         dstBinding
    u32                                         dstArrayElement
    u32                                         descriptorCount
    VkDescriptorType                            descriptorType
    platform.size_t                             offset
    platform.size_t                             stride
}

@extension("VK_KHR_descriptor_update_template") // 86
class VkDescriptorUpdateTemplateCreateInfoKHR {
    VkStructureType                              sType
    void*                                        pNext
    VkDescriptorUpdateTemplateCreateFlagsKHR     flags
    u32                                          descriptorUpdateEntryCount
    const VkDescriptorUpdateTemplateEntryKHR*    pDescriptorUpdateEntries
    VkDescriptorUpdateTemplateTypeKHR            templateType
    VkDescriptorSetLayout                        descriptorSetLayout
    VkPipelineBindPoint                          pipelineBindPoint
    VkPipelineLayout                             pipelineLayout
    u32                                          set
}

@extension("VK_NVX_device_generated_commands") // 87
class VkDeviceGeneratedCommandsFeaturesNVX {
    VkStructureType                             sType
    const void*                                 pNext
    VkBool32                                    computeBindingPointSupport
}

@extension("VK_NVX_device_generated_commands") // 87
class VkDeviceGeneratedCommandsLimitsNVX {
    VkStructureType                             sType
    const void*                                 pNext
    u32                                         maxIndirectCommandsLayoutTokenCount
    u32                                         maxObjectEntryCounts
    u32                                         minSequenceCountBufferOffsetAlignment
    u32                                         minSequenceIndexBufferOffsetAlignment
    u32                                         minCommandsTokenBufferOffsetAlignment
}

@extension("VK_NVX_device_generated_commands") // 87
class VkIndirectCommandsTokenNVX {
    VkIndirectCommandsTokenTypeNVX              tokenType
    VkBuffer                                    buffer
    VkDeviceSize                                offset
}

@extension("VK_NVX_device_generated_commands") // 87
class VkIndirectCommandsLayoutTokenNVX {
    VkIndirectCommandsTokenTypeNVX              tokenType
    u32                                         bindingUnit
    u32                                         dynamicCount
    u32                                         divisor
}

@extension("VK_NVX_device_generated_commands") // 87
class VkIndirectCommandsLayoutCreateInfoNVX {
    VkStructureType                             sType
    const void*                                 pNext
    VkPipelineBindPoint                         pipelineBindPoint
    VkIndirectCommandsLayoutUsageFlagsNVX       flags
    u32                                         tokenCount
    const VkIndirectCommandsLayoutTokenNVX*     pTokens
}

@extension("VK_NVX_device_generated_commands") // 87
class VkCmdProcessCommandsInfoNVX {
    VkStructureType                             sType
    const void*                                 pNext
    VkObjectTableNVX                            objectTable
    VkIndirectCommandsLayoutNVX                 indirectCommandsLayout
    u32                                         indirectCommandsTokenCount
    const VkIndirectCommandsTokenNVX*           pIndirectCommandsTokens
    u32                                         maxSequencesCount
    VkCommandBuffer                             targetCommandBuffer
    VkBuffer                                    sequencesCountBuffer
    VkDeviceSize                                sequencesCountOffset
    VkBuffer                                    sequencesIndexBuffer
    VkDeviceSize                                sequencesIndexOffset
}

@extension("VK_NVX_device_generated_commands") // 87
class VkCmdReserveSpaceForCommandsInfoNVX {
    VkStructureType                             sType
    const void*                                 pNext
    VkObjectTableNVX                            objectTable
    VkIndirectCommandsLayoutNVX                 indirectCommandsLayout
    u32                                         maxSequencesCount
}

@extension("VK_NVX_device_generated_commands") // 87
class VkObjectTableCreateInfoNVX {
    VkStructureType                             sType
    const void*                                 pNext
    u32                                         objectCount
    const VkObjectEntryTypeNVX*                 pObjectEntryTypes
    const u32*                                  pObjectEntryCounts
    const VkObjectEntryUsageFlagsNVX*           pObjectEntryUsageFlags
    u32                                         maxUniformBuffersPerDescriptor
    u32                                         maxStorageBuffersPerDescriptor
    u32                                         maxStorageImagesPerDescriptor
    u32                                         maxSampledImagesPerDescriptor
    u32                                         maxPipelineLayouts
}

@extension("VK_NVX_device_generated_commands") // 87
class VkObjectTableEntryNVX {
    VkObjectEntryTypeNVX                        type
    VkObjectEntryUsageFlagsNVX                  flags
}

@extension("VK_NVX_device_generated_commands") // 87
class VkObjectTablePipelineEntryNVX {
    VkObjectEntryTypeNVX                        type
    VkObjectEntryUsageFlagsNVX                  flags
    VkPipeline                                  pipeline
}

@extension("VK_NVX_device_generated_commands") // 87
class VkObjectTableDescriptorSetEntryNVX {
    VkObjectEntryTypeNVX                        type
    VkObjectEntryUsageFlagsNVX                  flags
    VkPipelineLayout                            pipelineLayout
    VkDescriptorSet                             descriptorSet
}

@extension("VK_NVX_device_generated_commands") // 87
class VkObjectTableVertexBufferEntryNVX {
    VkObjectEntryTypeNVX                        type
    VkObjectEntryUsageFlagsNVX                  flags
    VkBuffer                                    buffer
}

@extension("VK_NVX_device_generated_commands") // 87
class VkObjectTableIndexBufferEntryNVX {
    VkObjectEntryTypeNVX                        type
    VkObjectEntryUsageFlagsNVX                  flags
    VkBuffer                                    buffer
    VkIndexType                                 indexType
}

@extension("VK_NVX_device_generated_commands") // 87
class VkObjectTablePushConstantEntryNVX {
    VkObjectEntryTypeNVX                        type
    VkObjectEntryUsageFlagsNVX                  flags
    VkPipelineLayout                            pipelineLayout
    VkShaderStageFlags                          stageFlags
}

@extension("VK_NV_clip_space_w_scaling") // 88
class VkViewportWScalingNV {
    f32                                         xcoeff
    f32                                         ycoeff
}

@extension("VK_NV_clip_space_w_scaling") // 88
class VkPipelineViewportWScalingStateCreateInfoNV {
    VkStructureType                             sType
    const void*                                 pNext
    VkBool32                                    viewportWScalingEnable
    u32                                         viewportCount
    const VkViewportWScalingNV*                 pViewportWScalings
}

@extension("VK_EXT_display_surface_counter") // 91
class VkSurfaceCapabilities2EXT {
    VkStructureType                             sType
    void*                                       pNext
    u32                                         minImageCount
    u32                                         maxImageCount
    VkExtent2D                                  currentExtent
    VkExtent2D                                  minImageExtent
    VkExtent2D                                  maxImageExtent
    u32                                         maxImageArrayLayers
    VkSurfaceTransformFlagsKHR                  supportedTransforms
    VkSurfaceTransformFlagBitsKHR               currentTransform
    VkCompositeAlphaFlagsKHR                    supportedCompositeAlpha
    VkImageUsageFlags                           supportedUsageFlags
    VkSurfaceCounterFlagsEXT                    supportedSurfaceCounters
}

@extension("VK_EXT_display_control") // 92
class VkDisplayPowerInfoEXT {
    VkStructureType                             sType
    const void*                                 pNext
    VkDisplayPowerStateEXT                      powerState
}

@extension("VK_EXT_display_control") // 92
class VkDeviceEventInfoEXT {
    VkStructureType                             sType
    const void*                                 pNext
    VkDeviceEventTypeEXT                        deviceEvent
}

@extension("VK_EXT_display_control") // 92
class VkDisplayEventInfoEXT {
    VkStructureType                             sType
    const void*                                 pNext
    VkDisplayEventTypeEXT                       displayEvent
}

@extension("VK_EXT_display_control") // 92
class VkSwapchainCounterCreateInfoEXT {
    VkStructureType                             sType
    const void*                                 pNext
    VkSurfaceCounterFlagsEXT                    surfaceCounters
}

@extension("VK_GOOGLE_display_timing") // 93
class VkRefreshCycleDurationGOOGLE {
    u64                                             refreshDuration
}

@extension("VK_GOOGLE_display_timing") // 93
class VkPastPresentationTimingGOOGLE {
    u32                                             presentID
    u64                                             desiredPresentTime
    u64                                             actualPresentTime
    u64                                             earliestPresentTime
    u64                                             presentMargin
}

@extension("VK_GOOGLE_display_timing") // 93
class VkPresentTimeGOOGLE {
    u32                                             presentID
    u64                                             desiredPresentTime
}

@extension("VK_GOOGLE_display_timing") // 93
class VkPresentTimesInfoGOOGLE {
    VkStructureType                                 sType
    const void*                                     pNext
    u32                                             swapchainCount
    const VkPresentTimeGOOGLE*                      pTimes
}

@extension("VK_NVX_multiview_per_view_attributes") // 98
class VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
    VkStructureType                             sType
    void*                                       pNext
    VkBool32                                    perViewPositionAllComponents
}

@extension("VK_NV_viewport_swizzle") // 99
class VkViewportSwizzleNV {
    VkViewportCoordinateSwizzleNV               x
    VkViewportCoordinateSwizzleNV               y
    VkViewportCoordinateSwizzleNV               z
    VkViewportCoordinateSwizzleNV               w
}

@extension("VK_NV_viewport_swizzle") // 99
class VkPipelineViewportSwizzleStateCreateInfoNV {
    VkStructureType                             sType
    const void*                                 pNext
    VkPipelineViewportSwizzleStateCreateFlagsNV flags
    u32                                         viewportCount
    const VkViewportSwizzleNV*                  pViewportSwizzles
}

@extension("VK_EXT_discard_rectangles") // 100
class VkPhysicalDeviceDiscardRectanglePropertiesEXT {
    VkStructureType                             sType
    void*                                       pNext
    u32                                         maxDiscardRectangles
}

@extension("VK_EXT_discard_rectangles") // 100
class VkPipelineDiscardRectangleStateCreateInfoEXT {
    VkStructureType                                 sType
    const void*                                     pNext
    VkPipelineDiscardRectangleStateCreateFlagsEXT   flags
    VkDiscardRectangleModeEXT                       discardRectangleMode
    u32                                             discardRectangleCount
    const VkRect2D*                                 pDiscardRectangles
}

@extension("VK_EXT_conservative_rasterization") // 102
class VkPhysicalDeviceConservativeRasterizationPropertiesEXT {
    VkStructureType                                 sType
    void*                                           pNext
    f32                                             primitiveOverestimationSize
    f32                                             maxExtraPrimitiveOverestimationSize
    f32                                             extraPrimitiveOverestimationSizeGranularity
    VkBool32                                        primitiveUnderestimation
    VkBool32                                        conservativePointAndLineRasterization
    VkBool32                                        degenerateTrianglesRasterized
    VkBool32                                        degenerateLinesRasterized
    VkBool32                                        fullyCoveredFragmentShaderInputVariable
    VkBool32                                        conservativeRasterizationPostDepthCoverage
}

@extension("VK_EXT_conservative_rasterization") // 102
class VkPipelineRasterizationConservativeStateCreateInfoEXT {
    VkStructureType                                           sType
    const void*                                               pNext
    VkPipelineRasterizationConservativeStateCreateFlagsEXT    flags
    VkConservativeRasterizationModeEXT                        conservativeRasterizationMode
    f32                                                       extraPrimitiveOverestimationSize
}

@extension("VK_EXT_hdr_metadata") // 106
class VkXYColorEXT {
    f32                                             x
    f32                                             y
}

@extension("VK_EXT_hdr_metadata") // 106
class VkHdrMetadataEXT {
    VkStructureType                                 sType
    const void*                                     pNext
    VkXYColorEXT                                    displayPrimaryRed
    VkXYColorEXT                                    displayPrimaryGreen
    VkXYColorEXT                                    displayPrimaryBlue
    VkXYColorEXT                                    whitePoint
    f32                                             maxLuminance
    f32                                             minLuminance
    f32                                             maxContentLightLevel
    f32                                             maxFrameAverageLightLevel
}

@extension("VK_KHR_shared_presentable_image") // 112
class VkSharedPresentSurfaceCapabilitiesKHR {
    VkStructureType                                 sType
    const void*                                     pNext
    VkImageUsageFlags                               sharedPresentSupportedUsageFlags
}

@extension("VK_KHR_external_fence_capabilities") // 113
class VkPhysicalDeviceExternalFenceInfoKHR {
    VkStructureType                                 sType
    const void*                                     pNext
    VkExternalFenceHandleTypeFlagBitsKHR            handleType
}

@extension("VK_KHR_external_fence_capabilities") // 113
class VkExternalFencePropertiesKHR {
    VkStructureType                                 sType
    void*                                           pNext
    VkExternalFenceHandleTypeFlagsKHR               exportFromImportedHandleTypes
    VkExternalFenceHandleTypeFlagsKHR               compatibleHandleTypes
    VkExternalFenceFeatureFlagsKHR                  externalFenceFeatures
}

@extension("VK_KHR_external_fence") // 114
class VkExportFenceCreateInfoKHR {
    VkStructureType                                 sType
    const void*                                     pNext
    VkExternalFenceHandleTypeFlagsKHR               handleTypes
}

@extension("VK_KHR_external_fence_win32") // 115
class VkImportFenceWin32HandleInfoKHR {
    VkStructureType                                 sType
    const void*                                     pNext
    VkFence                                         fence
    VkFenceImportFlagsKHR                           flags
    VkExternalFenceHandleTypeFlagBitsKHR            handleType
    platform.HANDLE                                 handle
    platform.LPCWSTR                                name
}

@extension("VK_KHR_external_fence_win32") // 115
class VkExportFenceWin32HandleInfoKHR {
    VkStructureType                                 sType
    const void*                                     pNext
    const platform.SECURITY_ATTRIBUTES*             pAttributes
    platform.DWORD                                  dwAccess
    platform.LPCWSTR                                name
}

@extension("VK_KHR_external_fence_win32") // 115
class VkFenceGetWin32HandleInfoKHR {
    VkStructureType                                 sType
    const void*                                     pNext
    VkFence                                         fence
    VkExternalFenceHandleTypeFlagBitsKHR            handleType
}

@extension("VK_KHR_external_fence_fd") // 116
class VkImportFenceFdInfoKHR {
    VkStructureType                                 sType
    const void*                                     pNext
    VkFence                                         fence
    VkFenceImportFlagsKHR                           flags
    VkExternalFenceHandleTypeFlagBitsKHR            handleType
    int                                             fd
}

@extension("VK_KHR_external_fence_fd") // 116
class VkFenceGetFdInfoKHR {
    VkStructureType                                 sType
    const void*                                     pNext
    VkFence                                         fence
    VkExternalFenceHandleTypeFlagBitsKHR            handleType
}

@extension("VK_KHR_maintenance2") // 118
class VkPhysicalDevicePointClippingPropertiesKHR {
    VkStructureType                                 sType
    void*                                           pNext
    VkPointClippingBehaviorKHR                      pointClippingBehavior
}

@extension("VK_KHR_maintenance2") // 118
class VkInputAttachmentAspectReferenceKHR {
    u32                                             subpass
    u32                                             inputAttachmentIndex
    VkImageAspectFlags                              aspectMask
}

@extension("VK_KHR_maintenance2") // 118
class VkRenderPassInputAttachmentAspectCreateInfoKHR {
    VkStructureType                                 sType
    const void*                                     pNext
    u32                                             aspectReferenceCount
    const VkInputAttachmentAspectReferenceKHR*      pAspectReferences
}

@extension("VK_KHR_maintenance2") // 118
class VkImageViewUsageCreateInfoKHR {
    VkStructureType                                 sType
    const void*                                     pNext
    VkImageUsageFlags                               usage
}

@extension("VK_KHR_maintenance2") // 118
class VkPipelineTessellationDomainOriginStateCreateInfoKHR {
    VkStructureType                                 sType
    const void*                                     pNext
    VkTessellationDomainOriginKHR                   domainOrigin
}

@extension("VK_KHR_get_surface_capabilities2") // 120
class VkPhysicalDeviceSurfaceInfo2KHR {
    VkStructureType                                 sType
    const void*                                     pNext
    VkSurfaceKHR                                    surface
}

@extension("VK_KHR_get_surface_capabilities2") // 120
class VkSurfaceCapabilities2KHR {
    VkStructureType                                 sType
    void*                                           pNext
    VkSurfaceCapabilitiesKHR                        surfaceCapabilities
}

@extension("VK_KHR_get_surface_capabilities2") // 120
class VkSurfaceFormat2KHR {
    VkStructureType                                 sType
    void*                                           pNext
    VkSurfaceFormatKHR                              surfaceFormat
}

@extension("VK_KHR_variable_pointers") // 121
class VkPhysicalDeviceVariablePointerFeaturesKHR {
    VkStructureType                                 sType
    void*                                           pNext
    VkBool32                                        variablePointersStorageBuffer
    VkBool32                                        variablePointers
}

@extension("VK_MVK_ios_surface") // 123
class VkIOSSurfaceCreateInfoMVK {
    VkStructureType                                 sType
    const void*                                     pNext
    VkIOSSurfaceCreateFlagsMVK                      flags
    const void*                                     pView
}

@extension("VK_MVK_macos_surface") // 124
class VkMacOSSurfaceCreateInfoMVK {
    VkStructureType                                 sType
    const void*                                     pNext
    VkMacOSSurfaceCreateFlagsMVK                    flags
    const void*                                     pView
}

@extension("VK_KHR_dedicated_allocation") // 128
class VkMemoryDedicatedRequirementsKHR {
    VkStructureType                                 sType
    void*                                           pNext
    VkBool32                                        prefersDedicatedAllocation
    VkBool32                                        requiresDedicatedAllocation
}

@extension("VK_KHR_dedicated_allocation") // 128
class VkMemoryDedicatedAllocateInfoKHR {
    VkStructureType                                 sType
    const void*                                     pNext
    VkImage                                         image
    VkBuffer                                        buffer
}

@extension("VK_EXT_debug_utils") // 129
class VkDebugUtilsObjectNameInfoEXT {
    VkStructureType                                 sType
    const void*                                     pNext
    VkObjectType                                    objectType
    u64                                             objectHandle
    const char*                                     pObjectName
}
 
@extension("VK_EXT_debug_utils") // 129
class VkDebugUtilsObjectTagInfoEXT {
    VkStructureType                                 sType
    const void*                                     pNext
    VkObjectType                                    objectType
    u64                                             objectHandle
    u64                                             tagName
    platform.size_t                                 tagSize
    const void*                                     pTag
}
 
@extension("VK_EXT_debug_utils") // 129
class VkDebugUtilsLabelEXT {
    VkStructureType                                 sType
    const void*                                     pNext
    const char*                                     pLabelName
    f32[4]                                          color
}

@extension("VK_EXT_debug_utils") // 129
class VkDebugUtilsMessengerCallbackDataEXT {
    VkStructureType                                 sType
    const void*                                     pNext
    VkDebugUtilsMessengerCallbackDataFlagsEXT       flags
    const char*                                     pMessageIdName
    s32                                             messageIdNumber
    const char*                                     pMessage
    u32                                             queueLabelCount
    VkDebugUtilsLabelEXT*                           pQueueLabels
    u32                                             cmdBufLabelCount
    VkDebugUtilsLabelEXT*                           pCmdBufLabels
    u32                                             objectCount
    VkDebugUtilsObjectNameInfoEXT*                  pObjects
}

@extension("VK_EXT_debug_utils") // 129
class VkDebugUtilsMessengerCreateInfoEXT {
    VkStructureType                                 sType
    const void*                                     pNext
    VkDebugUtilsMessengerCreateFlagsEXT             flags
    VkDebugUtilsMessageSeverityFlagsEXT             messageSeverity
    VkDebugUtilsMessageTypeFlagsEXT                 messageType
    PFN_vkDebugUtilsMessengerCallbackEXT            pfnUserCallback
    void*                                           pUserData
}

@extension("VK_ANDROID_external_memory_android_hardware_buffer") // 131
class VkAndroidHardwareBufferUsageANDROID {
    VkStructureType                                 sType
    void*                                           pNext
    u64                                             androidHardwareBufferUsage
}

@extension("VK_ANDROID_external_memory_android_hardware_buffer") // 130
class VkAndroidHardwareBufferPropertiesANDROID {
    VkStructureType                                 sType
    void*                                           pNext
    VkDeviceSize                                    allocationSize
    u32                                             memoryTypeBits
}

@extension("VK_ANDROID_external_memory_android_hardware_buffer") // 130
class VkAndroidHardwareBufferFormatPropertiesANDROID {
    VkStructureType                                 sType
    void*                                           pNext
    VkFormat                                        format
    u64                                             externalFormat
    VkFormatFeatureFlags                            formatFeatures
    VkComponentMapping                              samplerYcbcrConversionComponents
    VkSamplerYcbcrModelConversion                   suggestedYcbcrModel
    VkSamplerYcbcrRange                             suggestedYcbcrRange
    VkChromaLocation                                suggestedXChromaOffset
    VkChromaLocation                                suggestedYChromaOffset
}

@extension("VK_ANDROID_external_memory_android_hardware_buffer") // 130
class VkImportAndroidHardwareBufferInfoANDROID {
    VkStructureType                                 sType
    const void*                                     pNext
    platform.AHardwareBuffer*                       buffer
}

@extension("VK_ANDROID_external_memory_android_hardware_buffer") // 130
class VkMemoryGetAndroidHardwareBufferInfoANDROID {
    VkStructureType                                 sType
    const void*                                     pNext
    VkDeviceMemory                                  memory
}

@extension("VK_ANDROID_external_memory_android_hardware_buffer") // 130
class VkExternalFormatANDROID {
    VkStructureType                                 sType
    void*                                           pNext
    u64                                             externalFormat
}

@extension("VK_EXT_sampler_filter_minmax") // 131
class VkSamplerReductionModeCreateInfoEXT {
    VkStructureType                                 sType
    const void*                                     pNext
    VkSamplerReductionModeEXT                       reductionMode
}

@extension("VK_EXT_sampler_filter_minmax") // 131
class VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT {
    VkStructureType                                 sType
    void*                                           pNext
    VkBool32                                        filterMinmaxSingleComponentFormats
    VkBool32                                        filterMinmaxImageComponentMapping
}

@extension("VK_EXT_sample_locations") // 144
class VkSampleLocationEXT {
    f32                                             x
    f32                                             y
}

@extension("VK_EXT_sample_locations") // 144
class VkSampleLocationsInfoEXT {
    VkStructureType                                 sType
    const void*                                     pNext
    VkSampleCountFlagBits                           sampleLocationsPerPixel
    VkExtent2D                                      sampleLocationGridSize
    u32                                             sampleLocationsCount
    const VkSampleLocationEXT*                      pSampleLocations
}

@extension("VK_EXT_sample_locations") // 144
class VkAttachmentSampleLocationsEXT {
    u32                                             attachmentIndex
    VkSampleLocationsInfoEXT                        sampleLocationsInfo
}

@extension("VK_EXT_sample_locations") // 144
class VkSubpassSampleLocationsEXT {
    u32                                             subpassIndex
    VkSampleLocationsInfoEXT                        sampleLocationsInfo
}

@extension("VK_EXT_sample_locations") // 144
class VkRenderPassSampleLocationsBeginInfoEXT {
    VkStructureType                                 sType
    const void*                                     pNext
    u32                                             attachmentInitialSampleLocationsCount
    const VkAttachmentSampleLocationsEXT*           pAttachmentInitialSampleLocations
    u32                                             postSubpassSampleLocationsCount
    const VkSubpassSampleLocationsEXT*              pPostSubpassSampleLocations
}

@extension("VK_EXT_sample_locations") // 144
class VkPipelineSampleLocationsStateCreateInfoEXT {
    VkStructureType                                 sType
    const void*                                     pNext
    VkBool32                                        sampleLocationsEnable
    VkSampleLocationsInfoEXT                        sampleLocationsInfo
}

@extension("VK_EXT_sample_locations") // 144
class VkPhysicalDeviceSampleLocationsPropertiesEXT {
    VkStructureType                                 sType
    void*                                           pNext
    VkSampleCountFlags                              sampleLocationSampleCounts
    VkExtent2D                                      maxSampleLocationGridSize
    f32[2]                                          sampleLocationCoordinateRange
    u32                                             sampleLocationSubPixelBits
    VkBool32                                        variableSampleLocations
}

@extension("VK_EXT_sample_locations") // 144
class VkMultisamplePropertiesEXT {
    VkStructureType                                 sType
    void*                                           pNext
    VkExtent2D                                      maxSampleLocationGridSize
}

@extension("VK_KHR_get_memory_requirements2") // 147
class VkBufferMemoryRequirementsInfo2KHR {
    VkStructureType                                 sType
    const void*                                     pNext
    VkBuffer                                        buffer
}

@extension("VK_KHR_get_memory_requirements2") // 147
class VkImageMemoryRequirementsInfo2KHR {
    VkStructureType                                 sType
    const void*                                     pNext
    VkImage                                         image
}

@extension("VK_KHR_get_memory_requirements2") // 147
class VkImageSparseMemoryRequirementsInfo2KHR {
    VkStructureType                                 sType
    const void*                                     pNext
    VkImage                                         image
}

@extension("VK_KHR_get_memory_requirements2") // 147
class VkMemoryRequirements2KHR {
    VkStructureType                                 sType
    void*                                           pNext
    VkMemoryRequirements                            memoryRequirements
}

@extension("VK_KHR_get_memory_requirements2") // 147
class VkSparseImageMemoryRequirements2KHR {
    VkStructureType                                 sType
    void*                                           pNext
    VkSparseImageMemoryRequirements                 memoryRequirements
}

@extension("VK_KHR_image_format_list") // 148
class VkImageFormatListCreateInfoKHR {
    VkStructureType                                 sType
    const void*                                     pNext
    u32                                             viewFormatCount
    const VkFormat*                                 pViewFormats
}

@extension("VK_EXT_blend_operation_advanced") // 149
class VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT {
    VkStructureType                                 sType
    void*                                           pNext
    VkBool32                                        advancedBlendCoherentOperations
}

@extension("VK_EXT_blend_operation_advanced") // 149
class VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT {
    VkStructureType                                 sType
    void*                                           pNext
    u32                                             advancedBlendMaxColorAttachments
    VkBool32                                        advancedBlendIndependentBlend
    VkBool32                                        advancedBlendNonPremultipliedSrcColor
    VkBool32                                        advancedBlendNonPremultipliedDstColor
    VkBool32                                        advancedBlendCorrelatedOverlap
    VkBool32                                        advancedBlendAllOperations
}

@extension("VK_EXT_blend_operation_advanced") // 149
class VkPipelineColorBlendAdvancedStateCreateInfoEXT {
    VkStructureType                                 sType
    const void*                                     pNext
    VkBool32                                        srcPremultiplied
    VkBool32                                        dstPremultiplied
    VkBlendOverlapEXT                               blendOverlap
}

@extension("VK_NV_fragment_coverage_to_color") // 150
class VkPipelineCoverageToColorStateCreateInfoNV {
    VkStructureType                                 sType
    const void*                                     pNext
    VkPipelineCoverageToColorStateCreateFlagsNV     flags
    VkBool32                                        coverageToColorEnable
    u32                                             coverageToColorLocation
}

@extension("VK_NV_framebuffer_mixed_samples") // 153
class VkPipelineCoverageModulationStateCreateInfoNV {
    VkStructureType                                 sType
    const void*                                     pNext
    VkPipelineCoverageModulationStateCreateFlagsNV  flags
    VkCoverageModulationModeNV                      coverageModulationMode
    VkBool32                                        coverageModulationTableEnable
    u32                                             coverageModulationTableCount
    const f32*                                      pCoverageModulationTable
}

@extension("VK_KHR_sampler_ycbcr_conversion") // 157
class VkSamplerYcbcrConversionCreateInfoKHR {
    VkStructureType                                 sType
    const void*                                     pNext
    VkFormat                                        format
    VkSamplerYcbcrModelConversionKHR                ycbcrModel
    VkSamplerYcbcrRangeKHR                          ycbcrRange
    VkComponentMapping                              components
    VkChromaLocationKHR                             xChromaOffset
    VkChromaLocationKHR                             yChromaOffset
    VkFilter                                        chromaFilter
    VkBool32                                        forceExplicitReconstruction
}

@extension("VK_KHR_sampler_ycbcr_conversion") // 157
class VkSamplerYcbcrConversionInfoKHR {
    VkStructureType                                 sType
    const void*                                     pNext
    VkSamplerYcbcrConversionKHR                     conversion
}

@extension("VK_KHR_sampler_ycbcr_conversion") // 157
class VkBindImagePlaneMemoryInfoKHR {
    VkStructureType                                 sType
    const void*                                     pNext
    VkImageAspectFlagBits                           planeAspect
}

@extension("VK_KHR_sampler_ycbcr_conversion") // 157
class VkImagePlaneMemoryRequirementsInfoKHR {
    VkStructureType                                 sType
    const void*                                     pNext
    VkImageAspectFlagBits                           planeAspect
}

@extension("VK_KHR_sampler_ycbcr_conversion") // 157
class VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR {
    VkStructureType                                 sType
    void*                                           pNext
    VkBool32                                        samplerYcbcrConversion
}

@extension("VK_KHR_sampler_ycbcr_conversion") // 157
class VkSamplerYcbcrConversionImageFormatPropertiesKHR {
    VkStructureType                                 sType
    void*                                           pNext
    u32                                             combinedImageSamplerDescriptorCount
}

@extension("VK_KHR_bind_memory2") // 158
class VkBindBufferMemoryInfoKHR {
    VkStructureType                                 sType
    const void*                                     pNext
    VkBuffer                                        buffer
    VkDeviceMemory                                  memory
    VkDeviceSize                                    memoryOffset
}

@extension("VK_KHR_bind_memory2") // 158
class VkBindImageMemoryInfoKHR {
    VkStructureType                                 sType
    const void*                                     pNext
    VkImage                                         image
    VkDeviceMemory                                  memory
    VkDeviceSize                                    memoryOffset
}

@extension("VK_EXT_validation_cache") // 161
class VkValidationCacheCreateInfoEXT {
    VkStructureType                                 sType
    const void*                                     pNext
    VkValidationCacheCreateFlagsEXT                 flags
    platform.size_t                                 initialDataSize
    const void*                                     pInitialData
}

@extension("VK_EXT_validation_cache") // 161
class VkShaderModuleValidationCacheCreateInfoEXT {
    VkStructureType                                 sType
    const void*                                     pNext
    VkValidationCacheEXT                            validationCache
}

@extension("VK_KHR_maintenance3") // 169
class VkPhysicalDeviceMaintenance3PropertiesKHR {
    VkStructureType                                 sType
    void*                                           pNext
    u32                                             maxPerSetDescriptors
    VkDeviceSize                                    maxMemoryAllocationSize
}

@extension("VK_KHR_maintenance3") // 169
class VkDescriptorSetLayoutSupportKHR {
    VkStructureType                                 sType
    void*                                           pNext
    VkBool32                                        supported
}

@extension("VK_EXT_global_priority") // 175
class VkDeviceQueueGlobalPriorityCreateInfoEXT {
    VkStructureType                                 sType
    const void*                                     pNext
    VkQueueGlobalPriorityEXT                        globalPriority
}

@extension("VK_EXT_external_memory_host") // 179
class VkImportMemoryHostPointerInfoEXT {
    VkStructureType                                 sType
    const void*                                     pNext
    VkExternalMemoryHandleTypeFlagBits              handleType
    void*                                           pHostPointer
}

@extension("VK_EXT_external_memory_host") // 179
class VkMemoryHostPointerPropertiesEXT {
    VkStructureType                                 sType
    void*                                           pNext
    u32                                             memoryTypeBits
}

@extension("VK_EXT_external_memory_host") // 179
class VkPhysicalDeviceExternalMemoryHostPropertiesEXT {
    VkStructureType                                 sType
    void*                                           pNext
    VkDeviceSize                                    minImportedHostPointerAlignment
}


////////////////
//  Commands  //
////////////////

// Function pointers. TODO: add support for function pointers.

@external type void* PFN_vkVoidFunction
@pfn cmd void vkVoidFunction() {
}

@external type void* PFN_vkAllocationFunction
@pfn cmd void* vkAllocationFunction(
        void*                                       pUserData,
        platform.size_t                             size,
        platform.size_t                             alignment,
        VkSystemAllocationScope                     allocationScope) {
    return ?
}

@external type void* PFN_vkReallocationFunction
@pfn cmd void* vkReallocationFunction(
        void*                                       pUserData,
        void*                                       pOriginal,
        platform.size_t                             size,
        platform.size_t                             alignment,
        VkSystemAllocationScope                     allocationScope) {
    return ?
}

@external type void* PFN_vkFreeFunction
@pfn cmd void vkFreeFunction(
        void*                                       pUserData,
        void*                                       pMemory) {
}

@external type void* PFN_vkInternalAllocationNotification
@pfn cmd void vkInternalAllocationNotification(
        void*                                       pUserData,
        platform.size_t                             size,
        VkInternalAllocationType                    allocationType,
        VkSystemAllocationScope                     allocationScope) {
}

@external type void* PFN_vkInternalFreeNotification
@pfn cmd void vkInternalFreeNotification(
        void*                                       pUserData,
        platform.size_t                             size,
        VkInternalAllocationType                    allocationType,
        VkSystemAllocationScope                     allocationScope) {
}

// Global functions

@threadSafety("system")
cmd VkResult vkCreateInstance(
        const VkInstanceCreateInfo*                 pCreateInfo,
        const VkAllocationCallbacks*                pAllocator,
        VkInstance*                                 pInstance) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO)

    instance := ?
    pInstance[0] = instance
    State.Instances[instance] = new!InstanceObject()

    layers := pCreateInfo.ppEnabledLayerNames[0:pCreateInfo.enabledLayerCount]
    extensions := pCreateInfo.ppEnabledExtensionNames[0:pCreateInfo.enabledExtensionCount]

    return ?
}

@threadSafety("system")
cmd void vkDestroyInstance(
        VkInstance                                  instance,
        const VkAllocationCallbacks*                pAllocator) {
    instanceObject := GetInstance(instance)

    State.Instances[instance] = null
}

@threadSafety("system")
cmd VkResult vkEnumeratePhysicalDevices(
        VkInstance                                  instance,
        u32*                                        pPhysicalDeviceCount,
        VkPhysicalDevice*                           pPhysicalDevices) {
    instanceObject := GetInstance(instance)

    physicalDeviceCount := as!u32(?)
    pPhysicalDeviceCount[0] = physicalDeviceCount
    physicalDevices := pPhysicalDevices[0:physicalDeviceCount]

    for i in (0 .. physicalDeviceCount) {
        physicalDevice := ?
        physicalDevices[i] = physicalDevice
        if !(physicalDevice in State.PhysicalDevices) {
            State.PhysicalDevices[physicalDevice] = new!PhysicalDeviceObject(instance: instance)
        }
    }

    return ?
}

cmd PFN_vkVoidFunction vkGetDeviceProcAddr(
        VkDevice                                    device,
        const char*                                 pName) {
    if device != NULL_HANDLE {
        device := GetDevice(device)
    }

    return ?
}

cmd PFN_vkVoidFunction vkGetInstanceProcAddr(
        VkInstance                                  instance,
        const char*                                 pName) {
    if instance != NULL_HANDLE {
        instanceObject := GetInstance(instance)
    }

    return ?
}

cmd void vkGetPhysicalDeviceProperties(
        VkPhysicalDevice                            physicalDevice,
        VkPhysicalDeviceProperties*                 pProperties) {
    physicalDeviceObject := GetPhysicalDevice(physicalDevice)

    properties := ?
    pProperties[0] = properties
}

cmd void vkGetPhysicalDeviceQueueFamilyProperties(
        VkPhysicalDevice                            physicalDevice,
        u32*                                        pQueueFamilyPropertyCount,
        VkQueueFamilyProperties*                    pQueueFamilyProperties) {
    physicalDeviceObject := GetPhysicalDevice(physicalDevice)
    // TODO: Figure out how to express fetch-count-or-properties
    // This version fails 'apic validate' with 'fence not allowed in
    // *semantic.Branch'. Other attempts have failed with the same or other
    // errors.
    // if pQueueFamilyProperties != null {
    //     queuesProperties := pQueueFamilyProperties[0:pCount[0]]
    //     for i in (0 .. pCount[0]) {
    //         queueProperties := as!VkQueueFamilyProperties(?)
    //         queuesProperties[i] = queueProperties
    //    }
    // } else {
    //     count := ?
    //     pCount[0] = count
    // }
}

cmd void vkGetPhysicalDeviceMemoryProperties(
        VkPhysicalDevice                            physicalDevice,
        VkPhysicalDeviceMemoryProperties*           pMemoryProperties) {
    physicalDeviceObject := GetPhysicalDevice(physicalDevice)

    memoryProperties := ?
    pMemoryProperties[0] = memoryProperties
}

cmd void vkGetPhysicalDeviceFeatures(
        VkPhysicalDevice                            physicalDevice,
        VkPhysicalDeviceFeatures*                   pFeatures) {
    physicalDeviceObject := GetPhysicalDevice(physicalDevice)

    features := ?
    pFeatures[0] = features
}

cmd void vkGetPhysicalDeviceFormatProperties(
        VkPhysicalDevice                            physicalDevice,
        VkFormat                                    format,
        VkFormatProperties*                         pFormatProperties) {
    physicalDeviceObject := GetPhysicalDevice(physicalDevice)

    formatProperties := ?
    pFormatProperties[0] = formatProperties
}

cmd VkResult vkGetPhysicalDeviceImageFormatProperties(
        VkPhysicalDevice                            physicalDevice,
        VkFormat                                    format,
        VkImageType                                 type,
        VkImageTiling                               tiling,
        VkImageUsageFlags                           usage,
        VkImageCreateFlags                          flags,
        VkImageFormatProperties*                    pImageFormatProperties) {
    physicalDeviceObject := GetPhysicalDevice(physicalDevice)

    imageFormatProperties := ?
    pImageFormatProperties[0] = imageFormatProperties

    return ?
}


// Device functions

@threadSafety("system")
cmd VkResult vkCreateDevice(
        VkPhysicalDevice                            physicalDevice,
        const VkDeviceCreateInfo*                   pCreateInfo,
        const VkAllocationCallbacks*                pAllocator,
        VkDevice*                                   pDevice) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO)
    physicalDeviceObject := GetPhysicalDevice(physicalDevice)

    device := ?
    pDevice[0] = device
    State.Devices[device] = new!DeviceObject(physicalDevice: physicalDevice)

    return ?
}

@threadSafety("system")
cmd void vkDestroyDevice(
        VkDevice                                    device,
        const VkAllocationCallbacks*                pAllocator) {
    deviceObject := GetDevice(device)

    State.Devices[device] = null
}


// Extension discovery functions

cmd VkResult vkEnumerateInstanceLayerProperties(
        u32*                                        pPropertyCount,
        VkLayerProperties*                          pProperties) {
    count := as!u32(?)
    pPropertyCount[0] = count

    properties := pProperties[0:count]
    for i in (0 .. count) {
        property := ?
        properties[i] = property
    }

    return ?
}

cmd VkResult vkEnumerateInstanceExtensionProperties(
        const char*                                 pLayerName,
        u32*                                        pPropertyCount,
        VkExtensionProperties*                      pProperties) {
    count := as!u32(?)
    pPropertyCount[0] = count

    properties := pProperties[0:count]
    for i in (0 .. count) {
        property := ?
        properties[i] = property
    }

    return ?
}

cmd VkResult vkEnumerateDeviceLayerProperties(
        VkPhysicalDevice                            physicalDevice,
        u32*                                        pPropertyCount,
        VkLayerProperties*                          pProperties) {
    physicalDeviceObject := GetPhysicalDevice(physicalDevice)
    count := as!u32(?)
    pPropertyCount[0] = count

    properties := pProperties[0:count]
    for i in (0 .. count) {
        property := ?
        properties[i] = property
    }

    return ?
}

cmd VkResult vkEnumerateDeviceExtensionProperties(
        VkPhysicalDevice                            physicalDevice,
        const char*                                 pLayerName,
        u32*                                        pPropertyCount,
        VkExtensionProperties*                      pProperties) {
    physicalDeviceObject := GetPhysicalDevice(physicalDevice)

    count := as!u32(?)
    pPropertyCount[0] = count

    properties := pProperties[0:count]
    for i in (0 .. count) {
        property := ?
        properties[i] = property
    }

    return ?
}


// Queue functions

@threadSafety("system")
cmd void vkGetDeviceQueue(
        VkDevice                                    device,
        u32                                         queueFamilyIndex,
        u32                                         queueIndex,
        VkQueue*                                    pQueue) {
    deviceObject := GetDevice(device)

    queue := ?
    pQueue[0] = queue

    if !(queue in State.Queues) {
        State.Queues[queue] = new!QueueObject(device: device)
    }
}

@threadSafety("app")
cmd VkResult vkQueueSubmit(
        VkQueue                                     queue,
        u32                                         submitCount,
        const VkSubmitInfo*                         pSubmits,
        VkFence                                     fence) {
    queueObject := GetQueue(queue)

    if fence != NULL_HANDLE {
        fenceObject := GetFence(fence)
        assert(fenceObject.device == queueObject.device)
    }

    // commandBuffers := pcommandBuffers[0:commandBufferCount]
    // for i in (0 .. commandBufferCount) {
    //    commandBuffer := commandBuffers[i]
    //    commandBufferObject := GetCommandBuffer(commandBuffer)
    //    assert(commandBufferObject.device == queueObject.device)
    //
    //    validate("QueueCheck", commandBufferObject.queueFlags in queueObject.flags,
    //        "vkQueueSubmit: enqueued commandBuffer requires missing queue capabilities.")
    // }

    return ?
}

@threadSafety("system")
cmd VkResult vkQueueWaitIdle(
        VkQueue                                     queue) {
    queueObject := GetQueue(queue)

    return ?
}

@threadSafety("system")
cmd VkResult vkDeviceWaitIdle(
        VkDevice                                    device) {
    deviceObject := GetDevice(device)

    return ?
}


// Memory functions

@threadSafety("system")
cmd VkResult vkAllocateMemory(
        VkDevice                                    device,
        const VkMemoryAllocateInfo*                 pAllocateInfo,
        const VkAllocationCallbacks*                pAllocator,
        VkDeviceMemory*                             pMemory) {
    assert(pAllocateInfo.sType == VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO)
    deviceObject := GetDevice(device)

    memory := ?
    pMemory[0] = memory
    State.DeviceMemories[memory] = new!DeviceMemoryObject(
        device: device,
        allocationSize: pAllocateInfo[0].allocationSize)

    return ?
}

@threadSafety("system")
cmd void vkFreeMemory(
        VkDevice                                    device,
        VkDeviceMemory                              memory,
        const VkAllocationCallbacks*                pAllocator) {
    deviceObject := GetDevice(device)
    memoryObject := GetDeviceMemory(memory)
    assert(memoryObject.device == device)

    // Check that no objects are still bound before freeing.
    validate("MemoryCheck", len(memoryObject.boundObjects) == 0,
        "vkFreeMemory: objects still bound")
    validate("MemoryCheck", len(memoryObject.boundCommandBuffers) == 0,
        "vkFreeMemory: commandBuffers still bound")
    State.DeviceMemories[memory] = null
}

@threadSafety("app")
cmd VkResult vkMapMemory(
        VkDevice                                    device,
        VkDeviceMemory                              memory,
        VkDeviceSize                                offset,
        VkDeviceSize                                size,
        VkMemoryMapFlags                            flags,
        void**                                      ppData) {
    deviceObject := GetDevice(device)
    memoryObject := GetDeviceMemory(memory)
    assert(memoryObject.device == device)

    assert(flags == as!VkMemoryMapFlags(0))
    assert((offset + size) <= memoryObject.allocationSize)

    return ?
}

@threadSafety("app")
cmd void vkUnmapMemory(
        VkDevice                                    device,
        VkDeviceMemory                              memory) {
    deviceObject := GetDevice(device)
    memoryObject := GetDeviceMemory(memory)
    assert(memoryObject.device == device)
}

cmd VkResult vkFlushMappedMemoryRanges(
        VkDevice                                    device,
        u32                                         memoryRangeCount
        const VkMappedMemoryRange*                  pMemoryRanges) {
    deviceObject := GetDevice(device)

    memoryRanges := pMemoryRanges[0:memoryRangeCount]
    for i in (0 .. memoryRangeCount) {
        memoryRange := memoryRanges[i]
        memoryObject := GetDeviceMemory(memoryRange.memory)
        assert(memoryObject.device == device)
        assert((memoryRange.offset + memoryRange.size) <= memoryObject.allocationSize)
    }

    return ?
}

cmd VkResult vkInvalidateMappedMemoryRanges(
        VkDevice                                    device,
        u32                                         memoryRangeCount,
        const VkMappedMemoryRange*                  pMemoryRanges) {
    deviceObject := GetDevice(device)

    memoryRanges := pMemoryRanges[0:memoryRangeCount]
    for i in (0 .. memoryRangeCount) {
        memoryRange := memoryRanges[i]
        memoryObject := GetDeviceMemory(memoryRange.memory)
        assert(memoryObject.device == device)
        assert((memoryRange.offset + memoryRange.size) <= memoryObject.allocationSize)
    }

    return ?
}


// Memory management API functions

cmd void vkGetDeviceMemoryCommitment(
        VkDevice                                    device,
        VkDeviceMemory                              memory,
        VkDeviceSize*                               pCommittedMemoryInBytes) {
    deviceObject := GetDevice(device)

    if memory != NULL_HANDLE {
        memoryObject := GetDeviceMemory(memory)
        assert(memoryObject.device == device)
    }

    committedMemoryInBytes := ?
    pCommittedMemoryInBytes[0] = committedMemoryInBytes
}

cmd void vkGetBufferMemoryRequirements(
        VkDevice                                    device,
        VkBuffer                                    buffer,
        VkMemoryRequirements*                       pMemoryRequirements) {
    deviceObject := GetDevice(device)
    bufferObject := GetBuffer(buffer)
    assert(bufferObject.device == device)
}

cmd VkResult vkBindBufferMemory(
        VkDevice                                    device,
        VkBuffer                                    buffer,
        VkDeviceMemory                              memory,
        VkDeviceSize                                memoryOffset) {
    deviceObject := GetDevice(device)
    bufferObject := GetBuffer(buffer)
    assert(bufferObject.device == device)

    // Unbind buffer from previous memory object, if not VK_NULL_HANDLE.
    if bufferObject.memory != NULL_HANDLE {
        memoryObject := GetDeviceMemory(bufferObject.memory)
        memoryObject.boundObjects[as!u64(buffer)] = null
    }

    // Bind buffer to given memory object, if not VK_NULL_HANDLE.
    if memory != NULL_HANDLE {
        memoryObject := GetDeviceMemory(memory)
        assert(memoryObject.device == device)
        memoryObject.boundObjects[as!u64(buffer)] = memoryOffset
    }
    bufferObject.memory = memory
    bufferObject.memoryOffset = memoryOffset

    return ?
}

cmd void vkGetImageMemoryRequirements(
        VkDevice                                    device,
        VkImage                                     image,
        VkMemoryRequirements*                       pMemoryRequirements) {
    deviceObject := GetDevice(device)
    imageObject := GetImage(image)
    assert(imageObject.device == device)
}

cmd VkResult vkBindImageMemory(
        VkDevice                                    device,
        VkImage                                     image,
        VkDeviceMemory                              memory,
        VkDeviceSize                                memoryOffset) {
    deviceObject := GetDevice(device)
    imageObject := GetImage(image)
    assert(imageObject.device == device)

    // Unbind image from previous memory object, if not VK_NULL_HANDLE.
    if imageObject.memory != NULL_HANDLE {
        memoryObject := GetDeviceMemory(imageObject.memory)
        memoryObject.boundObjects[as!u64(image)] = null
    }

    // Bind image to given memory object, if not VK_NULL_HANDLE.
    if memory != NULL_HANDLE {
        memoryObject := GetDeviceMemory(memory)
        assert(memoryObject.device == device)
        memoryObject.boundObjects[as!u64(image)] = memoryOffset
    }
    imageObject.memory = memory
    imageObject.memoryOffset = memoryOffset

    return ?
}

cmd void vkGetImageSparseMemoryRequirements(
        VkDevice                                    device,
        VkImage                                     image,
        u32*                                        pSparseMemoryRequirementCount,
        VkSparseImageMemoryRequirements*            pSparseMemoryRequirements) {
    deviceObject := GetDevice(device)
    imageObject := GetImage(image)
    assert(imageObject.device == device)
}

cmd void vkGetPhysicalDeviceSparseImageFormatProperties(
        VkPhysicalDevice                            physicalDevice,
        VkFormat                                    format,
        VkImageType                                 type,
        VkSampleCountFlagBits                       samples,
        VkImageUsageFlags                           usage,
        VkImageTiling                               tiling,
        u32*                                        pPropertyCount,
        VkSparseImageFormatProperties*              pProperties) {
    physicalDeviceObject := GetPhysicalDevice(physicalDevice)
}

cmd VkResult vkQueueBindSparse(
        VkQueue                                     queue,
        u32                                         bindInfoCount,
        const VkBindSparseInfo*                     pBindInfo,
        VkFence                                     fence) {
    queueObject := GetQueue(queue)

    return ?
}


// Fence functions

@threadSafety("system")
cmd VkResult vkCreateFence(
        VkDevice                                    device,
        const VkFenceCreateInfo*                    pCreateInfo,
        const VkAllocationCallbacks*                pAllocator,
        VkFence*                                    pFence) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_FENCE_CREATE_INFO)
    deviceObject := GetDevice(device)

    fence := ?
    pFence[0] = fence
    State.Fences[fence] = new!FenceObject(
        device: device, signaled: (pCreateInfo.flags == as!VkFenceCreateFlags(VK_FENCE_CREATE_SIGNALED_BIT)))

    return ?
}

@threadSafety("system")
cmd void vkDestroyFence(
        VkDevice                                    device,
        VkFence                                     fence,
        const VkAllocationCallbacks*                pAllocator) {
    deviceObject := GetDevice(device)
    fenceObject := GetFence(fence)
    assert(fenceObject.device == device)

    State.Fences[fence] = null
}

@threadSafety("system")
cmd VkResult vkResetFences(
        VkDevice                                    device,
        u32                                         fenceCount,
        const VkFence*                              pFences) {
    deviceObject := GetDevice(device)

    fences := pFences[0:fenceCount]
    for i in (0 .. fenceCount) {
        fence := fences[i]
        fenceObject := GetFence(fence)
        assert(fenceObject.device == device)
        fenceObject.signaled = false
    }

    return ?
}

@threadSafety("system")
cmd VkResult vkGetFenceStatus(
        VkDevice                                    device,
        VkFence                                     fence) {
    deviceObject := GetDevice(device)
    fenceObject := GetFence(fence)
    assert(fenceObject.device == device)

    return ?
}

@threadSafety("system")
cmd VkResult vkWaitForFences(
        VkDevice                                    device,
        u32                                         fenceCount,
        const VkFence*                              pFences,
        VkBool32                                    waitAll,
        u64                                         timeout) {  /// timeout in nanoseconds
    deviceObject := GetDevice(device)

    fences := pFences[0:fenceCount]
    for i in (0 .. fenceCount) {
        fence := fences[i]
        fenceObject := GetFence(fence)
        assert(fenceObject.device == device)
    }

    return ?
}


// Queue semaphore functions

@threadSafety("system")
cmd VkResult vkCreateSemaphore(
        VkDevice                                    device,
        const VkSemaphoreCreateInfo*                pCreateInfo,
        const VkAllocationCallbacks*                pAllocator,
        VkSemaphore*                                pSemaphore) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO)
    deviceObject := GetDevice(device)

    semaphore := ?
    pSemaphore[0] = semaphore
    State.Semaphores[semaphore] = new!SemaphoreObject(device: device)

    return ?
}

@threadSafety("system")
cmd void vkDestroySemaphore(
        VkDevice                                    device,
        VkSemaphore                                 semaphore,
        const VkAllocationCallbacks*                pAllocator) {
    deviceObject := GetDevice(device)
    semaphoreObject := GetSemaphore(semaphore)
    assert(semaphoreObject.device == device)

    State.Semaphores[semaphore] = null
}


// Event functions

@threadSafety("system")
cmd VkResult vkCreateEvent(
        VkDevice                                    device,
        const VkEventCreateInfo*                    pCreateInfo,
        const VkAllocationCallbacks*                pAllocator,
        VkEvent*                                    pEvent) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_EVENT_CREATE_INFO)
    deviceObject := GetDevice(device)

    event := ?
    pEvent[0] = event
    State.Events[event] = new!EventObject(device: device)

    return ?
}

@threadSafety("system")
cmd void vkDestroyEvent(
        VkDevice                                    device,
        VkEvent                                     event,
        const VkAllocationCallbacks*                pAllocator) {
    deviceObject := GetDevice(device)
    eventObject := GetEvent(event)
    assert(eventObject.device == device)

    State.Events[event] = null
}

@threadSafety("system")
cmd VkResult vkGetEventStatus(
        VkDevice                                    device,
        VkEvent                                     event) {
    deviceObject := GetDevice(device)
    eventObject := GetEvent(event)
    assert(eventObject.device == device)

    return ?
}

@threadSafety("system")
cmd VkResult vkSetEvent(
        VkDevice                                    device,
        VkEvent                                     event) {
    deviceObject := GetDevice(device)
    eventObject := GetEvent(event)
    assert(eventObject.device == device)

    return ?
}

@threadSafety("system")
cmd VkResult vkResetEvent(
        VkDevice                                    device,
        VkEvent                                     event) {
    deviceObject := GetDevice(device)
    eventObject := GetEvent(event)
    assert(eventObject.device == device)

    return ?
}


// Query functions

@threadSafety("system")
cmd VkResult vkCreateQueryPool(
        VkDevice                                    device,
        const VkQueryPoolCreateInfo*                pCreateInfo,
        const VkAllocationCallbacks*                pAllocator,
        VkQueryPool*                                pQueryPool) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO)
    deviceObject := GetDevice(device)

    queryPool := ?
    pQueryPool[0] = queryPool
    State.QueryPools[queryPool] = new!QueryPoolObject(device: device)

    return ?
}

@threadSafety("system")
cmd void vkDestroyQueryPool(
        VkDevice                                    device,
        VkQueryPool                                 queryPool,
        const VkAllocationCallbacks*                pAllocator) {
    deviceObject := GetDevice(device)
    queryPoolObject := GetQueryPool(queryPool)
    assert(queryPoolObject.device == device)

    State.QueryPools[queryPool] = null
}

@threadSafety("system")
cmd VkResult vkGetQueryPoolResults(
        VkDevice                                    device,
        VkQueryPool                                 queryPool,
        u32                                         firstQuery,
        u32                                         queryCount,
        platform.size_t                             dataSize,
        void*                                       pData,
        VkDeviceSize                                stride,
        VkQueryResultFlags                          flags) {
    deviceObject := GetDevice(device)
    queryPoolObject := GetQueryPool(queryPool)
    assert(queryPoolObject.device == device)

    data := pData[0:dataSize]

    return ?
}

// Buffer functions

@threadSafety("system")
cmd VkResult vkCreateBuffer(
        VkDevice                                    device,
        const VkBufferCreateInfo*                   pCreateInfo,
        const VkAllocationCallbacks*                pAllocator,
        VkBuffer*                                   pBuffer) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO)
    deviceObject := GetDevice(device)

    buffer := ?
    pBuffer[0] = buffer
    State.Buffers[buffer] = new!BufferObject(device: device)

    return ?
}

@threadSafety("system")
cmd void vkDestroyBuffer(
        VkDevice                                    device,
        VkBuffer                                    buffer,
        const VkAllocationCallbacks*                pAllocator) {
    deviceObject := GetDevice(device)
    bufferObject := GetBuffer(buffer)
    assert(bufferObject.device == device)

    assert(bufferObject.memory == 0)
    State.Buffers[buffer] = null
}


// Buffer view functions

@threadSafety("system")
cmd VkResult vkCreateBufferView(
        VkDevice                                    device,
        const VkBufferViewCreateInfo*               pCreateInfo,
        const VkAllocationCallbacks*                pAllocator,
        VkBufferView*                               pView) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO)
    deviceObject := GetDevice(device)

    bufferObject := GetBuffer(pCreateInfo.buffer)
    assert(bufferObject.device == device)

    view := ?
    pView[0] = view
    State.BufferViews[view] = new!BufferViewObject(device: device, buffer: pCreateInfo.buffer)

    return ?
}

@threadSafety("system")
cmd void vkDestroyBufferView(
        VkDevice                                    device,
        VkBufferView                                bufferView,
        const VkAllocationCallbacks*                pAllocator) {
    deviceObject := GetDevice(device)
    bufferViewObject := GetBufferView(bufferView)
    assert(bufferViewObject.device == device)

    State.BufferViews[bufferView] = null
}


// Image functions

@threadSafety("system")
cmd VkResult vkCreateImage(
        VkDevice                                    device,
        const VkImageCreateInfo*                    pCreateInfo,
        const VkAllocationCallbacks*                pAllocator,
        VkImage*                                    pImage) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO)
    deviceObject := GetDevice(device)

    image := ?
    pImage[0] = image
    State.Images[image] = new!ImageObject(device: device)

    return ?
}

@threadSafety("system")
cmd void vkDestroyImage(
        VkDevice                                    device,
        VkImage                                     image,
        const VkAllocationCallbacks*                pAllocator) {
    deviceObject := GetDevice(device)
    imageObject := GetImage(image)
    assert(imageObject.device == device)

    assert(imageObject.memory == 0)
    State.Images[image] = null
}

cmd void vkGetImageSubresourceLayout(
        VkDevice                                    device,
        VkImage                                     image,
        const VkImageSubresource*                   pSubresource,
        VkSubresourceLayout*                        pLayout) {
    deviceObject := GetDevice(device)
    imageObject := GetImage(image)
    assert(imageObject.device == device)
}


// Image view functions

@threadSafety("system")
cmd VkResult vkCreateImageView(
        VkDevice                                    device,
        const VkImageViewCreateInfo*                pCreateInfo,
        const VkAllocationCallbacks*                pAllocator,
        VkImageView*                                pView) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO)
    deviceObject := GetDevice(device)

    imageObject := GetImage(pCreateInfo.image)
    assert(imageObject.device == device)

    view := ?
    pView[0] = view
    State.ImageViews[view] = new!ImageViewObject(device: device, image: pCreateInfo.image)

    return ?
}

@threadSafety("system")
cmd void vkDestroyImageView(
        VkDevice                                    device,
        VkImageView                                 imageView,
        const VkAllocationCallbacks*                pAllocator) {
    deviceObject := GetDevice(device)
    imageViewObject := GetImageView(imageView)
    assert(imageViewObject.device == device)

    State.ImageViews[imageView] = null
}


// Shader functions

cmd VkResult vkCreateShaderModule(
        VkDevice                                    device,
        const VkShaderModuleCreateInfo*             pCreateInfo,
        const VkAllocationCallbacks*                pAllocator,
        VkShaderModule*                             pShaderModule) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO)
    deviceObject := GetDevice(device)

    shaderModule := ?
    pShaderModule[0] = shaderModule
    State.ShaderModules[shaderModule] = new!ShaderModuleObject(device: device)

    return ?
}

cmd void vkDestroyShaderModule(
        VkDevice                                    device,
        VkShaderModule                              shaderModule,
        const VkAllocationCallbacks*                pAllocator) {
    deviceObject := GetDevice(device)
    shaderModuleObject := GetShaderModule(shaderModule)
    assert(shaderModuleObject.device == device)

    State.ShaderModules[shaderModule] = null
}


// Pipeline functions

cmd VkResult vkCreatePipelineCache(
        VkDevice                                    device,
        const VkPipelineCacheCreateInfo*            pCreateInfo,
        const VkAllocationCallbacks*                pAllocator,
        VkPipelineCache*                            pPipelineCache) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO)
    deviceObject := GetDevice(device)

    pipelineCache := ?
    pPipelineCache[0] = pipelineCache
    State.PipelineCaches[pipelineCache] = new!PipelineCacheObject(device: device)

    return ?
}

cmd void vkDestroyPipelineCache(
        VkDevice                                    device,
        VkPipelineCache                             pipelineCache,
        const VkAllocationCallbacks*                pAllocator) {
    deviceObject := GetDevice(device)
    pipelineCacheObject := GetPipelineCache(pipelineCache)
    assert(pipelineCacheObject.device == device)

    State.PipelineCaches[pipelineCache] = null
}

cmd VkResult vkGetPipelineCacheData(
        VkDevice                                    device,
        VkPipelineCache                             pipelineCache,
        platform.size_t*                            pDataSize,
        void*                                       pData) {
    deviceObject := GetDevice(device)
    pipelineCacheObject := GetPipelineCache(pipelineCache)
    assert(pipelineCacheObject.device == device)

    return ?
}

cmd VkResult vkMergePipelineCaches(
        VkDevice                                    device,
        VkPipelineCache                             dstCache,
        u32                                         srcCacheCount,
        const VkPipelineCache*                      pSrcCaches) {
    deviceObject := GetDevice(device)
    dstCacheObject := GetPipelineCache(dstCache)
    assert(dstCacheObject.device == device)

    srcCaches := pSrcCaches[0:srcCacheCount]
    for i in (0 .. srcCacheCount) {
        srcCache := srcCaches[i]
        srcCacheObject := GetPipelineCache(srcCache)
        assert(srcCacheObject.device == device)
    }

    return ?
}

cmd VkResult vkCreateGraphicsPipelines(
        VkDevice                                    device,
        VkPipelineCache                             pipelineCache,
        u32                                         createInfoCount,
        const VkGraphicsPipelineCreateInfo*         pCreateInfos,
        const VkAllocationCallbacks*                pAllocator,
        VkPipeline*                                 pPipelines) {
    deviceObject := GetDevice(device)
    if pipelineCache != NULL_HANDLE {
        pipelineCacheObject := GetPipelineCache(pipelineCache)
        assert(pipelineCacheObject.device == device)
    }

    createInfos := pCreateInfos[0:createInfoCount]
    pipelines := pPipelines[0:createInfoCount]
    for i in (0 .. createInfoCount) {
        pipeline := ?
        pipelines[i] = pipeline
        State.Pipelines[pipeline] = new!PipelineObject(device: device)
    }

    return ?
}

cmd VkResult vkCreateComputePipelines(
        VkDevice                                    device,
        VkPipelineCache                             pipelineCache,
        u32                                         createInfoCount,
        const VkComputePipelineCreateInfo*          pCreateInfos,
        const VkAllocationCallbacks*                pAllocator,
        VkPipeline*                                 pPipelines) {
    deviceObject := GetDevice(device)
    if pipelineCache != NULL_HANDLE {
        pipelineCacheObject := GetPipelineCache(pipelineCache)
        assert(pipelineCacheObject.device == device)
    }

    createInfos := pCreateInfos[0:createInfoCount]
    pipelines := pPipelines[0:createInfoCount]
    for i in (0 .. createInfoCount) {
        pipeline := ?
        pipelines[i] = pipeline
        State.Pipelines[pipeline] = new!PipelineObject(device: device)
    }

    return ?
}

@threadSafety("system")
cmd void vkDestroyPipeline(
        VkDevice                                    device,
        VkPipeline                                  pipeline,
        const VkAllocationCallbacks*                pAllocator) {
    deviceObject := GetDevice(device)
    pipelineObjects := GetPipeline(pipeline)
    assert(pipelineObjects.device == device)

    State.Pipelines[pipeline] = null
}


// Pipeline layout functions

@threadSafety("system")
cmd VkResult vkCreatePipelineLayout(
        VkDevice                                    device,
        const VkPipelineLayoutCreateInfo*           pCreateInfo,
        const VkAllocationCallbacks*                pAllocator,
        VkPipelineLayout*                           pPipelineLayout) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO)
    deviceObject := GetDevice(device)

    pipelineLayout := ?
    pPipelineLayout[0] = pipelineLayout
    State.PipelineLayouts[pipelineLayout] = new!PipelineLayoutObject(device: device)

    return ?
}

@threadSafety("system")
cmd void vkDestroyPipelineLayout(
        VkDevice                                    device,
        VkPipelineLayout                            pipelineLayout,
        const VkAllocationCallbacks*                pAllocator) {
    deviceObject := GetDevice(device)
    pipelineLayoutObjects := GetPipelineLayout(pipelineLayout)
    assert(pipelineLayoutObjects.device == device)

    State.PipelineLayouts[pipelineLayout] = null
}


// Sampler functions

@threadSafety("system")
cmd VkResult vkCreateSampler(
        VkDevice                                    device,
        const VkSamplerCreateInfo*                  pCreateInfo,
        const VkAllocationCallbacks*                pAllocator,
        VkSampler*                                  pSampler) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO)
    deviceObject := GetDevice(device)

    sampler := ?
    pSampler[0] = sampler
    State.Samplers[sampler] = new!SamplerObject(device: device)

    return ?
}

@threadSafety("system")
cmd void vkDestroySampler(
        VkDevice                                    device,
        VkSampler                                   sampler,
        const VkAllocationCallbacks*                pAllocator) {
    deviceObject := GetDevice(device)
    samplerObject := GetSampler(sampler)
    assert(samplerObject.device == device)

    State.Samplers[sampler] = null
}


// Descriptor set functions

@threadSafety("system")
cmd VkResult vkCreateDescriptorSetLayout(
        VkDevice                                    device,
        const VkDescriptorSetLayoutCreateInfo*      pCreateInfo,
        const VkAllocationCallbacks*                pAllocator,
        VkDescriptorSetLayout*                      pSetLayout) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO)
    deviceObject := GetDevice(device)

    setLayout := ?
    pSetLayout[0] = setLayout
    State.DescriptorSetLayouts[setLayout] = new!DescriptorSetLayoutObject(device: device)

    return ?
}

@threadSafety("system")
cmd void vkDestroyDescriptorSetLayout(
        VkDevice                                    device,
        VkDescriptorSetLayout                       descriptorSetLayout,
        const VkAllocationCallbacks*                pAllocator) {
    deviceObject := GetDevice(device)
    descriptorSetLayoutObject := GetDescriptorSetLayout(descriptorSetLayout)
    assert(descriptorSetLayoutObject.device == device)

    State.DescriptorSetLayouts[descriptorSetLayout] = null
}

@threadSafety("system")
cmd VkResult vkCreateDescriptorPool(
        VkDevice                                    device,
        const VkDescriptorPoolCreateInfo*           pCreateInfo,
        const VkAllocationCallbacks*                pAllocator,
        VkDescriptorPool*                           pDescriptorPool) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO)
    deviceObject := GetDevice(device)

    descriptorPool := ?
    pDescriptorPool[0] = descriptorPool
    State.DescriptorPools[descriptorPool] = new!DescriptorPoolObject(device: device)

    return ?
}

@threadSafety("system")
cmd void vkDestroyDescriptorPool(
        VkDevice                                    device,
        VkDescriptorPool                            descriptorPool,
        const VkAllocationCallbacks*                pAllocator) {
    deviceObject := GetDevice(device)
    descriptorPoolObject := GetDescriptorPool(descriptorPool)
    assert(descriptorPoolObject.device == device)

    State.DescriptorPools[descriptorPool] = null
}

@threadSafety("app")
cmd VkResult vkResetDescriptorPool(
        VkDevice                                    device,
        VkDescriptorPool                            descriptorPool,
        VkDescriptorPoolResetFlags                  flags) {
    deviceObject := GetDevice(device)
    descriptorPoolObject := GetDescriptorPool(descriptorPool)
    assert(descriptorPoolObject.device == device)

    return ?
}

@threadSafety("app")
cmd VkResult vkAllocateDescriptorSets(
        VkDevice                                    device,
        const VkDescriptorSetAllocateInfo*          pAllocateInfo,
        VkDescriptorSet*                            pDescriptorSets) {
    deviceObject := GetDevice(device)
    allocInfo := pAllocateInfo[0]
    descriptorPoolObject := GetDescriptorPool(allocInfo.descriptorPool)

    setLayouts := allocInfo.pSetLayouts[0:allocInfo.setCount]
    for i in (0 .. allocInfo.setCount) {
        setLayout := setLayouts[i]
        setLayoutObject := GetDescriptorSetLayout(setLayout)
        assert(setLayoutObject.device == device)
    }

    descriptorSets := pDescriptorSets[0:allocInfo.setCount]
    for i in (0 .. allocInfo.setCount) {
        descriptorSet := ?
        descriptorSets[i] = descriptorSet
        State.DescriptorSets[descriptorSet] = new!DescriptorSetObject(device: device)
    }

    return ?
}

cmd VkResult vkFreeDescriptorSets(
        VkDevice                                    device,
        VkDescriptorPool                            descriptorPool,
        u32                                         descriptorSetCount,
        const VkDescriptorSet*                      pDescriptorSets) {
    deviceObject := GetDevice(device)
    descriptorPoolObject := GetDescriptorPool(descriptorPool)

    descriptorSets := pDescriptorSets[0:descriptorSetCount]
    for i in (0 .. descriptorSetCount) {
        descriptorSet := descriptorSets[i]
        descriptorSetObject := GetDescriptorSet(descriptorSet)
        assert(descriptorSetObject.device == device)
        State.DescriptorSets[descriptorSet] = null
    }

    return ?
}

cmd void vkUpdateDescriptorSets(
        VkDevice                                    device,
        u32                                         descriptorWriteCount,
        const VkWriteDescriptorSet*                 pDescriptorWrites,
        u32                                         descriptorCopyCount,
        const VkCopyDescriptorSet*                  pDescriptorCopies) {
    deviceObject := GetDevice(device)

    descriptorWrites := pDescriptorWrites[0:descriptorWriteCount]
    for i in (0 .. descriptorWriteCount) {
        descriptorWrite := descriptorWrites[i]
        descriptorWriteObject := GetDescriptorSet(descriptorWrite.dstSet)
        assert(descriptorWriteObject.device == device)
    }

    descriptorCopies := pDescriptorCopies[0:descriptorCopyCount]
    for i in (0 .. descriptorCopyCount) {
        descriptorCopy := descriptorCopies[i]
        descriptorCopyObject := GetDescriptorSet(descriptorCopy.dstSet)
        assert(descriptorCopyObject.device == device)
    }
}


// Framebuffer functions

@threadSafety("system")
cmd VkResult vkCreateFramebuffer(
        VkDevice                                    device,
        const VkFramebufferCreateInfo*              pCreateInfo,
        const VkAllocationCallbacks*                pAllocator,
        VkFramebuffer*                              pFramebuffer) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO)
    deviceObject := GetDevice(device)

    framebuffer := ?
    pFramebuffer[0] = framebuffer
    State.Framebuffers[framebuffer] = new!FramebufferObject(device: device)

    return ?
}

@threadSafety("system")
cmd void vkDestroyFramebuffer(
        VkDevice                                    device,
        VkFramebuffer                               framebuffer,
        const VkAllocationCallbacks*                pAllocator) {
    deviceObject := GetDevice(device)
    framebufferObject := GetFramebuffer(framebuffer)
    assert(framebufferObject.device == device)

    State.Framebuffers[framebuffer] = null
}


// Renderpass functions

@threadSafety("system")
cmd VkResult vkCreateRenderPass(
        VkDevice                                    device,
        const VkRenderPassCreateInfo*               pCreateInfo,
        const VkAllocationCallbacks*                pAllocator,
        VkRenderPass*                               pRenderPass) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO)
    deviceObject := GetDevice(device)

    renderpass := ?
    pRenderPass[0] = renderpass
    State.RenderPasses[renderpass] = new!RenderPassObject(device: device)

    return ?
}

@threadSafety("system")
cmd void vkDestroyRenderPass(
        VkDevice                                    device,
        VkRenderPass                                renderPass,
        const VkAllocationCallbacks*                pAllocator) {
    deviceObject := GetDevice(device)
    renderPassObject := GetRenderPass(renderPass)
    assert(renderPassObject.device == device)

    State.RenderPasses[renderPass] = null
}

cmd void vkGetRenderAreaGranularity(
        VkDevice                                    device,
        VkRenderPass                                renderPass,
        VkExtent2D*                                 pGranularity) {
    deviceObject := GetDevice(device)
    renderPassObject := GetRenderPass(renderPass)

    granularity := ?
    pGranularity[0] = granularity
}

// Command pool functions

cmd VkResult vkCreateCommandPool(
        VkDevice                                    device,
        const VkCommandPoolCreateInfo*              pCreateInfo,
        const VkAllocationCallbacks*                pAllocator,
        VkCommandPool*                              pCommandPool) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO)
    deviceObject := GetDevice(device)

    commandPool := ?
    pCommandPool[0] = commandPool
    State.CommandPools[commandPool] = new!CommandPoolObject(device: device)

    return ?
}

cmd void vkDestroyCommandPool(
        VkDevice                                    device,
        VkCommandPool                               commandPool,
        const VkAllocationCallbacks*                pAllocator) {
    deviceObject := GetDevice(device)
    commandPoolObject := GetCommandPool(commandPool)
    assert(commandPoolObject.device == device)

    State.CommandPools[commandPool] = null
}

cmd VkResult vkResetCommandPool(
        VkDevice                                    device,
        VkCommandPool                               commandPool,
        VkCommandPoolResetFlags                     flags) {
    deviceObject := GetDevice(device)
    commandPoolObject := GetCommandPool(commandPool)
    assert(commandPoolObject.device == device)

    return ?
}

// Command buffer functions

macro void bindCommandBuffer(VkCommandBuffer commandBuffer, any obj, VkDeviceMemory memory) {
    memoryObject := GetDeviceMemory(memory)
    memoryObject.boundCommandBuffers[commandBuffer] = commandBuffer

    commandBufferObject := GetCommandBuffer(commandBuffer)
    commandBufferObject.boundObjects[as!u64(obj)] = memory
}

macro void unbindCommandBuffer(VkCommandBuffer commandBuffer, any obj, VkDeviceMemory memory) {
    memoryObject := GetDeviceMemory(memory)
    memoryObject.boundCommandBuffers[commandBuffer] = null

    commandBufferObject := GetCommandBuffer(commandBuffer)
    commandBufferObject.boundObjects[as!u64(obj)] = null
}

@threadSafety("system")
cmd VkResult vkAllocateCommandBuffers(
        VkDevice                                    device,
        const VkCommandBufferAllocateInfo*          pAllocateInfo,
        VkCommandBuffer*                            pCommandBuffers) {
    assert(pAllocateInfo[0].sType == VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO)

    count := pAllocateInfo[0].commandBufferCount
    commandBuffers := pCommandBuffers[0:count]
    for i in (0 .. count) {
        commandBuffer := ?
        commandBuffers[i] = commandBuffer
        State.CommandBuffers[commandBuffer] = new!CommandBufferObject(device: device)
    }

    return ?
}

@threadSafety("system")
cmd void vkFreeCommandBuffers(
        VkDevice                                    device,
        VkCommandPool                               commandPool,
        u32                                         commandBufferCount,
        const VkCommandBuffer*                      pCommandBuffers) {
    deviceObject := GetDevice(device)

    commandBuffers := pCommandBuffers[0:commandBufferCount]
    for i in (0 .. commandBufferCount) {
        commandBufferObject := GetCommandBuffer(commandBuffers[i])
        assert(commandBufferObject.device == device)
        // TODO: iterate over boundObjects and clear memory bindings
        State.CommandBuffers[commandBuffers[i]] = null
    }
}

@threadSafety("app")
cmd VkResult vkBeginCommandBuffer(
        VkCommandBuffer                             commandBuffer,
        const VkCommandBufferBeginInfo*             pBeginInfo) {
    assert(pBeginInfo.sType == VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO)
    commandBufferObject := GetCommandBuffer(commandBuffer)

    // TODO: iterate over boundObjects and clear memory bindings

    return ?
}

@threadSafety("app")
cmd VkResult vkEndCommandBuffer(
        VkCommandBuffer                             commandBuffer) {
    commandBufferObject := GetCommandBuffer(commandBuffer)

    return ?
}

@threadSafety("app")
cmd VkResult vkResetCommandBuffer(
        VkCommandBuffer                             commandBuffer,
        VkCommandBufferResetFlags                   flags) {
    commandBufferObject := GetCommandBuffer(commandBuffer)

    // TODO: iterate over boundObjects and clear memory bindings

    return ?
}


// Command buffer building functions

@threadSafety("app")
cmd void vkCmdBindPipeline(
        VkCommandBuffer                             commandBuffer,
        VkPipelineBindPoint                         pipelineBindPoint,
        VkPipeline                                  pipeline) {
    commandBufferObject := GetCommandBuffer(commandBuffer)
    pipelineObject := GetPipeline(pipeline)
    assert(commandBufferObject.device == pipelineObject.device)

    queue := switch (pipelineBindPoint) {
        case VK_PIPELINE_BIND_POINT_COMPUTE:  VK_QUEUE_COMPUTE_BIT
        case VK_PIPELINE_BIND_POINT_GRAPHICS: VK_QUEUE_GRAPHICS_BIT
    }
    commandBufferObject.queueFlags = AddQueueFlag(commandBufferObject.queueFlags, queue)
}

@threadSafety("app")
cmd void vkCmdSetViewport(
        VkCommandBuffer                             commandBuffer,
        u32                                         firstViewport,
        u32                                         viewportCount,
        const VkViewport*                           pViewports) {
    commandBufferObject := GetCommandBuffer(commandBuffer)
    commandBufferObject.queueFlags = AddQueueFlag(commandBufferObject.queueFlags, VK_QUEUE_GRAPHICS_BIT)
}

@threadSafety("app")
cmd void vkCmdSetScissor(
        VkCommandBuffer                             commandBuffer,
        u32                                         firstScissor,
        u32                                         scissorCount,
        const VkRect2D*                             pScissors) {
    commandBufferObject := GetCommandBuffer(commandBuffer)
    commandBufferObject.queueFlags = AddQueueFlag(commandBufferObject.queueFlags, VK_QUEUE_GRAPHICS_BIT)
}

@threadSafety("app")
cmd void vkCmdSetLineWidth(
        VkCommandBuffer                             commandBuffer,
        f32                                         lineWidth) {
    commandBufferObject := GetCommandBuffer(commandBuffer)
    commandBufferObject.queueFlags = AddQueueFlag(commandBufferObject.queueFlags, VK_QUEUE_GRAPHICS_BIT)
}

@threadSafety("app")
cmd void vkCmdSetDepthBias(
        VkCommandBuffer                             commandBuffer,
        f32                                         depthBiasConstantFactor,
        f32                                         depthBiasClamp,
        f32                                         depthBiasSlopeFactor) {
    commandBufferObject := GetCommandBuffer(commandBuffer)
    commandBufferObject.queueFlags = AddQueueFlag(commandBufferObject.queueFlags, VK_QUEUE_GRAPHICS_BIT)
}

@threadSafety("app")
cmd void vkCmdSetBlendConstants(
        VkCommandBuffer                             commandBuffer,
        // TODO(jessehall): apic only supports 'const' on pointer types. Using
        // an annotation as a quick hack to pass this to the template without
        // having to modify the AST and semantic model.
        @readonly f32[4]                            blendConstants) {
    commandBufferObject := GetCommandBuffer(commandBuffer)
    commandBufferObject.queueFlags = AddQueueFlag(commandBufferObject.queueFlags, VK_QUEUE_GRAPHICS_BIT)
}

@threadSafety("app")
cmd void vkCmdSetDepthBounds(
        VkCommandBuffer                             commandBuffer,
        f32                                         minDepthBounds,
        f32                                         maxDepthBounds) {
    commandBufferObject := GetCommandBuffer(commandBuffer)
    commandBufferObject.queueFlags = AddQueueFlag(commandBufferObject.queueFlags, VK_QUEUE_GRAPHICS_BIT)
}

@threadSafety("app")
cmd void vkCmdSetStencilCompareMask(
        VkCommandBuffer                             commandBuffer,
        VkStencilFaceFlags                          faceMask,
        u32                                         compareMask) {
    commandBufferObject := GetCommandBuffer(commandBuffer)
    commandBufferObject.queueFlags = AddQueueFlag(commandBufferObject.queueFlags, VK_QUEUE_GRAPHICS_BIT)
}

@threadSafety("app")
cmd void vkCmdSetStencilWriteMask(
        VkCommandBuffer                             commandBuffer,
        VkStencilFaceFlags                          faceMask,
        u32                                         writeMask) {
    commandBufferObject := GetCommandBuffer(commandBuffer)
    commandBufferObject.queueFlags = AddQueueFlag(commandBufferObject.queueFlags, VK_QUEUE_GRAPHICS_BIT)
}

@threadSafety("app")
cmd void vkCmdSetStencilReference(
        VkCommandBuffer                             commandBuffer,
        VkStencilFaceFlags                          faceMask,
        u32                                         reference) {
    commandBufferObject := GetCommandBuffer(commandBuffer)
    commandBufferObject.queueFlags = AddQueueFlag(commandBufferObject.queueFlags, VK_QUEUE_GRAPHICS_BIT)
}

@threadSafety("app")
cmd void vkCmdBindDescriptorSets(
        VkCommandBuffer                             commandBuffer,
        VkPipelineBindPoint                         pipelineBindPoint,
        VkPipelineLayout                            layout,
        u32                                         firstSet,
        u32                                         descriptorSetCount,
        const VkDescriptorSet*                      pDescriptorSets,
        u32                                         dynamicOffsetCount,
        const u32*                                  pDynamicOffsets) {
    commandBufferObject := GetCommandBuffer(commandBuffer)

    descriptorSets := pDescriptorSets[0:descriptorSetCount]
    for i in (0 .. descriptorSetCount) {
        descriptorSet := descriptorSets[i]
        descriptorSetObject := GetDescriptorSet(descriptorSet)
        assert(commandBufferObject.device == descriptorSetObject.device)
    }

    dynamicOffsets := pDynamicOffsets[0:dynamicOffsetCount]
    for i in (0 .. dynamicOffsetCount) {
        dynamicOffset := dynamicOffsets[i]
    }

    queue := switch (pipelineBindPoint) {
        case VK_PIPELINE_BIND_POINT_COMPUTE:  VK_QUEUE_COMPUTE_BIT
        case VK_PIPELINE_BIND_POINT_GRAPHICS: VK_QUEUE_GRAPHICS_BIT
    }
    commandBufferObject.queueFlags = AddQueueFlag(commandBufferObject.queueFlags, queue)
}

@threadSafety("app")
cmd void vkCmdBindIndexBuffer(
        VkCommandBuffer                             commandBuffer,
        VkBuffer                                    buffer,
        VkDeviceSize                                offset,
        VkIndexType                                 indexType) {
    commandBufferObject := GetCommandBuffer(commandBuffer)
    bufferObject := GetBuffer(buffer)
    assert(commandBufferObject.device == bufferObject.device)

    bindCommandBuffer(commandBuffer, buffer, bufferObject.memory)

    commandBufferObject.queueFlags = AddQueueFlag(commandBufferObject.queueFlags, VK_QUEUE_GRAPHICS_BIT)
}

@threadSafety("app")
cmd void vkCmdBindVertexBuffers(
        VkCommandBuffer                             commandBuffer,
        u32                                         firstBinding,
        u32                                         bindingCount,
        const VkBuffer*                             pBuffers,
        const VkDeviceSize*                         pOffsets) {
    commandBufferObject := GetCommandBuffer(commandBuffer)

    // TODO: check if not [firstBinding:firstBinding+bindingCount]
    buffers := pBuffers[0:bindingCount]
    offsets := pOffsets[0:bindingCount]
    for i in (0 .. bindingCount) {
        buffer := buffers[i]
        offset := offsets[i]
        bufferObject := GetBuffer(buffer)
        assert(commandBufferObject.device == bufferObject.device)

        bindCommandBuffer(commandBuffer, buffer, bufferObject.memory)
    }

    commandBufferObject.queueFlags = AddQueueFlag(commandBufferObject.queueFlags, VK_QUEUE_GRAPHICS_BIT)
}

@threadSafety("app")
cmd void vkCmdDraw(
        VkCommandBuffer                             commandBuffer,
        u32                                         vertexCount,
        u32                                         instanceCount,
        u32                                         firstVertex,
        u32                                         firstInstance) {
    commandBufferObject := GetCommandBuffer(commandBuffer)

    commandBufferObject.queueFlags = AddQueueFlag(commandBufferObject.queueFlags, VK_QUEUE_GRAPHICS_BIT)
}

@threadSafety("app")
cmd void vkCmdDrawIndexed(
        VkCommandBuffer                             commandBuffer,
        u32                                         indexCount,
        u32                                         instanceCount,
        u32                                         firstIndex,
        s32                                         vertexOffset,
        u32                                         firstInstance) {
    commandBufferObject := GetCommandBuffer(commandBuffer)

    commandBufferObject.queueFlags = AddQueueFlag(commandBufferObject.queueFlags, VK_QUEUE_GRAPHICS_BIT)
}

@threadSafety("app")
cmd void vkCmdDrawIndirect(
        VkCommandBuffer                             commandBuffer,
        VkBuffer                                    buffer,
        VkDeviceSize                                offset,
        u32                                         drawCount,
        u32                                         stride) {
    commandBufferObject := GetCommandBuffer(commandBuffer)
    bufferObject := GetBuffer(buffer)
    assert(commandBufferObject.device == bufferObject.device)

    bindCommandBuffer(commandBuffer, buffer, bufferObject.memory)

    commandBufferObject.queueFlags = AddQueueFlag(commandBufferObject.queueFlags, VK_QUEUE_GRAPHICS_BIT)
}

@threadSafety("app")
cmd void vkCmdDrawIndexedIndirect(
        VkCommandBuffer                             commandBuffer,
        VkBuffer                                    buffer,
        VkDeviceSize                                offset,
        u32                                         drawCount,
        u32                                         stride) {
    commandBufferObject := GetCommandBuffer(commandBuffer)
    bufferObject := GetBuffer(buffer)
    assert(commandBufferObject.device == bufferObject.device)

    bindCommandBuffer(commandBuffer, buffer, bufferObject.memory)

    commandBufferObject.queueFlags = AddQueueFlag(commandBufferObject.queueFlags, VK_QUEUE_GRAPHICS_BIT)
}

@threadSafety("app")
cmd void vkCmdDispatch(
        VkCommandBuffer                             commandBuffer,
        u32                                         groupCountX,
        u32                                         groupCountY,
        u32                                         groupCountZ) {
    commandBufferObject := GetCommandBuffer(commandBuffer)

    commandBufferObject.queueFlags = AddQueueFlag(commandBufferObject.queueFlags, VK_QUEUE_COMPUTE_BIT)
}

@threadSafety("app")
cmd void vkCmdDispatchIndirect(
        VkCommandBuffer                             commandBuffer,
        VkBuffer                                    buffer,
        VkDeviceSize                                offset) {
    commandBufferObject := GetCommandBuffer(commandBuffer)
    bufferObject := GetBuffer(buffer)
    assert(commandBufferObject.device == bufferObject.device)

    bindCommandBuffer(commandBuffer, buffer, bufferObject.memory)

    commandBufferObject.queueFlags = AddQueueFlag(commandBufferObject.queueFlags, VK_QUEUE_COMPUTE_BIT)
}

@threadSafety("app")
cmd void vkCmdCopyBuffer(
        VkCommandBuffer                             commandBuffer,
        VkBuffer                                    srcBuffer,
        VkBuffer                                    dstBuffer,
        u32                                         regionCount,
        const VkBufferCopy*                         pRegions) {
    commandBufferObject := GetCommandBuffer(commandBuffer)
    srcBufferObject := GetBuffer(srcBuffer)
    dstBufferObject := GetBuffer(dstBuffer)
    assert(commandBufferObject.device == srcBufferObject.device)
    assert(commandBufferObject.device == dstBufferObject.device)

    regions := pRegions[0:regionCount]
    for i in (0 .. regionCount) {
        region := regions[i]
    }

    bindCommandBuffer(commandBuffer, srcBuffer, srcBufferObject.memory)
    bindCommandBuffer(commandBuffer, dstBuffer, dstBufferObject.memory)

    commandBufferObject.queueFlags = AddQueueFlag(commandBufferObject.queueFlags, VK_QUEUE_TRANSFER_BIT)
}

@threadSafety("app")
cmd void vkCmdCopyImage(
        VkCommandBuffer                             commandBuffer,
        VkImage                                     srcImage,
        VkImageLayout                               srcImageLayout,
        VkImage                                     dstImage,
        VkImageLayout                               dstImageLayout,
        u32                                         regionCount,
        const VkImageCopy*                          pRegions) {
    commandBufferObject := GetCommandBuffer(commandBuffer)
    srcImageObject := GetImage(srcImage)
    dstImageObject := GetImage(dstImage)
    assert(commandBufferObject.device == srcImageObject.device)
    assert(commandBufferObject.device == dstImageObject.device)

    regions := pRegions[0:regionCount]
    for i in (0 .. regionCount) {
        region := regions[i]
    }

    bindCommandBuffer(commandBuffer, srcImage, srcImageObject.memory)
    bindCommandBuffer(commandBuffer, dstImage, dstImageObject.memory)

    commandBufferObject.queueFlags = AddQueueFlag(commandBufferObject.queueFlags, VK_QUEUE_TRANSFER_BIT)
}

@threadSafety("app")
cmd void vkCmdBlitImage(
        VkCommandBuffer                             commandBuffer,
        VkImage                                     srcImage,
        VkImageLayout                               srcImageLayout,
        VkImage                                     dstImage,
        VkImageLayout                               dstImageLayout,
        u32                                         regionCount,
        const VkImageBlit*                          pRegions,
        VkFilter                                    filter) {
    commandBufferObject := GetCommandBuffer(commandBuffer)
    srcImageObject := GetImage(srcImage)
    dstImageObject := GetImage(dstImage)
    assert(commandBufferObject.device == srcImageObject.device)
    assert(commandBufferObject.device == dstImageObject.device)

    regions := pRegions[0:regionCount]
    for i in (0 .. regionCount) {
        region := regions[i]
    }

    bindCommandBuffer(commandBuffer, srcImage, srcImageObject.memory)
    bindCommandBuffer(commandBuffer, dstImage, dstImageObject.memory)

    commandBufferObject.queueFlags = AddQueueFlag(commandBufferObject.queueFlags, VK_QUEUE_GRAPHICS_BIT)
}

@threadSafety("app")
cmd void vkCmdCopyBufferToImage(
        VkCommandBuffer                             commandBuffer,
        VkBuffer                                    srcBuffer,
        VkImage                                     dstImage,
        VkImageLayout                               dstImageLayout,
        u32                                         regionCount,
        const VkBufferImageCopy*                    pRegions) {
    commandBufferObject := GetCommandBuffer(commandBuffer)
    srcBufferObject := GetBuffer(srcBuffer)
    dstImageObject := GetImage(dstImage)
    assert(commandBufferObject.device == srcBufferObject.device)
    assert(commandBufferObject.device == dstImageObject.device)

    regions := pRegions[0:regionCount]
    for i in (0 .. regionCount) {
        region := regions[i]
    }

    bindCommandBuffer(commandBuffer, srcBuffer, srcBufferObject.memory)
    bindCommandBuffer(commandBuffer, dstImage, dstImageObject.memory)

    commandBufferObject.queueFlags = AddQueueFlag(commandBufferObject.queueFlags, VK_QUEUE_TRANSFER_BIT)
}

@threadSafety("app")
cmd void vkCmdCopyImageToBuffer(
        VkCommandBuffer                             commandBuffer,
        VkImage                                     srcImage,
        VkImageLayout                               srcImageLayout,
        VkBuffer                                    dstBuffer,
        u32                                         regionCount,
        const VkBufferImageCopy*                    pRegions) {
    commandBufferObject := GetCommandBuffer(commandBuffer)
    srcImageObject := GetImage(srcImage)
    dstBufferObject := GetBuffer(dstBuffer)
    assert(commandBufferObject.device == srcImageObject.device)
    assert(commandBufferObject.device == dstBufferObject.device)

    regions := pRegions[0:regionCount]
    for i in (0 .. regionCount) {
        region := regions[i]
    }

    bindCommandBuffer(commandBuffer, srcImage, srcImageObject.memory)
    bindCommandBuffer(commandBuffer, dstBuffer, dstBufferObject.memory)

    commandBufferObject.queueFlags = AddQueueFlag(commandBufferObject.queueFlags, VK_QUEUE_TRANSFER_BIT)
}

@threadSafety("app")
cmd void vkCmdUpdateBuffer(
        VkCommandBuffer                             commandBuffer,
        VkBuffer                                    dstBuffer,
        VkDeviceSize                                dstOffset,
        VkDeviceSize                                dataSize,
        const void*                                 pData) {
    commandBufferObject := GetCommandBuffer(commandBuffer)
    dstBufferObject := GetBuffer(dstBuffer)
    assert(commandBufferObject.device == dstBufferObject.device)

    data := pData[0:dataSize]

    bindCommandBuffer(commandBuffer, dstBuffer, dstBufferObject.memory)

    commandBufferObject.queueFlags = AddQueueFlag(commandBufferObject.queueFlags, VK_QUEUE_TRANSFER_BIT)
}

@threadSafety("app")
cmd void vkCmdFillBuffer(
        VkCommandBuffer                             commandBuffer,
        VkBuffer                                    dstBuffer,
        VkDeviceSize                                dstOffset,
        VkDeviceSize                                size,
        u32                                         data) {
    commandBufferObject := GetCommandBuffer(commandBuffer)
    dstBufferObject := GetBuffer(dstBuffer)
    assert(commandBufferObject.device == dstBufferObject.device)

    commandBufferObject.queueFlags = AddQueueFlag(commandBufferObject.queueFlags, VK_QUEUE_TRANSFER_BIT)
}

@threadSafety("app")
cmd void vkCmdClearColorImage(
        VkCommandBuffer                             commandBuffer,
        VkImage                                     image,
        VkImageLayout                               imageLayout,
        const VkClearColorValue*                    pColor,
        u32                                         rangeCount,
        const VkImageSubresourceRange*              pRanges) {
    commandBufferObject := GetCommandBuffer(commandBuffer)
    imageObject := GetImage(image)
    assert(commandBufferObject.device == imageObject.device)

    ranges := pRanges[0:rangeCount]
    for i in (0 .. rangeCount) {
        range := ranges[i]
    }

    bindCommandBuffer(commandBuffer, image, imageObject.memory)

    commandBufferObject.queueFlags = AddQueueFlag(commandBufferObject.queueFlags, VK_QUEUE_GRAPHICS_BIT)
}

@threadSafety("app")
cmd void vkCmdClearDepthStencilImage(
        VkCommandBuffer                             commandBuffer,
        VkImage                                     image,
        VkImageLayout                               imageLayout,
        const VkClearDepthStencilValue*             pDepthStencil,
        u32                                         rangeCount,
        const VkImageSubresourceRange*              pRanges) {
    commandBufferObject := GetCommandBuffer(commandBuffer)
    imageObject := GetImage(image)
    assert(commandBufferObject.device == imageObject.device)

    ranges := pRanges[0:rangeCount]
    for i in (0 .. rangeCount) {
        range := ranges[i]
    }

    bindCommandBuffer(commandBuffer, image, imageObject.memory)

    commandBufferObject.queueFlags = AddQueueFlag(commandBufferObject.queueFlags, VK_QUEUE_GRAPHICS_BIT)
}

@threadSafety("app")
cmd void vkCmdClearAttachments(
        VkCommandBuffer                             commandBuffer,
        u32                                         attachmentCount,
        const VkClearAttachment*                    pAttachments,
        u32                                         rectCount,
        const VkClearRect*                          pRects) {
    commandBufferObject := GetCommandBuffer(commandBuffer)

    rects := pRects[0:rectCount]
    for i in (0 .. rectCount) {
        rect := rects[i]
    }

    commandBufferObject.queueFlags = AddQueueFlag(commandBufferObject.queueFlags, VK_QUEUE_GRAPHICS_BIT)
}

@threadSafety("app")
cmd void vkCmdResolveImage(
        VkCommandBuffer                             commandBuffer,
        VkImage                                     srcImage,
        VkImageLayout                               srcImageLayout,
        VkImage                                     dstImage,
        VkImageLayout                               dstImageLayout,
        u32                                         regionCount,
        const VkImageResolve*                       pRegions) {
    commandBufferObject := GetCommandBuffer(commandBuffer)
    srcImageObject := GetImage(srcImage)
    dstImageObject := GetImage(dstImage)
    assert(commandBufferObject.device == srcImageObject.device)
    assert(commandBufferObject.device == dstImageObject.device)

    regions := pRegions[0:regionCount]
    for i in (0 .. regionCount) {
        region := regions[i]
    }

    bindCommandBuffer(commandBuffer, srcImage, srcImageObject.memory)
    bindCommandBuffer(commandBuffer, dstImage, dstImageObject.memory)

    commandBufferObject.queueFlags = AddQueueFlag(commandBufferObject.queueFlags, VK_QUEUE_GRAPHICS_BIT)
}

@threadSafety("app")
cmd void vkCmdSetEvent(
        VkCommandBuffer                             commandBuffer,
        VkEvent                                     event,
        VkPipelineStageFlags                        stageMask) {
    commandBufferObject := GetCommandBuffer(commandBuffer)
    eventObject := GetEvent(event)
    assert(commandBufferObject.device == eventObject.device)
}

@threadSafety("app")
cmd void vkCmdResetEvent(
        VkCommandBuffer                             commandBuffer,
        VkEvent                                     event,
        VkPipelineStageFlags                        stageMask) {
    commandBufferObject := GetCommandBuffer(commandBuffer)
    eventObject := GetEvent(event)
    assert(commandBufferObject.device == eventObject.device)
}

@threadSafety("app")
cmd void vkCmdWaitEvents(
        VkCommandBuffer                             commandBuffer,
        u32                                         eventCount,
        const VkEvent*                              pEvents,
        VkPipelineStageFlags                        srcStageMask,
        VkPipelineStageFlags                        dstStageMask,
        u32                                         memoryBarrierCount,
        const VkMemoryBarrier*                      pMemoryBarriers,
        u32                                         bufferMemoryBarrierCount,
        const VkBufferMemoryBarrier*                pBufferMemoryBarriers,
        u32                                         imageMemoryBarrierCount,
        const VkImageMemoryBarrier*                 pImageMemoryBarriers) {
    commandBufferObject := GetCommandBuffer(commandBuffer)

    events := pEvents[0:eventCount]
    for i in (0 .. eventCount) {
        event := events[i]
        eventObject := GetEvent(event)
        assert(commandBufferObject.device == eventObject.device)
    }

    memoryBarriers := pMemoryBarriers[0:memoryBarrierCount]
    for i in (0 .. memoryBarrierCount) {
        memoryBarrier := memoryBarriers[i]
    }
    bufferMemoryBarriers := pBufferMemoryBarriers[0:bufferMemoryBarrierCount]
    for i in (0 .. bufferMemoryBarrierCount) {
        bufferMemoryBarrier := bufferMemoryBarriers[i]
        bufferObject := GetBuffer(bufferMemoryBarrier.buffer)
        assert(bufferObject.device == commandBufferObject.device)
    }
    imageMemoryBarriers := pImageMemoryBarriers[0:imageMemoryBarrierCount]
    for i in (0 .. imageMemoryBarrierCount) {
        imageMemoryBarrier := imageMemoryBarriers[i]
        imageObject := GetImage(imageMemoryBarrier.image)
        assert(imageObject.device == commandBufferObject.device)
    }
}

@threadSafety("app")
cmd void vkCmdPipelineBarrier(
        VkCommandBuffer                             commandBuffer,
        VkPipelineStageFlags                        srcStageMask,
        VkPipelineStageFlags                        dstStageMask,
        VkDependencyFlags                           dependencyFlags,
        u32                                         memoryBarrierCount,
        const VkMemoryBarrier*                      pMemoryBarriers,
        u32                                         bufferMemoryBarrierCount,
        const VkBufferMemoryBarrier*                pBufferMemoryBarriers,
        u32                                         imageMemoryBarrierCount,
        const VkImageMemoryBarrier*                 pImageMemoryBarriers) {
    commandBufferObject := GetCommandBuffer(commandBuffer)

    memoryBarriers := pMemoryBarriers[0:memoryBarrierCount]
    for i in (0 .. memoryBarrierCount) {
        memoryBarrier := memoryBarriers[i]
    }
    bufferMemoryBarriers := pBufferMemoryBarriers[0:bufferMemoryBarrierCount]
    for i in (0 .. bufferMemoryBarrierCount) {
        bufferMemoryBarrier := bufferMemoryBarriers[i]
        bufferObject := GetBuffer(bufferMemoryBarrier.buffer)
        assert(bufferObject.device == commandBufferObject.device)
    }
    imageMemoryBarriers := pImageMemoryBarriers[0:imageMemoryBarrierCount]
    for i in (0 .. imageMemoryBarrierCount) {
        imageMemoryBarrier := imageMemoryBarriers[i]
        imageObject := GetImage(imageMemoryBarrier.image)
        assert(imageObject.device == commandBufferObject.device)
    }
}

@threadSafety("app")
cmd void vkCmdBeginQuery(
        VkCommandBuffer                             commandBuffer,
        VkQueryPool                                 queryPool,
        u32                                         query,
        VkQueryControlFlags                         flags) {
    commandBufferObject := GetCommandBuffer(commandBuffer)
    queryPoolObject := GetQueryPool(queryPool)
    assert(commandBufferObject.device == queryPoolObject.device)
}

@threadSafety("app")
cmd void vkCmdEndQuery(
        VkCommandBuffer                             commandBuffer,
        VkQueryPool                                 queryPool,
        u32                                         query) {
    commandBufferObject := GetCommandBuffer(commandBuffer)
    queryPoolObject := GetQueryPool(queryPool)
    assert(commandBufferObject.device == queryPoolObject.device)
}

@threadSafety("app")
cmd void vkCmdResetQueryPool(
        VkCommandBuffer                             commandBuffer,
        VkQueryPool                                 queryPool,
        u32                                         firstQuery,
        u32                                         queryCount) {
    commandBufferObject := GetCommandBuffer(commandBuffer)
    queryPoolObject := GetQueryPool(queryPool)
    assert(commandBufferObject.device == queryPoolObject.device)
}

@threadSafety("app")
cmd void vkCmdWriteTimestamp(
        VkCommandBuffer                             commandBuffer,
        VkPipelineStageFlagBits                     pipelineStage,
        VkQueryPool                                 queryPool,
        u32                                         query) {
    commandBufferObject := GetCommandBuffer(commandBuffer)
    queryPoolObject := GetQueryPool(queryPool)
    assert(commandBufferObject.device == queryPoolObject.device)
}

@threadSafety("app")
cmd void vkCmdCopyQueryPoolResults(
        VkCommandBuffer                             commandBuffer,
        VkQueryPool                                 queryPool,
        u32                                         firstQuery,
        u32                                         queryCount,
        VkBuffer                                    dstBuffer,
        VkDeviceSize                                dstOffset,
        VkDeviceSize                                stride,
        VkQueryResultFlags                          flags) {
    commandBufferObject := GetCommandBuffer(commandBuffer)
    queryPoolObject := GetQueryPool(queryPool)
    dstBufferObject := GetBuffer(dstBuffer)
    assert(commandBufferObject.device == queryPoolObject.device)
    assert(commandBufferObject.device == dstBufferObject.device)
}

cmd void vkCmdPushConstants(
        VkCommandBuffer                             commandBuffer,
        VkPipelineLayout                            layout,
        VkShaderStageFlags                          stageFlags,
        u32                                         offset,
        u32                                         size,
        const void*                                 pValues) {
    commandBufferObject := GetCommandBuffer(commandBuffer)
    layoutObject := GetPipelineLayout(layout)
    assert(commandBufferObject.device == layoutObject.device)
}

@threadSafety("app")
cmd void vkCmdBeginRenderPass(
        VkCommandBuffer                             commandBuffer,
        const VkRenderPassBeginInfo*                pRenderPassBegin,
        VkSubpassContents                           contents) {
    commandBufferObject := GetCommandBuffer(commandBuffer)
    renderPassObject := GetRenderPass(pRenderPassBegin.renderPass)
    framebufferObject := GetFramebuffer(pRenderPassBegin.framebuffer)
    assert(commandBufferObject.device == renderPassObject.device)
    assert(commandBufferObject.device == framebufferObject.device)

    commandBufferObject.queueFlags = AddQueueFlag(commandBufferObject.queueFlags, VK_QUEUE_GRAPHICS_BIT)
}

cmd void vkCmdNextSubpass(
        VkCommandBuffer                             commandBuffer,
        VkSubpassContents                           contents) {
    commandBufferObject := GetCommandBuffer(commandBuffer)
}

@threadSafety("app")
cmd void vkCmdEndRenderPass(
        VkCommandBuffer                             commandBuffer) {
    commandBufferObject := GetCommandBuffer(commandBuffer)

    commandBufferObject.queueFlags = AddQueueFlag(commandBufferObject.queueFlags, VK_QUEUE_GRAPHICS_BIT)
}

cmd void vkCmdExecuteCommands(
        VkCommandBuffer                             commandBuffer,
        u32                                         commandBufferCount,
        const VkCommandBuffer*                      pCommandBuffers) {
    commandBufferObject := GetCommandBuffer(commandBuffer)

    commandBuffers := pCommandBuffers[0:commandBufferCount]
    for i in (0 .. commandBufferCount) {
        secondaryCommandBuffer := commandBuffers[i]
        secondaryCommandBufferObject := GetCommandBuffer(secondaryCommandBuffer)
        assert(commandBufferObject.device == secondaryCommandBufferObject.device)
    }
}

//@vulkan1_1 functions

@vulkan1_1
cmd VkResult vkEnumerateInstanceVersion(
        u32*                                            pApiVersion) {
    return ?
}

@vulkan1_1
cmd VkResult vkBindBufferMemory2(
        VkDevice                                        device,
        u32                                             bindInfoCount,
        const VkBindBufferMemoryInfo*                   pBindInfos) {
    return ?
}

@vulkan1_1
cmd VkResult vkBindImageMemory2(
        VkDevice                                        device,
        u32                                             bindInfoCount,
        const VkBindImageMemoryInfo*                    pBindInfos) {
    return ?
}

@vulkan1_1
cmd void vkGetDeviceGroupPeerMemoryFeatures(
        VkDevice                                    device,
        u32                                         heapIndex,
        u32                                         localDeviceIndex,
        u32                                         remoteDeviceIndex,
        VkPeerMemoryFeatureFlags*                   pPeerMemoryFeatures) {
}

@vulkan1_1
cmd void vkCmdSetDeviceMask(
        VkCommandBuffer                             commandBuffer,
        u32                                         deviceMask) {
}

@vulkan1_1
cmd void vkCmdDispatchBase(
        VkCommandBuffer                             commandBuffer,
        u32                                         baseGroupX,
        u32                                         baseGroupY,
        u32                                         baseGroupZ,
        u32                                         groupCountX,
        u32                                         groupCountY,
        u32                                         groupCountZ) {
}

@threadSafety("system")
@vulkan1_1
cmd VkResult vkEnumeratePhysicalDeviceGroups(
        VkInstance                                  instance,
        u32*                                        pPhysicalDeviceGroupCount,
        VkPhysicalDeviceGroupProperties*            pPhysicalDeviceGroupProperties) {
    instanceObject := GetInstance(instance)

    physicalDeviceGroupCount := as!u32(?)
    pPhysicalDeviceGroupCount[0] = physicalDeviceGroupCount
    physicalDevices := pPhysicalDeviceGroupProperties[0:physicalDeviceGroupCount]

    for i in (0 .. physicalDeviceGroupCount) {
        physicalDevice := ?
        physicalDevices[i] = physicalDevice
        if !(physicalDevice in State.PhysicalDevices) {
            State.PhysicalDevices[physicalDevice] = new!PhysicalDeviceObject(instance: instance)
        }
    }

    return ?
}

@vulkan1_1
cmd void vkGetImageMemoryRequirements2(
        VkDevice                                    device,
        const VkImageMemoryRequirementsInfo2*       pInfo,
        VkMemoryRequirements2*                      pMemoryRequirements) {
}

@vulkan1_1
cmd void vkGetBufferMemoryRequirements2(
        VkDevice                                    device,
        const VkBufferMemoryRequirementsInfo2*      pInfo,
        VkMemoryRequirements2*                      pMemoryRequirements) {
}

@vulkan1_1
cmd void vkGetImageSparseMemoryRequirements2(
        VkDevice                                        device,
        const VkImageSparseMemoryRequirementsInfo2*     pInfo,
        u32*                                            pSparseMemoryRequirementCount,
        VkSparseImageMemoryRequirements2*               pSparseMemoryRequirements) {
}

@vulkan1_1
cmd void vkGetPhysicalDeviceFeatures2(
        VkPhysicalDevice                            physicalDevice,
        VkPhysicalDeviceFeatures2*                  pFeatures) {
}

@vulkan1_1
cmd void vkGetPhysicalDeviceProperties2(
        VkPhysicalDevice                            physicalDevice,
        VkPhysicalDeviceProperties2*                pProperties) {
}

@vulkan1_1
cmd void vkGetPhysicalDeviceFormatProperties2(
        VkPhysicalDevice                            physicalDevice,
        VkFormat                                    format,
        VkFormatProperties2*                        pFormatProperties) {
}

@vulkan1_1
cmd VkResult vkGetPhysicalDeviceImageFormatProperties2(
        VkPhysicalDevice                            physicalDevice,
        const VkPhysicalDeviceImageFormatInfo2*     pImageFormatInfo,
        VkImageFormatProperties2*                   pImageFormatProperties) {
    return ?
}

@vulkan1_1
cmd void vkGetPhysicalDeviceQueueFamilyProperties2(
        VkPhysicalDevice                            physicalDevice,
        u32*                                        pQueueFamilyPropertyCount,
        VkQueueFamilyProperties2*                   pQueueFamilyProperties) {
}

@vulkan1_1
cmd void vkGetPhysicalDeviceMemoryProperties2(
        VkPhysicalDevice                            physicalDevice,
        VkPhysicalDeviceMemoryProperties2*          pMemoryProperties) {
}

@vulkan1_1
cmd void vkGetPhysicalDeviceSparseImageFormatProperties2(
        VkPhysicalDevice                                    physicalDevice,
        const VkPhysicalDeviceSparseImageFormatInfo2*       pFormatInfo,
        u32*                                                pPropertyCount,
        VkSparseImageFormatProperties2*                     pProperties) {
}

@vulkan1_1
cmd void vkTrimCommandPool(
        VkDevice                                    device,
        VkCommandPool                               commandPool,
        VkCommandPoolTrimFlags                      flags) {
}


@vulkan1_1
cmd void vkGetDeviceQueue2(
        VkDevice                                    device,
        const VkDeviceQueueInfo2*                   pQueueInfo,
        VkQueue*                                    pQueue) {
    deviceObject := GetDevice(device)

    queue := ?
    pQueue[0] = queue

    if !(queue in State.Queues) {
        State.Queues[queue] = new!QueueObject(device: device)
    }
}

@vulkan1_1
cmd VkResult vkCreateSamplerYcbcrConversion(
        VkDevice                                        device,
        const VkSamplerYcbcrConversionCreateInfo*       pCreateInfo,
        const VkAllocationCallbacks*                    pAllocator,
        VkSamplerYcbcrConversion*                       pYcbcrConversion) {
    return ?
}

@vulkan1_1
cmd void vkDestroySamplerYcbcrConversion(
        VkDevice                                        device,
        VkSamplerYcbcrConversion                        ycbcrConversion,
        const VkAllocationCallbacks*                    pAllocator) {
}

@vulkan1_1
cmd VkResult vkCreateDescriptorUpdateTemplate(
        VkDevice                                    device,
        const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
        const VkAllocationCallbacks*                pAllocator,
        VkDescriptorUpdateTemplate*                 pDescriptorUpdateTemplate) {
    return ?
}

@vulkan1_1
cmd void vkDestroyDescriptorUpdateTemplate(
        VkDevice                                    device,
        VkDescriptorUpdateTemplate                  descriptorUpdateTemplate,
        const VkAllocationCallbacks*                pAllocator) {
}

@vulkan1_1
cmd void vkUpdateDescriptorSetWithTemplate(
        VkDevice                                    device,
        VkDescriptorSet                             descriptorSet,
        VkDescriptorUpdateTemplate                  descriptorUpdateTemplate,
        const void*                                 pData) {
}

@vulkan1_1
cmd void vkGetPhysicalDeviceExternalBufferProperties(
        VkPhysicalDevice                                physicalDevice,
        const VkPhysicalDeviceExternalBufferInfo*       pExternalBufferInfo,
        VkExternalBufferProperties*                     pExternalBufferProperties) {
}

@vulkan1_1
cmd void vkGetPhysicalDeviceExternalFenceProperties(
        VkPhysicalDevice                            physicalDevice,
        const VkPhysicalDeviceExternalFenceInfo*    pExternalFenceInfo,
        VkExternalFenceProperties*                  pExternalFenceProperties) {
}

@vulkan1_1
cmd void vkGetPhysicalDeviceExternalSemaphoreProperties(
        VkPhysicalDevice                                physicalDevice,
        const VkPhysicalDeviceExternalSemaphoreInfo*    pExternalSemaphoreInfo,
        VkExternalSemaphoreProperties*                  pExternalSemaphoreProperties) {
}

@vulkan1_1
cmd void vkGetDescriptorSetLayoutSupport(
        VkDevice                                    device,
        const VkDescriptorSetLayoutCreateInfo*      pCreateInfo,
        VkDescriptorSetLayoutSupport*               pSupport) {
}


@extension("VK_KHR_surface") // 1
cmd void vkDestroySurfaceKHR(
        VkInstance                                  instance,
        VkSurfaceKHR                                surface,
        const VkAllocationCallbacks*                pAllocator) {
    instanceObject := GetInstance(instance)
    surfaceObject := GetSurface(surface)
    assert(surfaceObject.instance == instance)

    State.Surfaces[surface] = null
}

@extension("VK_KHR_surface") // 1
cmd VkResult vkGetPhysicalDeviceSurfaceSupportKHR(
        VkPhysicalDevice                            physicalDevice,
        u32                                         queueFamilyIndex,
        VkSurfaceKHR                                surface,
        VkBool32*                                   pSupported) {
    physicalDeviceObject := GetPhysicalDevice(physicalDevice)

    return ?
}

@extension("VK_KHR_surface") // 1
cmd VkResult vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
        VkPhysicalDevice                            physicalDevice,
        VkSurfaceKHR                                surface,
        VkSurfaceCapabilitiesKHR*                   pSurfaceCapabilities) {
    physicalDeviceObject := GetPhysicalDevice(physicalDevice)

    surfaceCapabilities := ?
    pSurfaceCapabilities[0] = surfaceCapabilities

    return ?
}

@extension("VK_KHR_surface") // 1
cmd VkResult vkGetPhysicalDeviceSurfaceFormatsKHR(
        VkPhysicalDevice                            physicalDevice,
        VkSurfaceKHR                                surface,
        u32*                                        pSurfaceFormatCount,
        VkSurfaceFormatKHR*                         pSurfaceFormats) {
    physicalDeviceObject := GetPhysicalDevice(physicalDevice)

    count := as!u32(?)
    pSurfaceFormatCount[0] = count
    surfaceFormats := pSurfaceFormats[0:count]

    for i in (0 .. count) {
        surfaceFormat := ?
        surfaceFormats[i] = surfaceFormat
    }

    return ?
}

@extension("VK_KHR_surface") // 1
cmd VkResult vkGetPhysicalDeviceSurfacePresentModesKHR(
        VkPhysicalDevice                            physicalDevice,
        VkSurfaceKHR                                surface,
        u32*                                        pPresentModeCount,
        VkPresentModeKHR*                           pPresentModes) {
    physicalDeviceObject := GetPhysicalDevice(physicalDevice)

    count := as!u32(?)
    pPresentModeCount[0] = count
    presentModes := pPresentModes[0:count]

    for i in (0 .. count) {
        presentMode := ?
        presentModes[i] = presentMode
    }

    return ?
}

@extension("VK_KHR_swapchain") // 2
cmd VkResult vkCreateSwapchainKHR(
        VkDevice                                 device,
        const VkSwapchainCreateInfoKHR*          pCreateInfo,
        const VkAllocationCallbacks*             pAllocator,
        VkSwapchainKHR*                          pSwapchain) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR)
    deviceObject := GetDevice(device)

    swapchain := ?
    pSwapchain[0] = swapchain
    State.Swapchains[swapchain] = new!SwapchainObject(device: device)

    return ?
}

@extension("VK_KHR_swapchain") // 2
cmd void vkDestroySwapchainKHR(
        VkDevice                                 device,
        VkSwapchainKHR                           swapchain,
        const VkAllocationCallbacks*             pAllocator) {
    deviceObject := GetDevice(device)
    swapchainObject := GetSwapchain(swapchain)
    assert(swapchainObject.device == device)

    State.Swapchains[swapchain] = null
}

@extension("VK_KHR_swapchain") // 2
cmd VkResult vkGetSwapchainImagesKHR(
        VkDevice                                 device,
        VkSwapchainKHR                           swapchain,
        u32*                                     pSwapchainImageCount,
        VkImage*                                 pSwapchainImages) {
    deviceObject := GetDevice(device)

    count := as!u32(?)
    pSwapchainImageCount[0] = count
    swapchainImages := pSwapchainImages[0:count]

    for i in (0 .. count) {
        swapchainImage := ?
        swapchainImages[i] = swapchainImage
        State.Images[swapchainImage] = new!ImageObject(device: device)
    }

    return ?
}

@extension("VK_KHR_swapchain") // 2
cmd VkResult vkAcquireNextImageKHR(
        VkDevice                                 device,
        VkSwapchainKHR                           swapchain,
        u64                                      timeout,
        VkSemaphore                              semaphore,
        VkFence                                  fence,
        u32*                                     pImageIndex) {
    deviceObject := GetDevice(device)
    swapchainObject := GetSwapchain(swapchain)

    imageIndex := ?
    pImageIndex[0] = imageIndex

    return ?
}

@extension("VK_KHR_swapchain") // 2
cmd VkResult vkQueuePresentKHR(
        VkQueue                                  queue,
        const VkPresentInfoKHR*                  pPresentInfo) {
    queueObject := GetQueue(queue)

    presentInfo := ?
    pPresentInfo[0] = presentInfo

    return ?
}

@vulkan1_1
@extension("VK_KHR_swapchain") // 2
cmd VkResult vkGetDeviceGroupPresentCapabilitiesKHR(
        VkDevice                                    device,
        VkDeviceGroupPresentCapabilitiesKHR*        pDeviceGroupPresentCapabilities) {
    return ?
}

@vulkan1_1
@extension("VK_KHR_swapchain") // 2
cmd VkResult vkGetDeviceGroupSurfacePresentModesKHR(
        VkDevice                                    device,
        VkSurfaceKHR                                surface,
        VkDeviceGroupPresentModeFlagsKHR*           pModes) {
    return ?
}

@vulkan1_1
@extension("VK_KHR_swapchain") // 2
cmd VkResult vkGetPhysicalDevicePresentRectanglesKHR(
        VkPhysicalDevice                            physicalDevice,
        VkSurfaceKHR                                surface,
        u32*                                        pRectCount,
        VkRect2D*                                   pRects) {
    return ?
}

@vulkan1_1
@extension("VK_KHR_swapchain") // 2
cmd VkResult vkAcquireNextImage2KHR(
        VkDevice                                    device,
        const VkAcquireNextImageInfoKHR*            pAcquireInfo,
        u32*                                        pImageIndex) {
    return ?
}

@extension("VK_KHR_display") // 3
cmd VkResult vkGetPhysicalDeviceDisplayPropertiesKHR(
        VkPhysicalDevice                        physicalDevice,
        u32*                                    pPropertyCount,
        VkDisplayPropertiesKHR*                 pProperties) {
    physicalDeviceObject := GetPhysicalDevice(physicalDevice)
    return ?
}

@extension("VK_KHR_display") // 3
cmd VkResult vkGetPhysicalDeviceDisplayPlanePropertiesKHR(
        VkPhysicalDevice                        physicalDevice,
        u32*                                    pPropertyCount,
        VkDisplayPlanePropertiesKHR*            pProperties) {
    physicalDeviceObject := GetPhysicalDevice(physicalDevice)
    return ?
}

@extension("VK_KHR_display") // 3
cmd VkResult vkGetDisplayPlaneSupportedDisplaysKHR(
        VkPhysicalDevice                        physicalDevice,
        u32                                     planeIndex,
        u32*                                    pDisplayCount,
        VkDisplayKHR*                           pDisplays) {
    physicalDeviceObject := GetPhysicalDevice(physicalDevice)
    return ?
}

@extension("VK_KHR_display") // 3
cmd VkResult vkGetDisplayModePropertiesKHR(
        VkPhysicalDevice                        physicalDevice,
        VkDisplayKHR                            display,
        u32*                                    pPropertyCount,
        VkDisplayModePropertiesKHR*             pProperties) {
    physicalDeviceObject := GetPhysicalDevice(physicalDevice)
    return ?
}

@extension("VK_KHR_display") // 3
cmd VkResult vkCreateDisplayModeKHR(
        VkPhysicalDevice                        physicalDevice,
        VkDisplayKHR                            display,
        const VkDisplayModeCreateInfoKHR*       pCreateInfo,
        const VkAllocationCallbacks*            pAllocator,
        VkDisplayModeKHR*                       pMode) {
    physicalDeviceObject := GetPhysicalDevice(physicalDevice)
    return ?
}

@extension("VK_KHR_display") // 3
cmd VkResult vkGetDisplayPlaneCapabilitiesKHR(
        VkPhysicalDevice                        physicalDevice,
        VkDisplayModeKHR                        mode,
        u32                                     planeIndex,
        VkDisplayPlaneCapabilitiesKHR*          pCapabilities) {
    physicalDeviceObject := GetPhysicalDevice(physicalDevice)
    return ?
}

@extension("VK_KHR_display") // 3
cmd VkResult vkCreateDisplayPlaneSurfaceKHR(
        VkInstance                              instance,
        const VkDisplaySurfaceCreateInfoKHR*    pCreateInfo,
        const VkAllocationCallbacks*            pAllocator,
        VkSurfaceKHR*                           pSurface) {
    return ?
}

@extension("VK_KHR_display_swapchain") // 4
cmd VkResult vkCreateSharedSwapchainsKHR(
        VkDevice                                device,
        u32                                     swapchainCount,
        const VkSwapchainCreateInfoKHR*         pCreateInfos,
        const VkAllocationCallbacks*            pAllocator,
        VkSwapchainKHR*                         pSwapchains) {
    return ?
}

@extension("VK_KHR_xlib_surface") // 5
cmd VkResult vkCreateXlibSurfaceKHR(
        VkInstance                              instance,
        const VkXlibSurfaceCreateInfoKHR*       pCreateInfo,
        const VkAllocationCallbacks*            pAllocator,
        VkSurfaceKHR*                           pSurface) {
    instanceObject := GetInstance(instance)
    return ?
}

@extension("VK_KHR_xlib_surface") // 5
cmd VkBool32 vkGetPhysicalDeviceXlibPresentationSupportKHR(
        VkPhysicalDevice                        physicalDevice,
        u32                                     queueFamilyIndex,
        platform.Display*                       dpy,
        platform.VisualID                       visualID) {
    physicalDeviceObject := GetPhysicalDevice(physicalDevice)
    return ?
}

@extension("VK_KHR_xcb_surface") // 6
cmd VkResult vkCreateXcbSurfaceKHR(
        VkInstance                              instance,
        const VkXcbSurfaceCreateInfoKHR*        pCreateInfo,
        const VkAllocationCallbacks*            pAllocator,
        VkSurfaceKHR*                           pSurface) {
    instanceObject := GetInstance(instance)
    return ?
}

@extension("VK_KHR_xcb_surface") // 6
cmd VkBool32 vkGetPhysicalDeviceXcbPresentationSupportKHR(
        VkPhysicalDevice                        physicalDevice,
        u32                                     queueFamilyIndex,
        platform.xcb_connection_t*              connection,
        platform.xcb_visualid_t                 visual_id) {
    physicalDeviceObject := GetPhysicalDevice(physicalDevice)
    return ?
}

@extension("VK_KHR_wayland_surface") // 7
cmd VkResult vkCreateWaylandSurfaceKHR(
        VkInstance                              instance,
        const VkWaylandSurfaceCreateInfoKHR*    pCreateInfo,
        const VkAllocationCallbacks*            pAllocator,
        VkSurfaceKHR*                           pSurface) {
    instanceObject := GetInstance(instance)
    return ?
}

@extension("VK_KHR_wayland_surface") // 7
cmd VkBool32 vkGetPhysicalDeviceWaylandPresentationSupportKHR(
        VkPhysicalDevice                        physicalDevice,
        u32                                     queueFamilyIndex,
        platform.wl_display*                    display) {
    physicalDeviceObject := GetPhysicalDevice(physicalDevice)
    return ?
}

@extension("VK_KHR_mir_surface") // 8
cmd VkResult vkCreateMirSurfaceKHR(
        VkInstance                              instance,
        const VkMirSurfaceCreateInfoKHR*        pCreateInfo,
        const VkAllocationCallbacks*            pAllocator,
        VkSurfaceKHR*                           pSurface) {
    instanceObject := GetInstance(instance)
    return ?
}

@extension("VK_KHR_mir_surface") // 8
cmd VkBool32 vkGetPhysicalDeviceMirPresentationSupportKHR(
        VkPhysicalDevice                        physicalDevice,
        u32                                     queueFamilyIndex,
        platform.MirConnection*                 connection) {
    physicalDeviceObject := GetPhysicalDevice(physicalDevice)
    return ?
}

@extension("VK_KHR_android_surface") // 9
cmd VkResult vkCreateAndroidSurfaceKHR(
        VkInstance                              instance,
        const VkAndroidSurfaceCreateInfoKHR*    pCreateInfo,
        const VkAllocationCallbacks*            pAllocator,
        VkSurfaceKHR*                           pSurface) {
    instanceObject := GetInstance(instance)
    return ?
}

@extension("VK_KHR_win32_surface") // 10
cmd VkResult vkCreateWin32SurfaceKHR(
        VkInstance                              instance,
        const VkWin32SurfaceCreateInfoKHR*      pCreateInfo,
        const VkAllocationCallbacks*            pAllocator,
        VkSurfaceKHR*                           pSurface) {
    instanceObject := GetInstance(instance)
    return ?
}

@extension("VK_KHR_win32_surface") // 10
cmd VkResult vkGetPhysicalDeviceWin32PresentationSupportKHR(
        VkPhysicalDevice                        physicalDevice,
        u32                                     queueFamilyIndex) {
    physicalDeviceObject := GetPhysicalDevice(physicalDevice)
    return ?
}

@extension("VK_ANDROID_native_buffer") // 11
@optional
cmd VkResult vkGetSwapchainGrallocUsageANDROID(
        VkDevice                                device,
        VkFormat                                format,
        VkImageUsageFlags                       imageUsage,
        s32*                                    grallocUsage) {
    return ?
}

@extension("VK_ANDROID_native_buffer") // 11
@optional
cmd VkResult vkGetSwapchainGrallocUsage2ANDROID(
        VkDevice                                device,
        VkFormat                                format,
        VkImageUsageFlags                       imageUsage,
        VkSwapchainImageUsageFlagsANDROID       swapchainImageUsage,
        u64*                                    grallocConsumerUsage,
        u64*                                    grallocProducerUsage) {
    return ?
}

@extension("VK_ANDROID_native_buffer") // 11
cmd VkResult vkAcquireImageANDROID(
        VkDevice                                device,
        VkImage                                 image,
        int                                     nativeFenceFd,
        VkSemaphore                             semaphore,
        VkFence                                 fence) {
    return ?
}

@extension("VK_ANDROID_native_buffer") // 11
cmd VkResult vkQueueSignalReleaseImageANDROID(
        VkQueue                                 queue,
        u32                                     waitSemaphoreCount,
        const VkSemaphore*                      pWaitSemaphores,
        VkImage                                 image,
        int*                                    pNativeFenceFd) {
    return ?
}

@extension("VK_EXT_debug_report") // 12
@external type void* PFN_vkDebugReportCallbackEXT
@extension("VK_EXT_debug_report") // 12
@pfn cmd VkBool32 vkDebugReportCallbackEXT(
        VkDebugReportFlagsEXT                   flags,
        VkDebugReportObjectTypeEXT              objectType,
        u64                                     object,
        platform.size_t                         location,
        s32                                     messageCode,
        const char*                             pLayerPrefix,
        const char*                             pMessage,
        void*                                   pUserData) {
    return ?
}

@extension("VK_EXT_debug_report") // 12
cmd VkResult vkCreateDebugReportCallbackEXT(
        VkInstance                                  instance,
        const VkDebugReportCallbackCreateInfoEXT*   pCreateInfo,
        const VkAllocationCallbacks*                pAllocator,
        VkDebugReportCallbackEXT*                   pCallback) {
    return ?
}

@extension("VK_EXT_debug_report") // 12
cmd void vkDestroyDebugReportCallbackEXT(
        VkInstance                                  instance,
        VkDebugReportCallbackEXT                    callback,
        const VkAllocationCallbacks*                pAllocator) {
}

@extension("VK_EXT_debug_report") // 12
cmd void vkDebugReportMessageEXT(
        VkInstance                                  instance,
        VkDebugReportFlagsEXT                       flags,
        VkDebugReportObjectTypeEXT                  objectType,
        u64                                         object,
        platform.size_t                             location,
        s32                                         messageCode,
        const char*                                 pLayerPrefix,
        const char*                                 pMessage) {
}

@extension("VK_EXT_debug_marker") // 23
cmd VkResult vkDebugMarkerSetObjectTagEXT(
        VkDevice                                    device,
        const VkDebugMarkerObjectTagInfoEXT*        pTagInfo) {
    return ?
}

@extension("VK_EXT_debug_marker") // 23
cmd VkResult vkDebugMarkerSetObjectNameEXT(
        VkDevice                                    device,
        const VkDebugMarkerObjectNameInfoEXT*       pNameInfo) {
    return ?
}

@extension("VK_EXT_debug_marker") // 23
cmd void vkCmdDebugMarkerBeginEXT(
        VkCommandBuffer                             commandBuffer,
        const VkDebugMarkerMarkerInfoEXT*           pMarkerInfo) {
}

@extension("VK_EXT_debug_marker") // 23
cmd void vkCmdDebugMarkerEndEXT(
        VkCommandBuffer                             commandBuffer) {
}

@extension("VK_EXT_debug_marker") // 23
cmd void vkCmdDebugMarkerInsertEXT(
        VkCommandBuffer                             commandBuffer,
        const VkDebugMarkerMarkerInfoEXT*           pMarkerInfo) {
}

@extension("VK_AMD_draw_indirect_count") // 34
cmd void vkCmdDrawIndirectCountAMD(
        VkCommandBuffer                             commandBuffer,
        VkBuffer                                    buffer,
        VkDeviceSize                                offset,
        VkBuffer                                    countBuffer,
        VkDeviceSize                                countBufferOffset,
        u32                                         maxDrawCount,
        u32                                         stride) {
}

@extension("VK_AMD_draw_indirect_count") // 34
cmd void vkCmdDrawIndexedIndirectCountAMD(
        VkCommandBuffer                             commandBuffer,
        VkBuffer                                    buffer,
        VkDeviceSize                                offset,
        VkBuffer                                    countBuffer,
        VkDeviceSize                                countBufferOffset,
        u32                                         maxDrawCount,
        u32                                         stride) {
}

@extension("VK_AMD_shader_info") // 43
cmd VkResult vkGetShaderInfoAMD(
        VkDevice                                    device,
        VkPipeline                                  pipeline,
        VkShaderStageFlagBits                       shaderStage,
        VkShaderInfoTypeAMD                         infoType,
        platform.size_t*                            pInfoSize,
        void*                                       pInfo) {
    return ?
}

@extension("VK_NV_external_memory_capabilities") // 56
cmd VkResult vkGetPhysicalDeviceExternalImageFormatPropertiesNV(
        VkPhysicalDevice                            physicalDevice,
        VkFormat                                    format,
        VkImageType                                 type,
        VkImageTiling                               tiling,
        VkImageUsageFlags                           usage,
        VkImageCreateFlags                          flags,
        VkExternalMemoryHandleTypeFlagsNV           externalHandleType,
        VkExternalImageFormatPropertiesNV*          pExternalImageFormatProperties) {
    return ?
}

@extension("VK_NV_external_memory_win32") // 58
cmd VkResult vkGetMemoryWin32HandleNV(
        VkDevice                                    device,
        VkDeviceMemory                              memory,
        VkExternalMemoryHandleTypeFlagsNV           handleType,
        platform.HANDLE*                            pHandle) {
    return ?
}

@extension("VK_KHR_get_physical_device_properties2") // 60
cmd void vkGetPhysicalDeviceFeatures2KHR(
        VkPhysicalDevice                            physicalDevice,
        VkPhysicalDeviceFeatures2KHR*               pFeatures) {
}

@extension("VK_KHR_get_physical_device_properties2") // 60
cmd void vkGetPhysicalDeviceProperties2KHR(
        VkPhysicalDevice                            physicalDevice,
        VkPhysicalDeviceProperties2KHR*             pProperties) {
}

@extension("VK_KHR_get_physical_device_properties2") // 60
cmd void vkGetPhysicalDeviceFormatProperties2KHR(
        VkPhysicalDevice                            physicalDevice,
        VkFormat                                    format,
        VkFormatProperties2KHR*                     pFormatProperties) {
}

@extension("VK_KHR_get_physical_device_properties2") // 60
cmd VkResult vkGetPhysicalDeviceImageFormatProperties2KHR(
        VkPhysicalDevice                            physicalDevice,
        const VkPhysicalDeviceImageFormatInfo2KHR*  pImageFormatInfo,
        VkImageFormatProperties2KHR*                pImageFormatProperties) {
    return ?
}

@extension("VK_KHR_get_physical_device_properties2") // 60
cmd void vkGetPhysicalDeviceQueueFamilyProperties2KHR(
        VkPhysicalDevice                            physicalDevice,
        u32*                                        pQueueFamilyPropertyCount,
        VkQueueFamilyProperties2KHR*                pQueueFamilyProperties) {
}

@extension("VK_KHR_get_physical_device_properties2") // 60
cmd void vkGetPhysicalDeviceMemoryProperties2KHR(
        VkPhysicalDevice                            physicalDevice,
        VkPhysicalDeviceMemoryProperties2KHR*       pMemoryProperties) {
}

@extension("VK_KHR_get_physical_device_properties2") // 60
cmd void vkGetPhysicalDeviceSparseImageFormatProperties2KHR(
        VkPhysicalDevice                                    physicalDevice,
        const VkPhysicalDeviceSparseImageFormatInfo2KHR*    pFormatInfo,
        u32*                                                pPropertyCount,
        VkSparseImageFormatProperties2KHR*                  pProperties) {
}

@extension("VK_KHR_device_group") // 61
cmd void vkGetDeviceGroupPeerMemoryFeaturesKHR(
        VkDevice                                    device,
        u32                                         heapIndex,
        u32                                         localDeviceIndex,
        u32                                         remoteDeviceIndex,
        VkPeerMemoryFeatureFlagsKHR*                pPeerMemoryFeatures) {
}

@extension("VK_KHR_device_group") // 61
cmd void vkCmdSetDeviceMaskKHR(
        VkCommandBuffer                             commandBuffer,
        u32                                         deviceMask) {
}


@extension("VK_KHR_device_group") // 61
cmd void vkCmdDispatchBaseKHR(
        VkCommandBuffer                             commandBuffer,
        u32                                         baseGroupX,
        u32                                         baseGroupY,
        u32                                         baseGroupZ,
        u32                                         groupCountX,
        u32                                         groupCountY,
        u32                                         groupCountZ) {
}

@extension("VK_NN_vi_surface") // 63
cmd VkResult vkCreateViSurfaceNN(
        VkInstance                                  instance,
        const VkViSurfaceCreateInfoNN*              pCreateInfo,
        const VkAllocationCallbacks*                pAllocator,
        VkSurfaceKHR*                               pSurface) {
    return ?
}

@extension("VK_KHR_maintenance1") // 70
cmd void vkTrimCommandPoolKHR(
        VkDevice                                    device,
        VkCommandPool                               commandPool,
        VkCommandPoolTrimFlagsKHR                   flags) {
}

@extension("VK_KHR_device_group_creation") // 71
@threadSafety("system")
cmd VkResult vkEnumeratePhysicalDeviceGroupsKHR(
        VkInstance                                  instance,
        u32*                                        pPhysicalDeviceGroupCount,
        VkPhysicalDeviceGroupPropertiesKHR*         pPhysicalDeviceGroupProperties) {
    instanceObject := GetInstance(instance)

    physicalDeviceGroupCount := as!u32(?)
    pPhysicalDeviceGroupCount[0] = physicalDeviceGroupCount
    physicalDevices := pPhysicalDeviceGroupProperties[0:physicalDeviceGroupCount]

    for i in (0 .. physicalDeviceGroupCount) {
        physicalDevice := ?
        physicalDevices[i] = physicalDevice
        if !(physicalDevice in State.PhysicalDevices) {
            State.PhysicalDevices[physicalDevice] = new!PhysicalDeviceObject(instance: instance)
        }
    }

    return ?
}

@extension("VK_KHR_external_memory_capabilities") // 72
cmd void vkGetPhysicalDeviceExternalBufferPropertiesKHR(
        VkPhysicalDevice                                physicalDevice,
        const VkPhysicalDeviceExternalBufferInfoKHR*    pExternalBufferInfo,
        VkExternalBufferPropertiesKHR*                  pExternalBufferProperties) {
}

@extension("VK_KHR_external_memory_win32") // 74
cmd VkResult vkGetMemoryWin32HandleKHR(
        VkDevice                                    device,
        const VkMemoryGetWin32HandleInfoKHR*        pGetWin32HandleInfo,
        platform.HANDLE*                            pHandle) {
    return ?
}

@extension("VK_KHR_external_memory_win32") // 74
cmd VkResult vkGetMemoryWin32HandlePropertiesKHR(
        VkDevice                                    device,
        VkExternalMemoryHandleTypeFlagBitsKHR       handleType,
        platform.HANDLE                             handle,
        VkMemoryWin32HandlePropertiesKHR*           pMemoryWin32HandleProperties) {
    return ?
}

@extension("VK_KHR_external_memory_fd") // 75
cmd VkResult vkGetMemoryFdKHR(
        VkDevice                                    device,
        const VkMemoryGetFdInfoKHR*                 pGetFdInfo,
        s32*                                        pFd) {
    return ?
}

@extension("VK_KHR_external_memory_fd") // 75
cmd VkResult vkGetMemoryFdPropertiesKHR(
        VkDevice                                    device,
        VkExternalMemoryHandleTypeFlagBitsKHR       handleType,
        s32                                         fd,
        VkMemoryFdPropertiesKHR*                    pMemoryFdProperties) {
    return ?
}

@extension("VK_KHR_external_semaphore_capabilities") // 77
cmd void vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(
        VkPhysicalDevice                            physicalDevice,
        const VkPhysicalDeviceExternalSemaphoreInfoKHR* pExternalSemaphoreInfo,
        VkExternalSemaphorePropertiesKHR*           pExternalSemaphoreProperties) {
}

@extension("VK_KHR_external_semaphore_win32") // 79
cmd VkResult vkImportSemaphoreWin32HandleKHR(
        VkDevice                                    device,
        const VkImportSemaphoreWin32HandleInfoKHR*  pImportSemaphoreWin32HandleInfo) {
    return ?
}

@extension("VK_KHR_external_semaphore_win32") // 79
cmd VkResult vkGetSemaphoreWin32HandleKHR(
        VkDevice                                    device,
        const VkSemaphoreGetWin32HandleInfoKHR*     pGetWin32HandleInfo,
        platform.HANDLE*                            pHandle) {
    return ?
}

@extension("VK_KHR_external_semaphore_fd") // 80
cmd VkResult vkImportSemaphoreFdKHR(
        VkDevice                                    device,
        const VkImportSemaphoreFdInfoKHR*           pImportSemaphoreFdInfo) {
    return ?
}

@extension("VK_KHR_external_semaphore_fd") // 80
cmd VkResult vkGetSemaphoreFdKHR(
        VkDevice                                    device,
        const VkSemaphoreGetFdInfoKHR*              pGetFdInfo,
        s32*                                        pFd) {
    return ?
}

@extension("VK_KHR_push_descriptor") // 81
cmd void vkCmdPushDescriptorSetKHR(
        VkCommandBuffer                             commandBuffer,
        VkPipelineBindPoint                         pipelineBindPoint,
        VkPipelineLayout                            layout,
        u32                                         set,
        u32                                         descriptorWriteCount,
        const VkWriteDescriptorSet*                 pDescriptorWrites) {
}

@extension("VK_KHR_descriptor_update_template") // 86
cmd VkResult vkCreateDescriptorUpdateTemplateKHR(
        VkDevice                                    device,
        const VkDescriptorUpdateTemplateCreateInfoKHR* pCreateInfo,
        const VkAllocationCallbacks*                pAllocator,
        VkDescriptorUpdateTemplateKHR*              pDescriptorUpdateTemplate) {
    return ?
}

@extension("VK_KHR_descriptor_update_template") // 86
cmd void vkDestroyDescriptorUpdateTemplateKHR(
        VkDevice                                    device,
        VkDescriptorUpdateTemplateKHR               descriptorUpdateTemplate,
        const VkAllocationCallbacks*                pAllocator) {
}

@extension("VK_KHR_descriptor_update_template") // 86
cmd void vkUpdateDescriptorSetWithTemplateKHR(
        VkDevice                                    device,
        VkDescriptorSet                             descriptorSet,
        VkDescriptorUpdateTemplateKHR               descriptorUpdateTemplate,
        const void*                                 pData) {
}

@extension("VK_KHR_descriptor_update_template") // 86
cmd void vkCmdPushDescriptorSetWithTemplateKHR(
        VkCommandBuffer                             commandBuffer,
        VkDescriptorUpdateTemplateKHR               descriptorUpdateTemplate,
        VkPipelineLayout                            layout,
        u32                                         set,
        const void*                                 pData) {
}

@extension("VK_NVX_device_generated_commands") // 87
cmd void vkCmdProcessCommandsNVX(
        VkCommandBuffer                             commandBuffer,
        const VkCmdProcessCommandsInfoNVX*          pProcessCommandsInfo) {
}

@extension("VK_NVX_device_generated_commands") // 87
cmd void vkCmdReserveSpaceForCommandsNVX(
        VkCommandBuffer                             commandBuffer,
        const VkCmdReserveSpaceForCommandsInfoNVX*  pReserveSpaceInfo) {
}

@extension("VK_NVX_device_generated_commands") // 87
cmd VkResult vkCreateIndirectCommandsLayoutNVX(
        VkDevice                                    device,
        const VkIndirectCommandsLayoutCreateInfoNVX* pCreateInfo,
        const VkAllocationCallbacks*                pAllocator,
        VkIndirectCommandsLayoutNVX*                pIndirectCommandsLayout) {
    return ?
}

@extension("VK_NVX_device_generated_commands") // 87
cmd void vkDestroyIndirectCommandsLayoutNVX(
        VkDevice                                    device,
        VkIndirectCommandsLayoutNVX                 indirectCommandsLayout,
        const VkAllocationCallbacks*                pAllocator) {
}

@extension("VK_NVX_device_generated_commands") // 87
cmd VkResult vkCreateObjectTableNVX(
        VkDevice                                    device,
        const VkObjectTableCreateInfoNVX*           pCreateInfo,
        const VkAllocationCallbacks*                pAllocator,
        VkObjectTableNVX*                           pObjectTable) {
    return ?
}

@extension("VK_NVX_device_generated_commands") // 87
cmd void vkDestroyObjectTableNVX(
        VkDevice                                    device,
        VkObjectTableNVX                            objectTable,
        const VkAllocationCallbacks*                pAllocator) {
}

@extension("VK_NVX_device_generated_commands") // 87
cmd VkResult vkRegisterObjectsNVX(
        VkDevice                                    device,
        VkObjectTableNVX                            objectTable,
        u32                                         objectCount,
        const VkObjectTableEntryNVX* const*         ppObjectTableEntries,
        const u32*                                  pObjectIndices) {
    return ?
}

@extension("VK_NVX_device_generated_commands") // 87
cmd VkResult vkUnregisterObjectsNVX(
        VkDevice                                    device,
        VkObjectTableNVX                            objectTable,
        u32                                         objectCount,
        const VkObjectEntryTypeNVX*                 pObjectEntryTypes,
        const u32*                                  pObjectIndices) {
    return ?
}

@extension("VK_NVX_device_generated_commands") // 87
cmd void vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(
        VkPhysicalDevice                            physicalDevice,
        VkDeviceGeneratedCommandsFeaturesNVX*       pFeatures,
        VkDeviceGeneratedCommandsLimitsNVX*         pLimits) {
}

@extension("VK_NV_clip_space_w_scaling") // 88
cmd void vkCmdSetViewportWScalingNV(
        VkCommandBuffer                             commandBuffer,
        u32                                         firstViewport,
        u32                                         viewportCount,
        const VkViewportWScalingNV*                 pViewportWScalings) {
}

@extension("VK_EXT_direct_mode_display") // 89
cmd VkResult vkReleaseDisplayEXT(
        VkPhysicalDevice                            physicalDevice,
        VkDisplayKHR                                display) {
    return ?
}

@extension("VK_EXT_acquire_xlib_display") // 90
cmd VkResult vkAcquireXlibDisplayEXT(
        VkPhysicalDevice                            physicalDevice,
        platform.Display*                           dpy,
        VkDisplayKHR                                display) {
    return ?
}

@extension("VK_EXT_acquire_xlib_display") // 90
cmd VkResult vkGetRandROutputDisplayEXT(
        VkPhysicalDevice                            physicalDevice,
        platform.Display*                           dpy,
        platform.RROutput                           rrOutput,
        VkDisplayKHR*                               pDisplay) {
    return ?
}

@extension("VK_EXT_display_surface_counter") // 91
cmd VkResult vkGetPhysicalDeviceSurfaceCapabilities2EXT(
        VkPhysicalDevice                            physicalDevice,
        VkSurfaceKHR                                surface,
        VkSurfaceCapabilities2EXT*                  pSurfaceCapabilities) {
    return ?
}

@extension("VK_EXT_display_control") // 92
cmd VkResult vkDisplayPowerControlEXT(
        VkDevice                                    device,
        VkDisplayKHR                                display,
        const VkDisplayPowerInfoEXT*                pDisplayPowerInfo) {
    return ?
}

@extension("VK_EXT_display_control") // 92
cmd VkResult vkRegisterDeviceEventEXT(
        VkDevice                                    device,
        const VkDeviceEventInfoEXT*                 pDeviceEventInfo,
        const VkAllocationCallbacks*                pAllocator,
        VkFence*                                    pFence) {
    return ?
}

@extension("VK_EXT_display_control") // 92
cmd VkResult vkRegisterDisplayEventEXT(
        VkDevice                                    device,
        VkDisplayKHR                                display,
        const VkDisplayEventInfoEXT*                pDisplayEventInfo,
        const VkAllocationCallbacks*                pAllocator,
        VkFence*                                    pFence) {
    return ?
}

@extension("VK_EXT_display_control") // 92
cmd VkResult vkGetSwapchainCounterEXT(
        VkDevice                                    device,
        VkSwapchainKHR                              swapchain,
        VkSurfaceCounterFlagBitsEXT                 counter,
        u64*                                        pCounterValue) {
    return ?
}

@extension("VK_GOOGLE_display_timing") // 93
cmd VkResult vkGetRefreshCycleDurationGOOGLE(
        VkDevice                                    device,
        VkSwapchainKHR                              swapchain,
        VkRefreshCycleDurationGOOGLE*               pDisplayTimingProperties) {
    deviceObject := GetDevice(device)
    swapchainObject := GetSwapchain(swapchain)

    displayTimingProperties := ?
    pDisplayTimingProperties[0] = displayTimingProperties

    return ?
}

@extension("VK_GOOGLE_display_timing") // 93
cmd VkResult vkGetPastPresentationTimingGOOGLE(
        VkDevice                                    device,
        VkSwapchainKHR                              swapchain,
        u32*                                        pPresentationTimingCount,
        VkPastPresentationTimingGOOGLE*             pPresentationTimings) {
    return ?
}

@extension("VK_EXT_discard_rectangles") // 100
cmd void vkCmdSetDiscardRectangleEXT(
        VkCommandBuffer                             commandBuffer,
        u32                                         firstDiscardRectangle,
        u32                                         discardRectangleCount,
        const VkRect2D*                             pDiscardRectangles) {
}

@extension("VK_EXT_hdr_metadata") // 106
cmd void vkSetHdrMetadataEXT(
        VkDevice                                    device,
        u32                                         swapchainCount,
        const VkSwapchainKHR*                       pSwapchains,
        const VkHdrMetadataEXT*                     pMetadata) {
}

@extension("VK_KHR_shared_presentable_image") // 112
cmd VkResult vkGetSwapchainStatusKHR(
        VkDevice                                    device,
        VkSwapchainKHR                              swapchain) {
    return ?
}

@extension("VK_KHR_external_fence_capabilities") // 113
cmd void vkGetPhysicalDeviceExternalFencePropertiesKHR(
        VkPhysicalDevice                            physicalDevice,
        const VkPhysicalDeviceExternalFenceInfoKHR* pExternalFenceInfo,
        VkExternalFencePropertiesKHR*               pExternalFenceProperties) {
}

@extension("VK_KHR_external_fence_win32") // 115
cmd VkResult vkImportFenceWin32HandleKHR(
        VkDevice                                    device,
        const VkImportFenceWin32HandleInfoKHR*      pImportFenceWin32HandleInfo) {
    return ?
}

@extension("VK_KHR_external_fence_win32") // 115
cmd VkResult vkGetFenceWin32HandleKHR(
        VkDevice                                    device,
        const VkFenceGetWin32HandleInfoKHR*         pGetWin32HandleInfo,
        platform.HANDLE*                            pHandle) {
    return ?
}

@extension("VK_KHR_external_fence_fd") // 116
cmd VkResult vkImportFenceFdKHR(
        VkDevice                                    device,
        const VkImportFenceFdInfoKHR*               pImportFenceFdInfo) {
    return ?
}

@extension("VK_KHR_external_fence_fd") // 116
cmd VkResult vkGetFenceFdKHR(
        VkDevice                                    device,
        const VkFenceGetFdInfoKHR*                  pGetFdInfo,
        int*                                        pFd) {
    return ?
}

@extension("VK_KHR_get_surface_capabilities2") // 120
cmd VkResult vkGetPhysicalDeviceSurfaceCapabilities2KHR(
        VkPhysicalDevice                            physicalDevice,
        const VkPhysicalDeviceSurfaceInfo2KHR*      pSurfaceInfo,
        VkSurfaceCapabilities2KHR*                  pSurfaceCapabilities) {
    return ?
}

@extension("VK_KHR_get_surface_capabilities2") // 120
cmd VkResult vkGetPhysicalDeviceSurfaceFormats2KHR(
        VkPhysicalDevice                            physicalDevice,
        const VkPhysicalDeviceSurfaceInfo2KHR*      pSurfaceInfo,
        u32*                                        pSurfaceFormatCount,
        VkSurfaceFormat2KHR*                        pSurfaceFormats) {
    return ?
}

@extension("VK_MVK_ios_surface") // 123
cmd VkResult vkCreateIOSSurfaceMVK(
        VkInstance                                  instance,
        const VkIOSSurfaceCreateInfoMVK*            pCreateInfo,
        const VkAllocationCallbacks*                pAllocator,
        VkSurfaceKHR*                               pSurface) {
    return ?
}

@extension("VK_MVK_macos_surface") // 124
cmd VkResult vkCreateMacOSSurfaceMVK(
        VkInstance                                  instance,
        const VkMacOSSurfaceCreateInfoMVK*          pCreateInfo,
        const VkAllocationCallbacks*                pAllocator,
        VkSurfaceKHR*                               pSurface) {
    return ?
}

@extension("VK_EXT_debug_utils") // 129
@external type void* PFN_vkDebugUtilsMessengerCallbackEXT
@extension("VK_EXT_debug_utils") // 129
@pfn cmd VkBool32 vkDebugUtilsMessengerCallbackEXT(
        VkDebugUtilsMessageSeverityFlagBitsEXT      messageSeverity,
        VkDebugUtilsMessageTypeFlagsEXT             messageType,
        const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData,
        void*                                       pUserData) {
    return ?
}

@extension("VK_EXT_debug_utils") // 129
cmd VkResult vkSetDebugUtilsObjectNameEXT(
        VkDevice                                    device,
        const VkDebugUtilsObjectNameInfoEXT*        pNameInfo) {
    return ?
}
 
@extension("VK_EXT_debug_utils") // 129
cmd VkResult vkSetDebugUtilsObjectTagEXT(
        VkDevice                                    device,
        const VkDebugUtilsObjectTagInfoEXT*         pTagInfo) {
    return ?
}
 
@extension("VK_EXT_debug_utils") // 129
cmd void vkQueueBeginDebugUtilsLabelEXT(
        VkQueue                                     queue,
        const VkDebugUtilsLabelEXT*                 pLabelInfo) {
}
 
@extension("VK_EXT_debug_utils") // 129
cmd void vkQueueEndDebugUtilsLabelEXT(VkQueue       queue) {
}
 
@extension("VK_EXT_debug_utils") // 129
cmd void vkQueueInsertDebugUtilsLabelEXT(
        VkQueue                                     queue,
        const VkDebugUtilsLabelEXT*                 pLabelInfo) {
}
 
@extension("VK_EXT_debug_utils") // 129
cmd void vkCmdBeginDebugUtilsLabelEXT(
        VkCommandBuffer                             commandBuffer,
        const VkDebugUtilsLabelEXT*                 pLabelInfo) {
}
 
@extension("VK_EXT_debug_utils") // 129
cmd void vkCmdEndDebugUtilsLabelEXT(VkCommandBuffer commandBuffer) {
}

@extension("VK_EXT_debug_utils") // 129
cmd void vkCmdInsertDebugUtilsLabelEXT(
        VkCommandBuffer                             commandBuffer,
        const VkDebugUtilsLabelEXT*                 pLabelInfo) {
}

@extension("VK_EXT_debug_utils") // 129
cmd VkResult vkCreateDebugUtilsMessengerEXT(
        VkInstance                                  instance,
        const VkDebugUtilsMessengerCreateInfoEXT*   pCreateInfo,
        const VkAllocationCallbacks*                pAllocator,
        VkDebugUtilsMessengerEXT*                   pMessenger) {
    return ?
}

@extension("VK_EXT_debug_utils") // 129
cmd void vkDestroyDebugUtilsMessengerEXT(
        VkInstance                                  instance,
        VkDebugUtilsMessengerEXT                    messenger,
        const VkAllocationCallbacks*                pAllocator) {
}

@extension("VK_EXT_debug_utils") // 129
cmd void vkSubmitDebugUtilsMessageEXT(
        VkInstance                                  instance,
        VkDebugUtilsMessageSeverityFlagBitsEXT      messageSeverity,
        VkDebugUtilsMessageTypeFlagsEXT             messageTypes,
        const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData) {
}

@extension("VK_ANDROID_external_memory_android_hardware_buffer") // 130
@vulkan1_1 // extension requires 1.1, and should become non-optional when 1.1 does
cmd VkResult vkGetAndroidHardwareBufferPropertiesANDROID(
        VkDevice                                    device,
        const platform.AHardwareBuffer*             buffer,
        VkAndroidHardwareBufferPropertiesANDROID*   pProperties) {
    return ?
}

@extension("VK_ANDROID_external_memory_android_hardware_buffer") // 130
@vulkan1_1 // extension requires 1.1, and should become non-optional when 1.1 does
cmd VkResult vkGetMemoryAndroidHardwareBufferANDROID(
        VkDevice                                            device,
        const VkMemoryGetAndroidHardwareBufferInfoANDROID*  pInfo,
        platform.AHardwareBuffer**                          pBuffer) {
    return ?
}

@extension("VK_EXT_sample_locations") // 144
cmd void vkCmdSetSampleLocationsEXT(
        VkCommandBuffer                             commandBuffer,
        const VkSampleLocationsInfoEXT*             pSampleLocationsInfo) {
}

@extension("VK_EXT_sample_locations") // 144
cmd void vkGetPhysicalDeviceMultisamplePropertiesEXT(
        VkPhysicalDevice                            physicalDevice,
        VkSampleCountFlagBits                       samples,
        VkMultisamplePropertiesEXT*                 pMultisampleProperties) {
}

@extension("VK_KHR_get_memory_requirements2") // 147
cmd void vkGetImageMemoryRequirements2KHR(
        VkDevice                                    device,
        const VkImageMemoryRequirementsInfo2KHR*    pInfo,
        VkMemoryRequirements2KHR*                   pMemoryRequirements) {
}

@extension("VK_KHR_get_memory_requirements2") // 147
cmd void vkGetBufferMemoryRequirements2KHR(
        VkDevice                                    device,
        const VkBufferMemoryRequirementsInfo2KHR*   pInfo,
        VkMemoryRequirements2KHR*                   pMemoryRequirements) {
}

@extension("VK_KHR_get_memory_requirements2") // 147
cmd void vkGetImageSparseMemoryRequirements2KHR(
        VkDevice                                        device,
        const VkImageSparseMemoryRequirementsInfo2KHR*  pInfo,
        u32*                                            pSparseMemoryRequirementCount,
        VkSparseImageMemoryRequirements2KHR*            pSparseMemoryRequirements) {
}

@extension("VK_KHR_sampler_ycbcr_conversion") // 157
cmd VkResult vkCreateSamplerYcbcrConversionKHR(
        VkDevice                                        device,
        const VkSamplerYcbcrConversionCreateInfoKHR*    pCreateInfo,
        const VkAllocationCallbacks*                    pAllocator,
        VkSamplerYcbcrConversionKHR*                    pYcbcrConversion) {
    return ?
}

@extension("VK_KHR_sampler_ycbcr_conversion") // 157
cmd void vkDestroySamplerYcbcrConversionKHR(
        VkDevice                                        device,
        VkSamplerYcbcrConversionKHR                     ycbcrConversion,
        const VkAllocationCallbacks*                    pAllocator) {
}

@extension("VK_KHR_bind_memory2") // 158
cmd VkResult vkBindBufferMemory2KHR(
        VkDevice                                        device,
        u32                                             bindInfoCount,
        const VkBindBufferMemoryInfoKHR*                pBindInfos) {
    return ?
}

@extension("VK_KHR_bind_memory2") // 158
cmd VkResult vkBindImageMemory2KHR(
        VkDevice                                        device,
        u32                                             bindInfoCount,
        const VkBindImageMemoryInfoKHR*                 pBindInfos) {
    return ?
}

@extension("VK_EXT_validation_cache") // 161
cmd VkResult vkCreateValidationCacheEXT(
        VkDevice                                    device,
        const VkValidationCacheCreateInfoEXT*       pCreateInfo,
        const VkAllocationCallbacks*                pAllocator,
        VkValidationCacheEXT*                       pValidationCache) {
    return ?
}

@extension("VK_EXT_validation_cache") // 161
cmd void vkDestroyValidationCacheEXT(
        VkDevice                                    device,
        VkValidationCacheEXT                        validationCache,
        const VkAllocationCallbacks*                pAllocator) {
}

@extension("VK_EXT_validation_cache") // 161
cmd VkResult vkMergeValidationCachesEXT(
        VkDevice                                    device,
        VkValidationCacheEXT                        dstCache,
        u32                                         srcCacheCount,
        const VkValidationCacheEXT*                 pSrcCaches) {
    return ?
}

@extension("VK_EXT_validation_cache") // 161
cmd VkResult vkGetValidationCacheDataEXT(
        VkDevice                                    device,
        VkValidationCacheEXT                        validationCache,
        platform.size_t*                            pDataSize,
        void*                                       pData) {
    return ?
}

@extension("VK_KHR_maintenance3") // 169
cmd void vkGetDescriptorSetLayoutSupportKHR(
        VkDevice                                    device,
        const VkDescriptorSetLayoutCreateInfo*      pCreateInfo,
        VkDescriptorSetLayoutSupportKHR*            pSupport) {
}

@extension("VK_EXT_external_memory_host") // 179
cmd VkResult vkGetMemoryHostPointerPropertiesEXT(
        VkDevice                                    device,
        VkExternalMemoryHandleTypeFlagBits          handleType,
        const void*                                 pHostPointer,
        VkMemoryHostPointerPropertiesEXT*           pMemoryHostPointerProperties) {
    return ?
}

////////////////
// Validation //
////////////////

extern void validate(string layerName, bool condition, string message)


/////////////////////////////
// Internal State Tracking //
/////////////////////////////

StateObject State

@internal class StateObject {
    // Dispatchable objects.
    map!(VkInstance,       ref!InstanceObject)       Instances
    map!(VkPhysicalDevice, ref!PhysicalDeviceObject) PhysicalDevices
    map!(VkDevice,         ref!DeviceObject)         Devices
    map!(VkQueue,          ref!QueueObject)          Queues
    map!(VkCommandBuffer,  ref!CommandBufferObject)  CommandBuffers

    // Non-dispatchable objects.
    map!(VkDeviceMemory,             ref!DeviceMemoryObject)             DeviceMemories
    map!(VkBuffer,                   ref!BufferObject)                   Buffers
    map!(VkBufferView,               ref!BufferViewObject)               BufferViews
    map!(VkImage,                    ref!ImageObject)                    Images
    map!(VkImageView,                ref!ImageViewObject)                ImageViews
    map!(VkShaderModule,             ref!ShaderModuleObject)             ShaderModules
    map!(VkPipeline,                 ref!PipelineObject)                 Pipelines
    map!(VkPipelineLayout,           ref!PipelineLayoutObject)           PipelineLayouts
    map!(VkSampler,                  ref!SamplerObject)                  Samplers
    map!(VkDescriptorSet,            ref!DescriptorSetObject)            DescriptorSets
    map!(VkDescriptorSetLayout,      ref!DescriptorSetLayoutObject)      DescriptorSetLayouts
    map!(VkDescriptorPool,           ref!DescriptorPoolObject)           DescriptorPools
    map!(VkFence,                    ref!FenceObject)                    Fences
    map!(VkSemaphore,                ref!SemaphoreObject)                Semaphores
    map!(VkEvent,                    ref!EventObject)                    Events
    map!(VkQueryPool,                ref!QueryPoolObject)                QueryPools
    map!(VkFramebuffer,              ref!FramebufferObject)              Framebuffers
    map!(VkRenderPass,               ref!RenderPassObject)               RenderPasses
    map!(VkPipelineCache,            ref!PipelineCacheObject)            PipelineCaches
    map!(VkCommandPool,              ref!CommandPoolObject)              CommandPools
    map!(VkSurfaceKHR,               ref!SurfaceObject)                  Surfaces
    map!(VkSwapchainKHR,             ref!SwapchainObject)                Swapchains
}

@internal class InstanceObject {
}

@internal class PhysicalDeviceObject {
    VkInstance instance
}

@internal class DeviceObject {
    VkPhysicalDevice physicalDevice
}

@internal class QueueObject {
    VkDevice      device
    VkQueueFlags  flags
}

@internal class CommandBufferObject {
    VkDevice                  device
    map!(u64, VkDeviceMemory) boundObjects
    VkQueueFlags              queueFlags
}

@internal class DeviceMemoryObject {
    VkDevice                                device
    VkDeviceSize                            allocationSize
    map!(u64, VkDeviceSize)                 boundObjects
    map!(VkCommandBuffer, VkCommandBuffer)  boundCommandBuffers
}

@internal class BufferObject {
    VkDevice              device
    VkDeviceMemory        memory
    VkDeviceSize          memoryOffset
}

@internal class BufferViewObject {
    VkDevice      device
    VkBuffer      buffer
}

@internal class ImageObject {
    VkDevice              device
    VkDeviceMemory        memory
    VkDeviceSize          memoryOffset
}

@internal class ImageViewObject {
    VkDevice      device
    VkImage       image
}

@internal class ShaderObject {
    VkDevice      device
}

@internal class ShaderModuleObject {
    VkDevice      device
}

@internal class PipelineObject {
    VkDevice      device
}

@internal class PipelineLayoutObject {
    VkDevice      device
}

@internal class SamplerObject {
    VkDevice      device
}

@internal class DescriptorSetObject {
    VkDevice      device
}

@internal class DescriptorSetLayoutObject {
    VkDevice      device
}

@internal class DescriptorPoolObject {
    VkDevice      device
}

@internal class FenceObject {
    VkDevice      device
    bool          signaled
}

@internal class SemaphoreObject {
    VkDevice      device
}

@internal class EventObject {
    VkDevice      device
}

@internal class QueryPoolObject {
    VkDevice      device
}

@internal class FramebufferObject {
    VkDevice      device
}

@internal class RenderPassObject {
    VkDevice      device
}

@internal class PipelineCacheObject {
    VkDevice      device
}

@internal class CommandPoolObject {
    VkDevice      device
}

@internal class SurfaceObject {
    VkInstance    instance
}

@internal class SwapchainObject {
    VkDevice      device
}

macro ref!InstanceObject GetInstance(VkInstance instance) {
    assert(instance in State.Instances)
    return State.Instances[instance]
}

macro ref!PhysicalDeviceObject GetPhysicalDevice(VkPhysicalDevice physicalDevice) {
    assert(physicalDevice in State.PhysicalDevices)
    return State.PhysicalDevices[physicalDevice]
}

macro ref!DeviceObject GetDevice(VkDevice device) {
    assert(device in State.Devices)
    return State.Devices[device]
}

macro ref!QueueObject GetQueue(VkQueue queue) {
    assert(queue in State.Queues)
    return State.Queues[queue]
}

macro ref!CommandBufferObject GetCommandBuffer(VkCommandBuffer commandBuffer) {
    assert(commandBuffer in State.CommandBuffers)
    return State.CommandBuffers[commandBuffer]
}

macro ref!DeviceMemoryObject GetDeviceMemory(VkDeviceMemory memory) {
    assert(memory in State.DeviceMemories)
    return State.DeviceMemories[memory]
}

macro ref!BufferObject GetBuffer(VkBuffer buffer) {
    assert(buffer in State.Buffers)
    return State.Buffers[buffer]
}

macro ref!BufferViewObject GetBufferView(VkBufferView bufferView) {
    assert(bufferView in State.BufferViews)
    return State.BufferViews[bufferView]
}

macro ref!ImageObject GetImage(VkImage image) {
    assert(image in State.Images)
    return State.Images[image]
}

macro ref!ImageViewObject GetImageView(VkImageView imageView) {
    assert(imageView in State.ImageViews)
    return State.ImageViews[imageView]
}

macro ref!ShaderModuleObject GetShaderModule(VkShaderModule shaderModule) {
    assert(shaderModule in State.ShaderModules)
    return State.ShaderModules[shaderModule]
}

macro ref!PipelineObject GetPipeline(VkPipeline pipeline) {
    assert(pipeline in State.Pipelines)
    return State.Pipelines[pipeline]
}

macro ref!PipelineLayoutObject GetPipelineLayout(VkPipelineLayout pipelineLayout) {
    assert(pipelineLayout in State.PipelineLayouts)
    return State.PipelineLayouts[pipelineLayout]
}

macro ref!SamplerObject GetSampler(VkSampler sampler) {
    assert(sampler in State.Samplers)
    return State.Samplers[sampler]
}

macro ref!DescriptorSetObject GetDescriptorSet(VkDescriptorSet descriptorSet) {
    assert(descriptorSet in State.DescriptorSets)
    return State.DescriptorSets[descriptorSet]
}

macro ref!DescriptorSetLayoutObject GetDescriptorSetLayout(VkDescriptorSetLayout descriptorSetLayout) {
    assert(descriptorSetLayout in State.DescriptorSetLayouts)
    return State.DescriptorSetLayouts[descriptorSetLayout]
}

macro ref!DescriptorPoolObject GetDescriptorPool(VkDescriptorPool descriptorPool) {
    assert(descriptorPool in State.DescriptorPools)
    return State.DescriptorPools[descriptorPool]
}

macro ref!FenceObject GetFence(VkFence fence) {
    assert(fence in State.Fences)
    return State.Fences[fence]
}

macro ref!SemaphoreObject GetSemaphore(VkSemaphore semaphore) {
    assert(semaphore in State.Semaphores)
    return State.Semaphores[semaphore]
}

macro ref!EventObject GetEvent(VkEvent event) {
    assert(event in State.Events)
    return State.Events[event]
}

macro ref!QueryPoolObject GetQueryPool(VkQueryPool queryPool) {
    assert(queryPool in State.QueryPools)
    return State.QueryPools[queryPool]
}

macro ref!FramebufferObject GetFramebuffer(VkFramebuffer framebuffer) {
    assert(framebuffer in State.Framebuffers)
    return State.Framebuffers[framebuffer]
}

macro ref!RenderPassObject GetRenderPass(VkRenderPass renderPass) {
    assert(renderPass in State.RenderPasses)
    return State.RenderPasses[renderPass]
}

macro ref!PipelineCacheObject GetPipelineCache(VkPipelineCache pipelineCache) {
    assert(pipelineCache in State.PipelineCaches)
    return State.PipelineCaches[pipelineCache]
}

macro ref!CommandPoolObject GetCommandPool(VkCommandPool commandPool) {
    assert(commandPool in State.CommandPools)
    return State.CommandPools[commandPool]
}

macro ref!SurfaceObject GetSurface(VkSurfaceKHR surface) {
    assert(surface in State.Surfaces)
    return State.Surfaces[surface]
}

macro ref!SwapchainObject GetSwapchain(VkSwapchainKHR swapchain) {
    assert(swapchain in State.Swapchains)
    return State.Swapchains[swapchain]
}

macro VkQueueFlags AddQueueFlag(VkQueueFlags flags, VkQueueFlagBits bit) {
    return as!VkQueueFlags(as!u32(flags) | as!u32(bit))
}
