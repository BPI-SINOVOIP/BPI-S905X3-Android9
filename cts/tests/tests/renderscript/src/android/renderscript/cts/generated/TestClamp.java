/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Don't edit this file!  It is auto-generated by frameworks/rs/api/generate.sh.

package android.renderscript.cts;

import android.renderscript.Allocation;
import android.renderscript.RSRuntimeException;
import android.renderscript.Element;
import android.renderscript.cts.Target;

import java.util.Arrays;

public class TestClamp extends RSBaseCompute {

    private ScriptC_TestClamp script;
    private ScriptC_TestClampRelaxed scriptRelaxed;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        script = new ScriptC_TestClamp(mRS);
        scriptRelaxed = new ScriptC_TestClampRelaxed(mRS);
    }

    @Override
    protected void tearDown() throws Exception {
        script.destroy();
        scriptRelaxed.destroy();
        super.tearDown();
    }

    public class ArgumentsFloatFloatFloatFloat {
        public float inValue;
        public float inMinValue;
        public float inMaxValue;
        public Target.Floaty out;
    }

    private void checkClampFloatFloatFloatFloat() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 1, 0x7e886d7cc83c447dl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 1, 0xdcebf6f230234027l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 1, 0xdcebf6e6c180322dl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 1), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampFloatFloatFloatFloat(inValue, out);
            verifyResultsClampFloatFloatFloatFloat(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloatFloatFloatFloat: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampFloatFloatFloatFloat(inValue, out);
            verifyResultsClampFloatFloatFloatFloat(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloatFloatFloatFloat: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampFloatFloatFloatFloat(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        float[] arrayInValue = new float[INPUTSIZE * 1];
        Arrays.fill(arrayInValue, (float) 42);
        inValue.copyTo(arrayInValue);
        float[] arrayInMinValue = new float[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (float) 42);
        inMinValue.copyTo(arrayInMinValue);
        float[] arrayInMaxValue = new float[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (float) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        float[] arrayOut = new float[INPUTSIZE * 1];
        Arrays.fill(arrayOut, (float) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsFloatFloatFloatFloat args = new ArgumentsFloatFloatFloatFloat();
                args.inValue = arrayInValue[i];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.FLOAT, relaxed);
                CoreMathVerifier.computeClamp(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(arrayOut[i * 1 + j])) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 1 + j]);
                        if (!args.out.couldBe(arrayOut[i * 1 + j])) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampFloatFloatFloatFloat" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampFloat2Float2Float2Float2() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 2, 0xa0d28bf142b07a5l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 2, 0xb4e5c5f6ea8fc01fl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 2, 0xb4e5c5eb7becb225l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampFloat2Float2Float2Float2(inValue, out);
            verifyResultsClampFloat2Float2Float2Float2(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloat2Float2Float2Float2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampFloat2Float2Float2Float2(inValue, out);
            verifyResultsClampFloat2Float2Float2Float2(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloat2Float2Float2Float2: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampFloat2Float2Float2Float2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        float[] arrayInValue = new float[INPUTSIZE * 2];
        Arrays.fill(arrayInValue, (float) 42);
        inValue.copyTo(arrayInValue);
        float[] arrayInMinValue = new float[INPUTSIZE * 2];
        Arrays.fill(arrayInMinValue, (float) 42);
        inMinValue.copyTo(arrayInMinValue);
        float[] arrayInMaxValue = new float[INPUTSIZE * 2];
        Arrays.fill(arrayInMaxValue, (float) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        float[] arrayOut = new float[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (float) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsFloatFloatFloatFloat args = new ArgumentsFloatFloatFloatFloat();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i * 2 + j];
                args.inMaxValue = arrayInMaxValue[i * 2 + j];
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.FLOAT, relaxed);
                CoreMathVerifier.computeClamp(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(arrayOut[i * 2 + j])) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (!args.out.couldBe(arrayOut[i * 2 + j])) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampFloat2Float2Float2Float2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampFloat3Float3Float3Float3() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 3, 0xd3716a4730ad7481l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 3, 0xc0d239a53946aa73l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 3, 0xc0d23999caa39c79l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampFloat3Float3Float3Float3(inValue, out);
            verifyResultsClampFloat3Float3Float3Float3(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloat3Float3Float3Float3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampFloat3Float3Float3Float3(inValue, out);
            verifyResultsClampFloat3Float3Float3Float3(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloat3Float3Float3Float3: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampFloat3Float3Float3Float3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        float[] arrayInValue = new float[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (float) 42);
        inValue.copyTo(arrayInValue);
        float[] arrayInMinValue = new float[INPUTSIZE * 4];
        Arrays.fill(arrayInMinValue, (float) 42);
        inMinValue.copyTo(arrayInMinValue);
        float[] arrayInMaxValue = new float[INPUTSIZE * 4];
        Arrays.fill(arrayInMaxValue, (float) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        float[] arrayOut = new float[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (float) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsFloatFloatFloatFloat args = new ArgumentsFloatFloatFloatFloat();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.FLOAT, relaxed);
                CoreMathVerifier.computeClamp(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(arrayOut[i * 4 + j])) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (!args.out.couldBe(arrayOut[i * 4 + j])) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampFloat3Float3Float3Float3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampFloat4Float4Float4Float4() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 4, 0x9cd5abcf4d2fe15dl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 4, 0xccbead5387fd94c7l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 4, 0xccbead48195a86cdl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampFloat4Float4Float4Float4(inValue, out);
            verifyResultsClampFloat4Float4Float4Float4(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloat4Float4Float4Float4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampFloat4Float4Float4Float4(inValue, out);
            verifyResultsClampFloat4Float4Float4Float4(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloat4Float4Float4Float4: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampFloat4Float4Float4Float4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        float[] arrayInValue = new float[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (float) 42);
        inValue.copyTo(arrayInValue);
        float[] arrayInMinValue = new float[INPUTSIZE * 4];
        Arrays.fill(arrayInMinValue, (float) 42);
        inMinValue.copyTo(arrayInMinValue);
        float[] arrayInMaxValue = new float[INPUTSIZE * 4];
        Arrays.fill(arrayInMaxValue, (float) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        float[] arrayOut = new float[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (float) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsFloatFloatFloatFloat args = new ArgumentsFloatFloatFloatFloat();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.FLOAT, relaxed);
                CoreMathVerifier.computeClamp(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(arrayOut[i * 4 + j])) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (!args.out.couldBe(arrayOut[i * 4 + j])) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampFloat4Float4Float4Float4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampFloat2FloatFloatFloat2() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 2, 0x71623fb3f1fca1a1l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 1, 0x148e792e1a6253d3l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 1, 0x148e7922abbf45d9l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampFloat2FloatFloatFloat2(inValue, out);
            verifyResultsClampFloat2FloatFloatFloat2(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloat2FloatFloatFloat2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampFloat2FloatFloatFloat2(inValue, out);
            verifyResultsClampFloat2FloatFloatFloat2(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloat2FloatFloatFloat2: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampFloat2FloatFloatFloat2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        float[] arrayInValue = new float[INPUTSIZE * 2];
        Arrays.fill(arrayInValue, (float) 42);
        inValue.copyTo(arrayInValue);
        float[] arrayInMinValue = new float[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (float) 42);
        inMinValue.copyTo(arrayInMinValue);
        float[] arrayInMaxValue = new float[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (float) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        float[] arrayOut = new float[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (float) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsFloatFloatFloatFloat args = new ArgumentsFloatFloatFloatFloat();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.FLOAT, relaxed);
                CoreMathVerifier.computeClamp(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(arrayOut[i * 2 + j])) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (!args.out.couldBe(arrayOut[i * 2 + j])) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampFloat2FloatFloatFloat2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampFloat3FloatFloatFloat3() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 3, 0xc06893ff6ab8cf27l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 1, 0x1f4444b84d90bbc5l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 1, 0x1f4444acdeedadcbl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampFloat3FloatFloatFloat3(inValue, out);
            verifyResultsClampFloat3FloatFloatFloat3(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloat3FloatFloatFloat3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampFloat3FloatFloatFloat3(inValue, out);
            verifyResultsClampFloat3FloatFloatFloat3(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloat3FloatFloatFloat3: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampFloat3FloatFloatFloat3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        float[] arrayInValue = new float[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (float) 42);
        inValue.copyTo(arrayInValue);
        float[] arrayInMinValue = new float[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (float) 42);
        inMinValue.copyTo(arrayInMinValue);
        float[] arrayInMaxValue = new float[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (float) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        float[] arrayOut = new float[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (float) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsFloatFloatFloatFloat args = new ArgumentsFloatFloatFloatFloat();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.FLOAT, relaxed);
                CoreMathVerifier.computeClamp(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(arrayOut[i * 4 + j])) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (!args.out.couldBe(arrayOut[i * 4 + j])) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampFloat3FloatFloatFloat3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampFloat4FloatFloatFloat4() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 4, 0xf6ee84ae374fcadl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 1, 0x29fa104280bf23b7l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.FLOAT_32, 1, 0x29fa1037121c15bdl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampFloat4FloatFloatFloat4(inValue, out);
            verifyResultsClampFloat4FloatFloatFloat4(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloat4FloatFloatFloat4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_32, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampFloat4FloatFloatFloat4(inValue, out);
            verifyResultsClampFloat4FloatFloatFloat4(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampFloat4FloatFloatFloat4: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampFloat4FloatFloatFloat4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        float[] arrayInValue = new float[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (float) 42);
        inValue.copyTo(arrayInValue);
        float[] arrayInMinValue = new float[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (float) 42);
        inMinValue.copyTo(arrayInMinValue);
        float[] arrayInMaxValue = new float[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (float) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        float[] arrayOut = new float[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (float) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsFloatFloatFloatFloat args = new ArgumentsFloatFloatFloatFloat();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.FLOAT, relaxed);
                CoreMathVerifier.computeClamp(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(arrayOut[i * 4 + j])) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (!args.out.couldBe(arrayOut[i * 4 + j])) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampFloat4FloatFloatFloat4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    public class ArgumentsCharCharCharChar {
        public byte inValue;
        public byte inMinValue;
        public byte inMaxValue;
        public byte out;
    }

    private void checkClampCharCharCharChar() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 1, 0xaec8640bb673cf75l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 1, 0x6379f7c3c505c8fl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 1, 0x6379f70cdad4e95l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 1), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampCharCharCharChar(inValue, out);
            verifyResultsClampCharCharCharChar(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampCharCharCharChar: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampCharCharCharChar(inValue, out);
            verifyResultsClampCharCharCharChar(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampCharCharCharChar: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampCharCharCharChar(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayInValue, (byte) 42);
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (byte) 42);
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (byte) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayOut, (byte) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsCharCharCharChar args = new ArgumentsCharCharCharChar();
                args.inValue = arrayInValue[i];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 1 + j]);
                        if (args.out != arrayOut[i * 1 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampCharCharCharChar" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampChar2Char2Char2Char2() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 2, 0xa209cfe6c3feb45dl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 2, 0xed63d0ab3442bdc7l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 2, 0xed63d09fc59fafcdl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampChar2Char2Char2Char2(inValue, out);
            verifyResultsClampChar2Char2Char2Char2(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampChar2Char2Char2Char2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampChar2Char2Char2Char2(inValue, out);
            verifyResultsClampChar2Char2Char2Char2(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampChar2Char2Char2Char2: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampChar2Char2Char2Char2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 2];
        Arrays.fill(arrayInValue, (byte) 42);
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 2];
        Arrays.fill(arrayInMinValue, (byte) 42);
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 2];
        Arrays.fill(arrayInMaxValue, (byte) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (byte) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsCharCharCharChar args = new ArgumentsCharCharCharChar();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i * 2 + j];
                args.inMaxValue = arrayInMaxValue[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (args.out != arrayOut[i * 2 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampChar2Char2Char2Char2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampChar3Char3Char3Char3() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 3, 0xfab6edb7b9d3b0a5l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 3, 0x7ae6f958470ecb1fl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 3, 0x7ae6f94cd86bbd25l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampChar3Char3Char3Char3(inValue, out);
            verifyResultsClampChar3Char3Char3Char3(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampChar3Char3Char3Char3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampChar3Char3Char3Char3(inValue, out);
            verifyResultsClampChar3Char3Char3Char3(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampChar3Char3Char3Char3: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampChar3Char3Char3Char3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (byte) 42);
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayInMinValue, (byte) 42);
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayInMaxValue, (byte) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (byte) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsCharCharCharChar args = new ArgumentsCharCharCharChar();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampChar3Char3Char3Char3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampChar4Char4Char4Char4() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 4, 0x53640b88afa8acedl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 4, 0x86a220559dad877l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 4, 0x86a21f9eb37ca7dl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampChar4Char4Char4Char4(inValue, out);
            verifyResultsClampChar4Char4Char4Char4(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampChar4Char4Char4Char4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampChar4Char4Char4Char4(inValue, out);
            verifyResultsClampChar4Char4Char4Char4(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampChar4Char4Char4Char4: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampChar4Char4Char4Char4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (byte) 42);
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayInMinValue, (byte) 42);
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayInMaxValue, (byte) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (byte) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsCharCharCharChar args = new ArgumentsCharCharCharChar();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampChar4Char4Char4Char4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    public class ArgumentsUcharUcharUcharUchar {
        public byte inValue;
        public byte inMinValue;
        public byte inMaxValue;
        public byte out;
    }

    private void checkClampUcharUcharUcharUchar() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 1, 0x680c818a4447655l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 1, 0xae40bae375336f2fl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 1, 0xae40bad806906135l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 1), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUcharUcharUcharUchar(inValue, out);
            verifyResultsClampUcharUcharUcharUchar(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUcharUcharUcharUchar: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUcharUcharUcharUchar(inValue, out);
            verifyResultsClampUcharUcharUcharUchar(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUcharUcharUcharUchar: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampUcharUcharUcharUchar(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayInValue, (byte) 42);
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (byte) 42);
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (byte) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayOut, (byte) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUcharUcharUchar args = new ArgumentsUcharUcharUcharUchar();
                args.inValue = arrayInValue[i];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 1 + j]);
                        if (args.out != arrayOut[i * 1 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUcharUcharUcharUchar" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUchar2Uchar2Uchar2Uchar2() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 2, 0xd69df43245dae301l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 2, 0x82681747662c1df3l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 2, 0x8268173bf7890ff9l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUchar2Uchar2Uchar2Uchar2(inValue, out);
            verifyResultsClampUchar2Uchar2Uchar2Uchar2(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUchar2Uchar2Uchar2Uchar2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUchar2Uchar2Uchar2Uchar2(inValue, out);
            verifyResultsClampUchar2Uchar2Uchar2Uchar2(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUchar2Uchar2Uchar2Uchar2: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampUchar2Uchar2Uchar2Uchar2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 2];
        Arrays.fill(arrayInValue, (byte) 42);
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 2];
        Arrays.fill(arrayInMinValue, (byte) 42);
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 2];
        Arrays.fill(arrayInMaxValue, (byte) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (byte) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUcharUcharUchar args = new ArgumentsUcharUcharUcharUchar();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i * 2 + j];
                args.inMaxValue = arrayInMaxValue[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (args.out != arrayOut[i * 2 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUchar2Uchar2Uchar2Uchar2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUchar3Uchar3Uchar3Uchar3() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 3, 0xa00235ba625d4fddl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 3, 0x8e548af5b4e30847l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 3, 0x8e548aea463ffa4dl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUchar3Uchar3Uchar3Uchar3(inValue, out);
            verifyResultsClampUchar3Uchar3Uchar3Uchar3(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUchar3Uchar3Uchar3Uchar3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUchar3Uchar3Uchar3Uchar3(inValue, out);
            verifyResultsClampUchar3Uchar3Uchar3Uchar3(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUchar3Uchar3Uchar3Uchar3: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampUchar3Uchar3Uchar3Uchar3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (byte) 42);
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayInMinValue, (byte) 42);
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayInMaxValue, (byte) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (byte) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUcharUcharUchar args = new ArgumentsUcharUcharUcharUchar();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUchar3Uchar3Uchar3Uchar3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUchar4Uchar4Uchar4Uchar4() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 4, 0x696677427edfbcb9l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 4, 0x9a40fea40399f29bl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 4, 0x9a40fe9894f6e4a1l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUchar4Uchar4Uchar4Uchar4(inValue, out);
            verifyResultsClampUchar4Uchar4Uchar4Uchar4(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUchar4Uchar4Uchar4Uchar4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUchar4Uchar4Uchar4Uchar4(inValue, out);
            verifyResultsClampUchar4Uchar4Uchar4Uchar4(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUchar4Uchar4Uchar4Uchar4: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampUchar4Uchar4Uchar4Uchar4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (byte) 42);
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayInMinValue, (byte) 42);
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayInMaxValue, (byte) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (byte) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUcharUcharUchar args = new ArgumentsUcharUcharUcharUchar();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUchar4Uchar4Uchar4Uchar4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    public class ArgumentsShortShortShortShort {
        public short inValue;
        public short inMinValue;
        public short inMaxValue;
        public short out;
    }

    private void checkClampShortShortShortShort() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 1, 0x8035c0627fc993ddl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 1, 0xb5d4bd1fb4661447l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 1, 0xb5d4bd1445c3064dl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 1), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampShortShortShortShort(inValue, out);
            verifyResultsClampShortShortShortShort(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShortShortShortShort: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampShortShortShortShort(inValue, out);
            verifyResultsClampShortShortShortShort(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShortShortShortShort: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampShortShortShortShort(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 1];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsShortShortShortShort args = new ArgumentsShortShortShortShort();
                args.inValue = arrayInValue[i];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 1 + j]);
                        if (args.out != arrayOut[i * 1 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampShortShortShortShort" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampShort2Short2Short2Short2() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 2, 0x7eab8e9b984e0915l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 2, 0x7b334b992e67336fl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 2, 0x7b334b8dbfc42575l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampShort2Short2Short2Short2(inValue, out);
            verifyResultsClampShort2Short2Short2Short2(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShort2Short2Short2Short2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampShort2Short2Short2Short2(inValue, out);
            verifyResultsClampShort2Short2Short2Short2(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShort2Short2Short2Short2: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampShort2Short2Short2Short2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 2];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 2];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 2];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsShortShortShortShort args = new ArgumentsShortShortShortShort();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i * 2 + j];
                args.inMaxValue = arrayInMaxValue[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (args.out != arrayOut[i * 2 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampShort2Short2Short2Short2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampShort3Short3Short3Short3() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 3, 0x480fd023b4d075f1l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 3, 0x871fbf477d1e1dc3l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 3, 0x871fbf3c0e7b0fc9l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampShort3Short3Short3Short3(inValue, out);
            verifyResultsClampShort3Short3Short3Short3(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShort3Short3Short3Short3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampShort3Short3Short3Short3(inValue, out);
            verifyResultsClampShort3Short3Short3Short3(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShort3Short3Short3Short3: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampShort3Short3Short3Short3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsShortShortShortShort args = new ArgumentsShortShortShortShort();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampShort3Short3Short3Short3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampShort4Short4Short4Short4() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 4, 0x117411abd152e2cdl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 4, 0x930c32f5cbd50817l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 4, 0x930c32ea5d31fa1dl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampShort4Short4Short4Short4(inValue, out);
            verifyResultsClampShort4Short4Short4Short4(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShort4Short4Short4Short4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampShort4Short4Short4Short4(inValue, out);
            verifyResultsClampShort4Short4Short4Short4(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShort4Short4Short4Short4: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampShort4Short4Short4Short4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsShortShortShortShort args = new ArgumentsShortShortShortShort();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampShort4Short4Short4Short4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    public class ArgumentsUshortUshortUshortUshort {
        public short inValue;
        public short inMinValue;
        public short inMaxValue;
        public short out;
    }

    private void checkClampUshortUshortUshortUshort() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 1, 0xf5881eeff74c4341l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 1, 0xd2a0571394d3e2b3l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 1, 0xd2a057082630d4b9l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 1), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUshortUshortUshortUshort(inValue, out);
            verifyResultsClampUshortUshortUshortUshort(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshortUshortUshortUshort: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUshortUshortUshortUshort(inValue, out);
            verifyResultsClampUshortUshortUshortUshort(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshortUshortUshortUshort: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampUshortUshortUshortUshort(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 1];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshortUshortUshort args = new ArgumentsUshortUshortUshortUshort();
                args.inValue = arrayInValue[i];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 1 + j]);
                        if (args.out != arrayOut[i * 1 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUshortUshortUshortUshort" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUshort2Ushort2Ushort2Ushort2() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 2, 0x6441dbe2fc36b705l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 2, 0x52161e934fa3b43fl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 2, 0x52161e87e100a645l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUshort2Ushort2Ushort2Ushort2(inValue, out);
            verifyResultsClampUshort2Ushort2Ushort2Ushort2(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshort2Ushort2Ushort2Ushort2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUshort2Ushort2Ushort2Ushort2(inValue, out);
            verifyResultsClampUshort2Ushort2Ushort2Ushort2(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshort2Ushort2Ushort2Ushort2: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampUshort2Ushort2Ushort2Ushort2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 2];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 2];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 2];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshortUshortUshort args = new ArgumentsUshortUshortUshortUshort();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i * 2 + j];
                args.inMaxValue = arrayInMaxValue[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (args.out != arrayOut[i * 2 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUshort2Ushort2Ushort2Ushort2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUshort3Ushort3Ushort3Ushort3() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 3, 0x6b244d61fc64ee3dl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 3, 0x7b8d14b8610b3967l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 3, 0x7b8d14acf2682b6dl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUshort3Ushort3Ushort3Ushort3(inValue, out);
            verifyResultsClampUshort3Ushort3Ushort3Ushort3(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshort3Ushort3Ushort3Ushort3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUshort3Ushort3Ushort3Ushort3(inValue, out);
            verifyResultsClampUshort3Ushort3Ushort3Ushort3(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshort3Ushort3Ushort3Ushort3: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampUshort3Ushort3Ushort3Ushort3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshortUshortUshort args = new ArgumentsUshortUshortUshortUshort();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUshort3Ushort3Ushort3Ushort3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUshort4Ushort4Ushort4Ushort4() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 4, 0x7206bee0fc932575l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 4, 0xa5040add7272be8fl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 4, 0xa5040ad203cfb095l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUshort4Ushort4Ushort4Ushort4(inValue, out);
            verifyResultsClampUshort4Ushort4Ushort4Ushort4(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshort4Ushort4Ushort4Ushort4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUshort4Ushort4Ushort4Ushort4(inValue, out);
            verifyResultsClampUshort4Ushort4Ushort4Ushort4(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshort4Ushort4Ushort4Ushort4: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampUshort4Ushort4Ushort4Ushort4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshortUshortUshort args = new ArgumentsUshortUshortUshortUshort();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUshort4Ushort4Ushort4Ushort4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    public class ArgumentsIntIntIntInt {
        public int inValue;
        public int inMinValue;
        public int inMaxValue;
        public int out;
    }

    private void checkClampIntIntIntInt() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 1, 0xfeb3aa11be6164c5l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 1, 0xd11c228c7c8bf97fl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 1, 0xd11c22810de8eb85l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 1), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampIntIntIntInt(inValue, out);
            verifyResultsClampIntIntIntInt(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampIntIntIntInt: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampIntIntIntInt(inValue, out);
            verifyResultsClampIntIntIntInt(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampIntIntIntInt: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampIntIntIntInt(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 1];
        Arrays.fill(arrayInValue, (int) 42);
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (int) 42);
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (int) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 1];
        Arrays.fill(arrayOut, (int) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsIntIntIntInt args = new ArgumentsIntIntIntInt();
                args.inValue = arrayInValue[i];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 1 + j]);
                        if (args.out != arrayOut[i * 1 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampIntIntIntInt" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampInt2Int2Int2Int2() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 2, 0x56252903bd307c01l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 2, 0x770112109398f8f3l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 2, 0x7701120524f5eaf9l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampInt2Int2Int2Int2(inValue, out);
            verifyResultsClampInt2Int2Int2Int2(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampInt2Int2Int2Int2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampInt2Int2Int2Int2(inValue, out);
            verifyResultsClampInt2Int2Int2Int2(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampInt2Int2Int2Int2: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampInt2Int2Int2Int2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 2];
        Arrays.fill(arrayInValue, (int) 42);
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 2];
        Arrays.fill(arrayInMinValue, (int) 42);
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 2];
        Arrays.fill(arrayInMaxValue, (int) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (int) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsIntIntIntInt args = new ArgumentsIntIntIntInt();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i * 2 + j];
                args.inMaxValue = arrayInMaxValue[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (args.out != arrayOut[i * 2 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampInt2Int2Int2Int2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampInt3Int3Int3Int3() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 3, 0x966882045600d2edl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 3, 0xeb73e6749c7caa77l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 3, 0xeb73e6692dd99c7dl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampInt3Int3Int3Int3(inValue, out);
            verifyResultsClampInt3Int3Int3Int3(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampInt3Int3Int3Int3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampInt3Int3Int3Int3(inValue, out);
            verifyResultsClampInt3Int3Int3Int3(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampInt3Int3Int3Int3: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampInt3Int3Int3Int3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (int) 42);
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 4];
        Arrays.fill(arrayInMinValue, (int) 42);
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 4];
        Arrays.fill(arrayInMaxValue, (int) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (int) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsIntIntIntInt args = new ArgumentsIntIntIntInt();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampInt3Int3Int3Int3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampInt4Int4Int4Int4() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 4, 0xd6abdb04eed129d9l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 4, 0x5fe6bad8a5605bfbl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 4, 0x5fe6bacd36bd4e01l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampInt4Int4Int4Int4(inValue, out);
            verifyResultsClampInt4Int4Int4Int4(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampInt4Int4Int4Int4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampInt4Int4Int4Int4(inValue, out);
            verifyResultsClampInt4Int4Int4Int4(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampInt4Int4Int4Int4: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampInt4Int4Int4Int4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (int) 42);
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 4];
        Arrays.fill(arrayInMinValue, (int) 42);
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 4];
        Arrays.fill(arrayInMaxValue, (int) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (int) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsIntIntIntInt args = new ArgumentsIntIntIntInt();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampInt4Int4Int4Int4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    public class ArgumentsUintUintUintUint {
        public int inValue;
        public int inMinValue;
        public int inMaxValue;
        public int out;
    }

    private void checkClampUintUintUintUint() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 1, 0xd8df32b2efc89475l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 1, 0xcf8ec8eece8b7b8fl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 1, 0xcf8ec8e35fe86d95l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 1), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUintUintUintUint(inValue, out);
            verifyResultsClampUintUintUintUint(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUintUintUintUint: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUintUintUintUint(inValue, out);
            verifyResultsClampUintUintUintUint(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUintUintUintUint: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampUintUintUintUint(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 1];
        Arrays.fill(arrayInValue, (int) 42);
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (int) 42);
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (int) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 1];
        Arrays.fill(arrayOut, (int) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsUintUintUintUint args = new ArgumentsUintUintUintUint();
                args.inValue = arrayInValue[i];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 1 + j]);
                        if (args.out != arrayOut[i * 1 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUintUintUintUint" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUint2Uint2Uint2Uint2() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 2, 0xaf28d478873ae5dl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 2, 0x5bbd21aa2a4bc7l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 2, 0x5bbd163b873dcdl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUint2Uint2Uint2Uint2(inValue, out);
            verifyResultsClampUint2Uint2Uint2Uint2(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUint2Uint2Uint2Uint2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUint2Uint2Uint2Uint2(inValue, out);
            verifyResultsClampUint2Uint2Uint2Uint2(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUint2Uint2Uint2Uint2: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampUint2Uint2Uint2Uint2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 2];
        Arrays.fill(arrayInValue, (int) 42);
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 2];
        Arrays.fill(arrayInMinValue, (int) 42);
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 2];
        Arrays.fill(arrayInMaxValue, (int) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (int) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsUintUintUintUint args = new ArgumentsUintUintUintUint();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i * 2 + j];
                args.inMaxValue = arrayInMaxValue[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (args.out != arrayOut[i * 2 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUint2Uint2Uint2Uint2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUint3Uint3Uint3Uint3() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 3, 0x639fab187e48aaa5l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 3, 0x8ddee5cebcf6591fl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 3, 0x8ddee5c34e534b25l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUint3Uint3Uint3Uint3(inValue, out);
            verifyResultsClampUint3Uint3Uint3Uint3(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUint3Uint3Uint3Uint3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUint3Uint3Uint3Uint3(inValue, out);
            verifyResultsClampUint3Uint3Uint3Uint3(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUint3Uint3Uint3Uint3: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampUint3Uint3Uint3Uint3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (int) 42);
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 4];
        Arrays.fill(arrayInMinValue, (int) 42);
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 4];
        Arrays.fill(arrayInMaxValue, (int) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (int) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsUintUintUintUint args = new ArgumentsUintUintUintUint();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUint3Uint3Uint3Uint3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUint4Uint4Uint4Uint4() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 4, 0xbc4cc8e9741da6edl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 4, 0x1b620e7bcfc26677l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 4, 0x1b620e70611f587dl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUint4Uint4Uint4Uint4(inValue, out);
            verifyResultsClampUint4Uint4Uint4Uint4(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUint4Uint4Uint4Uint4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUint4Uint4Uint4Uint4(inValue, out);
            verifyResultsClampUint4Uint4Uint4Uint4(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUint4Uint4Uint4Uint4: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampUint4Uint4Uint4Uint4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (int) 42);
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 4];
        Arrays.fill(arrayInMinValue, (int) 42);
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 4];
        Arrays.fill(arrayInMaxValue, (int) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (int) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsUintUintUintUint args = new ArgumentsUintUintUintUint();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUint4Uint4Uint4Uint4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    public class ArgumentsLongLongLongLong {
        public long inValue;
        public long inMinValue;
        public long inMaxValue;
        public long out;
    }

    private void checkClampLongLongLongLong() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 1, 0x63fd360531c9c41dl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 1, 0x9d04d1824ef4907l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 1, 0x9d04d0cb64c3b0dl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 1), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampLongLongLongLong(inValue, out);
            verifyResultsClampLongLongLongLong(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampLongLongLongLong: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampLongLongLongLong(inValue, out);
            verifyResultsClampLongLongLongLong(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampLongLongLongLong: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampLongLongLongLong(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        long[] arrayInValue = new long[INPUTSIZE * 1];
        Arrays.fill(arrayInValue, (long) 42);
        inValue.copyTo(arrayInValue);
        long[] arrayInMinValue = new long[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (long) 42);
        inMinValue.copyTo(arrayInMinValue);
        long[] arrayInMaxValue = new long[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (long) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        long[] arrayOut = new long[INPUTSIZE * 1];
        Arrays.fill(arrayOut, (long) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsLongLongLongLong args = new ArgumentsLongLongLongLong();
                args.inValue = arrayInValue[i];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 1 + j]);
                        if (args.out != arrayOut[i * 1 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampLongLongLongLong" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampLong2Long2Long2Long2() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 2, 0xccbae869c2b0f12dl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 2, 0xe4c3844f4a3f8937l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 2, 0xe4c38443db9c7b3dl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampLong2Long2Long2Long2(inValue, out);
            verifyResultsClampLong2Long2Long2Long2(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampLong2Long2Long2Long2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampLong2Long2Long2Long2(inValue, out);
            verifyResultsClampLong2Long2Long2Long2(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampLong2Long2Long2Long2: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampLong2Long2Long2Long2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        long[] arrayInValue = new long[INPUTSIZE * 2];
        Arrays.fill(arrayInValue, (long) 42);
        inValue.copyTo(arrayInValue);
        long[] arrayInMinValue = new long[INPUTSIZE * 2];
        Arrays.fill(arrayInMinValue, (long) 42);
        inMinValue.copyTo(arrayInMinValue);
        long[] arrayInMaxValue = new long[INPUTSIZE * 2];
        Arrays.fill(arrayInMaxValue, (long) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        long[] arrayOut = new long[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (long) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsLongLongLongLong args = new ArgumentsLongLongLongLong();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i * 2 + j];
                args.inMaxValue = arrayInMaxValue[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (args.out != arrayOut[i * 2 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampLong2Long2Long2Long2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampLong3Long3Long3Long3() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 3, 0x2568063ab885ed75l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 3, 0x7246acfc5d0b968fl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 3, 0x7246acf0ee688895l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampLong3Long3Long3Long3(inValue, out);
            verifyResultsClampLong3Long3Long3Long3(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampLong3Long3Long3Long3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampLong3Long3Long3Long3(inValue, out);
            verifyResultsClampLong3Long3Long3Long3(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampLong3Long3Long3Long3: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampLong3Long3Long3Long3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        long[] arrayInValue = new long[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (long) 42);
        inValue.copyTo(arrayInValue);
        long[] arrayInMinValue = new long[INPUTSIZE * 4];
        Arrays.fill(arrayInMinValue, (long) 42);
        inMinValue.copyTo(arrayInMinValue);
        long[] arrayInMaxValue = new long[INPUTSIZE * 4];
        Arrays.fill(arrayInMaxValue, (long) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        long[] arrayOut = new long[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (long) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsLongLongLongLong args = new ArgumentsLongLongLongLong();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampLong3Long3Long3Long3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampLong4Long4Long4Long4() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 4, 0x7e15240bae5ae9bdl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 4, 0xffc9d5a96fd7a3e7l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 4, 0xffc9d59e013495edl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampLong4Long4Long4Long4(inValue, out);
            verifyResultsClampLong4Long4Long4Long4(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampLong4Long4Long4Long4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampLong4Long4Long4Long4(inValue, out);
            verifyResultsClampLong4Long4Long4Long4(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampLong4Long4Long4Long4: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampLong4Long4Long4Long4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        long[] arrayInValue = new long[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (long) 42);
        inValue.copyTo(arrayInValue);
        long[] arrayInMinValue = new long[INPUTSIZE * 4];
        Arrays.fill(arrayInMinValue, (long) 42);
        inMinValue.copyTo(arrayInMinValue);
        long[] arrayInMaxValue = new long[INPUTSIZE * 4];
        Arrays.fill(arrayInMaxValue, (long) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        long[] arrayOut = new long[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (long) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsLongLongLongLong args = new ArgumentsLongLongLongLong();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampLong4Long4Long4Long4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    public class ArgumentsUlongUlongUlongUlong {
        public long inValue;
        public long inMinValue;
        public long inMaxValue;
        public long out;
    }

    private void checkClampUlongUlongUlongUlong() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 1, 0x2b378139749bf4c5l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 1, 0x75ac5050a8ca97fl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 1, 0x75ac4f99be99b85l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 1), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUlongUlongUlongUlong(inValue, out);
            verifyResultsClampUlongUlongUlongUlong(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUlongUlongUlongUlong: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUlongUlongUlongUlong(inValue, out);
            verifyResultsClampUlongUlongUlongUlong(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUlongUlongUlongUlong: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampUlongUlongUlongUlong(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        long[] arrayInValue = new long[INPUTSIZE * 1];
        Arrays.fill(arrayInValue, (long) 42);
        inValue.copyTo(arrayInValue);
        long[] arrayInMinValue = new long[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (long) 42);
        inMinValue.copyTo(arrayInMinValue);
        long[] arrayInMaxValue = new long[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (long) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        long[] arrayOut = new long[INPUTSIZE * 1];
        Arrays.fill(arrayOut, (long) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsUlongUlongUlongUlong args = new ArgumentsUlongUlongUlongUlong();
                args.inValue = arrayInValue[i];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 1 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 1 + j]);
                        if (args.out != arrayOut[i * 1 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUlongUlongUlongUlong" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUlong2Ulong2Ulong2Ulong2() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 2, 0xa8c7fb17a09bb299l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 2, 0x14e3c8dffe45623bl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 2, 0x14e3c8d48fa25441l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUlong2Ulong2Ulong2Ulong2(inValue, out);
            verifyResultsClampUlong2Ulong2Ulong2Ulong2(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUlong2Ulong2Ulong2Ulong2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUlong2Ulong2Ulong2Ulong2(inValue, out);
            verifyResultsClampUlong2Ulong2Ulong2Ulong2(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUlong2Ulong2Ulong2Ulong2: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampUlong2Ulong2Ulong2Ulong2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        long[] arrayInValue = new long[INPUTSIZE * 2];
        Arrays.fill(arrayInValue, (long) 42);
        inValue.copyTo(arrayInValue);
        long[] arrayInMinValue = new long[INPUTSIZE * 2];
        Arrays.fill(arrayInMinValue, (long) 42);
        inMinValue.copyTo(arrayInMinValue);
        long[] arrayInMaxValue = new long[INPUTSIZE * 2];
        Arrays.fill(arrayInMaxValue, (long) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        long[] arrayOut = new long[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (long) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsUlongUlongUlongUlong args = new ArgumentsUlongUlongUlongUlong();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i * 2 + j];
                args.inMaxValue = arrayInMaxValue[i * 2 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (args.out != arrayOut[i * 2 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUlong2Ulong2Ulong2Ulong2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUlong3Ulong3Ulong3Ulong3() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 3, 0x722c3c9fbd1e1f75l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 3, 0x20d03c8e4cfc4c8fl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 3, 0x20d03c82de593e95l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUlong3Ulong3Ulong3Ulong3(inValue, out);
            verifyResultsClampUlong3Ulong3Ulong3Ulong3(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUlong3Ulong3Ulong3Ulong3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUlong3Ulong3Ulong3Ulong3(inValue, out);
            verifyResultsClampUlong3Ulong3Ulong3Ulong3(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUlong3Ulong3Ulong3Ulong3: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampUlong3Ulong3Ulong3Ulong3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        long[] arrayInValue = new long[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (long) 42);
        inValue.copyTo(arrayInValue);
        long[] arrayInMinValue = new long[INPUTSIZE * 4];
        Arrays.fill(arrayInMinValue, (long) 42);
        inMinValue.copyTo(arrayInMinValue);
        long[] arrayInMaxValue = new long[INPUTSIZE * 4];
        Arrays.fill(arrayInMaxValue, (long) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        long[] arrayOut = new long[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (long) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsUlongUlongUlongUlong args = new ArgumentsUlongUlongUlongUlong();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUlong3Ulong3Ulong3Ulong3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUlong4Ulong4Ulong4Ulong4() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 4, 0x3b907e27d9a08c51l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 4, 0x2cbcb03c9bb336e3l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 4, 0x2cbcb0312d1028e9l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUlong4Ulong4Ulong4Ulong4(inValue, out);
            verifyResultsClampUlong4Ulong4Ulong4Ulong4(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUlong4Ulong4Ulong4Ulong4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUlong4Ulong4Ulong4Ulong4(inValue, out);
            verifyResultsClampUlong4Ulong4Ulong4Ulong4(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUlong4Ulong4Ulong4Ulong4: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampUlong4Ulong4Ulong4Ulong4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        long[] arrayInValue = new long[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (long) 42);
        inValue.copyTo(arrayInValue);
        long[] arrayInMinValue = new long[INPUTSIZE * 4];
        Arrays.fill(arrayInMinValue, (long) 42);
        inMinValue.copyTo(arrayInMinValue);
        long[] arrayInMaxValue = new long[INPUTSIZE * 4];
        Arrays.fill(arrayInMaxValue, (long) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        long[] arrayOut = new long[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (long) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsUlongUlongUlongUlong args = new ArgumentsUlongUlongUlongUlong();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUlong4Ulong4Ulong4Ulong4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampChar2CharCharChar2() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 2, 0xd6884bbb7c57a5d1l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 1, 0x3bf8830cc3b7db63l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 1, 0x3bf883015514cd69l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampChar2CharCharChar2(inValue, out);
            verifyResultsClampChar2CharCharChar2(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampChar2CharCharChar2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampChar2CharCharChar2(inValue, out);
            verifyResultsClampChar2CharCharChar2(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampChar2CharCharChar2: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampChar2CharCharChar2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 2];
        Arrays.fill(arrayInValue, (byte) 42);
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (byte) 42);
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (byte) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (byte) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsCharCharCharChar args = new ArgumentsCharCharCharChar();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (args.out != arrayOut[i * 2 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampChar2CharCharChar2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampChar3CharCharChar3() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 3, 0x4aa68c1b65a26ee5l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 1, 0x8b4b9ea0492789dfl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 1, 0x8b4b9e94da847be5l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampChar3CharCharChar3(inValue, out);
            verifyResultsClampChar3CharCharChar3(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampChar3CharCharChar3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampChar3CharCharChar3(inValue, out);
            verifyResultsClampChar3CharCharChar3(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampChar3CharCharChar3: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampChar3CharCharChar3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (byte) 42);
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (byte) 42);
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (byte) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (byte) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsCharCharCharChar args = new ArgumentsCharCharCharChar();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampChar3CharCharChar3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampChar4CharCharChar4() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 4, 0xbec4cc7b4eed37f9l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 1, 0xda9eba33ce97385bl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_8, 1, 0xda9eba285ff42a61l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampChar4CharCharChar4(inValue, out);
            verifyResultsClampChar4CharCharChar4(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampChar4CharCharChar4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_8, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampChar4CharCharChar4(inValue, out);
            verifyResultsClampChar4CharCharChar4(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampChar4CharCharChar4: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampChar4CharCharChar4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (byte) 42);
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (byte) 42);
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (byte) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (byte) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsCharCharCharChar args = new ArgumentsCharCharCharChar();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampChar4CharCharChar4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUchar2UcharUcharUchar2() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 2, 0xafd4a680f02e0d63l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 1, 0x78bbbcb3e9402039l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 1, 0x78bbbca87a9d123fl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUchar2UcharUcharUchar2(inValue, out);
            verifyResultsClampUchar2UcharUcharUchar2(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUchar2UcharUcharUchar2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUchar2UcharUcharUchar2(inValue, out);
            verifyResultsClampUchar2UcharUcharUchar2(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUchar2UcharUcharUchar2: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampUchar2UcharUcharUchar2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 2];
        Arrays.fill(arrayInValue, (byte) 42);
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (byte) 42);
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (byte) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (byte) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUcharUcharUchar args = new ArgumentsUcharUcharUcharUchar();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (args.out != arrayOut[i * 2 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUchar2UcharUcharUchar2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUchar3UcharUcharUchar3() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 3, 0xfedafacc68ea3ae9l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 1, 0x8371883e1c6e882bl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 1, 0x83718832adcb7a31l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUchar3UcharUcharUchar3(inValue, out);
            verifyResultsClampUchar3UcharUcharUchar3(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUchar3UcharUcharUchar3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUchar3UcharUcharUchar3(inValue, out);
            verifyResultsClampUchar3UcharUcharUchar3(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUchar3UcharUcharUchar3: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampUchar3UcharUcharUchar3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (byte) 42);
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (byte) 42);
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (byte) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (byte) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUcharUcharUchar args = new ArgumentsUcharUcharUcharUchar();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUchar3UcharUcharUchar3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUchar4UcharUcharUchar4() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 4, 0x4de14f17e1a6686fl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 1, 0x8e2753c84f9cf01dl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_8, 1, 0x8e2753bce0f9e223l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUchar4UcharUcharUchar4(inValue, out);
            verifyResultsClampUchar4UcharUcharUchar4(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUchar4UcharUcharUchar4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_8, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUchar4UcharUcharUchar4(inValue, out);
            verifyResultsClampUchar4UcharUcharUchar4(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUchar4UcharUcharUchar4: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampUchar4UcharUcharUchar4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        byte[] arrayInValue = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (byte) 42);
        inValue.copyTo(arrayInValue);
        byte[] arrayInMinValue = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (byte) 42);
        inMinValue.copyTo(arrayInMinValue);
        byte[] arrayInMaxValue = new byte[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (byte) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        byte[] arrayOut = new byte[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (byte) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsUcharUcharUcharUchar args = new ArgumentsUcharUcharUcharUchar();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUchar4UcharUcharUchar4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampShort2ShortShortShort2() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 2, 0x89e3627eae2d6a9l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 1, 0x886d6d2ccaca776bl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 1, 0x886d6d215c276971l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampShort2ShortShortShort2(inValue, out);
            verifyResultsClampShort2ShortShortShort2(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShort2ShortShortShort2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampShort2ShortShortShort2(inValue, out);
            verifyResultsClampShort2ShortShortShort2(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShort2ShortShortShort2: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampShort2ShortShortShort2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 2];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsShortShortShortShort args = new ArgumentsShortShortShortShort();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (args.out != arrayOut[i * 2 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampShort2ShortShortShort2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampShort3ShortShortShort3() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 3, 0x57a48a73639f042fl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 1, 0x932338b6fdf8df5dl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 1, 0x932338ab8f55d163l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampShort3ShortShortShort3(inValue, out);
            verifyResultsClampShort3ShortShortShort3(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShort3ShortShortShort3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampShort3ShortShortShort3(inValue, out);
            verifyResultsClampShort3ShortShortShort3(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShort3ShortShortShort3: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampShort3ShortShortShort3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsShortShortShortShort args = new ArgumentsShortShortShortShort();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampShort3ShortShortShort3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampShort4ShortShortShort4() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 4, 0xa6aadebedc5b31b5l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 1, 0x9dd904413127474fl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_16, 1, 0x9dd90435c2843955l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampShort4ShortShortShort4(inValue, out);
            verifyResultsClampShort4ShortShortShort4(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShort4ShortShortShort4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_16, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampShort4ShortShortShort4(inValue, out);
            verifyResultsClampShort4ShortShortShort4(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampShort4ShortShortShort4: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampShort4ShortShortShort4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsShortShortShortShort args = new ArgumentsShortShortShortShort();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampShort4ShortShortShort4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUshort2UshortUshortUshort2() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 2, 0x2ece6d045621ef07l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 1, 0xd88bd79cc7874965l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 1, 0xd88bd79158e43b6bl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUshort2UshortUshortUshort2(inValue, out);
            verifyResultsClampUshort2UshortUshortUshort2(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshort2UshortUshortUshort2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUshort2UshortUshortUshort2(inValue, out);
            verifyResultsClampUshort2UshortUshortUshort2(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshort2UshortUshortUshort2: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampUshort2UshortUshortUshort2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 2];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshortUshortUshort args = new ArgumentsUshortUshortUshortUshort();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (args.out != arrayOut[i * 2 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUshort2UshortUshortUshort2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUshort3UshortUshortUshort3() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 3, 0x393771467c9cd603l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 1, 0xfe016431b3cf1419l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 1, 0xfe016426452c061fl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUshort3UshortUshortUshort3(inValue, out);
            verifyResultsClampUshort3UshortUshortUshort3(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshort3UshortUshortUshort3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUshort3UshortUshortUshort3(inValue, out);
            verifyResultsClampUshort3UshortUshortUshort3(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshort3UshortUshortUshort3: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampUshort3UshortUshortUshort3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshortUshortUshort args = new ArgumentsUshortUshortUshortUshort();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUshort3UshortUshortUshort3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUshort4UshortUshortUshort4() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 4, 0x43a07588a317bcffl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 1, 0x2376f0c6a016decdl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_16, 1, 0x2376f0bb3173d0d3l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUshort4UshortUshortUshort4(inValue, out);
            verifyResultsClampUshort4UshortUshortUshort4(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshort4UshortUshortUshort4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_16, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUshort4UshortUshortUshort4(inValue, out);
            verifyResultsClampUshort4UshortUshortUshort4(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUshort4UshortUshortUshort4: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampUshort4UshortUshortUshort4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsUshortUshortUshortUshort args = new ArgumentsUshortUshortUshortUshort();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUshort4UshortUshortUshort4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampInt2IntIntInt2() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 2, 0xbb55c0997906d1dbl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 1, 0x69776e80fba24121l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 1, 0x69776e758cff3327l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampInt2IntIntInt2(inValue, out);
            verifyResultsClampInt2IntIntInt2(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampInt2IntIntInt2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampInt2IntIntInt2(inValue, out);
            verifyResultsClampInt2IntIntInt2(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampInt2IntIntInt2: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampInt2IntIntInt2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 2];
        Arrays.fill(arrayInValue, (int) 42);
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (int) 42);
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (int) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (int) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsIntIntIntInt args = new ArgumentsIntIntIntInt();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (args.out != arrayOut[i * 2 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampInt2IntIntInt2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampInt3IntIntInt3() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 3, 0x3af8924ab5370be9l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 1, 0xdde27628f1a08b2bl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 1, 0xdde2761d82fd7d31l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampInt3IntIntInt3(inValue, out);
            verifyResultsClampInt3IntIntInt3(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampInt3IntIntInt3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampInt3IntIntInt3(inValue, out);
            verifyResultsClampInt3IntIntInt3(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampInt3IntIntInt3: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampInt3IntIntInt3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (int) 42);
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (int) 42);
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (int) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (int) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsIntIntIntInt args = new ArgumentsIntIntIntInt();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampInt3IntIntInt3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampInt4IntIntInt4() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 4, 0xba9b63fbf16745f7l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 1, 0x524d7dd0e79ed535l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_32, 1, 0x524d7dc578fbc73bl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampInt4IntIntInt4(inValue, out);
            verifyResultsClampInt4IntIntInt4(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampInt4IntIntInt4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_32, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampInt4IntIntInt4(inValue, out);
            verifyResultsClampInt4IntIntInt4(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampInt4IntIntInt4: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampInt4IntIntInt4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (int) 42);
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (int) 42);
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (int) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (int) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsIntIntIntInt args = new ArgumentsIntIntIntInt();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampInt4IntIntInt4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUint2UintUintUint2() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 2, 0x4fd098dd770d5a51l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 1, 0x6de3f327c2a180e3l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 1, 0x6de3f31c53fe72e9l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUint2UintUintUint2(inValue, out);
            verifyResultsClampUint2UintUintUint2(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUint2UintUintUint2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUint2UintUintUint2(inValue, out);
            verifyResultsClampUint2UintUintUint2(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUint2UintUintUint2: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampUint2UintUintUint2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 2];
        Arrays.fill(arrayInValue, (int) 42);
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (int) 42);
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (int) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (int) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsUintUintUintUint args = new ArgumentsUintUintUintUint();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (args.out != arrayOut[i * 2 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUint2UintUintUint2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUint3UintUintUint3() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 3, 0xc3eed93d60582365l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 1, 0xbd370ebb48112f5fl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 1, 0xbd370eafd96e2165l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUint3UintUintUint3(inValue, out);
            verifyResultsClampUint3UintUintUint3(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUint3UintUintUint3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUint3UintUintUint3(inValue, out);
            verifyResultsClampUint3UintUintUint3(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUint3UintUintUint3: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampUint3UintUintUint3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (int) 42);
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (int) 42);
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (int) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (int) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsUintUintUintUint args = new ArgumentsUintUintUintUint();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUint3UintUintUint3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUint4UintUintUint4() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 4, 0x380d199d49a2ec79l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 1, 0xc8a2a4ecd80dddbl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_32, 1, 0xc8a2a435eddcfe1l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUint4UintUintUint4(inValue, out);
            verifyResultsClampUint4UintUintUint4(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUint4UintUintUint4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_32, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUint4UintUintUint4(inValue, out);
            verifyResultsClampUint4UintUintUint4(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUint4UintUintUint4: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampUint4UintUintUint4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        int[] arrayInValue = new int[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (int) 42);
        inValue.copyTo(arrayInValue);
        int[] arrayInMinValue = new int[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (int) 42);
        inMinValue.copyTo(arrayInMinValue);
        int[] arrayInMaxValue = new int[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (int) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        int[] arrayOut = new int[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (int) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsUintUintUintUint args = new ArgumentsUintUintUintUint();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUint4UintUintUint4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampLong2LongLongLong2() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 2, 0x19353a9f7c535bb5l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 1, 0xee8dc7f38f83654fl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 1, 0xee8dc7e820e05755l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampLong2LongLongLong2(inValue, out);
            verifyResultsClampLong2LongLongLong2(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampLong2LongLongLong2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampLong2LongLongLong2(inValue, out);
            verifyResultsClampLong2LongLongLong2(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampLong2LongLongLong2: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampLong2LongLongLong2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        long[] arrayInValue = new long[INPUTSIZE * 2];
        Arrays.fill(arrayInValue, (long) 42);
        inValue.copyTo(arrayInValue);
        long[] arrayInMinValue = new long[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (long) 42);
        inMinValue.copyTo(arrayInMinValue);
        long[] arrayInMaxValue = new long[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (long) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        long[] arrayOut = new long[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (long) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsLongLongLongLong args = new ArgumentsLongLongLongLong();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (args.out != arrayOut[i * 2 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampLong2LongLongLong2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampLong3LongLongLong3() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 3, 0x8d537aff659e24c9l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 1, 0x3de0e38714f313cbl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 1, 0x3de0e37ba65005d1l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampLong3LongLongLong3(inValue, out);
            verifyResultsClampLong3LongLongLong3(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampLong3LongLongLong3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampLong3LongLongLong3(inValue, out);
            verifyResultsClampLong3LongLongLong3(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampLong3LongLongLong3: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampLong3LongLongLong3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        long[] arrayInValue = new long[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (long) 42);
        inValue.copyTo(arrayInValue);
        long[] arrayInMinValue = new long[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (long) 42);
        inMinValue.copyTo(arrayInMinValue);
        long[] arrayInMaxValue = new long[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (long) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        long[] arrayOut = new long[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (long) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsLongLongLongLong args = new ArgumentsLongLongLongLong();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampLong3LongLongLong3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampLong4LongLongLong4() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 4, 0x171bb5f4ee8edddl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 1, 0x8d33ff1a9a62c247l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.SIGNED_64, 1, 0x8d33ff0f2bbfb44dl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampLong4LongLongLong4(inValue, out);
            verifyResultsClampLong4LongLongLong4(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampLong4LongLongLong4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.SIGNED_64, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampLong4LongLongLong4(inValue, out);
            verifyResultsClampLong4LongLongLong4(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampLong4LongLongLong4: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampLong4LongLongLong4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        long[] arrayInValue = new long[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (long) 42);
        inValue.copyTo(arrayInValue);
        long[] arrayInMinValue = new long[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (long) 42);
        inMinValue.copyTo(arrayInMinValue);
        long[] arrayInMaxValue = new long[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (long) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        long[] arrayOut = new long[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (long) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsLongLongLongLong args = new ArgumentsLongLongLongLong();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampLong4LongLongLong4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUlong2UlongUlongUlong2() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 2, 0xf275dabaa7fa1bf7l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 1, 0xf08a9e698d13b735l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 1, 0xf08a9e5e1e70a93bl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUlong2UlongUlongUlong2(inValue, out);
            verifyResultsClampUlong2UlongUlongUlong2(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUlong2UlongUlongUlong2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUlong2UlongUlongUlong2(inValue, out);
            verifyResultsClampUlong2UlongUlongUlong2(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUlong2UlongUlongUlong2: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampUlong2UlongUlongUlong2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        long[] arrayInValue = new long[INPUTSIZE * 2];
        Arrays.fill(arrayInValue, (long) 42);
        inValue.copyTo(arrayInValue);
        long[] arrayInMinValue = new long[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (long) 42);
        inMinValue.copyTo(arrayInMinValue);
        long[] arrayInMaxValue = new long[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (long) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        long[] arrayOut = new long[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (long) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsUlongUlongUlongUlong args = new ArgumentsUlongUlongUlongUlong();
                args.inValue = arrayInValue[i * 2 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 2 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        if (args.out != arrayOut[i * 2 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUlong2UlongUlongUlong2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUlong3UlongUlongUlong3() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 3, 0x417c2f0620b6497dl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 1, 0xfb4069f3c0421f27l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 1, 0xfb4069e8519f112dl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUlong3UlongUlongUlong3(inValue, out);
            verifyResultsClampUlong3UlongUlongUlong3(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUlong3UlongUlongUlong3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUlong3UlongUlongUlong3(inValue, out);
            verifyResultsClampUlong3UlongUlongUlong3(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUlong3UlongUlongUlong3: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampUlong3UlongUlongUlong3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        long[] arrayInValue = new long[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (long) 42);
        inValue.copyTo(arrayInValue);
        long[] arrayInMinValue = new long[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (long) 42);
        inMinValue.copyTo(arrayInMinValue);
        long[] arrayInMaxValue = new long[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (long) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        long[] arrayOut = new long[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (long) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsUlongUlongUlongUlong args = new ArgumentsUlongUlongUlongUlong();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUlong3UlongUlongUlong3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampUlong4UlongUlongUlong4() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 4, 0x9082835199727703l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 1, 0x5f6357df3708719l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.UNSIGNED_64, 1, 0x5f6357284cd791fl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampUlong4UlongUlongUlong4(inValue, out);
            verifyResultsClampUlong4UlongUlongUlong4(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUlong4UlongUlongUlong4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.UNSIGNED_64, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampUlong4UlongUlongUlong4(inValue, out);
            verifyResultsClampUlong4UlongUlongUlong4(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampUlong4UlongUlongUlong4: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampUlong4UlongUlongUlong4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        long[] arrayInValue = new long[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (long) 42);
        inValue.copyTo(arrayInValue);
        long[] arrayInMinValue = new long[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (long) 42);
        inMinValue.copyTo(arrayInMinValue);
        long[] arrayInMaxValue = new long[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (long) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        long[] arrayOut = new long[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (long) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsUlongUlongUlongUlong args = new ArgumentsUlongUlongUlongUlong();
                args.inValue = arrayInValue[i * 4 + j];
                args.inMinValue = arrayInMinValue[i];
                args.inMaxValue = arrayInMaxValue[i];
                // Figure out what the outputs should have been.
                CoreMathVerifier.computeClamp(args);
                // Validate the outputs.
                boolean valid = true;
                if (args.out != arrayOut[i * 4 + j]) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        if (args.out != arrayOut[i * 4 + j]) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampUlong4UlongUlongUlong4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    public class ArgumentsHalfHalfHalfHalf {
        public short inValue;
        public double inValueDouble;
        public short inMinValue;
        public double inMinValueDouble;
        public short inMaxValue;
        public double inMaxValueDouble;
        public Target.Floaty out;
    }

    private void checkClampHalfHalfHalfHalf() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 1, 0xa14cfae504b82831l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 1, 0xd705630af102f883l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 1, 0xd70562ff825fea89l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 1), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampHalfHalfHalfHalf(inValue, out);
            verifyResultsClampHalfHalfHalfHalf(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampHalfHalfHalfHalf: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 1), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampHalfHalfHalfHalf(inValue, out);
            verifyResultsClampHalfHalfHalfHalf(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampHalfHalfHalfHalf: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampHalfHalfHalfHalf(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 1];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 1 ; j++) {
                // Extract the inputs.
                ArgumentsHalfHalfHalfHalf args = new ArgumentsHalfHalfHalfHalf();
                args.inValue = arrayInValue[i];
                args.inValueDouble = Float16Utils.convertFloat16ToDouble(args.inValue);
                args.inMinValue = arrayInMinValue[i];
                args.inMinValueDouble = Float16Utils.convertFloat16ToDouble(args.inMinValue);
                args.inMaxValue = arrayInMaxValue[i];
                args.inMaxValueDouble = Float16Utils.convertFloat16ToDouble(args.inMaxValue);
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.HALF, relaxed);
                CoreMathVerifier.computeClamp(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 1 + j]))) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 1 + j]);
                        message.append("\n");
                        message.append("Actual   output out (in double): ");
                        appendVariableToMessage(message, Float16Utils.convertFloat16ToDouble(arrayOut[i * 1 + j]));
                        if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 1 + j]))) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampHalfHalfHalfHalf" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampHalf2Half2Half2Half2() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 2, 0x21a2a411b1049715l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 2, 0x4311a0566f2ebd6fl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 2, 0x4311a04b008baf75l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampHalf2Half2Half2Half2(inValue, out);
            verifyResultsClampHalf2Half2Half2Half2(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampHalf2Half2Half2Half2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampHalf2Half2Half2Half2(inValue, out);
            verifyResultsClampHalf2Half2Half2Half2(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampHalf2Half2Half2Half2: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampHalf2Half2Half2Half2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 2];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 2];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 2];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsHalfHalfHalfHalf args = new ArgumentsHalfHalfHalfHalf();
                args.inValue = arrayInValue[i * 2 + j];
                args.inValueDouble = Float16Utils.convertFloat16ToDouble(args.inValue);
                args.inMinValue = arrayInMinValue[i * 2 + j];
                args.inMinValueDouble = Float16Utils.convertFloat16ToDouble(args.inMinValue);
                args.inMaxValue = arrayInMaxValue[i * 2 + j];
                args.inMaxValueDouble = Float16Utils.convertFloat16ToDouble(args.inMaxValue);
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.HALF, relaxed);
                CoreMathVerifier.computeClamp(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 2 + j]))) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        message.append("\n");
                        message.append("Actual   output out (in double): ");
                        appendVariableToMessage(message, Float16Utils.convertFloat16ToDouble(arrayOut[i * 2 + j]));
                        if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 2 + j]))) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampHalf2Half2Half2Half2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampHalf3Half3Half3Half3() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 3, 0x7a4fc1e2a6d9935dl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 3, 0xd094c90381facac7l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 3, 0xd094c8f81357bccdl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampHalf3Half3Half3Half3(inValue, out);
            verifyResultsClampHalf3Half3Half3Half3(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampHalf3Half3Half3Half3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampHalf3Half3Half3Half3(inValue, out);
            verifyResultsClampHalf3Half3Half3Half3(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampHalf3Half3Half3Half3: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampHalf3Half3Half3Half3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsHalfHalfHalfHalf args = new ArgumentsHalfHalfHalfHalf();
                args.inValue = arrayInValue[i * 4 + j];
                args.inValueDouble = Float16Utils.convertFloat16ToDouble(args.inValue);
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMinValueDouble = Float16Utils.convertFloat16ToDouble(args.inMinValue);
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                args.inMaxValueDouble = Float16Utils.convertFloat16ToDouble(args.inMaxValue);
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.HALF, relaxed);
                CoreMathVerifier.computeClamp(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 4 + j]))) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        message.append("\n");
                        message.append("Actual   output out (in double): ");
                        appendVariableToMessage(message, Float16Utils.convertFloat16ToDouble(arrayOut[i * 4 + j]));
                        if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 4 + j]))) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampHalf3Half3Half3Half3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampHalf4Half4Half4Half4() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 4, 0xd2fcdfb39cae8fa5l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 4, 0x5e17f1b094c6d81fl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 4, 0x5e17f1a52623ca25l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampHalf4Half4Half4Half4(inValue, out);
            verifyResultsClampHalf4Half4Half4Half4(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampHalf4Half4Half4Half4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampHalf4Half4Half4Half4(inValue, out);
            verifyResultsClampHalf4Half4Half4Half4(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampHalf4Half4Half4Half4: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampHalf4Half4Half4Half4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsHalfHalfHalfHalf args = new ArgumentsHalfHalfHalfHalf();
                args.inValue = arrayInValue[i * 4 + j];
                args.inValueDouble = Float16Utils.convertFloat16ToDouble(args.inValue);
                args.inMinValue = arrayInMinValue[i * 4 + j];
                args.inMinValueDouble = Float16Utils.convertFloat16ToDouble(args.inMinValue);
                args.inMaxValue = arrayInMaxValue[i * 4 + j];
                args.inMaxValueDouble = Float16Utils.convertFloat16ToDouble(args.inMaxValue);
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.HALF, relaxed);
                CoreMathVerifier.computeClamp(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 4 + j]))) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        message.append("\n");
                        message.append("Actual   output out (in double): ");
                        appendVariableToMessage(message, Float16Utils.convertFloat16ToDouble(arrayOut[i * 4 + j]));
                        if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 4 + j]))) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampHalf4Half4Half4Half4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampHalf2HalfHalfHalf2() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 2, 0x5a2c9cb635f68507l, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 1, 0xcd629fcbbc3d6b65l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 1, 0xcd629fc04d9a5d6bl, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 2), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampHalf2HalfHalfHalf2(inValue, out);
            verifyResultsClampHalf2HalfHalfHalf2(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampHalf2HalfHalfHalf2: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 2), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampHalf2HalfHalfHalf2(inValue, out);
            verifyResultsClampHalf2HalfHalfHalf2(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampHalf2HalfHalfHalf2: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampHalf2HalfHalfHalf2(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 2];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 2];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 2 ; j++) {
                // Extract the inputs.
                ArgumentsHalfHalfHalfHalf args = new ArgumentsHalfHalfHalfHalf();
                args.inValue = arrayInValue[i * 2 + j];
                args.inValueDouble = Float16Utils.convertFloat16ToDouble(args.inValue);
                args.inMinValue = arrayInMinValue[i];
                args.inMinValueDouble = Float16Utils.convertFloat16ToDouble(args.inMinValue);
                args.inMaxValue = arrayInMaxValue[i];
                args.inMaxValueDouble = Float16Utils.convertFloat16ToDouble(args.inMaxValue);
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.HALF, relaxed);
                CoreMathVerifier.computeClamp(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 2 + j]))) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 2 + j]);
                        message.append("\n");
                        message.append("Actual   output out (in double): ");
                        appendVariableToMessage(message, Float16Utils.convertFloat16ToDouble(arrayOut[i * 2 + j]));
                        if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 2 + j]))) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampHalf2HalfHalfHalf2" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampHalf3HalfHalfHalf3() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 3, 0xce4add161f414e1bl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 1, 0x1cb5bb5f41ad19e1l, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 1, 0x1cb5bb53d30a0be7l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 3), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampHalf3HalfHalfHalf3(inValue, out);
            verifyResultsClampHalf3HalfHalfHalf3(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampHalf3HalfHalfHalf3: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 3), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampHalf3HalfHalfHalf3(inValue, out);
            verifyResultsClampHalf3HalfHalfHalf3(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampHalf3HalfHalfHalf3: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampHalf3HalfHalfHalf3(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 3 ; j++) {
                // Extract the inputs.
                ArgumentsHalfHalfHalfHalf args = new ArgumentsHalfHalfHalfHalf();
                args.inValue = arrayInValue[i * 4 + j];
                args.inValueDouble = Float16Utils.convertFloat16ToDouble(args.inValue);
                args.inMinValue = arrayInMinValue[i];
                args.inMinValueDouble = Float16Utils.convertFloat16ToDouble(args.inMinValue);
                args.inMaxValue = arrayInMaxValue[i];
                args.inMaxValueDouble = Float16Utils.convertFloat16ToDouble(args.inMaxValue);
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.HALF, relaxed);
                CoreMathVerifier.computeClamp(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 4 + j]))) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        message.append("\n");
                        message.append("Actual   output out (in double): ");
                        appendVariableToMessage(message, Float16Utils.convertFloat16ToDouble(arrayOut[i * 4 + j]));
                        if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 4 + j]))) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampHalf3HalfHalfHalf3" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    private void checkClampHalf4HalfHalfHalf4() {
        Allocation inValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 4, 0x42691d76088c172fl, false);
        Allocation inMinValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 1, 0x6c08d6f2c71cc85dl, false);
        Allocation inMaxValue = createRandomAllocation(mRS, Element.DataType.FLOAT_16, 1, 0x6c08d6e75879ba63l, false);
        enforceOrdering(inMinValue, inMaxValue);
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 4), INPUTSIZE);
            script.set_gAllocInMinValue(inMinValue);
            script.set_gAllocInMaxValue(inMaxValue);
            script.forEach_testClampHalf4HalfHalfHalf4(inValue, out);
            verifyResultsClampHalf4HalfHalfHalf4(inValue, inMinValue, inMaxValue, out, false);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampHalf4HalfHalfHalf4: " + e.toString());
        }
        try {
            Allocation out = Allocation.createSized(mRS, getElement(mRS, Element.DataType.FLOAT_16, 4), INPUTSIZE);
            scriptRelaxed.set_gAllocInMinValue(inMinValue);
            scriptRelaxed.set_gAllocInMaxValue(inMaxValue);
            scriptRelaxed.forEach_testClampHalf4HalfHalfHalf4(inValue, out);
            verifyResultsClampHalf4HalfHalfHalf4(inValue, inMinValue, inMaxValue, out, true);
            out.destroy();
        } catch (Exception e) {
            throw new RSRuntimeException("RenderScript. Can't invoke forEach_testClampHalf4HalfHalfHalf4: " + e.toString());
        }
        inValue.destroy();
        inMinValue.destroy();
        inMaxValue.destroy();
    }

    private void verifyResultsClampHalf4HalfHalfHalf4(Allocation inValue, Allocation inMinValue, Allocation inMaxValue, Allocation out, boolean relaxed) {
        short[] arrayInValue = new short[INPUTSIZE * 4];
        Arrays.fill(arrayInValue, (short) 42);
        inValue.copyTo(arrayInValue);
        short[] arrayInMinValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMinValue, (short) 42);
        inMinValue.copyTo(arrayInMinValue);
        short[] arrayInMaxValue = new short[INPUTSIZE * 1];
        Arrays.fill(arrayInMaxValue, (short) 42);
        inMaxValue.copyTo(arrayInMaxValue);
        short[] arrayOut = new short[INPUTSIZE * 4];
        Arrays.fill(arrayOut, (short) 42);
        out.copyTo(arrayOut);
        StringBuilder message = new StringBuilder();
        boolean errorFound = false;
        for (int i = 0; i < INPUTSIZE; i++) {
            for (int j = 0; j < 4 ; j++) {
                // Extract the inputs.
                ArgumentsHalfHalfHalfHalf args = new ArgumentsHalfHalfHalfHalf();
                args.inValue = arrayInValue[i * 4 + j];
                args.inValueDouble = Float16Utils.convertFloat16ToDouble(args.inValue);
                args.inMinValue = arrayInMinValue[i];
                args.inMinValueDouble = Float16Utils.convertFloat16ToDouble(args.inMinValue);
                args.inMaxValue = arrayInMaxValue[i];
                args.inMaxValueDouble = Float16Utils.convertFloat16ToDouble(args.inMaxValue);
                // Figure out what the outputs should have been.
                Target target = new Target(Target.FunctionType.NORMAL, Target.ReturnType.HALF, relaxed);
                CoreMathVerifier.computeClamp(args, target);
                // Validate the outputs.
                boolean valid = true;
                if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 4 + j]))) {
                    valid = false;
                }
                if (!valid) {
                    if (!errorFound) {
                        errorFound = true;
                        message.append("Input inValue: ");
                        appendVariableToMessage(message, args.inValue);
                        message.append("\n");
                        message.append("Input inMinValue: ");
                        appendVariableToMessage(message, args.inMinValue);
                        message.append("\n");
                        message.append("Input inMaxValue: ");
                        appendVariableToMessage(message, args.inMaxValue);
                        message.append("\n");
                        message.append("Expected output out: ");
                        appendVariableToMessage(message, args.out);
                        message.append("\n");
                        message.append("Actual   output out: ");
                        appendVariableToMessage(message, arrayOut[i * 4 + j]);
                        message.append("\n");
                        message.append("Actual   output out (in double): ");
                        appendVariableToMessage(message, Float16Utils.convertFloat16ToDouble(arrayOut[i * 4 + j]));
                        if (!args.out.couldBe(Float16Utils.convertFloat16ToDouble(arrayOut[i * 4 + j]))) {
                            message.append(" FAIL");
                        }
                        message.append("\n");
                        message.append("Errors at");
                    }
                    message.append(" [");
                    message.append(Integer.toString(i));
                    message.append(", ");
                    message.append(Integer.toString(j));
                    message.append("]");
                }
            }
        }
        assertFalse("Incorrect output for checkClampHalf4HalfHalfHalf4" +
                (relaxed ? "_relaxed" : "") + ":\n" + message.toString(), errorFound);
    }

    public void testClamp() {
        checkClampFloatFloatFloatFloat();
        checkClampFloat2Float2Float2Float2();
        checkClampFloat3Float3Float3Float3();
        checkClampFloat4Float4Float4Float4();
        checkClampFloat2FloatFloatFloat2();
        checkClampFloat3FloatFloatFloat3();
        checkClampFloat4FloatFloatFloat4();
        checkClampCharCharCharChar();
        checkClampChar2Char2Char2Char2();
        checkClampChar3Char3Char3Char3();
        checkClampChar4Char4Char4Char4();
        checkClampUcharUcharUcharUchar();
        checkClampUchar2Uchar2Uchar2Uchar2();
        checkClampUchar3Uchar3Uchar3Uchar3();
        checkClampUchar4Uchar4Uchar4Uchar4();
        checkClampShortShortShortShort();
        checkClampShort2Short2Short2Short2();
        checkClampShort3Short3Short3Short3();
        checkClampShort4Short4Short4Short4();
        checkClampUshortUshortUshortUshort();
        checkClampUshort2Ushort2Ushort2Ushort2();
        checkClampUshort3Ushort3Ushort3Ushort3();
        checkClampUshort4Ushort4Ushort4Ushort4();
        checkClampIntIntIntInt();
        checkClampInt2Int2Int2Int2();
        checkClampInt3Int3Int3Int3();
        checkClampInt4Int4Int4Int4();
        checkClampUintUintUintUint();
        checkClampUint2Uint2Uint2Uint2();
        checkClampUint3Uint3Uint3Uint3();
        checkClampUint4Uint4Uint4Uint4();
        checkClampLongLongLongLong();
        checkClampLong2Long2Long2Long2();
        checkClampLong3Long3Long3Long3();
        checkClampLong4Long4Long4Long4();
        checkClampUlongUlongUlongUlong();
        checkClampUlong2Ulong2Ulong2Ulong2();
        checkClampUlong3Ulong3Ulong3Ulong3();
        checkClampUlong4Ulong4Ulong4Ulong4();
        checkClampChar2CharCharChar2();
        checkClampChar3CharCharChar3();
        checkClampChar4CharCharChar4();
        checkClampUchar2UcharUcharUchar2();
        checkClampUchar3UcharUcharUchar3();
        checkClampUchar4UcharUcharUchar4();
        checkClampShort2ShortShortShort2();
        checkClampShort3ShortShortShort3();
        checkClampShort4ShortShortShort4();
        checkClampUshort2UshortUshortUshort2();
        checkClampUshort3UshortUshortUshort3();
        checkClampUshort4UshortUshortUshort4();
        checkClampInt2IntIntInt2();
        checkClampInt3IntIntInt3();
        checkClampInt4IntIntInt4();
        checkClampUint2UintUintUint2();
        checkClampUint3UintUintUint3();
        checkClampUint4UintUintUint4();
        checkClampLong2LongLongLong2();
        checkClampLong3LongLongLong3();
        checkClampLong4LongLongLong4();
        checkClampUlong2UlongUlongUlong2();
        checkClampUlong3UlongUlongUlong3();
        checkClampUlong4UlongUlongUlong4();
        checkClampHalfHalfHalfHalf();
        checkClampHalf2Half2Half2Half2();
        checkClampHalf3Half3Half3Half3();
        checkClampHalf4Half4Half4Half4();
        checkClampHalf2HalfHalfHalf2();
        checkClampHalf3HalfHalfHalf3();
        checkClampHalf4HalfHalfHalf4();
    }
}
