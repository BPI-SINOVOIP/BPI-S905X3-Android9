----------------DEX_FILE--------------

Filename: DexFile
-----------DEFINED_CLASSES------------


________________CLASS________________


public class java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

private native java.lang.Object internalClone(
java.lang.Cloneable)
@dalvik.annotation.Throws (value =Ljava/lang/CloneNotSupportedException; )
protected java.lang.Object clone()

public boolean equals(
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/lang/Throwable; )
protected void finalize()
@dalvik.annotation.Signature (value =()Ljava/lang/Class<+Ljava/lang/Object;>; )
public final native java.lang.Class getClass()

public native int hashCode()

public final native void notify()

public final native void notifyAll()

public java.lang.String toString()
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public final void wait()
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public final void wait(
long)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public final native void wait(
long
int)

________________CLASS________________


public abstract interface class SQLite.Authorizer extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract int authorize(
int
java.lang.String
java.lang.String
java.lang.String
java.lang.String)

________________CLASS________________


public class SQLite.Blob extends java.lang.Object

----------------FIELDS----------------

private long handle

protected int size
----------------METHODS----------------

static void <clinit>()

public void <init>()

private static native void internal_init()

public native void close()

protected native void finalize()

public java.io.InputStream getInputStream()

public java.io.OutputStream getOutputStream()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
native int read(
byte[]
int
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
native int write(
byte[]
int
int
int)

________________CLASS________________


public abstract interface class java.io.Closeable extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void close()

________________CLASS________________


public abstract class java.io.InputStream extends java.lang.Object implements java.io.Closeable

----------------FIELDS----------------

private static byte[] skipBuf
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int available()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()

public void mark(
int)

public boolean markSupported()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void reset()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long skip(
long)

________________CLASS________________


 class SQLite.BlobR extends java.io.InputStream

----------------FIELDS----------------

private SQLite.Blob blob

private int pos
----------------METHODS----------------

 void <init>(
SQLite.Blob)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int available()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()

public void mark(
int)

public boolean markSupported()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void reset()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long skip(
long)

________________CLASS________________


public abstract interface class java.io.Flushable extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void flush()

________________CLASS________________


public abstract class java.io.OutputStream extends java.lang.Object implements java.io.Closeable, java.io.Flushable

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void flush()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void write(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
byte[]
int
int)

________________CLASS________________


 class SQLite.BlobW extends java.io.OutputStream

----------------FIELDS----------------

private SQLite.Blob blob

private int pos
----------------METHODS----------------

 void <init>(
SQLite.Blob)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void flush()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
byte[]
int
int)

________________CLASS________________


public abstract interface class SQLite.BusyHandler extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract boolean busy(
java.lang.String
int)

________________CLASS________________


public abstract interface class SQLite.Callback extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract void columns(
java.lang.String[])

public abstract boolean newrow(
java.lang.String[])

public abstract void types(
java.lang.String[])

________________CLASS________________


public final class SQLite.Constants extends java.lang.Object

----------------FIELDS----------------

public static final int SQLITE2_TEXT

public static final int SQLITE3_TEXT

public static final int SQLITE_ABORT

public static final int SQLITE_ARGS

public static final int SQLITE_ATTACH

public static final int SQLITE_AUTH

public static final int SQLITE_BLOB

public static final int SQLITE_BUSY

public static final int SQLITE_CANTOPEN

public static final int SQLITE_CONSTRAINT

public static final int SQLITE_COPY

public static final int SQLITE_CORRUPT

public static final int SQLITE_CREATE_INDEX

public static final int SQLITE_CREATE_TABLE

public static final int SQLITE_CREATE_TEMP_INDEX

public static final int SQLITE_CREATE_TEMP_TABLE

public static final int SQLITE_CREATE_TEMP_TRIGGER

public static final int SQLITE_CREATE_TEMP_VIEW

public static final int SQLITE_CREATE_TRIGGER

public static final int SQLITE_CREATE_VIEW

public static final int SQLITE_DELETE

public static final int SQLITE_DENY

public static final int SQLITE_DETACH

public static final int SQLITE_DONE

public static final int SQLITE_DROP_INDEX

public static final int SQLITE_DROP_TABLE

public static final int SQLITE_DROP_TEMP_INDEX

public static final int SQLITE_DROP_TEMP_TABLE

public static final int SQLITE_DROP_TEMP_TRIGGER

public static final int SQLITE_DROP_TEMP_VIEW

public static final int SQLITE_DROP_TRIGGER

public static final int SQLITE_DROP_VIEW

public static final int SQLITE_EMPTY

public static final int SQLITE_ERROR

public static final int SQLITE_FLOAT

public static final int SQLITE_FORMAT

public static final int SQLITE_FULL

public static final int SQLITE_IGNORE

public static final int SQLITE_INSERT

public static final int SQLITE_INTEGER

public static final int SQLITE_INTERNAL

public static final int SQLITE_INTERRUPT

public static final int SQLITE_IOERR

public static final int SQLITE_LOCKED

public static final int SQLITE_MISMATCH

public static final int SQLITE_MISUSE

public static final int SQLITE_NOLFS

public static final int SQLITE_NOMEM

public static final int SQLITE_NOTADB

public static final int SQLITE_NOTFOUND

public static final int SQLITE_NULL

public static final int SQLITE_NUMERIC

public static final int SQLITE_OK

public static final int SQLITE_PERM

public static final int SQLITE_PRAGMA

public static final int SQLITE_PROTOCOL

public static final int SQLITE_RANGE

public static final int SQLITE_READ

public static final int SQLITE_READONLY

public static final int SQLITE_ROW

public static final int SQLITE_SCHEMA

public static final int SQLITE_SELECT

public static final int SQLITE_TEXT

public static final int SQLITE_TOOBIG

public static final int SQLITE_TRANSACTION

public static final int SQLITE_UPDATE
----------------METHODS----------------

public void <init>()

________________CLASS________________


 class SQLite.DBDump extends java.lang.Object implements SQLite.Callback

----------------FIELDS----------------

 SQLite.Shell s
----------------METHODS----------------

 void <init>(
SQLite.Shell
java.lang.String[])

public void columns(
java.lang.String[])

public boolean newrow(
java.lang.String[])

public void types(
java.lang.String[])

________________CLASS________________


public class SQLite.Database extends java.lang.Object

----------------FIELDS----------------

protected int error_code

protected long handle
----------------METHODS----------------

static void <clinit>()

public void <init>()

private native void _busy_handler(
SQLite.BusyHandler)

private native void _busy_timeout(
int)

private native long _changes()
@dalvik.annotation.Throws (value =LSQLite/Exception; )
private native void _close()

private static native boolean _complete(
java.lang.String)

private native void _create_aggregate(
java.lang.String
int
SQLite.Function)

private native void _create_function(
java.lang.String
int
SQLite.Function)

private native java.lang.String _errmsg()
@dalvik.annotation.Throws (value =LSQLite/Exception; )
private native void _exec(
java.lang.String
SQLite.Callback)
@dalvik.annotation.Throws (value =LSQLite/Exception; )
private native void _exec(
java.lang.String
SQLite.Callback
java.lang.String[])

private native void _finalize()

private native void _function_type(
java.lang.String
int)

private native void _interrupt()

private native long _last_insert_rowid()
@dalvik.annotation.Throws (value =LSQLite/Exception; )
private native void _open(
java.lang.String
int)
@dalvik.annotation.Throws (value =LSQLite/Exception; )
private native void _open_aux_file(
java.lang.String)
@dalvik.annotation.Throws (value =LSQLite/Exception; )
private native void _open_blob(
java.lang.String
java.lang.String
java.lang.String
long
boolean
SQLite.Blob)

private native void _progress_handler(
int
SQLite.ProgressHandler)

private native void _set_authorizer(
SQLite.Authorizer)
@dalvik.annotation.Throws (value =LSQLite/Exception; )
private native void _set_encoding(
java.lang.String)

private native void _trace(
SQLite.Trace)

public static boolean complete(
java.lang.String)

public static native java.lang.String error_string(
int)

private static native void internal_init()
@dalvik.annotation.Throws (value =LSQLite/Exception; )
private native void stmt_prepare(
java.lang.String
SQLite.Stmt)

public static native java.lang.String version()
@dalvik.annotation.Throws (value =LSQLite/Exception; )
private native void vm_compile(
java.lang.String
SQLite.Vm)
@dalvik.annotation.Throws (value =LSQLite/Exception; )
private native void vm_compile_args(
java.lang.String
SQLite.Vm
java.lang.String[])

public void busy_handler(
SQLite.BusyHandler)

public void busy_timeout(
int)

public long changes()
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public void close()
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public SQLite.Vm compile(
java.lang.String)
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public SQLite.Vm compile(
java.lang.String
java.lang.String[])

public void create_aggregate(
java.lang.String
int
SQLite.Function)

public void create_function(
java.lang.String
int
SQLite.Function)

public native java.lang.String dbversion()

public java.lang.String error_message()
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public void exec(
java.lang.String
SQLite.Callback)
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public void exec(
java.lang.String
SQLite.Callback
java.lang.String[])

protected void finalize()

public void function_type(
java.lang.String
int)
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public SQLite.TableResult get_table(
java.lang.String)
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public SQLite.TableResult get_table(
java.lang.String
java.lang.String[])
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public void get_table(
java.lang.String
java.lang.String[]
SQLite.TableResult)

public void interrupt()

public native boolean is3()

public int last_error()

public long last_insert_rowid()
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public void open(
java.lang.String
int)
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public void open_aux_file(
java.lang.String)
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public SQLite.Blob open_blob(
java.lang.String
java.lang.String
java.lang.String
long
boolean)
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public SQLite.Stmt prepare(
java.lang.String)

public void progress_handler(
int
SQLite.ProgressHandler)

public void set_authorizer(
SQLite.Authorizer)
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public void set_encoding(
java.lang.String)

protected void set_last_error(
int)

public void trace(
SQLite.Trace)

________________CLASS________________


public abstract interface class java.io.Serializable extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________


public class java.lang.Throwable extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

private java.lang.Throwable cause

private java.lang.String detailMessage

private volatile java.lang.Object stackState

private java.lang.StackTraceElement[] stackTrace
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.Throwable)

public void <init>(
java.lang.Throwable)

private static int countDuplicates(
java.lang.StackTraceElement[]
java.lang.StackTraceElement[])

private java.lang.StackTraceElement[] getInternalStackTrace()

private static native java.lang.Object nativeFillInStackTrace()

private static native java.lang.StackTraceElement[] nativeGetStackTrace(
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

public java.lang.Throwable fillInStackTrace()

public java.lang.Throwable getCause()

public java.lang.String getLocalizedMessage()

public java.lang.String getMessage()

public java.lang.StackTraceElement[] getStackTrace()

public java.lang.Throwable initCause(
java.lang.Throwable)

public void printStackTrace()

public void printStackTrace(
java.io.PrintStream)

public void printStackTrace(
java.io.PrintWriter)

public void setStackTrace(
java.lang.StackTraceElement[])

public java.lang.String toString()

________________CLASS________________


public class java.lang.Exception extends java.lang.Throwable

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.Throwable)

public void <init>(
java.lang.Throwable)

________________CLASS________________


public class SQLite.Exception extends java.lang.Exception

----------------FIELDS----------------
----------------METHODS----------------

public void <init>(
java.lang.String)

________________CLASS________________


public abstract interface class SQLite.Function extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract void function(
SQLite.FunctionContext
java.lang.String[])

public abstract void last_step(
SQLite.FunctionContext)

public abstract void step(
SQLite.FunctionContext
java.lang.String[])

________________CLASS________________


public class SQLite.FunctionContext extends java.lang.Object

----------------FIELDS----------------

private long handle
----------------METHODS----------------

static void <clinit>()

public void <init>()

private static native void internal_init()

public native int count()

public native void set_error(
java.lang.String)

public native void set_result(
double)

public native void set_result(
int)

public native void set_result(
java.lang.String)

public native void set_result(
byte[])

public native void set_result_zeroblob(
int)

________________CLASS________________


 class SQLite.JDBC2y.BatchArg extends java.lang.Object

----------------FIELDS----------------

 java.lang.String arg

 boolean blob
----------------METHODS----------------

 void <init>(
java.lang.String
boolean)

________________CLASS________________


 class SQLite.JDBC2y.DatabaseX extends SQLite.Database

----------------FIELDS----------------

static java.lang.Object lock
----------------METHODS----------------

static void <clinit>()

public void <init>()
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public void exec(
java.lang.String
SQLite.Callback)
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public void exec(
java.lang.String
SQLite.Callback
java.lang.String[])
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public SQLite.TableResult get_table(
java.lang.String
java.lang.String[])
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public void get_table(
java.lang.String
java.lang.String[]
SQLite.TableResult)

 void wait(
int)

________________CLASS________________


public abstract interface class java.sql.Connection extends java.lang.Object

----------------FIELDS----------------

public static final int TRANSACTION_NONE

public static final int TRANSACTION_READ_COMMITTED

public static final int TRANSACTION_READ_UNCOMMITTED

public static final int TRANSACTION_REPEATABLE_READ

public static final int TRANSACTION_SERIALIZABLE
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void clearWarnings()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void close()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void commit()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Statement createStatement()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Statement createStatement(
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Statement createStatement(
int
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean getAutoCommit()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String getCatalog()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getHoldability()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.DatabaseMetaData getMetaData()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getTransactionIsolation()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
@dalvik.annotation.Signature (value =()Ljava/util/Map<Ljava/lang/String;Ljava/lang/Class<*>;>; )
public abstract java.util.Map getTypeMap()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.SQLWarning getWarnings()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean isClosed()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean isReadOnly()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String nativeSQL(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.CallableStatement prepareCall(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.CallableStatement prepareCall(
java.lang.String
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.CallableStatement prepareCall(
java.lang.String
int
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.PreparedStatement prepareStatement(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.PreparedStatement prepareStatement(
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.PreparedStatement prepareStatement(
java.lang.String
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.PreparedStatement prepareStatement(
java.lang.String
int
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.PreparedStatement prepareStatement(
java.lang.String
int[])
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.PreparedStatement prepareStatement(
java.lang.String
java.lang.String[])
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void releaseSavepoint(
java.sql.Savepoint)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void rollback()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void rollback(
java.sql.Savepoint)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setAutoCommit(
boolean)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setCatalog(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setHoldability(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setReadOnly(
boolean)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Savepoint setSavepoint()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Savepoint setSavepoint(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setTransactionIsolation(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
@dalvik.annotation.Signature (value =(Ljava/util/Map<Ljava/lang/String;Ljava/lang/Class<*>;>;)V )
public abstract void setTypeMap(
java.util.Map)

________________CLASS________________


public class SQLite.JDBC2y.JDBCConnection extends java.lang.Object implements java.sql.Connection, SQLite.BusyHandler

----------------FIELDS----------------

protected boolean autocommit

protected SQLite.JDBC2y.DatabaseX db

private java.lang.String dbfile

protected java.lang.String enc

protected boolean intrans

private SQLite.JDBC2y.JDBCDatabaseMetaData meta

private boolean readonly

private long t0

protected int timeout

protected java.lang.String url
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void <init>(
java.lang.String
java.lang.String)

private boolean busy0(
SQLite.JDBC2y.DatabaseX
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
private SQLite.JDBC2y.DatabaseX open(
boolean)

public boolean busy(
java.lang.String
int)

protected boolean busy3(
SQLite.JDBC2y.DatabaseX
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void clearWarnings()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void commit()

public java.sql.Statement createStatement()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Statement createStatement(
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Statement createStatement(
int
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean getAutoCommit()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.lang.String getCatalog()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getHoldability()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.DatabaseMetaData getMetaData()

public SQLite.Database getSQLiteDatabase()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getTransactionIsolation()
@dalvik.annotation.Signature (value =()Ljava/util/Map<Ljava/lang/String;Ljava/lang/Class<*>;>; )
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.util.Map getTypeMap()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.SQLWarning getWarnings()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean isClosed()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean isReadOnly()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.lang.String nativeSQL(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.CallableStatement prepareCall(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.CallableStatement prepareCall(
java.lang.String
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.CallableStatement prepareCall(
java.lang.String
int
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.PreparedStatement prepareStatement(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.PreparedStatement prepareStatement(
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.PreparedStatement prepareStatement(
java.lang.String
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.PreparedStatement prepareStatement(
java.lang.String
int
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.PreparedStatement prepareStatement(
java.lang.String
int[])
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.PreparedStatement prepareStatement(
java.lang.String
java.lang.String[])
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void releaseSavepoint(
java.sql.Savepoint)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void rollback()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void rollback(
java.sql.Savepoint)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setAutoCommit(
boolean)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setCatalog(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setHoldability(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setReadOnly(
boolean)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Savepoint setSavepoint()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Savepoint setSavepoint(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setTransactionIsolation(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setTypeMap(
java.util.Map)

________________CLASS________________


public abstract interface class java.sql.DatabaseMetaData extends java.lang.Object

----------------FIELDS----------------

public static final short attributeNoNulls

public static final short attributeNullable

public static final short attributeNullableUnknown

public static final int bestRowNotPseudo

public static final int bestRowPseudo

public static final int bestRowSession

public static final int bestRowTemporary

public static final int bestRowTransaction

public static final int bestRowUnknown

public static final int columnNoNulls

public static final int columnNullable

public static final int columnNullableUnknown

public static final int importedKeyCascade

public static final int importedKeyInitiallyDeferred

public static final int importedKeyInitiallyImmediate

public static final int importedKeyNoAction

public static final int importedKeyNotDeferrable

public static final int importedKeyRestrict

public static final int importedKeySetDefault

public static final int importedKeySetNull

public static final int procedureColumnIn

public static final int procedureColumnInOut

public static final int procedureColumnOut

public static final int procedureColumnResult

public static final int procedureColumnReturn

public static final int procedureColumnUnknown

public static final int procedureNoNulls

public static final int procedureNoResult

public static final int procedureNullable

public static final int procedureNullableUnknown

public static final int procedureResultUnknown

public static final int procedureReturnsResult

public static final int sqlStateSQL99

public static final int sqlStateXOpen

public static final short tableIndexClustered

public static final short tableIndexHashed

public static final short tableIndexOther

public static final short tableIndexStatistic

public static final int typeNoNulls

public static final int typeNullable

public static final int typeNullableUnknown

public static final int typePredBasic

public static final int typePredChar

public static final int typePredNone

public static final int typeSearchable

public static final int versionColumnNotPseudo

public static final int versionColumnPseudo

public static final int versionColumnUnknown
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean allProceduresAreCallable()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean allTablesAreSelectable()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean dataDefinitionCausesTransactionCommit()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean dataDefinitionIgnoredInTransactions()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean deletesAreDetected(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean doesMaxRowSizeIncludeBlobs()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.ResultSet getAttributes(
java.lang.String
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.ResultSet getBestRowIdentifier(
java.lang.String
java.lang.String
java.lang.String
int
boolean)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String getCatalogSeparator()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String getCatalogTerm()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.ResultSet getCatalogs()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.ResultSet getColumnPrivileges(
java.lang.String
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.ResultSet getColumns(
java.lang.String
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Connection getConnection()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.ResultSet getCrossReference(
java.lang.String
java.lang.String
java.lang.String
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getDatabaseMajorVersion()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getDatabaseMinorVersion()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String getDatabaseProductName()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String getDatabaseProductVersion()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getDefaultTransactionIsolation()

public abstract int getDriverMajorVersion()

public abstract int getDriverMinorVersion()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String getDriverName()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String getDriverVersion()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.ResultSet getExportedKeys(
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String getExtraNameCharacters()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String getIdentifierQuoteString()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.ResultSet getImportedKeys(
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.ResultSet getIndexInfo(
java.lang.String
java.lang.String
java.lang.String
boolean
boolean)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getJDBCMajorVersion()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getJDBCMinorVersion()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getMaxBinaryLiteralLength()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getMaxCatalogNameLength()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getMaxCharLiteralLength()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getMaxColumnNameLength()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getMaxColumnsInGroupBy()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getMaxColumnsInIndex()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getMaxColumnsInOrderBy()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getMaxColumnsInSelect()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getMaxColumnsInTable()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getMaxConnections()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getMaxCursorNameLength()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getMaxIndexLength()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getMaxProcedureNameLength()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getMaxRowSize()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getMaxSchemaNameLength()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getMaxStatementLength()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getMaxStatements()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getMaxTableNameLength()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getMaxTablesInSelect()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getMaxUserNameLength()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String getNumericFunctions()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.ResultSet getPrimaryKeys(
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.ResultSet getProcedureColumns(
java.lang.String
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String getProcedureTerm()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.ResultSet getProcedures(
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getResultSetHoldability()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String getSQLKeywords()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getSQLStateType()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String getSchemaTerm()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.ResultSet getSchemas()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String getSearchStringEscape()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String getStringFunctions()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.ResultSet getSuperTables(
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.ResultSet getSuperTypes(
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String getSystemFunctions()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.ResultSet getTablePrivileges(
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.ResultSet getTableTypes()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.ResultSet getTables(
java.lang.String
java.lang.String
java.lang.String
java.lang.String[])
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String getTimeDateFunctions()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.ResultSet getTypeInfo()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.ResultSet getUDTs(
java.lang.String
java.lang.String
java.lang.String
int[])
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String getURL()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String getUserName()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.ResultSet getVersionColumns(
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean insertsAreDetected(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean isCatalogAtStart()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean isReadOnly()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean locatorsUpdateCopy()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean nullPlusNonNullIsNull()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean nullsAreSortedAtEnd()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean nullsAreSortedAtStart()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean nullsAreSortedHigh()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean nullsAreSortedLow()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean othersDeletesAreVisible(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean othersInsertsAreVisible(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean othersUpdatesAreVisible(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean ownDeletesAreVisible(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean ownInsertsAreVisible(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean ownUpdatesAreVisible(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean storesLowerCaseIdentifiers()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean storesLowerCaseQuotedIdentifiers()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean storesMixedCaseIdentifiers()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean storesMixedCaseQuotedIdentifiers()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean storesUpperCaseIdentifiers()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean storesUpperCaseQuotedIdentifiers()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsANSI92EntryLevelSQL()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsANSI92FullSQL()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsANSI92IntermediateSQL()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsAlterTableWithAddColumn()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsAlterTableWithDropColumn()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsBatchUpdates()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsCatalogsInDataManipulation()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsCatalogsInIndexDefinitions()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsCatalogsInPrivilegeDefinitions()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsCatalogsInProcedureCalls()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsCatalogsInTableDefinitions()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsColumnAliasing()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsConvert()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsConvert(
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsCoreSQLGrammar()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsCorrelatedSubqueries()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsDataDefinitionAndDataManipulationTransactions()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsDataManipulationTransactionsOnly()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsDifferentTableCorrelationNames()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsExpressionsInOrderBy()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsExtendedSQLGrammar()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsFullOuterJoins()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsGetGeneratedKeys()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsGroupBy()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsGroupByBeyondSelect()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsGroupByUnrelated()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsIntegrityEnhancementFacility()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsLikeEscapeClause()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsLimitedOuterJoins()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsMinimumSQLGrammar()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsMixedCaseIdentifiers()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsMixedCaseQuotedIdentifiers()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsMultipleOpenResults()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsMultipleResultSets()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsMultipleTransactions()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsNamedParameters()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsNonNullableColumns()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsOpenCursorsAcrossCommit()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsOpenCursorsAcrossRollback()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsOpenStatementsAcrossCommit()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsOpenStatementsAcrossRollback()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsOrderByUnrelated()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsOuterJoins()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsPositionedDelete()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsPositionedUpdate()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsResultSetConcurrency(
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsResultSetHoldability(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsResultSetType(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsSavepoints()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsSchemasInDataManipulation()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsSchemasInIndexDefinitions()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsSchemasInPrivilegeDefinitions()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsSchemasInProcedureCalls()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsSchemasInTableDefinitions()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsSelectForUpdate()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsStatementPooling()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsStoredProcedures()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsSubqueriesInComparisons()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsSubqueriesInExists()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsSubqueriesInIns()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsSubqueriesInQuantifieds()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsTableCorrelationNames()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsTransactionIsolationLevel(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsTransactions()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsUnion()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean supportsUnionAll()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean updatesAreDetected(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean usesLocalFilePerTable()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean usesLocalFiles()

________________CLASS________________


public class SQLite.JDBC2y.JDBCDatabaseMetaData extends java.lang.Object implements java.sql.DatabaseMetaData

----------------FIELDS----------------

private SQLite.JDBC2y.JDBCConnection conn
----------------METHODS----------------

public void <init>(
SQLite.JDBC2y.JDBCConnection)

static int getD(
java.lang.String
int)

static int getM(
java.lang.String
int)

private void internalImportedKeys(
java.lang.String
java.lang.String
SQLite.JDBC2y.JDBCResultSet
SQLite.JDBC2y.TableResultX)

static int mapSqlType(
java.lang.String)

static java.lang.String mapTypeName(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean allProceduresAreCallable()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean allTablesAreSelectable()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean dataDefinitionCausesTransactionCommit()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean dataDefinitionIgnoredInTransactions()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean deletesAreDetected(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean doesMaxRowSizeIncludeBlobs()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.ResultSet getAttributes(
java.lang.String
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.ResultSet getBestRowIdentifier(
java.lang.String
java.lang.String
java.lang.String
int
boolean)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.lang.String getCatalogSeparator()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.lang.String getCatalogTerm()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.ResultSet getCatalogs()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.ResultSet getColumnPrivileges(
java.lang.String
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.ResultSet getColumns(
java.lang.String
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Connection getConnection()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.ResultSet getCrossReference(
java.lang.String
java.lang.String
java.lang.String
java.lang.String
java.lang.String
java.lang.String)

public int getDatabaseMajorVersion()

public int getDatabaseMinorVersion()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.lang.String getDatabaseProductName()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.lang.String getDatabaseProductVersion()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getDefaultTransactionIsolation()

public int getDriverMajorVersion()

public int getDriverMinorVersion()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.lang.String getDriverName()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.lang.String getDriverVersion()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.ResultSet getExportedKeys(
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.lang.String getExtraNameCharacters()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.lang.String getIdentifierQuoteString()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.ResultSet getImportedKeys(
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.ResultSet getIndexInfo(
java.lang.String
java.lang.String
java.lang.String
boolean
boolean)

public int getJDBCMajorVersion()

public int getJDBCMinorVersion()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getMaxBinaryLiteralLength()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getMaxCatalogNameLength()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getMaxCharLiteralLength()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getMaxColumnNameLength()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getMaxColumnsInGroupBy()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getMaxColumnsInIndex()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getMaxColumnsInOrderBy()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getMaxColumnsInSelect()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getMaxColumnsInTable()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getMaxConnections()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getMaxCursorNameLength()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getMaxIndexLength()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getMaxProcedureNameLength()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getMaxRowSize()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getMaxSchemaNameLength()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getMaxStatementLength()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getMaxStatements()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getMaxTableNameLength()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getMaxTablesInSelect()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getMaxUserNameLength()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.lang.String getNumericFunctions()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.ResultSet getPrimaryKeys(
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.ResultSet getProcedureColumns(
java.lang.String
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.lang.String getProcedureTerm()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.ResultSet getProcedures(
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getResultSetHoldability()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.lang.String getSQLKeywords()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getSQLStateType()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.lang.String getSchemaTerm()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.ResultSet getSchemas()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.lang.String getSearchStringEscape()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.lang.String getStringFunctions()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.ResultSet getSuperTables(
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.ResultSet getSuperTypes(
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.lang.String getSystemFunctions()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.ResultSet getTablePrivileges(
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.ResultSet getTableTypes()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.ResultSet getTables(
java.lang.String
java.lang.String
java.lang.String
java.lang.String[])
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.lang.String getTimeDateFunctions()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.ResultSet getTypeInfo()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.ResultSet getUDTs(
java.lang.String
java.lang.String
java.lang.String
int[])
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.lang.String getURL()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.lang.String getUserName()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.ResultSet getVersionColumns(
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean insertsAreDetected(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean isCatalogAtStart()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean isReadOnly()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean locatorsUpdateCopy()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean nullPlusNonNullIsNull()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean nullsAreSortedAtEnd()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean nullsAreSortedAtStart()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean nullsAreSortedHigh()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean nullsAreSortedLow()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean othersDeletesAreVisible(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean othersInsertsAreVisible(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean othersUpdatesAreVisible(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean ownDeletesAreVisible(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean ownInsertsAreVisible(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean ownUpdatesAreVisible(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean storesLowerCaseIdentifiers()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean storesLowerCaseQuotedIdentifiers()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean storesMixedCaseIdentifiers()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean storesMixedCaseQuotedIdentifiers()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean storesUpperCaseIdentifiers()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean storesUpperCaseQuotedIdentifiers()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsANSI92EntryLevelSQL()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsANSI92FullSQL()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsANSI92IntermediateSQL()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsAlterTableWithAddColumn()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsAlterTableWithDropColumn()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsBatchUpdates()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsCatalogsInDataManipulation()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsCatalogsInIndexDefinitions()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsCatalogsInPrivilegeDefinitions()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsCatalogsInProcedureCalls()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsCatalogsInTableDefinitions()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsColumnAliasing()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsConvert()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsConvert(
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsCoreSQLGrammar()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsCorrelatedSubqueries()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsDataDefinitionAndDataManipulationTransactions()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsDataManipulationTransactionsOnly()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsDifferentTableCorrelationNames()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsExpressionsInOrderBy()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsExtendedSQLGrammar()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsFullOuterJoins()

public boolean supportsGetGeneratedKeys()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsGroupBy()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsGroupByBeyondSelect()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsGroupByUnrelated()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsIntegrityEnhancementFacility()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsLikeEscapeClause()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsLimitedOuterJoins()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsMinimumSQLGrammar()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsMixedCaseIdentifiers()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsMixedCaseQuotedIdentifiers()

public boolean supportsMultipleOpenResults()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsMultipleResultSets()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsMultipleTransactions()

public boolean supportsNamedParameters()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsNonNullableColumns()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsOpenCursorsAcrossCommit()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsOpenCursorsAcrossRollback()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsOpenStatementsAcrossCommit()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsOpenStatementsAcrossRollback()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsOrderByUnrelated()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsOuterJoins()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsPositionedDelete()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsPositionedUpdate()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsResultSetConcurrency(
int
int)

public boolean supportsResultSetHoldability(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsResultSetType(
int)

public boolean supportsSavepoints()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsSchemasInDataManipulation()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsSchemasInIndexDefinitions()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsSchemasInPrivilegeDefinitions()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsSchemasInProcedureCalls()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsSchemasInTableDefinitions()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsSelectForUpdate()

public boolean supportsStatementPooling()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsStoredProcedures()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsSubqueriesInComparisons()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsSubqueriesInExists()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsSubqueriesInIns()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsSubqueriesInQuantifieds()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsTableCorrelationNames()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsTransactionIsolationLevel(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsTransactions()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsUnion()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean supportsUnionAll()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean updatesAreDetected(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean usesLocalFilePerTable()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean usesLocalFiles()

________________CLASS________________


public abstract interface class java.sql.Statement extends java.lang.Object

----------------FIELDS----------------

public static final int CLOSE_ALL_RESULTS

public static final int CLOSE_CURRENT_RESULT

public static final int EXECUTE_FAILED

public static final int KEEP_CURRENT_RESULT

public static final int NO_GENERATED_KEYS

public static final int RETURN_GENERATED_KEYS

public static final int SUCCESS_NO_INFO
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void addBatch(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void cancel()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void clearBatch()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void clearWarnings()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void close()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean execute(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean execute(
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean execute(
java.lang.String
int[])
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean execute(
java.lang.String
java.lang.String[])
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int[] executeBatch()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.ResultSet executeQuery(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int executeUpdate(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int executeUpdate(
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int executeUpdate(
java.lang.String
int[])
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int executeUpdate(
java.lang.String
java.lang.String[])
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Connection getConnection()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getFetchDirection()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getFetchSize()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.ResultSet getGeneratedKeys()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getMaxFieldSize()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getMaxRows()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean getMoreResults()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean getMoreResults(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getQueryTimeout()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.ResultSet getResultSet()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getResultSetConcurrency()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getResultSetHoldability()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getResultSetType()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getUpdateCount()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.SQLWarning getWarnings()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setCursorName(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setEscapeProcessing(
boolean)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setFetchDirection(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setFetchSize(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setMaxFieldSize(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setMaxRows(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setQueryTimeout(
int)

________________CLASS________________


public class SQLite.JDBC2y.JDBCStatement extends java.lang.Object implements java.sql.Statement

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/ArrayList<Ljava/lang/String;>; )
private java.util.ArrayList batch

protected SQLite.JDBC2y.JDBCConnection conn

protected SQLite.JDBC2y.JDBCResultSet rs

protected int updcnt
----------------METHODS----------------

public void <init>(
SQLite.JDBC2y.JDBCConnection)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void addBatch(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void cancel()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void clearBatch()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void clearWarnings()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean execute(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean execute(
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean execute(
java.lang.String
int[])
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean execute(
java.lang.String
java.lang.String[])
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int[] executeBatch()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.ResultSet executeQuery(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
 java.sql.ResultSet executeQuery(
java.lang.String
java.lang.String[]
boolean)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int executeUpdate(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int executeUpdate(
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int executeUpdate(
java.lang.String
int[])
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int executeUpdate(
java.lang.String
java.lang.String[])
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Connection getConnection()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getFetchDirection()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getFetchSize()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.ResultSet getGeneratedKeys()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getMaxFieldSize()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getMaxRows()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean getMoreResults()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean getMoreResults(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getQueryTimeout()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.ResultSet getResultSet()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getResultSetConcurrency()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getResultSetHoldability()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getResultSetType()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getUpdateCount()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.SQLWarning getWarnings()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setCursorName(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setEscapeProcessing(
boolean)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setFetchDirection(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setFetchSize(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setMaxFieldSize(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setMaxRows(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setQueryTimeout(
int)

________________CLASS________________


public abstract interface class java.sql.PreparedStatement extends java.lang.Object implements java.sql.Statement

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void addBatch()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void clearParameters()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean execute()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.ResultSet executeQuery()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int executeUpdate()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.ResultSetMetaData getMetaData()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.ParameterMetaData getParameterMetaData()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setArray(
int
java.sql.Array)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setAsciiStream(
int
java.io.InputStream
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setBigDecimal(
int
java.math.BigDecimal)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setBinaryStream(
int
java.io.InputStream
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setBlob(
int
java.sql.Blob)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setBoolean(
int
boolean)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setByte(
int
byte)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setBytes(
int
byte[])
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setCharacterStream(
int
java.io.Reader
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setClob(
int
java.sql.Clob)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setDate(
int
java.sql.Date)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setDate(
int
java.sql.Date
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setDouble(
int
double)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setFloat(
int
float)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setInt(
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setLong(
int
long)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setNull(
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setNull(
int
int
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setObject(
int
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setObject(
int
java.lang.Object
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setObject(
int
java.lang.Object
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setRef(
int
java.sql.Ref)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setShort(
int
short)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setString(
int
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setTime(
int
java.sql.Time)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setTime(
int
java.sql.Time
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setTimestamp(
int
java.sql.Timestamp)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setTimestamp(
int
java.sql.Timestamp
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setURL(
int
java.net.URL)
@java.lang.Deprecated
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setUnicodeStream(
int
java.io.InputStream
int)

________________CLASS________________


public class SQLite.JDBC2y.JDBCPreparedStatement extends SQLite.JDBC2y.JDBCStatement implements java.sql.PreparedStatement

----------------FIELDS----------------

private static final boolean nullrepl

private java.lang.String[] args
@dalvik.annotation.Signature (value =Ljava/util/ArrayList<LSQLite/JDBC2y/BatchArg;>; )
private java.util.ArrayList batch

private boolean[] blobs

private java.lang.String sql
----------------METHODS----------------

static void <clinit>()

public void <init>(
SQLite.JDBC2y.JDBCConnection
java.lang.String)

private java.lang.String fixup(
java.lang.String)

private java.lang.String fixup2(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void addBatch()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void clearBatch()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void clearParameters()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean execute()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int[] executeBatch()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.ResultSet executeQuery()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int executeUpdate()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Array getArray(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Array getArray(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.math.BigDecimal getBigDecimal(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Blob getBlob(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Blob getBlob(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean getBoolean(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public byte getByte(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public byte[] getBytes(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Clob getClob(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Clob getClob(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Date getDate(
int
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Date getDate(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Date getDate(
java.lang.String
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public double getDouble(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public float getFloat(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getInt(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public long getLong(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.ResultSetMetaData getMetaData()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.lang.Object getObject(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.lang.Object getObject(
int
java.util.Map)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.lang.Object getObject(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.lang.Object getObject(
java.lang.String
java.util.Map)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.ParameterMetaData getParameterMetaData()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Ref getRef(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Ref getRef(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public short getShort(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.lang.String getString(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Time getTime(
int
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Time getTime(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Time getTime(
java.lang.String
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Timestamp getTimestamp(
int
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Timestamp getTimestamp(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Timestamp getTimestamp(
java.lang.String
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.net.URL getURL(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.net.URL getURL(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void registerOutputParameter(
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void registerOutputParameter(
java.lang.String
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void registerOutputParameter(
java.lang.String
int
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setArray(
int
java.sql.Array)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setAsciiStream(
int
java.io.InputStream
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setAsciiStream(
java.lang.String
java.io.InputStream
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setBigDecimal(
int
java.math.BigDecimal)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setBigDecimal(
java.lang.String
java.math.BigDecimal)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setBinaryStream(
int
java.io.InputStream
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setBinaryStream(
java.lang.String
java.io.InputStream
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setBlob(
int
java.sql.Blob)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setBoolean(
int
boolean)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setBoolean(
java.lang.String
boolean)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setByte(
int
byte)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setByte(
java.lang.String
byte)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setBytes(
int
byte[])
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setBytes(
java.lang.String
byte[])
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setCharacterStream(
int
java.io.Reader
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setCharacterStream(
java.lang.String
java.io.Reader
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setClob(
int
java.sql.Clob)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setDate(
int
java.sql.Date)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setDate(
int
java.sql.Date
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setDate(
java.lang.String
java.sql.Date)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setDate(
java.lang.String
java.sql.Date
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setDouble(
int
double)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setDouble(
java.lang.String
double)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setFloat(
int
float)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setFloat(
java.lang.String
float)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setInt(
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setInt(
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setLong(
int
long)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setLong(
java.lang.String
long)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setNull(
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setNull(
int
int
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setNull(
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setNull(
java.lang.String
int
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setObject(
int
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setObject(
int
java.lang.Object
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setObject(
int
java.lang.Object
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setObject(
java.lang.String
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setObject(
java.lang.String
java.lang.Object
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setObject(
java.lang.String
java.lang.Object
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setRef(
int
java.sql.Ref)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setShort(
int
short)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setShort(
java.lang.String
short)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setString(
int
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setString(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setTime(
int
java.sql.Time)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setTime(
int
java.sql.Time
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setTime(
java.lang.String
java.sql.Time)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setTime(
java.lang.String
java.sql.Time
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setTimestamp(
int
java.sql.Timestamp)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setTimestamp(
int
java.sql.Timestamp
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setTimestamp(
java.lang.String
java.sql.Timestamp)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setTimestamp(
java.lang.String
java.sql.Timestamp
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setURL(
int
java.net.URL)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
@java.lang.Deprecated
public void setUnicodeStream(
int
java.io.InputStream
int)

________________CLASS________________


public abstract interface class java.sql.ResultSet extends java.lang.Object

----------------FIELDS----------------

public static final int CLOSE_CURSORS_AT_COMMIT

public static final int CONCUR_READ_ONLY

public static final int CONCUR_UPDATABLE

public static final int FETCH_FORWARD

public static final int FETCH_REVERSE

public static final int FETCH_UNKNOWN

public static final int HOLD_CURSORS_OVER_COMMIT

public static final int TYPE_FORWARD_ONLY

public static final int TYPE_SCROLL_INSENSITIVE

public static final int TYPE_SCROLL_SENSITIVE
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean absolute(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void afterLast()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void beforeFirst()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void cancelRowUpdates()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void clearWarnings()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void close()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void deleteRow()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int findColumn(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean first()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Array getArray(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Array getArray(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.io.InputStream getAsciiStream(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.io.InputStream getAsciiStream(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.math.BigDecimal getBigDecimal(
int)
@java.lang.Deprecated
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.math.BigDecimal getBigDecimal(
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.math.BigDecimal getBigDecimal(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
@java.lang.Deprecated
public abstract java.math.BigDecimal getBigDecimal(
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.io.InputStream getBinaryStream(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.io.InputStream getBinaryStream(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Blob getBlob(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Blob getBlob(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean getBoolean(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean getBoolean(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract byte getByte(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract byte getByte(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract byte[] getBytes(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract byte[] getBytes(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.io.Reader getCharacterStream(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.io.Reader getCharacterStream(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Clob getClob(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Clob getClob(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getConcurrency()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String getCursorName()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Date getDate(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Date getDate(
int
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Date getDate(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Date getDate(
java.lang.String
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract double getDouble(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract double getDouble(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getFetchDirection()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getFetchSize()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract float getFloat(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract float getFloat(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getInt(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getInt(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract long getLong(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract long getLong(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.ResultSetMetaData getMetaData()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.Object getObject(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
@dalvik.annotation.Signature (value =(ILjava/util/Map<Ljava/lang/String;Ljava/lang/Class<*>;>;)Ljava/lang/Object; )
public abstract java.lang.Object getObject(
int
java.util.Map)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.Object getObject(
java.lang.String)
@dalvik.annotation.Signature (value =(Ljava/lang/String;Ljava/util/Map<Ljava/lang/String;Ljava/lang/Class<*>;>;)Ljava/lang/Object; )
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.Object getObject(
java.lang.String
java.util.Map)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Ref getRef(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Ref getRef(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getRow()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract short getShort(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract short getShort(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Statement getStatement()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String getString(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String getString(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Time getTime(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Time getTime(
int
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Time getTime(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Time getTime(
java.lang.String
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Timestamp getTimestamp(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Timestamp getTimestamp(
int
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Timestamp getTimestamp(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Timestamp getTimestamp(
java.lang.String
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getType()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.net.URL getURL(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.net.URL getURL(
java.lang.String)
@java.lang.Deprecated
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.io.InputStream getUnicodeStream(
int)
@java.lang.Deprecated
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.io.InputStream getUnicodeStream(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.SQLWarning getWarnings()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void insertRow()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean isAfterLast()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean isBeforeFirst()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean isFirst()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean isLast()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean last()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void moveToCurrentRow()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void moveToInsertRow()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean next()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean previous()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void refreshRow()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean relative(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean rowDeleted()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean rowInserted()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean rowUpdated()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setFetchDirection(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setFetchSize(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateArray(
int
java.sql.Array)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateArray(
java.lang.String
java.sql.Array)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateAsciiStream(
int
java.io.InputStream
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateAsciiStream(
java.lang.String
java.io.InputStream
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateBigDecimal(
int
java.math.BigDecimal)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateBigDecimal(
java.lang.String
java.math.BigDecimal)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateBinaryStream(
int
java.io.InputStream
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateBinaryStream(
java.lang.String
java.io.InputStream
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateBlob(
int
java.sql.Blob)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateBlob(
java.lang.String
java.sql.Blob)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateBoolean(
int
boolean)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateBoolean(
java.lang.String
boolean)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateByte(
int
byte)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateByte(
java.lang.String
byte)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateBytes(
int
byte[])
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateBytes(
java.lang.String
byte[])
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateCharacterStream(
int
java.io.Reader
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateCharacterStream(
java.lang.String
java.io.Reader
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateClob(
int
java.sql.Clob)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateClob(
java.lang.String
java.sql.Clob)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateDate(
int
java.sql.Date)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateDate(
java.lang.String
java.sql.Date)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateDouble(
int
double)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateDouble(
java.lang.String
double)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateFloat(
int
float)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateFloat(
java.lang.String
float)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateInt(
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateInt(
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateLong(
int
long)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateLong(
java.lang.String
long)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateNull(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateNull(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateObject(
int
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateObject(
int
java.lang.Object
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateObject(
java.lang.String
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateObject(
java.lang.String
java.lang.Object
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateRef(
int
java.sql.Ref)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateRef(
java.lang.String
java.sql.Ref)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateRow()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateShort(
int
short)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateShort(
java.lang.String
short)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateString(
int
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateString(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateTime(
int
java.sql.Time)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateTime(
java.lang.String
java.sql.Time)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateTimestamp(
int
java.sql.Timestamp)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void updateTimestamp(
java.lang.String
java.sql.Timestamp)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean wasNull()

________________CLASS________________


public class SQLite.JDBC2y.JDBCResultSet extends java.lang.Object implements java.sql.ResultSet

----------------FIELDS----------------

private java.lang.String lastg

private SQLite.JDBC2y.JDBCResultSetMetaData m

private int row

private SQLite.JDBC2y.JDBCStatement s

protected SQLite.TableResult tr
----------------METHODS----------------

public void <init>(
SQLite.TableResult
SQLite.JDBC2y.JDBCStatement)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
private java.sql.Date internalGetDate(
int
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
private java.lang.Double internalGetDouble(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
private java.lang.Float internalGetFloat(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
private java.lang.Integer internalGetInt(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
private java.lang.Long internalGetLong(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
private java.lang.Short internalGetShort(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
private java.sql.Time internalGetTime(
int
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
private java.sql.Timestamp internalGetTimestamp(
int
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean absolute(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void afterLast()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void beforeFirst()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void cancelRowUpdates()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void clearWarnings()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void deleteRow()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int findColumn(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean first()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Array getArray(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Array getArray(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.io.InputStream getAsciiStream(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.io.InputStream getAsciiStream(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.math.BigDecimal getBigDecimal(
int)
@java.lang.Deprecated
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.math.BigDecimal getBigDecimal(
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.math.BigDecimal getBigDecimal(
java.lang.String)
@java.lang.Deprecated
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.math.BigDecimal getBigDecimal(
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.io.InputStream getBinaryStream(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.io.InputStream getBinaryStream(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Blob getBlob(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Blob getBlob(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean getBoolean(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean getBoolean(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public byte getByte(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public byte getByte(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public byte[] getBytes(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public byte[] getBytes(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.io.Reader getCharacterStream(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.io.Reader getCharacterStream(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Clob getClob(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Clob getClob(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getConcurrency()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.lang.String getCursorName()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Date getDate(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Date getDate(
int
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Date getDate(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Date getDate(
java.lang.String
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public double getDouble(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public double getDouble(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getFetchDirection()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getFetchSize()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public float getFloat(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public float getFloat(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getInt(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getInt(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public long getLong(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public long getLong(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.ResultSetMetaData getMetaData()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.lang.Object getObject(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.lang.Object getObject(
int
java.util.Map)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.lang.Object getObject(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.lang.Object getObject(
java.lang.String
java.util.Map)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Ref getRef(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Ref getRef(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getRow()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public short getShort(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public short getShort(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Statement getStatement()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.lang.String getString(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.lang.String getString(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Time getTime(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Time getTime(
int
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Time getTime(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Time getTime(
java.lang.String
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Timestamp getTimestamp(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Timestamp getTimestamp(
int
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Timestamp getTimestamp(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Timestamp getTimestamp(
java.lang.String
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getType()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.net.URL getURL(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.net.URL getURL(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
@java.lang.Deprecated
public java.io.InputStream getUnicodeStream(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
@java.lang.Deprecated
public java.io.InputStream getUnicodeStream(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.SQLWarning getWarnings()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void insertRow()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean isAfterLast()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean isBeforeFirst()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean isFirst()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean isLast()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean last()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void moveToCurrentRow()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void moveToInsertRow()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean next()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean previous()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void refreshRow()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean relative(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean rowDeleted()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean rowInserted()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean rowUpdated()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setFetchDirection(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void setFetchSize(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateArray(
int
java.sql.Array)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateArray(
java.lang.String
java.sql.Array)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateAsciiStream(
int
java.io.InputStream
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateAsciiStream(
java.lang.String
java.io.InputStream
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateBigDecimal(
int
java.math.BigDecimal)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateBigDecimal(
java.lang.String
java.math.BigDecimal)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateBinaryStream(
int
java.io.InputStream
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateBinaryStream(
java.lang.String
java.io.InputStream
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateBlob(
int
java.sql.Blob)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateBlob(
java.lang.String
java.sql.Blob)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateBoolean(
int
boolean)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateBoolean(
java.lang.String
boolean)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateByte(
int
byte)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateByte(
java.lang.String
byte)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateBytes(
int
byte[])
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateBytes(
java.lang.String
byte[])
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateCharacterStream(
int
java.io.Reader
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateCharacterStream(
java.lang.String
java.io.Reader
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateClob(
int
java.sql.Clob)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateClob(
java.lang.String
java.sql.Clob)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateDate(
int
java.sql.Date)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateDate(
java.lang.String
java.sql.Date)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateDouble(
int
double)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateDouble(
java.lang.String
double)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateFloat(
int
float)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateFloat(
java.lang.String
float)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateInt(
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateInt(
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateLong(
int
long)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateLong(
java.lang.String
long)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateNull(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateNull(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateObject(
int
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateObject(
int
java.lang.Object
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateObject(
java.lang.String
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateObject(
java.lang.String
java.lang.Object
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateRef(
int
java.sql.Ref)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateRef(
java.lang.String
java.sql.Ref)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateRow()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateShort(
int
short)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateShort(
java.lang.String
short)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateString(
int
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateString(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateTime(
int
java.sql.Time)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateTime(
java.lang.String
java.sql.Time)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateTimestamp(
int
java.sql.Timestamp)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public void updateTimestamp(
java.lang.String
java.sql.Timestamp)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean wasNull()

________________CLASS________________


public abstract interface class java.sql.ResultSetMetaData extends java.lang.Object

----------------FIELDS----------------

public static final int columnNoNulls

public static final int columnNullable

public static final int columnNullableUnknown
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String getCatalogName(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String getColumnClassName(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getColumnCount()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getColumnDisplaySize(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String getColumnLabel(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String getColumnName(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getColumnType(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String getColumnTypeName(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getPrecision(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getScale(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String getSchemaName(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String getTableName(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean isAutoIncrement(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean isCaseSensitive(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean isCurrency(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean isDefinitelyWritable(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int isNullable(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean isReadOnly(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean isSearchable(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean isSigned(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean isWritable(
int)

________________CLASS________________


public class SQLite.JDBC2y.JDBCResultSetMetaData extends java.lang.Object implements java.sql.ResultSetMetaData

----------------FIELDS----------------

private SQLite.JDBC2y.JDBCResultSet r
----------------METHODS----------------

public void <init>(
SQLite.JDBC2y.JDBCResultSet)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
 int findColByName(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.lang.String getCatalogName(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.lang.String getColumnClassName(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getColumnCount()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getColumnDisplaySize(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.lang.String getColumnLabel(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.lang.String getColumnName(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getColumnType(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.lang.String getColumnTypeName(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getPrecision(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int getScale(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.lang.String getSchemaName(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.lang.String getTableName(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean isAutoIncrement(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean isCaseSensitive(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean isCurrency(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean isDefinitelyWritable(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public int isNullable(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean isReadOnly(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean isSearchable(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean isSigned(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean isWritable(
int)

________________CLASS________________


public class SQLite.TableResult extends java.lang.Object implements SQLite.Callback

----------------FIELDS----------------

public java.lang.String[] column

public int ncolumns

public int nrows

public java.util.Vector rows

public java.lang.String[] types
----------------METHODS----------------

public void <init>()

public void clear()

public void columns(
java.lang.String[])

public boolean newrow(
java.lang.String[])

public java.lang.String toString()

public void types(
java.lang.String[])

________________CLASS________________


public class SQLite.JDBC2y.TableResultX extends SQLite.TableResult

----------------FIELDS----------------

public int[] sql_type
----------------METHODS----------------

public void <init>()

public void <init>(
SQLite.TableResult)

 void sql_types(
int[])

________________CLASS________________


public abstract interface class java.sql.Driver extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean acceptsURL(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Connection connect(
java.lang.String
java.util.Properties)

public abstract int getMajorVersion()

public abstract int getMinorVersion()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.DriverPropertyInfo[] getPropertyInfo(
java.lang.String
java.util.Properties)

public abstract boolean jdbcCompliant()

________________CLASS________________


public class SQLite.JDBCDriver extends java.lang.Object implements java.sql.Driver

----------------FIELDS----------------

public static final int MAJORVERSION

public static final int MINORVERSION

private static java.lang.reflect.Constructor makeConn

protected java.sql.Connection conn
----------------METHODS----------------

static void <clinit>()

public void <init>()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public boolean acceptsURL(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.Connection connect(
java.lang.String
java.util.Properties)

public int getMajorVersion()

public int getMinorVersion()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public java.sql.DriverPropertyInfo[] getPropertyInfo(
java.lang.String
java.util.Properties)

public boolean jdbcCompliant()

________________CLASS________________


public abstract interface class SQLite.ProgressHandler extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract boolean progress()

________________CLASS________________


public class SQLite.Shell extends java.lang.Object implements SQLite.Callback

----------------FIELDS----------------

static final int MODE_Column

static final int MODE_Html

static final int MODE_Insert

static final int MODE_Insert2

static final int MODE_Line

static final int MODE_List

static final int MODE_Semi

 java.lang.String[] cols

 int[] colwidth

 int count

 SQLite.Database db

 java.lang.String destTable

 boolean echo

 java.io.PrintWriter err

 int mode

 java.io.PrintWriter pw

 java.lang.String sep

 boolean showHeader

 java.lang.String tableName
----------------METHODS----------------

public void <init>(
java.io.PrintStream
java.io.PrintStream)

public void <init>(
java.io.PrintWriter
java.io.PrintWriter)

static java.lang.String html_quote(
java.lang.String)

static boolean is_numeric(
java.lang.String)

public static void main(
java.lang.String[])

public static java.lang.String sql_quote(
java.lang.String)

public static java.lang.String sql_quote_dbl(
java.lang.String)

protected java.lang.Object clone()

public void columns(
java.lang.String[])

 void do_cmd(
java.lang.String)

 void do_input(
java.io.BufferedReader)

 void do_meta(
java.lang.String)

public boolean newrow(
java.lang.String[])

 java.lang.String read_line(
java.io.BufferedReader
java.lang.String)

 void set_table_name(
java.lang.String)

public void types(
java.lang.String[])

________________CLASS________________


public class SQLite.Stmt extends java.lang.Object

----------------FIELDS----------------

protected int error_code

private long handle
----------------METHODS----------------

static void <clinit>()

public void <init>()

private static native void internal_init()
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public native void bind(
int)
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public native void bind(
int
double)
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public native void bind(
int
int)
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public native void bind(
int
long)
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public native void bind(
int
java.lang.String)
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public native void bind(
int
byte[])
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public native int bind_parameter_count()
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public native int bind_parameter_index(
java.lang.String)
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public native java.lang.String bind_parameter_name(
int)
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public native void bind_zeroblob(
int
int)
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public native void clear_bindings()
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public native void close()
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public java.lang.Object column(
int)
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public native byte[] column_bytes(
int)
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public native int column_count()
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public native java.lang.String column_database_name(
int)
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public native java.lang.String column_decltype(
int)
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public native double column_double(
int)
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public native int column_int(
int)
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public native long column_long(
int)
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public native java.lang.String column_origin_name(
int)
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public native java.lang.String column_string(
int)
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public native java.lang.String column_table_name(
int)
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public native int column_type(
int)

protected native void finalize()
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public native boolean prepare()
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public native void reset()
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public native boolean step()

________________CLASS________________


public class SQLite.StringEncoder extends java.lang.Object

----------------FIELDS----------------

static final char[] xdigits
----------------METHODS----------------

static void <clinit>()

public void <init>()

private static byte[] byteCopy(
byte[]
int
int
byte[])

public static byte[] decode(
java.lang.String)

public static java.lang.String encode(
byte[])

public static java.lang.String encodeX(
byte[])

________________CLASS________________


public abstract interface class SQLite.Trace extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract void trace(
java.lang.String)

________________CLASS________________


public class SQLite.Vm extends java.lang.Object

----------------FIELDS----------------

protected int error_code

private long handle
----------------METHODS----------------

static void <clinit>()

public void <init>()

private static native void internal_init()
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public native boolean compile()

protected native void finalize()
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public native boolean step(
SQLite.Callback)
@dalvik.annotation.Throws (value =LSQLite/Exception; )
public native void stop()

________________CLASS________________


public abstract class java.nio.charset.CharsetDecoder extends java.lang.Object

----------------FIELDS----------------

private static final int END

private static final int FLUSH

private static final int INIT

private static final int ONGOING

private float averChars

private java.nio.charset.Charset cs

private java.nio.charset.CodingErrorAction malformAction

private float maxChars

private java.lang.String replace

private int status

private java.nio.charset.CodingErrorAction unmapAction
----------------METHODS----------------

protected void <init>(
java.nio.charset.Charset
float
float)

private java.nio.CharBuffer allocateMore(
java.nio.CharBuffer)
@dalvik.annotation.Throws (value =Ljava/nio/charset/CharacterCodingException; )
private void checkCoderResult(
java.nio.charset.CoderResult)

public final float averageCharsPerByte()

public final java.nio.charset.Charset charset()
@dalvik.annotation.Throws (value =Ljava/nio/charset/CharacterCodingException; )
public final java.nio.CharBuffer decode(
java.nio.ByteBuffer)

public final java.nio.charset.CoderResult decode(
java.nio.ByteBuffer
java.nio.CharBuffer
boolean)

protected abstract java.nio.charset.CoderResult decodeLoop(
java.nio.ByteBuffer
java.nio.CharBuffer)

public java.nio.charset.Charset detectedCharset()

public final java.nio.charset.CoderResult flush(
java.nio.CharBuffer)

protected java.nio.charset.CoderResult implFlush(
java.nio.CharBuffer)

protected void implOnMalformedInput(
java.nio.charset.CodingErrorAction)

protected void implOnUnmappableCharacter(
java.nio.charset.CodingErrorAction)

protected void implReplaceWith(
java.lang.String)

protected void implReset()

public boolean isAutoDetecting()

public boolean isCharsetDetected()

public java.nio.charset.CodingErrorAction malformedInputAction()

public final float maxCharsPerByte()

public final java.nio.charset.CharsetDecoder onMalformedInput(
java.nio.charset.CodingErrorAction)

public final java.nio.charset.CharsetDecoder onUnmappableCharacter(
java.nio.charset.CodingErrorAction)

public final java.nio.charset.CharsetDecoder replaceWith(
java.lang.String)

public final java.lang.String replacement()

public final java.nio.charset.CharsetDecoder reset()

public java.nio.charset.CodingErrorAction unmappableCharacterAction()

________________CLASS________________


public final class com.ibm.icu4jni.charset.CharsetDecoderICU extends java.nio.charset.CharsetDecoder

----------------FIELDS----------------

private static final int INPUT_HELD

private static final int INPUT_OFFSET

private static final int INVALID_BYTES

private static final int LIMIT

private static final int OUTPUT_OFFSET

private long converterHandle

private int[] data

private int ec

private int inEnd

private byte[] input

private int onMalformedInput

private int onUnmappableInput

private int outEnd

private char[] output

private int savedInputHeldLen
----------------METHODS----------------

public void <init>(
java.nio.charset.Charset
long)

private final int getArray(
java.nio.ByteBuffer)

private final int getArray(
java.nio.CharBuffer)

private final void setPosition(
java.nio.ByteBuffer)

private final void setPosition(
java.nio.CharBuffer)

protected java.nio.charset.CoderResult decodeLoop(
java.nio.ByteBuffer
java.nio.CharBuffer)
@dalvik.annotation.Throws (value =Ljava/lang/Throwable; )
protected void finalize()

protected final java.nio.charset.CoderResult implFlush(
java.nio.CharBuffer)

protected final void implOnMalformedInput(
java.nio.charset.CodingErrorAction)

protected final void implOnUnmappableCharacter(
java.nio.charset.CodingErrorAction)

protected void implReplaceWith(
java.lang.String)

protected void implReset()

________________CLASS________________


public abstract class java.nio.charset.CharsetEncoder extends java.lang.Object

----------------FIELDS----------------

private static final int END

private static final int FLUSH

private static final int INIT

private static final int ONGOING

private float averBytes

private java.nio.charset.Charset cs

private java.nio.charset.CharsetDecoder decoder

private java.nio.charset.CodingErrorAction malformAction

private float maxBytes

private byte[] replace

private int status

private java.nio.charset.CodingErrorAction unmapAction
----------------METHODS----------------

protected void <init>(
java.nio.charset.Charset
float
float)

protected void <init>(
java.nio.charset.Charset
float
float
byte[])

private java.nio.ByteBuffer allocateMore(
java.nio.ByteBuffer)
@dalvik.annotation.Throws (value =Ljava/nio/charset/CharacterCodingException; )
private void checkCoderResult(
java.nio.charset.CoderResult)

private boolean implCanEncode(
java.nio.CharBuffer)

public final float averageBytesPerChar()

public boolean canEncode(
char)

public boolean canEncode(
java.lang.CharSequence)

public final java.nio.charset.Charset charset()
@dalvik.annotation.Throws (value =Ljava/nio/charset/CharacterCodingException; )
public final java.nio.ByteBuffer encode(
java.nio.CharBuffer)

public final java.nio.charset.CoderResult encode(
java.nio.CharBuffer
java.nio.ByteBuffer
boolean)

protected abstract java.nio.charset.CoderResult encodeLoop(
java.nio.CharBuffer
java.nio.ByteBuffer)

public final java.nio.charset.CoderResult flush(
java.nio.ByteBuffer)

protected java.nio.charset.CoderResult implFlush(
java.nio.ByteBuffer)

protected void implOnMalformedInput(
java.nio.charset.CodingErrorAction)

protected void implOnUnmappableCharacter(
java.nio.charset.CodingErrorAction)

protected void implReplaceWith(
byte[])

protected void implReset()

public boolean isLegalReplacement(
byte[])

public java.nio.charset.CodingErrorAction malformedInputAction()

public final float maxBytesPerChar()

public final java.nio.charset.CharsetEncoder onMalformedInput(
java.nio.charset.CodingErrorAction)

public final java.nio.charset.CharsetEncoder onUnmappableCharacter(
java.nio.charset.CodingErrorAction)

public final java.nio.charset.CharsetEncoder replaceWith(
byte[])

public final byte[] replacement()

public final java.nio.charset.CharsetEncoder reset()

public java.nio.charset.CodingErrorAction unmappableCharacterAction()

________________CLASS________________


public final class com.ibm.icu4jni.charset.CharsetEncoderICU extends java.nio.charset.CharsetEncoder

----------------FIELDS----------------

private static final int INPUT_HELD

private static final int INPUT_OFFSET

private static final int INVALID_CHARS

private static final int LIMIT

private static final int OUTPUT_OFFSET

private long converterHandle

private int[] data

private int ec

private int inEnd

private char[] input

private int onMalformedInput

private int onUnmappableInput

private int outEnd

private byte[] output

private int savedInputHeldLen
----------------METHODS----------------

public void <init>(
java.nio.charset.Charset
long
byte[])

private final int getArray(
java.nio.ByteBuffer)

private final int getArray(
java.nio.CharBuffer)

private final void setPosition(
java.nio.ByteBuffer)

private final void setPosition(
java.nio.CharBuffer)

public boolean canEncode(
char)

public boolean canEncode(
int)

protected java.nio.charset.CoderResult encodeLoop(
java.nio.CharBuffer
java.nio.ByteBuffer)
@dalvik.annotation.Throws (value =Ljava/lang/Throwable; )
protected void finalize()

protected java.nio.charset.CoderResult implFlush(
java.nio.ByteBuffer)

protected void implOnMalformedInput(
java.nio.charset.CodingErrorAction)

protected void implOnUnmappableCharacter(
java.nio.charset.CodingErrorAction)

protected void implReplaceWith(
byte[])

protected void implReset()

________________CLASS________________

@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>Ljava/lang/Object; )
public abstract interface class java.lang.Comparable extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =(TT;)I )
public abstract int compareTo(
java.lang.Object)

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/lang/Comparable<Ljava/nio/charset/Charset;>; )
@dalvik.annotation.MemberClasses (value =Ljava/nio/charset/Charset$IgnoreCaseComparator; )
public abstract class java.nio.charset.Charset extends java.lang.Object implements java.lang.Comparable

----------------FIELDS----------------

private static final java.lang.String PROVIDER_CONFIGURATION_FILE_COMMENT

private static final java.lang.String PROVIDER_CONFIGURATION_FILE_ENCODING

private static final java.lang.String PROVIDER_CONFIGURATION_FILE_NAME
@dalvik.annotation.Signature (value =Ljava/util/TreeMap<Ljava/lang/String;Ljava/nio/charset/Charset;>; )
private static java.util.TreeMap _builtInCharsets

private static com.ibm.icu4jni.charset.CharsetProviderICU _builtInProvider
@dalvik.annotation.Signature (value =Ljava/util/HashMap<Ljava/lang/String;Ljava/nio/charset/CharsetDecoder;>; )
private static java.util.HashMap cachedCharsetDecoderTable
@dalvik.annotation.Signature (value =Ljava/util/HashMap<Ljava/lang/String;Ljava/nio/charset/CharsetEncoder;>; )
private static java.util.HashMap cachedCharsetEncoderTable
@dalvik.annotation.Signature (value =Ljava/util/HashMap<Ljava/lang/String;Ljava/nio/charset/Charset;>; )
private static java.util.HashMap cachedCharsetTable

private static java.lang.ClassLoader systemClassLoader
@dalvik.annotation.Signature (value =Ljava/util/HashSet<Ljava/lang/String;>; )
private final java.util.HashSet aliasesSet

private final java.lang.String canonicalName
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Throws (value =Ljava/nio/charset/IllegalCharsetNameException; )
protected void <init>(
java.lang.String
java.lang.String[])
@dalvik.annotation.Signature (value =(Ljava/nio/charset/spi/CharsetProvider;Ljava/util/TreeMap<Ljava/lang/String;Ljava/nio/charset/Charset;>;)V )
private static void addCharsets(
java.nio.charset.spi.CharsetProvider
java.util.TreeMap)
@dalvik.annotation.Signature (value =()Ljava/util/SortedMap<Ljava/lang/String;Ljava/nio/charset/Charset;>; )
public static java.util.SortedMap availableCharsets()

private static void cacheCharset(
java.nio.charset.Charset)

private static void checkCharsetName(
java.lang.String)

public static java.nio.charset.Charset defaultCharset()
@dalvik.annotation.Throws (value =Ljava/nio/charset/IllegalCharsetNameException;Ljava/nio/charset/UnsupportedCharsetException; )
public static java.nio.charset.Charset forName(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/nio/charset/IllegalCharsetNameException; )
private static java.nio.charset.Charset forNameInternal(
java.lang.String)

private static java.nio.charset.Charset getCachedCharset(
java.lang.String)

private java.nio.charset.CharsetDecoder getCachedCharsetDecoder(
java.lang.String)

private java.nio.charset.CharsetEncoder getCachedCharsetEncoder(
java.lang.String)

private static java.lang.ClassLoader getContextClassLoader()

private static void getSystemClassLoader()

private static boolean isDigit(
char)

private static boolean isLetter(
char)

private static boolean isSpecial(
char)
@dalvik.annotation.Throws (value =Ljava/nio/charset/IllegalCharsetNameException; )
public static boolean isSupported(
java.lang.String)
@dalvik.annotation.Signature (value =(Ljava/net/URL;Ljava/lang/ClassLoader;Ljava/util/TreeMap<Ljava/lang/String;Ljava/nio/charset/Charset;>;)V )
private static void loadConfiguredCharsets(
java.net.URL
java.lang.ClassLoader
java.util.TreeMap)

private static java.nio.charset.Charset searchConfiguredCharsets(
java.lang.String
java.lang.ClassLoader
java.net.URL)

private static java.lang.String trimClassName(
java.lang.String)
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/lang/String;>; )
public final java.util.Set aliases()

public boolean canEncode()

public volatile int compareTo(
java.lang.Object)

public final int compareTo(
java.nio.charset.Charset)

public abstract boolean contains(
java.nio.charset.Charset)

public final java.nio.CharBuffer decode(
java.nio.ByteBuffer)

public java.lang.String displayName()

public java.lang.String displayName(
java.util.Locale)

public final java.nio.ByteBuffer encode(
java.lang.String)

public final java.nio.ByteBuffer encode(
java.nio.CharBuffer)

public final boolean equals(
java.lang.Object)

public final int hashCode()

public final boolean isRegistered()

public final java.lang.String name()

public abstract java.nio.charset.CharsetDecoder newDecoder()

public abstract java.nio.charset.CharsetEncoder newEncoder()

public final java.lang.String toString()

________________CLASS________________


public final class com.ibm.icu4jni.charset.CharsetICU extends java.nio.charset.Charset

----------------FIELDS----------------

private static final java.util.Map subByteMap

private java.lang.String icuCanonicalName
----------------METHODS----------------

static void <clinit>()

protected void <init>(
java.lang.String
java.lang.String
java.lang.String[])

public boolean contains(
java.nio.charset.Charset)

public java.nio.charset.CharsetDecoder newDecoder()

public java.nio.charset.CharsetEncoder newEncoder()

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/lang/Object; )
public abstract interface class java.util.Iterator extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract boolean hasNext()
@dalvik.annotation.Signature (value =()TE; )
public abstract java.lang.Object next()

public abstract void remove()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lcom/ibm/icu4jni/charset/CharsetProviderICU; )
@dalvik.annotation.InnerClass (accessFlags =20 name =CharsetIterator )
public final class com.ibm.icu4jni.charset.CharsetProviderICU$CharsetIterator extends java.lang.Object implements java.util.Iterator

----------------FIELDS----------------

private int currentIndex

private java.lang.String[] names

final com.ibm.icu4jni.charset.CharsetProviderICU this$0
----------------METHODS----------------

protected void <init>(
com.ibm.icu4jni.charset.CharsetProviderICU
java.lang.String[])

public boolean hasNext()

public java.lang.Object next()

public void remove()

________________CLASS________________


public abstract class java.nio.charset.spi.CharsetProvider extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.RuntimePermission CONSTRUCT_PERM
----------------METHODS----------------

static void <clinit>()

protected void <init>()

public abstract java.nio.charset.Charset charsetForName(
java.lang.String)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<Ljava/nio/charset/Charset;>; )
public abstract java.util.Iterator charsets()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lcom/ibm/icu4jni/charset/CharsetProviderICU$CharsetIterator; )
public final class com.ibm.icu4jni.charset.CharsetProviderICU extends java.nio.charset.spi.CharsetProvider

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

private final java.nio.charset.Charset getCharset(
java.lang.String)

public final java.nio.charset.Charset charsetForName(
java.lang.String)

public final java.util.Iterator charsets()

public final void putCharsets(
java.util.Map)

________________CLASS________________


public final class com.ibm.icu4jni.common.ErrorCode extends java.lang.Exception

----------------FIELDS----------------

private static final java.lang.String[] ERROR_NAMES_

public static boolean LIBRARY_LOADED

public static final int U_BUFFER_OVERFLOW_ERROR

public static final int U_ERROR_INFO_LIMIT

public static final int U_ERROR_INFO_START

public static final int U_ERROR_LIMIT

public static final int U_FILE_ACCESS_ERROR

public static final int U_ILLEGAL_ARGUMENT_ERROR

public static final int U_ILLEGAL_CHAR_FOUND

public static final int U_ILLEGAL_ESCAPE_SEQUENCE

public static final int U_INDEX_OUTOFBOUNDS_ERROR

public static final int U_INTERNAL_PROGRAM_ERROR

public static final int U_INVALID_CHAR_FOUND

public static final int U_INVALID_FORMAT_ERROR

public static final int U_INVALID_TABLE_FILE

public static final int U_INVALID_TABLE_FORMAT

public static final int U_MEMORY_ALLOCATION_ERROR

public static final int U_MESSAGE_PARSE_ERROR

public static final int U_MISSING_RESOURCE_ERROR

public static final int U_NO_SPACE_AVAILABLE

public static final int U_PARSE_ERROR

public static final int U_RESOURCE_TYPE_MISMATCH

public static final int U_SAFECLONE_ALLOCATED_ERROR

public static final int U_TRUNCATED_CHAR_FOUND

public static final int U_UNSUPPORTED_ERROR

public static final int U_UNSUPPORTED_ESCAPE_SEQUENCE

public static final int U_USING_DEFAULT_ERROR

public static final int U_USING_FALLBACK_ERROR

public static final int U_ZERO_ERROR
----------------METHODS----------------

static void <clinit>()

public void <init>()

public static java.lang.String getErrorName(
int)

public static final java.lang.RuntimeException getException(
int)

public static boolean isFailure(
int)

public static boolean isSuccess(
int)

________________CLASS________________


public final class com.ibm.icu4jni.converters.NativeConverter extends java.lang.Object

----------------FIELDS----------------

public static final int SKIP_CALLBACK

public static final int STOP_CALLBACK

public static final int SUBSTITUTE_CALLBACK
----------------METHODS----------------

public void <init>()

public static final native boolean canDecode(
long
byte[])

public static final native boolean canEncode(
long
int)

public static final native void closeConverter(
long)

public static final native boolean contains(
long
long)

public static final native int convertByteToChar(
long
byte[]
int
char[]
int
int[]
boolean)

public static final native int convertCharToByte(
long
char[]
int
byte[]
int
int[]
boolean)

public static final native int countAliases(
java.lang.String)

public static final native int countAvailable()

public static final native int countInvalidBytes(
long
int[])

public static final native int countInvalidChars(
long
int[])

public static final native int decode(
long
byte[]
int
char[]
int
int[]
boolean)

public static final native int encode(
long
char[]
int
byte[]
int
int[]
boolean)

public static final native int flushByteToChar(
long
char[]
int
int[])

public static final native int flushCharToByte(
long
byte[]
int
int[])

public static final native java.lang.String[] getAliases(
java.lang.String)

public static final native java.lang.String[] getAvailable()

public static final native float getAveBytesPerChar(
long)

public static final native float getAveCharsPerByte(
long)

public static final native java.lang.String getCanonicalName(
java.lang.String)

public static final native java.lang.String getICUCanonicalName(
java.lang.String)

public static final native java.lang.String getJavaCanonicalName(
java.lang.String)

public static final native int getMaxBytesPerChar(
long)

public static final native int getMaxCharsPerByte(
long)

public static final native int getMinBytesPerChar(
long)

public static final native byte[] getSubstitutionBytes(
long)

public static final native long openConverter(
java.lang.String)

public static final native void resetByteToChar(
long)

public static final native void resetCharToByte(
long)

public static final native long safeClone(
long)

public static final native int setCallbackDecode(
long
int
int
char[]
int)

public static final native int setCallbackEncode(
long
int
int
byte[]
int)

public static final native int setSubstitutionBytes(
long
byte[]
int)

public static final native int setSubstitutionChars(
long
char[]
int)

public static final native int setSubstitutionModeByteToChar(
long
boolean)

public static final native int setSubstitutionModeCharToByte(
long
boolean)

________________CLASS________________


public class com.ibm.icu4jni.lang.UCharacter extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

private static native int codeblock(
int)

public static int digit(
int
int)

private static native int digitImpl(
int
int)

public static int forName(
java.lang.String)

private static native int forname(
java.lang.String)

public static java.lang.Character$UnicodeBlock[] getBlockTable()

public static byte getDirectionality(
int)

private static native byte getDirectionalityImpl(
int)

public static int getNumericValue(
int)

private static native int getNumericValueImpl(
int)

public static int getType(
int)

private static native int getTypeImpl(
int)

public static boolean isDefined(
int)

private static native boolean isDefinedValueImpl(
int)

public static boolean isDigit(
int)

private static native boolean isDigitImpl(
int)

public static boolean isIdentifierIgnorable(
int)

private static native boolean isIdentifierIgnorableImpl(
int)

public static boolean isLetter(
int)

private static native boolean isLetterImpl(
int)

public static boolean isLetterOrDigit(
int)

private static native boolean isLetterOrDigitImpl(
int)

public static boolean isLowerCase(
int)

private static native boolean isLowerCaseImpl(
int)

public static boolean isMirrored(
int)

private static native boolean isMirroredImpl(
int)

public static boolean isSpaceChar(
int)

private static native boolean isSpaceCharImpl(
int)

public static boolean isTitleCase(
int)

private static native boolean isTitleCaseImpl(
int)

public static boolean isUnicodeIdentifierPart(
int)

private static native boolean isUnicodeIdentifierPartImpl(
int)

public static boolean isUnicodeIdentifierStart(
int)

private static native boolean isUnicodeIdentifierStartImpl(
int)

public static boolean isUpperCase(
int)

private static native boolean isUpperCaseImpl(
int)

public static boolean isWhitespace(
int)

private static native boolean isWhitespaceImpl(
int)

public static int of(
int)

public static int toLowerCase(
int)

private static native int toLowerCaseImpl(
int)

public static int toTitleCase(
int)

private static native int toTitleCaseImpl(
int)

public static int toUpperCase(
int)

private static native int toUpperCaseImpl(
int)

________________CLASS________________


public abstract class java.lang.Number extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public byte byteValue()

public abstract double doubleValue()

public abstract float floatValue()

public abstract int intValue()

public abstract long longValue()

public short shortValue()

________________CLASS________________


public class com.ibm.icu4jni.math.BigDecimal extends java.lang.Number

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public double doubleValue()

public float floatValue()

public int intValue()

public long longValue()

public java.lang.String toString()

________________CLASS________________


public class com.ibm.icu4jni.regex.NativeRegEx extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public static native int clone(
int)

public static native void close(
int)

public static native boolean find(
int
int)

public static native boolean findNext(
int)

public static native int groupCount(
int)

public static native boolean hasAnchoringBounds(
int)

public static native boolean hasTransparentBounds(
int)

public static native boolean hitEnd(
int)

public static native boolean lookingAt(
int
int)

public static native boolean matches(
int
int)

public static native int open(
java.lang.String
int)

public static native int regionEnd(
int)

public static native int regionStart(
int)

public static native boolean requireEnd(
int)

public static native void reset(
int
int)

public static native void setRegion(
int
int
int)

public static native void setText(
int
java.lang.String)

public static native void startEnd(
int
int[])

public static native void useAnchoringBounds(
int
boolean)

public static native void useTransparentBounds(
int
boolean)

________________CLASS________________


public abstract interface class java.lang.Cloneable extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________


public abstract class com.ibm.icu4jni.text.BreakIterator extends java.lang.Object implements java.lang.Cloneable

----------------FIELDS----------------

protected static int BI_CHAR_INSTANCE

protected static int BI_LINE_INSTANCE

protected static int BI_SENT_INSTANCE

protected static int BI_WORD_INSTANCE

protected int type
----------------METHODS----------------

static void <clinit>()

public void <init>()

public static java.util.Locale[] getAvailableLocales()

public static com.ibm.icu4jni.text.BreakIterator getCharacterInstance()

public static com.ibm.icu4jni.text.BreakIterator getCharacterInstance(
java.util.Locale)

public static com.ibm.icu4jni.text.BreakIterator getLineInstance()

public static com.ibm.icu4jni.text.BreakIterator getLineInstance(
java.util.Locale)

public static com.ibm.icu4jni.text.BreakIterator getSentenceInstance()

public static com.ibm.icu4jni.text.BreakIterator getSentenceInstance(
java.util.Locale)

public static com.ibm.icu4jni.text.BreakIterator getWordInstance()

public static com.ibm.icu4jni.text.BreakIterator getWordInstance(
java.util.Locale)

public abstract java.lang.Object clone()

public abstract int current()

public abstract int first()

public abstract int following(
int)

public abstract java.text.CharacterIterator getText()

public abstract boolean isBoundary(
int)

public abstract int last()

public abstract int next()

public abstract int next(
int)

public abstract int preceding(
int)

public abstract int previous()

public void setText(
java.lang.String)

public abstract void setText(
java.text.CharacterIterator)

________________CLASS________________


public final class com.ibm.icu4jni.text.CollationAttribute extends java.lang.Object

----------------FIELDS----------------

public static final int ALTERNATE_HANDLING

public static final int ATTRIBUTE_COUNT

public static final int CASE_FIRST

public static final int CASE_LEVEL

public static final int FRENCH_COLLATION

public static final int NORMALIZATION_MODE

public static final int STRENGTH

public static final int VALUE_ATTRIBUTE_VALUE_COUNT

public static final int VALUE_DEFAULT

public static final int VALUE_DEFAULT_STRENGTH

public static final int VALUE_IDENTICAL

public static final int VALUE_LOWER_FIRST

public static final int VALUE_NON_IGNORABLE

public static final int VALUE_OFF

public static final int VALUE_ON

public static final int VALUE_ON_WITHOUT_HANGUL

public static final int VALUE_PRIMARY

public static final int VALUE_QUATERNARY

public static final int VALUE_SECONDARY

public static final int VALUE_SHIFTED

public static final int VALUE_TERTIARY

public static final int VALUE_UPPER_FIRST
----------------METHODS----------------

public void <init>()

static boolean checkAttribute(
int
int)

static boolean checkNormalization(
int)

static boolean checkStrength(
int)

static boolean checkType(
int)

________________CLASS________________


public final class com.ibm.icu4jni.text.CollationElementIterator extends java.lang.Object

----------------FIELDS----------------

public static final int NULLORDER

private static final int PRIMARY_ORDER_MASK_

private static final int PRIMARY_ORDER_SHIFT_

private static final int SECONDARY_ORDER_MASK_

private static final int SECONDARY_ORDER_SHIFT_

private static final int TERTIARY_ORDER_MASK_

private static final int UNSIGNED_16_BIT_MASK_

private int m_collelemiterator_
----------------METHODS----------------

 void <init>(
int)

public static int primaryOrder(
int)

public static int secondaryOrder(
int)

public static int tertiaryOrder(
int)

protected void finalize()

public int getMaxExpansion(
int)

public int getOffset()

public int next()

public int previous()

public void reset()

public void setOffset(
int)

public void setText(
java.lang.String)

public void setText(
java.text.CharacterIterator)

________________CLASS________________


public final class com.ibm.icu4jni.text.CollationKey extends java.lang.Object implements java.lang.Comparable

----------------FIELDS----------------

private static final int UNSIGNED_BYTE_MASK_

private byte[] m_bytes_

private int m_hash_
----------------METHODS----------------

 void <init>()

 void <init>(
byte[])

public int compareTo(
com.ibm.icu4jni.text.CollationKey)

public int compareTo(
java.lang.Object)

public boolean equals(
java.lang.Object)

public int hashCode()

public byte[] toByteArray()

________________CLASS________________


public abstract class com.ibm.icu4jni.text.Collator extends java.lang.Object implements java.lang.Cloneable

----------------FIELDS----------------

public static final int CANONICAL_DECOMPOSITION

public static final int IDENTICAL

public static final int NO_DECOMPOSITION

public static final int PRIMARY

public static final int QUATERNARY

public static final int RESULT_DEFAULT

public static final int RESULT_EQUAL

public static final int RESULT_GREATER

public static final int RESULT_LESS

public static final int SECONDARY

public static final int TERTIARY
----------------METHODS----------------

public void <init>()

public static java.util.Locale[] getAvailableLocales()

public static com.ibm.icu4jni.text.Collator getInstance()

public static com.ibm.icu4jni.text.Collator getInstance(
java.util.Locale)
@dalvik.annotation.Throws (value =Ljava/lang/CloneNotSupportedException; )
public abstract java.lang.Object clone()

public abstract int compare(
java.lang.String
java.lang.String)

public abstract boolean equals(
java.lang.Object)

public boolean equals(
java.lang.String
java.lang.String)

public abstract int getAttribute(
int)

public abstract com.ibm.icu4jni.text.CollationKey getCollationKey(
java.lang.String)

public abstract int getDecomposition()

public abstract int getStrength()

public abstract int hashCode()

public abstract void setAttribute(
int
int)

public abstract void setDecomposition(
int)

public abstract void setStrength(
int)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/text/Format$Field; )
public abstract class java.text.Format extends java.lang.Object implements java.io.Serializable, java.lang.Cloneable

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

static java.util.ResourceBundle getBundle(
java.util.Locale)

static boolean upTo(
java.lang.String
java.text.ParsePosition
java.lang.StringBuffer
char)

static boolean upToWithQuotes(
java.lang.String
java.text.ParsePosition
java.lang.StringBuffer
char
char)

public java.lang.Object clone()

 java.lang.String convertPattern(
java.lang.String
java.lang.String
java.lang.String
boolean)

public final java.lang.String format(
java.lang.Object)

public abstract java.lang.StringBuffer format(
java.lang.Object
java.lang.StringBuffer
java.text.FieldPosition)

public java.text.AttributedCharacterIterator formatToCharacterIterator(
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/text/ParseException; )
public java.lang.Object parseObject(
java.lang.String)

public abstract java.lang.Object parseObject(
java.lang.String
java.text.ParsePosition)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/text/NumberFormat$Field; )
public abstract class java.text.NumberFormat extends java.text.Format

----------------FIELDS----------------

public static final int FRACTION_FIELD

public static final int INTEGER_FIELD

private static final java.io.ObjectStreamField[] serialPersistentFields

private static final long serialVersionUID

private boolean groupingUsed

private int maximumFractionDigits

private int maximumIntegerDigits

private int minimumFractionDigits

private int minimumIntegerDigits

private boolean parseIntegerOnly
----------------METHODS----------------

static void <clinit>()

public void <init>()

public static java.util.Locale[] getAvailableLocales()

public static final java.text.NumberFormat getCurrencyInstance()

public static java.text.NumberFormat getCurrencyInstance(
java.util.Locale)

public static final java.text.NumberFormat getInstance()

public static java.text.NumberFormat getInstance(
java.util.Locale)

static java.text.NumberFormat getInstance(
java.util.Locale
java.lang.String)

public static final java.text.NumberFormat getIntegerInstance()

public static java.text.NumberFormat getIntegerInstance(
java.util.Locale)

public static final java.text.NumberFormat getNumberInstance()

public static java.text.NumberFormat getNumberInstance(
java.util.Locale)

static java.lang.String getPattern(
java.util.Locale
java.lang.String)

public static final java.text.NumberFormat getPercentInstance()

public static java.text.NumberFormat getPercentInstance(
java.util.Locale)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

public java.lang.Object clone()

public boolean equals(
java.lang.Object)

public final java.lang.String format(
double)

public final java.lang.String format(
long)

public abstract java.lang.StringBuffer format(
double
java.lang.StringBuffer
java.text.FieldPosition)

public abstract java.lang.StringBuffer format(
long
java.lang.StringBuffer
java.text.FieldPosition)

public java.lang.StringBuffer format(
java.lang.Object
java.lang.StringBuffer
java.text.FieldPosition)

public java.util.Currency getCurrency()

public int getMaximumFractionDigits()

public int getMaximumIntegerDigits()

public int getMinimumFractionDigits()

public int getMinimumIntegerDigits()

public int hashCode()

public boolean isGroupingUsed()

public boolean isParseIntegerOnly()
@dalvik.annotation.Throws (value =Ljava/text/ParseException; )
public java.lang.Number parse(
java.lang.String)

public abstract java.lang.Number parse(
java.lang.String
java.text.ParsePosition)

public final java.lang.Object parseObject(
java.lang.String
java.text.ParsePosition)

public void setCurrency(
java.util.Currency)

public void setGroupingUsed(
boolean)

public void setMaximumFractionDigits(
int)

public void setMaximumIntegerDigits(
int)

public void setMinimumFractionDigits(
int)

public void setMinimumIntegerDigits(
int)

public void setParseIntegerOnly(
boolean)

________________CLASS________________


public class com.ibm.icu4jni.text.DecimalFormat extends java.text.NumberFormat

----------------FIELDS----------------

private int addr

private byte minExponentDigits

private com.ibm.icu4jni.text.DecimalFormatSymbols symbols

private boolean useExponentialNotation
----------------METHODS----------------

public void <init>(
java.lang.String
com.ibm.icu4jni.text.DecimalFormatSymbols)

protected static java.lang.String getFieldType(
java.text.Format$Field)

public void applyLocalizedPattern(
java.lang.String)

public void applyPattern(
java.lang.String)

public java.lang.Object clone()

public boolean equals(
java.lang.Object)

public java.lang.StringBuffer format(
double
java.lang.StringBuffer
java.text.FieldPosition)

public java.lang.StringBuffer format(
long
java.lang.StringBuffer
java.text.FieldPosition)

public java.lang.StringBuffer format(
java.lang.Object
java.lang.StringBuffer
java.text.FieldPosition)

public java.text.AttributedCharacterIterator formatToCharacterIterator(
java.lang.Object)

public java.util.Currency getCurrency()

public com.ibm.icu4jni.text.DecimalFormatSymbols getDecimalFormatSymbols()

protected java.text.Format$Field getField(
java.lang.String)

public int getGroupingSize()

public int getMaximumFractionDigits()

public int getMaximumIntegerDigits()

public int getMinimumFractionDigits()

public int getMinimumIntegerDigits()

public int getMultiplier()

public java.lang.String getNegativePrefix()

public java.lang.String getNegativeSuffix()

public java.lang.String getPositivePrefix()

public java.lang.String getPositiveSuffix()

public int hashCode()

public boolean isDecimalSeparatorAlwaysShown()

public boolean isGroupingUsed()

public boolean isParseIntegerOnly()

public java.lang.Number parse(
java.lang.String
java.text.ParsePosition)

public void setCurrency(
java.util.Currency)

public void setDecimalFormatSymbols(
com.ibm.icu4jni.text.DecimalFormatSymbols)

public void setDecimalSeparatorAlwaysShown(
boolean)

public void setGroupingSize(
int)

public void setGroupingUsed(
boolean)

public void setMaximumFractionDigits(
int)

public void setMaximumIntegerDigits(
int)

public void setMinimumFractionDigits(
int)

public void setMinimumIntegerDigits(
int)

public void setMultiplier(
int)

public void setNegativePrefix(
java.lang.String)

public void setNegativeSuffix(
java.lang.String)

public void setParseIntegerOnly(
boolean)

public void setPositivePrefix(
java.lang.String)

public void setPositiveSuffix(
java.lang.String)

public java.lang.String toLocalizedPattern()

public java.lang.String toPattern()

________________CLASS________________

@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>Ljava/lang/Object; )
public abstract interface class java.security.PrivilegedAction extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =()TT; )
public abstract java.lang.Object run()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/util/ResourceBundle;>; )
 class com.ibm.icu4jni.text.DecimalFormatSymbols$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final com.ibm.icu4jni.text.DecimalFormatSymbols this$0
----------------METHODS----------------

 void <init>(
com.ibm.icu4jni.text.DecimalFormatSymbols)

public volatile java.lang.Object run()

public java.util.ResourceBundle run()

________________CLASS________________


public class com.ibm.icu4jni.text.DecimalFormatSymbols extends java.lang.Object

----------------FIELDS----------------

private int addr

private java.util.Locale loc
----------------METHODS----------------

private void <init>(
int
java.util.Locale)

public void <init>(
java.util.Locale)

static java.util.Locale access$000(
com.ibm.icu4jni.text.DecimalFormatSymbols)

public java.lang.Object clone()

public boolean equals(
java.lang.Object)

protected void finalize()

 int getAddr()

public java.util.Currency getCurrency()

public java.lang.String getCurrencySymbol()

public char getDecimalSeparator()

public char getDigit()

public char getGroupingSeparator()

public java.lang.String getInfinity()

public java.lang.String getInternationalCurrencySymbol()

 java.util.Locale getLocale()

public char getMinusSign()

public char getMonetaryDecimalSeparator()

public java.lang.String getNaN()

public char getPatternSeparator()

public char getPerMill()

public char getPercent()

public char getZeroDigit()

public void setCurrency(
java.util.Currency)

public void setCurrencySymbol(
java.lang.String)

public void setDecimalSeparator(
char)

public void setDigit(
char)

public void setGroupingSeparator(
char)

public void setInfinity(
java.lang.String)

public void setInternationalCurrencySymbol(
java.lang.String)

public void setMinusSign(
char)

public void setMonetaryDecimalSeparator(
char)

public void setNaN(
java.lang.String)

public void setPatternSeparator(
char)

public void setPerMill(
char)

public void setPercent(
char)

public void setZeroDigit(
char)

________________CLASS________________


public final class com.ibm.icu4jni.text.NativeBreakIterator extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

static native int cloneImpl(
int)

static native void closeBreakIteratorImpl(
int)

static native int currentImpl(
int)

static native int firstImpl(
int)

static native int followingImpl(
int
int)

private static native int getAvailableLocalesCountImpl()

private static native java.lang.String getAvailableLocalesImpl(
int)

static java.lang.String[] getAvailableLocalesImpl()

static native int getCharacterInstanceImpl(
java.lang.String)

static native int getLineInstanceImpl(
java.lang.String)

static native int getSentenceInstanceImpl(
java.lang.String)

static native int getWordInstanceImpl(
java.lang.String)

static native boolean isBoundaryImpl(
int
int)

static native int lastImpl(
int)

static native int nextImpl(
int
int)

static native int precedingImpl(
int
int)

static native int previousImpl(
int)

static native void setTextImpl(
int
java.lang.String)

________________CLASS________________


public final class com.ibm.icu4jni.text.NativeCollation extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

static native void closeCollator(
int)

static native void closeElements(
int)

static native int compare(
int
java.lang.String
java.lang.String)

static native int getAttribute(
int
int)

private static native int getAvailableLocalesCountImpl()

private static native java.lang.String getAvailableLocalesImpl(
int)

static java.lang.String[] getAvailableLocalesImpl()

static native int getCollationElementIterator(
int
java.lang.String)

static native int getMaxExpansion(
int
int)

static native int getNormalization(
int)

static native int getOffset(
int)

static native java.lang.String getRules(
int)

static native byte[] getSortKey(
int
java.lang.String)

static native int hashCode(
int)

static native int next(
int)

static native int openCollator()

static native int openCollator(
java.lang.String)

static native int openCollatorFromRules(
java.lang.String
int
int)

static native int previous(
int)

static native void reset(
int)

static native int safeClone(
int)

static native void setAttribute(
int
int
int)

static native void setNormalization(
int
int)

static native void setOffset(
int
int)

static native void setText(
int
java.lang.String)

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Enum<TE;>;>Ljava/lang/Object;Ljava/io/Serializable;Ljava/lang/Comparable<TE;>; )
public abstract class java.lang.Enum extends java.lang.Object implements java.io.Serializable, java.lang.Comparable

----------------FIELDS----------------

private static final long serialVersionUID

private final java.lang.String name

private final int ordinal
----------------METHODS----------------

protected void <init>(
java.lang.String
int)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Enum<TT;>;>(Ljava/lang/Class<TT;>;)[TT; )
static java.lang.Enum[] getValues(
java.lang.Class)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Enum<TT;>;>(Ljava/lang/Class<TT;>;Ljava/lang/String;)TT; )
public static java.lang.Enum valueOf(
java.lang.Class
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/lang/CloneNotSupportedException; )
protected final java.lang.Object clone()
@dalvik.annotation.Signature (value =(TE;)I )
public final int compareTo(
java.lang.Enum)

public volatile int compareTo(
java.lang.Object)

public final boolean equals(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/lang/Class<TE;>; )
public final java.lang.Class getDeclaringClass()

public final int hashCode()

public final java.lang.String name()

public final int ordinal()

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Enum<Lcom/ibm/icu4jni/text/NativeDecimalFormat$UNumberFormatAttribute;>; )
@dalvik.annotation.InnerClass (accessFlags =16408 name =UNumberFormatAttribute )
@dalvik.annotation.EnclosingClass (value =Lcom/ibm/icu4jni/text/NativeDecimalFormat; )
final class com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatAttribute extends java.lang.Enum

----------------FIELDS----------------

private static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatAttribute[] $VALUES

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatAttribute UNUM_DECIMAL_ALWAYS_SHOWN

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatAttribute UNUM_FORMAT_WIDTH

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatAttribute UNUM_FRACTION_DIGITS

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatAttribute UNUM_GROUPING_SIZE

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatAttribute UNUM_GROUPING_USED

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatAttribute UNUM_INTEGER_DIGITS

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatAttribute UNUM_LENIENT_PARSE

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatAttribute UNUM_MAX_FRACTION_DIGITS

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatAttribute UNUM_MAX_INTEGER_DIGITS

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatAttribute UNUM_MAX_SIGNIFICANT_DIGITS

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatAttribute UNUM_MIN_FRACTION_DIGITS

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatAttribute UNUM_MIN_INTEGER_DIGITS

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatAttribute UNUM_MIN_SIGNIFICANT_DIGITS

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatAttribute UNUM_MULTIPLIER

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatAttribute UNUM_PADDING_POSITION

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatAttribute UNUM_PARSE_INT_ONLY

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatAttribute UNUM_ROUNDING_INCREMENT

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatAttribute UNUM_ROUNDING_MODE

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatAttribute UNUM_SECONDARY_GROUPING_SIZE

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatAttribute UNUM_SIGNIFICANT_DIGITS_USED
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Signature (value =()V )
private void <init>(
java.lang.String
int)

public static com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatAttribute valueOf(
java.lang.String)

public static com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatAttribute[] values()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =16408 name =UNumberFormatSymbol )
@dalvik.annotation.EnclosingClass (value =Lcom/ibm/icu4jni/text/NativeDecimalFormat; )
@dalvik.annotation.Signature (value =Ljava/lang/Enum<Lcom/ibm/icu4jni/text/NativeDecimalFormat$UNumberFormatSymbol;>; )
final class com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatSymbol extends java.lang.Enum

----------------FIELDS----------------

private static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatSymbol[] $VALUES

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatSymbol UNUM_CURRENCY_SYMBOL

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatSymbol UNUM_DECIMAL_SEPARATOR_SYMBOL

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatSymbol UNUM_DIGIT_SYMBOL

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatSymbol UNUM_EXPONENTIAL_SYMBOL

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatSymbol UNUM_FORMAT_SYMBOL_COUNT

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatSymbol UNUM_GROUPING_SEPARATOR_SYMBOL

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatSymbol UNUM_INFINITY_SYMBOL

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatSymbol UNUM_INTL_CURRENCY_SYMBOL

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatSymbol UNUM_MINUS_SIGN_SYMBOL

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatSymbol UNUM_MONETARY_GROUPING_SEPARATOR_SYMBOL

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatSymbol UNUM_MONETARY_SEPARATOR_SYMBOL

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatSymbol UNUM_NAN_SYMBOL

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatSymbol UNUM_PAD_ESCAPE_SYMBOL

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatSymbol UNUM_PATTERN_SEPARATOR_SYMBOL

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatSymbol UNUM_PERCENT_SYMBOL

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatSymbol UNUM_PERMILL_SYMBOL

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatSymbol UNUM_PLUS_SIGN_SYMBOL

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatSymbol UNUM_SIGNIFICANT_DIGIT_SYMBOL

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatSymbol UNUM_ZERO_DIGIT_SYMBOL
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Signature (value =()V )
private void <init>(
java.lang.String
int)

public static com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatSymbol valueOf(
java.lang.String)

public static com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatSymbol[] values()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =16408 name =UNumberFormatTextAttribute )
@dalvik.annotation.EnclosingClass (value =Lcom/ibm/icu4jni/text/NativeDecimalFormat; )
@dalvik.annotation.Signature (value =Ljava/lang/Enum<Lcom/ibm/icu4jni/text/NativeDecimalFormat$UNumberFormatTextAttribute;>; )
final class com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatTextAttribute extends java.lang.Enum

----------------FIELDS----------------

private static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatTextAttribute[] $VALUES

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatTextAttribute UNUM_CURRENCY_CODE

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatTextAttribute UNUM_DEFAULT_RULESET

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatTextAttribute UNUM_NEGATIVE_PREFIX

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatTextAttribute UNUM_NEGATIVE_SUFFIX

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatTextAttribute UNUM_PADDING_CHARACTER

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatTextAttribute UNUM_POSITIVE_PREFIX

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatTextAttribute UNUM_POSITIVE_SUFFIX

public static final com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatTextAttribute UNUM_PUBLIC_RULESETS
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Signature (value =()V )
private void <init>(
java.lang.String
int)

public static com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatTextAttribute valueOf(
java.lang.String)

public static com.ibm.icu4jni.text.NativeDecimalFormat$UNumberFormatTextAttribute[] values()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lcom/ibm/icu4jni/text/NativeDecimalFormat$UNumberFormatTextAttribute;Lcom/ibm/icu4jni/text/NativeDecimalFormat$UNumberFormatAttribute;Lcom/ibm/icu4jni/text/NativeDecimalFormat$UNumberFormatSymbol; )
public final class com.ibm.icu4jni.text.NativeDecimalFormat extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

static native void applyPatternImpl(
int
boolean
java.lang.String)

static native int cloneImpl(
int)

static native void closeDecimalFormatImpl(
int)

static native java.lang.String format(
int
double
java.text.FieldPosition
java.lang.String
java.lang.StringBuffer)

static native java.lang.String format(
int
long
java.text.FieldPosition
java.lang.String
java.lang.StringBuffer)

static native java.lang.String format(
int
java.lang.String
java.text.FieldPosition
java.lang.String
java.lang.StringBuffer
int)

static native int getAttribute(
int
int)

static native java.lang.String getSymbol(
int
int)

static native java.lang.String getTextAttribute(
int
int)

static native int openDecimalFormatImpl(
java.lang.String
java.lang.String)

static native java.lang.Number parse(
int
java.lang.String
java.text.ParsePosition)

static native void setAttribute(
int
int
int)

static native void setSymbol(
int
int
java.lang.String)

static native void setTextAttribute(
int
int
java.lang.String)

static native java.lang.String toPatternImpl(
int
boolean)

________________CLASS________________


public class com.ibm.icu4jni.text.RuleBasedBreakIterator extends com.ibm.icu4jni.text.BreakIterator

----------------FIELDS----------------

private int addr

private java.text.CharacterIterator charIter
----------------METHODS----------------

 void <init>(
int
int)

public java.lang.Object clone()

public int current()

public boolean equals(
java.lang.Object)

protected void finalize()

public int first()

public int following(
int)

public java.text.CharacterIterator getText()

public boolean isBoundary(
int)

public int last()

public int next()

public int next(
int)

public int preceding(
int)

public int previous()

public void setText(
java.text.CharacterIterator)

________________CLASS________________


public final class com.ibm.icu4jni.text.RuleBasedCollator extends com.ibm.icu4jni.text.Collator

----------------FIELDS----------------

private int m_collator_

private int m_hashcode_
----------------METHODS----------------

 void <init>()

private void <init>(
int)
@dalvik.annotation.Throws (value =Ljava/text/ParseException; )
public void <init>(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/text/ParseException; )
public void <init>(
java.lang.String
int)

public void <init>(
java.lang.String
int
int)

 void <init>(
java.util.Locale)

public java.lang.Object clone()

public int compare(
java.lang.String
java.lang.String)

public boolean equals(
java.lang.Object)

protected void finalize()

public int getAttribute(
int)

public com.ibm.icu4jni.text.CollationElementIterator getCollationElementIterator(
java.lang.String)

public com.ibm.icu4jni.text.CollationElementIterator getCollationElementIterator(
java.text.CharacterIterator)

public com.ibm.icu4jni.text.CollationKey getCollationKey(
java.lang.String)

public int getDecomposition()

public java.lang.String getRules()

public byte[] getSortKey(
java.lang.String)

public int getStrength()

public int hashCode()

public void setAttribute(
int
int)

public void setDecomposition(
int)

public void setStrength(
int)

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Enum<Lcom/ibm/icu4jni/text/RuleBasedNumberFormat$RBNFType;>; )
@dalvik.annotation.EnclosingClass (value =Lcom/ibm/icu4jni/text/RuleBasedNumberFormat; )
@dalvik.annotation.InnerClass (accessFlags =16409 name =RBNFType )
public final class com.ibm.icu4jni.text.RuleBasedNumberFormat$RBNFType extends java.lang.Enum

----------------FIELDS----------------

private static final com.ibm.icu4jni.text.RuleBasedNumberFormat$RBNFType[] $VALUES

public static final com.ibm.icu4jni.text.RuleBasedNumberFormat$RBNFType DURATION

public static final com.ibm.icu4jni.text.RuleBasedNumberFormat$RBNFType ORDINAL

public static final com.ibm.icu4jni.text.RuleBasedNumberFormat$RBNFType SPELLOUT

 int type
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Signature (value =(I)V )
private void <init>(
java.lang.String
int
int)

public static com.ibm.icu4jni.text.RuleBasedNumberFormat$RBNFType valueOf(
java.lang.String)

public static com.ibm.icu4jni.text.RuleBasedNumberFormat$RBNFType[] values()

 int getType()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lcom/ibm/icu4jni/text/RuleBasedNumberFormat$RBNFType; )
public class com.ibm.icu4jni.text.RuleBasedNumberFormat extends java.text.NumberFormat

----------------FIELDS----------------

private int addr
----------------METHODS----------------

public void <init>()

private static native void closeRBNFImpl(
int)

private static native java.lang.String formatRBNFImpl(
int
double
java.text.FieldPosition
java.lang.String
java.lang.StringBuffer)

private static native java.lang.String formatRBNFImpl(
int
long
java.text.FieldPosition
java.lang.String
java.lang.StringBuffer)

private static java.lang.String getFieldType(
java.text.Format$Field)

private static native int openRBNFImpl(
int
java.lang.String)

private static native int openRBNFImpl(
java.lang.String
java.lang.String)

static native java.lang.Number parseRBNFImpl(
int
java.lang.String
java.text.ParsePosition
boolean)

public void close()

protected void finalize()

public java.lang.StringBuffer format(
double
java.lang.StringBuffer
java.text.FieldPosition)

public java.lang.StringBuffer format(
long
java.lang.StringBuffer
java.text.FieldPosition)

public void open(
com.ibm.icu4jni.text.RuleBasedNumberFormat$RBNFType)

public void open(
com.ibm.icu4jni.text.RuleBasedNumberFormat$RBNFType
java.util.Locale)

public void open(
java.lang.String)

public void open(
java.lang.String
java.util.Locale)

public java.lang.Number parse(
java.lang.String
java.text.ParsePosition)

public java.lang.Number parseLenient(
java.lang.String
java.text.ParsePosition)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =4104 name =null )
@dalvik.annotation.EnclosingClass (value =Lcom/ibm/icu4jni/util/Resources; )
 class com.ibm.icu4jni.util.Resources$1 extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/ResourceBundle$MissingBundle; )
public abstract class java.util.ResourceBundle extends java.lang.Object

----------------FIELDS----------------

private static final java.util.ResourceBundle MISSING

private static final java.util.ResourceBundle MISSINGBASE
@dalvik.annotation.Signature (value =Ljava/util/WeakHashMap<Ljava/lang/Object;Ljava/util/Hashtable<Ljava/lang/String;Ljava/util/ResourceBundle;>;>; )
private static final java.util.WeakHashMap cache

private java.util.Locale locale

protected java.util.ResourceBundle parent
----------------METHODS----------------

static void <clinit>()

public void <init>()
@dalvik.annotation.Throws (value =Ljava/util/MissingResourceException; )
public static final java.util.ResourceBundle getBundle(
java.lang.String)

public static final java.util.ResourceBundle getBundle(
java.lang.String
java.util.Locale)
@dalvik.annotation.Throws (value =Ljava/util/MissingResourceException; )
public static java.util.ResourceBundle getBundle(
java.lang.String
java.util.Locale
java.lang.ClassLoader)
@dalvik.annotation.Throws (value =Ljava/util/MissingResourceException; )
private static java.util.ResourceBundle getBundleImpl(
java.lang.String
java.util.Locale
java.lang.ClassLoader)

private static java.util.ResourceBundle handleGetBundle(
java.lang.String
java.lang.String
boolean
java.lang.ClassLoader)

private void setLocale(
java.lang.String)

private static java.lang.String strip(
java.lang.String)
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<Ljava/lang/String;>; )
public abstract java.util.Enumeration getKeys()

public java.util.Locale getLocale()

public final java.lang.Object getObject(
java.lang.String)

public final java.lang.String getString(
java.lang.String)

public final java.lang.String[] getStringArray(
java.lang.String)

protected abstract java.lang.Object handleGetObject(
java.lang.String)

protected void setParent(
java.util.ResourceBundle)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =26 name =Country )
@dalvik.annotation.EnclosingClass (value =Lcom/ibm/icu4jni/util/Resources; )
final class com.ibm.icu4jni.util.Resources$Country extends java.util.ResourceBundle

----------------FIELDS----------------

private java.lang.String locale
----------------METHODS----------------

public void <init>(
java.lang.String)
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<Ljava/lang/String;>; )
public java.util.Enumeration getKeys()

protected java.lang.Object handleGetObject(
java.lang.String)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =26 name =Currency )
@dalvik.annotation.EnclosingClass (value =Lcom/ibm/icu4jni/util/Resources; )
final class com.ibm.icu4jni.util.Resources$Currency extends java.util.ResourceBundle

----------------FIELDS----------------

private java.lang.String locale
----------------METHODS----------------

public void <init>(
java.lang.String)
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<Ljava/lang/String;>; )
public java.util.Enumeration getKeys()

protected java.lang.Object handleGetObject(
java.lang.String)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lcom/ibm/icu4jni/util/Resources; )
@dalvik.annotation.InnerClass (accessFlags =26 name =ISO3Countries )
final class com.ibm.icu4jni.util.Resources$ISO3Countries extends java.util.ResourceBundle

----------------FIELDS----------------
----------------METHODS----------------

private void <init>()

 void <init>(
com.ibm.icu4jni.util.Resources$1)
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<Ljava/lang/String;>; )
public java.util.Enumeration getKeys()

protected java.lang.Object handleGetObject(
java.lang.String)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lcom/ibm/icu4jni/util/Resources; )
@dalvik.annotation.InnerClass (accessFlags =26 name =ISO3Languages )
final class com.ibm.icu4jni.util.Resources$ISO3Languages extends java.util.ResourceBundle

----------------FIELDS----------------
----------------METHODS----------------

private void <init>()

 void <init>(
com.ibm.icu4jni.util.Resources$1)
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<Ljava/lang/String;>; )
public java.util.Enumeration getKeys()

protected java.lang.Object handleGetObject(
java.lang.String)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lcom/ibm/icu4jni/util/Resources; )
@dalvik.annotation.InnerClass (accessFlags =26 name =ISO4Currencies )
final class com.ibm.icu4jni.util.Resources$ISO4Currencies extends java.util.ResourceBundle

----------------FIELDS----------------
----------------METHODS----------------

private void <init>()

 void <init>(
com.ibm.icu4jni.util.Resources$1)
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<Ljava/lang/String;>; )
public java.util.Enumeration getKeys()

protected java.lang.Object handleGetObject(
java.lang.String)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lcom/ibm/icu4jni/util/Resources; )
@dalvik.annotation.InnerClass (accessFlags =26 name =ISO4CurrenciesToDigits )
final class com.ibm.icu4jni.util.Resources$ISO4CurrenciesToDigits extends java.util.ResourceBundle

----------------FIELDS----------------
----------------METHODS----------------

private void <init>()

 void <init>(
com.ibm.icu4jni.util.Resources$1)
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<Ljava/lang/String;>; )
public java.util.Enumeration getKeys()

protected java.lang.Object handleGetObject(
java.lang.String)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =26 name =Language )
@dalvik.annotation.EnclosingClass (value =Lcom/ibm/icu4jni/util/Resources; )
final class com.ibm.icu4jni.util.Resources$Language extends java.util.ResourceBundle

----------------FIELDS----------------

private java.lang.String locale
----------------METHODS----------------

public void <init>(
java.lang.String)
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<Ljava/lang/String;>; )
public java.util.Enumeration getKeys()

protected java.lang.Object handleGetObject(
java.lang.String)

________________CLASS________________


public abstract class java.util.ListResourceBundle extends java.util.ResourceBundle

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Hashtable<Ljava/lang/String;Ljava/lang/Object;>; )
 java.util.Hashtable table
----------------METHODS----------------

public void <init>()

private void initializeTable()

protected abstract java.lang.Object[][] getContents()
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<Ljava/lang/String;>; )
public java.util.Enumeration getKeys()

public final java.lang.Object handleGetObject(
java.lang.String)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =26 name =Locale )
@dalvik.annotation.EnclosingClass (value =Lcom/ibm/icu4jni/util/Resources; )
final class com.ibm.icu4jni.util.Resources$Locale extends java.util.ListResourceBundle

----------------FIELDS----------------

private java.lang.String locale
----------------METHODS----------------

public void <init>(
java.lang.String)

protected java.lang.Object[][] getContents()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lcom/ibm/icu4jni/util/Resources; )
@dalvik.annotation.InnerClass (accessFlags =26 name =Variant )
final class com.ibm.icu4jni.util.Resources$Variant extends java.util.ResourceBundle

----------------FIELDS----------------

private java.lang.String locale
----------------METHODS----------------

public void <init>(
java.lang.String)
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<Ljava/lang/String;>; )
public java.util.Enumeration getKeys()

protected java.lang.Object handleGetObject(
java.lang.String)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lcom/ibm/icu4jni/util/Resources$1;Lcom/ibm/icu4jni/util/Resources$Locale;Lcom/ibm/icu4jni/util/Resources$Variant;Lcom/ibm/icu4jni/util/Resources$Language;Lcom/ibm/icu4jni/util/Resources$Currency;Lcom/ibm/icu4jni/util/Resources$Country;Lcom/ibm/icu4jni/util/Resources$ISO4CurrenciesToDigits;Lcom/ibm/icu4jni/util/Resources$ISO4Currencies;Lcom/ibm/icu4jni/util/Resources$ISO3Languages;Lcom/ibm/icu4jni/util/Resources$ISO3Countries; )
public class com.ibm.icu4jni.util.Resources extends java.lang.Object

----------------FIELDS----------------

private static java.lang.String[] availableLocales

private static java.lang.String[] availableTimezones

private static java.lang.String[][] defaultTimezoneNames

private static final java.lang.String initialLocale

private static java.lang.String[] isoCountries

private static java.lang.String[] isoLanguages
----------------METHODS----------------

static void <clinit>()

public void <init>()

static java.lang.String access$1000(
java.lang.String
java.lang.String)

static java.lang.String access$1100(
java.lang.String
java.lang.String)

static java.lang.Object[][] access$1200(
java.lang.String
boolean)

static java.lang.String access$400(
java.lang.String)

static java.lang.String access$500(
java.lang.String)

static java.lang.String access$600(
java.lang.String)

static int access$700(
java.lang.String)

static java.lang.String access$800(
java.lang.String
java.lang.String)

static java.lang.String access$900(
java.lang.String
java.lang.String)

private static java.lang.String[][] createTimeZoneNamesFor(
java.lang.String)

public static java.lang.String[] getAvailableLocales()

private static native java.lang.String[] getAvailableLocalesNative()

private static native java.lang.Object[][] getContentImpl(
java.lang.String
boolean)

private static native java.lang.String getCurrencyCodeNative(
java.lang.String)

private static native java.lang.String getCurrencySymbolNative(
java.lang.String
java.lang.String)

private static java.lang.String getDefaultLocaleName()

private static native java.lang.String getDisplayCountryNative(
java.lang.String
java.lang.String)

private static native java.lang.String getDisplayLanguageNative(
java.lang.String
java.lang.String)

public static java.lang.String getDisplayTimeZone(
java.lang.String
boolean
int
java.lang.String)

private static native java.lang.String getDisplayTimeZoneNative(
java.lang.String
boolean
int
java.lang.String)

public static java.lang.String[][] getDisplayTimeZones(
java.lang.String)

private static native java.lang.String getDisplayVariantNative(
java.lang.String
java.lang.String)

private static native int getFractionDigitsNative(
java.lang.String)

private static native java.lang.String getISO3CountryNative(
java.lang.String)

private static native java.lang.String getISO3LanguageNative(
java.lang.String)

public static java.lang.String[] getISOCountries()

private static native java.lang.String[] getISOCountriesNative()

public static java.lang.String[] getISOLanguages()

private static native java.lang.String[] getISOLanguagesNative()

public static java.util.ResourceBundle getInstance(
java.lang.String
java.lang.String)

public static java.lang.String[] getKnownTimezones()

private static native void getTimeZonesNative(
java.lang.String[][]
java.lang.String)

________________CLASS________________


public abstract interface class java.lang.annotation.Annotation extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =()Ljava/lang/Class<+Ljava/lang/annotation/Annotation;>; )
public abstract java.lang.Class annotationType()

public abstract boolean equals(
java.lang.Object)

public abstract int hashCode()

public abstract java.lang.String toString()

________________CLASS________________

@java.lang.annotation.Retention (value =Ljava/lang/annotation/RetentionPolicy;!RUNTIME )
@java.lang.annotation.Target (value =Ljava/lang/annotation/ElementType;!ANNOTATION_TYPE )
abstract interface class dalvik.annotation.AnnotationDefault extends java.lang.Object implements java.lang.annotation.Annotation

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@java.lang.annotation.Retention (value =Ljava/lang/annotation/RetentionPolicy;!RUNTIME )
@java.lang.annotation.Target (value =Ljava/lang/annotation/ElementType;!ANNOTATION_TYPE )
abstract interface class dalvik.annotation.EnclosingClass extends java.lang.Object implements java.lang.annotation.Annotation

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@java.lang.annotation.Retention (value =Ljava/lang/annotation/RetentionPolicy;!RUNTIME )
@java.lang.annotation.Target (value =Ljava/lang/annotation/ElementType;!ANNOTATION_TYPE )
abstract interface class dalvik.annotation.EnclosingMethod extends java.lang.Object implements java.lang.annotation.Annotation

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@java.lang.annotation.Target (value =Ljava/lang/annotation/ElementType;!ANNOTATION_TYPE )
@java.lang.annotation.Retention (value =Ljava/lang/annotation/RetentionPolicy;!RUNTIME )
abstract interface class dalvik.annotation.InnerClass extends java.lang.Object implements java.lang.annotation.Annotation

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@java.lang.annotation.Target (value =Ljava/lang/annotation/ElementType;!ANNOTATION_TYPE )
@java.lang.annotation.Retention (value =Ljava/lang/annotation/RetentionPolicy;!RUNTIME )
abstract interface class dalvik.annotation.MemberClasses extends java.lang.Object implements java.lang.annotation.Annotation

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@java.lang.annotation.Target (value =Ljava/lang/annotation/ElementType;!ANNOTATION_TYPE )
@java.lang.annotation.Retention (value =Ljava/lang/annotation/RetentionPolicy;!RUNTIME )
abstract interface class dalvik.annotation.Signature extends java.lang.Object implements java.lang.annotation.Annotation

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@dalvik.annotation.AnnotationDefault (value =Ldalvik/annotation/TestInfo;:[level =Ldalvik/annotation/TestLevel;!PARTIAL, purpose =] )
@java.lang.annotation.Target (value =Ljava/lang/annotation/ElementType;!METHOD )
@java.lang.annotation.Retention (value =Ljava/lang/annotation/RetentionPolicy;!RUNTIME )
public abstract interface class dalvik.annotation.TestInfo extends java.lang.Object implements java.lang.annotation.Annotation

----------------FIELDS----------------
----------------METHODS----------------

public abstract dalvik.annotation.TestLevel level()

public abstract java.lang.String purpose()

public abstract dalvik.annotation.TestTarget[] targets()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Enum<Ldalvik/annotation/TestLevel;>; )
public final class dalvik.annotation.TestLevel extends java.lang.Enum

----------------FIELDS----------------

private static final dalvik.annotation.TestLevel[] $VALUES

public static final dalvik.annotation.TestLevel COMPLETE

public static final dalvik.annotation.TestLevel PARTIAL

public static final dalvik.annotation.TestLevel PARTIAL_OK

public static final dalvik.annotation.TestLevel TODO
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Signature (value =()V )
private void <init>(
java.lang.String
int)

public static dalvik.annotation.TestLevel valueOf(
java.lang.String)

public static dalvik.annotation.TestLevel[] values()

________________CLASS________________

@java.lang.annotation.Target (value =Ljava/lang/annotation/ElementType;!ANNOTATION_TYPE )
@dalvik.annotation.AnnotationDefault (value =Ldalvik/annotation/TestTarget;:[conceptName =, methodArgs =, methodName =] )
@java.lang.annotation.Retention (value =Ljava/lang/annotation/RetentionPolicy;!RUNTIME )
public abstract interface class dalvik.annotation.TestTarget extends java.lang.Object implements java.lang.annotation.Annotation

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.lang.String conceptName()
@dalvik.annotation.Signature (value =()[Ljava/lang/Class<*>; )
public abstract java.lang.Class[] methodArgs()

public abstract java.lang.String methodName()

________________CLASS________________

@java.lang.annotation.Target (value =Ljava/lang/annotation/ElementType;!TYPE )
@java.lang.annotation.Retention (value =Ljava/lang/annotation/RetentionPolicy;!RUNTIME )
public abstract interface class dalvik.annotation.TestTargetClass extends java.lang.Object implements java.lang.annotation.Annotation

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =()Ljava/lang/Class<*>; )
public abstract java.lang.Class value()

________________CLASS________________

@java.lang.annotation.Retention (value =Ljava/lang/annotation/RetentionPolicy;!RUNTIME )
@java.lang.annotation.Target (value =Ljava/lang/annotation/ElementType;!ANNOTATION_TYPE )
abstract interface class dalvik.annotation.Throws extends java.lang.Object implements java.lang.annotation.Annotation

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________


public abstract interface class dalvik.bytecode.Opcodes extends java.lang.Object

----------------FIELDS----------------

public static final int OP_ADD_DOUBLE

public static final int OP_ADD_DOUBLE_2ADDR

public static final int OP_ADD_FLOAT

public static final int OP_ADD_FLOAT_2ADDR

public static final int OP_ADD_INT

public static final int OP_ADD_INT_2ADDR

public static final int OP_ADD_INT_LIT16

public static final int OP_ADD_INT_LIT8

public static final int OP_ADD_LONG

public static final int OP_ADD_LONG_2ADDR

public static final int OP_AGET

public static final int OP_AGET_BOOLEAN

public static final int OP_AGET_BYTE

public static final int OP_AGET_CHAR

public static final int OP_AGET_OBJECT

public static final int OP_AGET_SHORT

public static final int OP_AGET_WIDE

public static final int OP_AND_INT

public static final int OP_AND_INT_2ADDR

public static final int OP_AND_INT_LIT16

public static final int OP_AND_INT_LIT8

public static final int OP_AND_LONG

public static final int OP_AND_LONG_2ADDR

public static final int OP_APUT

public static final int OP_APUT_BOOLEAN

public static final int OP_APUT_BYTE

public static final int OP_APUT_CHAR

public static final int OP_APUT_OBJECT

public static final int OP_APUT_SHORT

public static final int OP_APUT_WIDE

public static final int OP_ARRAY_LENGTH

public static final int OP_CHECK_CAST

public static final int OP_CMPG_DOUBLE

public static final int OP_CMPG_FLOAT

public static final int OP_CMPL_DOUBLE

public static final int OP_CMPL_FLOAT

public static final int OP_CMP_LONG

public static final int OP_CONST

public static final int OP_CONST_16

public static final int OP_CONST_4

public static final int OP_CONST_CLASS

public static final int OP_CONST_HIGH16

public static final int OP_CONST_STRING

public static final int OP_CONST_STRING_JUMBO

public static final int OP_CONST_WIDE

public static final int OP_CONST_WIDE_16

public static final int OP_CONST_WIDE_32

public static final int OP_CONST_WIDE_HIGH16

public static final int OP_DIV_DOUBLE

public static final int OP_DIV_DOUBLE_2ADDR

public static final int OP_DIV_FLOAT

public static final int OP_DIV_FLOAT_2ADDR

public static final int OP_DIV_INT

public static final int OP_DIV_INT_2ADDR

public static final int OP_DIV_INT_LIT16

public static final int OP_DIV_INT_LIT8

public static final int OP_DIV_LONG

public static final int OP_DIV_LONG_2ADDR

public static final int OP_DOUBLE_TO_FLOAT

public static final int OP_DOUBLE_TO_INT

public static final int OP_DOUBLE_TO_LONG

public static final int OP_EXECUTE_INLINE

public static final int OP_FILLED_NEW_ARRAY

public static final int OP_FILLED_NEW_ARRAY_RANGE

public static final int OP_FILL_ARRAY_DATA

public static final int OP_FLOAT_TO_DOUBLE

public static final int OP_FLOAT_TO_INT

public static final int OP_FLOAT_TO_LONG

public static final int OP_GOTO

public static final int OP_GOTO_16

public static final int OP_GOTO_32

public static final int OP_IF_EQ

public static final int OP_IF_EQZ

public static final int OP_IF_GE

public static final int OP_IF_GEZ

public static final int OP_IF_GT

public static final int OP_IF_GTZ

public static final int OP_IF_LE

public static final int OP_IF_LEZ

public static final int OP_IF_LT

public static final int OP_IF_LTZ

public static final int OP_IF_NE

public static final int OP_IF_NEZ

public static final int OP_IGET

public static final int OP_IGET_BOOLEAN

public static final int OP_IGET_BYTE

public static final int OP_IGET_CHAR

public static final int OP_IGET_OBJECT

public static final int OP_IGET_OBJECT_QUICK

public static final int OP_IGET_QUICK

public static final int OP_IGET_SHORT

public static final int OP_IGET_WIDE

public static final int OP_IGET_WIDE_QUICK

public static final int OP_INSTANCE_OF

public static final int OP_INT_TO_BYTE

public static final int OP_INT_TO_CHAR

public static final int OP_INT_TO_DOUBLE

public static final int OP_INT_TO_FLOAT

public static final int OP_INT_TO_LONG

public static final int OP_INT_TO_SHORT

public static final int OP_INVOKE_DIRECT

public static final int OP_INVOKE_DIRECT_EMPTY

public static final int OP_INVOKE_DIRECT_RANGE

public static final int OP_INVOKE_INTERFACE

public static final int OP_INVOKE_INTERFACE_RANGE

public static final int OP_INVOKE_STATIC

public static final int OP_INVOKE_STATIC_RANGE

public static final int OP_INVOKE_SUPER

public static final int OP_INVOKE_SUPER_QUICK

public static final int OP_INVOKE_SUPER_QUICK_RANGE

public static final int OP_INVOKE_SUPER_RANGE

public static final int OP_INVOKE_VIRTUAL

public static final int OP_INVOKE_VIRTUAL_QUICK

public static final int OP_INVOKE_VIRTUAL_QUICK_RANGE

public static final int OP_INVOKE_VIRTUAL_RANGE

public static final int OP_IPUT

public static final int OP_IPUT_BOOLEAN

public static final int OP_IPUT_BYTE

public static final int OP_IPUT_CHAR

public static final int OP_IPUT_OBJECT

public static final int OP_IPUT_OBJECT_QUICK

public static final int OP_IPUT_QUICK

public static final int OP_IPUT_SHORT

public static final int OP_IPUT_WIDE

public static final int OP_IPUT_WIDE_QUICK

public static final int OP_LONG_TO_DOUBLE

public static final int OP_LONG_TO_FLOAT

public static final int OP_LONG_TO_INT

public static final int OP_MONITOR_ENTER

public static final int OP_MONITOR_EXIT

public static final int OP_MOVE

public static final int OP_MOVE_16

public static final int OP_MOVE_EXCEPTION

public static final int OP_MOVE_FROM16

public static final int OP_MOVE_OBJECT

public static final int OP_MOVE_OBJECT_16

public static final int OP_MOVE_OBJECT_FROM16

public static final int OP_MOVE_RESULT

public static final int OP_MOVE_RESULT_OBJECT

public static final int OP_MOVE_RESULT_WIDE

public static final int OP_MOVE_WIDE

public static final int OP_MOVE_WIDE_16

public static final int OP_MOVE_WIDE_FROM16

public static final int OP_MUL_DOUBLE

public static final int OP_MUL_DOUBLE_2ADDR

public static final int OP_MUL_FLOAT

public static final int OP_MUL_FLOAT_2ADDR

public static final int OP_MUL_INT

public static final int OP_MUL_INT_2ADDR

public static final int OP_MUL_INT_LIT16

public static final int OP_MUL_INT_LIT8

public static final int OP_MUL_LONG

public static final int OP_MUL_LONG_2ADDR

public static final int OP_NEG_DOUBLE

public static final int OP_NEG_FLOAT

public static final int OP_NEG_INT

public static final int OP_NEG_LONG

public static final int OP_NEW_ARRAY

public static final int OP_NEW_INSTANCE

public static final int OP_NOP

public static final int OP_NOT_INT

public static final int OP_NOT_LONG

public static final int OP_OR_INT

public static final int OP_OR_INT_2ADDR

public static final int OP_OR_INT_LIT16

public static final int OP_OR_INT_LIT8

public static final int OP_OR_LONG

public static final int OP_OR_LONG_2ADDR

public static final int OP_PACKED_SWITCH

public static final int OP_REM_DOUBLE

public static final int OP_REM_DOUBLE_2ADDR

public static final int OP_REM_FLOAT

public static final int OP_REM_FLOAT_2ADDR

public static final int OP_REM_INT

public static final int OP_REM_INT_2ADDR

public static final int OP_REM_INT_LIT16

public static final int OP_REM_INT_LIT8

public static final int OP_REM_LONG

public static final int OP_REM_LONG_2ADDR

public static final int OP_RETURN

public static final int OP_RETURN_OBJECT

public static final int OP_RETURN_VOID

public static final int OP_RETURN_WIDE

public static final int OP_RSUB_INT

public static final int OP_RSUB_INT_LIT8

public static final int OP_SGET

public static final int OP_SGET_BOOLEAN

public static final int OP_SGET_BYTE

public static final int OP_SGET_CHAR

public static final int OP_SGET_OBJECT

public static final int OP_SGET_SHORT

public static final int OP_SGET_WIDE

public static final int OP_SHL_INT

public static final int OP_SHL_INT_2ADDR

public static final int OP_SHL_INT_LIT8

public static final int OP_SHL_LONG

public static final int OP_SHL_LONG_2ADDR

public static final int OP_SHR_INT

public static final int OP_SHR_INT_2ADDR

public static final int OP_SHR_INT_LIT8

public static final int OP_SHR_LONG

public static final int OP_SHR_LONG_2ADDR

public static final int OP_SPARSE_SWITCH

public static final int OP_SPUT

public static final int OP_SPUT_BOOLEAN

public static final int OP_SPUT_BYTE

public static final int OP_SPUT_CHAR

public static final int OP_SPUT_OBJECT

public static final int OP_SPUT_SHORT

public static final int OP_SPUT_WIDE

public static final int OP_SUB_DOUBLE

public static final int OP_SUB_DOUBLE_2ADDR

public static final int OP_SUB_FLOAT

public static final int OP_SUB_FLOAT_2ADDR

public static final int OP_SUB_INT

public static final int OP_SUB_INT_2ADDR

public static final int OP_SUB_LONG

public static final int OP_SUB_LONG_2ADDR

public static final int OP_THROW

public static final int OP_UNUSED_3e

public static final int OP_UNUSED_3f

public static final int OP_UNUSED_40

public static final int OP_UNUSED_41

public static final int OP_UNUSED_42

public static final int OP_UNUSED_43

public static final int OP_UNUSED_73

public static final int OP_UNUSED_79

public static final int OP_UNUSED_7A

public static final int OP_UNUSED_E3

public static final int OP_UNUSED_E4

public static final int OP_UNUSED_E5

public static final int OP_UNUSED_E6

public static final int OP_UNUSED_E7

public static final int OP_UNUSED_E8

public static final int OP_UNUSED_E9

public static final int OP_UNUSED_EA

public static final int OP_UNUSED_EB

public static final int OP_UNUSED_EC

public static final int OP_UNUSED_ED

public static final int OP_UNUSED_EF

public static final int OP_UNUSED_F1

public static final int OP_UNUSED_FC

public static final int OP_UNUSED_FD

public static final int OP_UNUSED_FE

public static final int OP_UNUSED_FF

public static final int OP_USHR_INT

public static final int OP_USHR_INT_2ADDR

public static final int OP_USHR_INT_LIT8

public static final int OP_USHR_LONG

public static final int OP_USHR_LONG_2ADDR

public static final int OP_XOR_INT

public static final int OP_XOR_INT_2ADDR

public static final int OP_XOR_INT_LIT16

public static final int OP_XOR_INT_LIT8

public static final int OP_XOR_LONG

public static final int OP_XOR_LONG_2ADDR
----------------METHODS----------------

________________CLASS________________


public class java.lang.Error extends java.lang.Throwable

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.Throwable)

public void <init>(
java.lang.Throwable)

________________CLASS________________


public abstract class java.lang.VirtualMachineError extends java.lang.Error

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class dalvik.system.AllocationLimitError extends java.lang.VirtualMachineError

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/lang/Object; )
public abstract interface class java.util.Enumeration extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract boolean hasMoreElements()
@dalvik.annotation.Signature (value =()TE; )
public abstract java.lang.Object nextElement()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ldalvik/system/DexFile; )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Enumeration<Ljava/lang/String;>; )
@dalvik.annotation.InnerClass (accessFlags =2 name =DFEnum )
 class dalvik.system.DexFile$DFEnum extends java.lang.Object implements java.util.Enumeration

----------------FIELDS----------------

private int mIndex

private java.lang.String[] mNameList

final dalvik.system.DexFile this$0
----------------METHODS----------------

 void <init>(
dalvik.system.DexFile
dalvik.system.DexFile)

public boolean hasMoreElements()

public volatile java.lang.Object nextElement()

public java.lang.String nextElement()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ldalvik/system/DexFile$DFEnum; )
public final class dalvik.system.DexFile extends java.lang.Object

----------------FIELDS----------------

private final int mCookie

private java.lang.String mFileName
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.io.File)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.lang.String)

static int access$000(
dalvik.system.DexFile)

static java.lang.String[] access$100(
int)

private static native void closeDexFile(
int)

private static native java.lang.Class defineClass(
java.lang.String
java.lang.ClassLoader
int
java.security.ProtectionDomain)

private static native java.lang.String[] getClassNameList(
int)
@dalvik.annotation.Throws (value =Ljava/io/FileNotFoundException;Ljava/io/IOException; )
public static native boolean isDexOptNeeded(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private static native int openDexFile(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<Ljava/lang/String;>; )
public java.util.Enumeration entries()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void finalize()

public java.lang.String getName()

public java.lang.Class loadClass(
java.lang.String
java.lang.ClassLoader)

________________CLASS________________


public abstract interface class java.lang.Runnable extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract void run()

________________CLASS________________


 class dalvik.system.NativeStart extends java.lang.Object implements java.lang.Runnable

----------------FIELDS----------------
----------------METHODS----------------

private void <init>()

private static native void main(
java.lang.String[])

public native void run()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/lang/ClassLoader$SystemClassLoader; )
public abstract class java.lang.ClassLoader extends java.lang.Object

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Map<Ljava/lang/String;Ljava/lang/Package;>; )
private java.util.Map packages

private java.lang.ClassLoader parent
----------------METHODS----------------

protected void <init>()

protected void <init>(
java.lang.ClassLoader)

static java.lang.ClassLoader access$000()

static java.lang.ClassLoader callerClassLoader()

private static java.lang.ClassLoader createSystemClassLoader()

static java.lang.Package getPackage(
java.lang.ClassLoader
java.lang.String)

static final java.lang.ClassLoader getStackClassLoader(
int)

public static java.lang.ClassLoader getSystemClassLoader()

public static java.net.URL getSystemResource(
java.lang.String)

public static java.io.InputStream getSystemResourceAsStream(
java.lang.String)
@dalvik.annotation.Signature (value =(Ljava/lang/String;)Ljava/util/Enumeration<Ljava/net/URL;>; )
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static java.util.Enumeration getSystemResources(
java.lang.String)

static void loadLibraryWithClassLoader(
java.lang.String
java.lang.ClassLoader)

static void loadLibraryWithPath(
java.lang.String
java.lang.ClassLoader
java.lang.String)

public void clearAssertionStatus()
@dalvik.annotation.Throws (value =Ljava/lang/ClassFormatError; )
@dalvik.annotation.Signature (value =(Ljava/lang/String;Ljava/nio/ByteBuffer;Ljava/security/ProtectionDomain;)Ljava/lang/Class<*>; )
protected final java.lang.Class defineClass(
java.lang.String
java.nio.ByteBuffer
java.security.ProtectionDomain)
@dalvik.annotation.Throws (value =Ljava/lang/ClassFormatError; )
@dalvik.annotation.Signature (value =(Ljava/lang/String;[BII)Ljava/lang/Class<*>; )
protected final java.lang.Class defineClass(
java.lang.String
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/lang/ClassFormatError; )
@dalvik.annotation.Signature (value =(Ljava/lang/String;[BIILjava/security/ProtectionDomain;)Ljava/lang/Class<*>; )
protected final java.lang.Class defineClass(
java.lang.String
byte[]
int
int
java.security.ProtectionDomain)
@dalvik.annotation.Throws (value =Ljava/lang/ClassFormatError; )
@dalvik.annotation.Signature (value =([BII)Ljava/lang/Class<*>; )
@java.lang.Deprecated
protected final java.lang.Class defineClass(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
protected java.lang.Package definePackage(
java.lang.String
java.lang.String
java.lang.String
java.lang.String
java.lang.String
java.lang.String
java.lang.String
java.net.URL)
@dalvik.annotation.Signature (value =(Ljava/lang/String;)Ljava/lang/Class<*>; )
@dalvik.annotation.Throws (value =Ljava/lang/ClassNotFoundException; )
protected java.lang.Class findClass(
java.lang.String)

protected java.lang.String findLibrary(
java.lang.String)
@dalvik.annotation.Signature (value =(Ljava/lang/String;)Ljava/lang/Class<*>; )
protected final java.lang.Class findLoadedClass(
java.lang.String)

protected java.net.URL findResource(
java.lang.String)
@dalvik.annotation.Signature (value =(Ljava/lang/String;)Ljava/util/Enumeration<Ljava/net/URL;>; )
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected java.util.Enumeration findResources(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/lang/ClassNotFoundException; )
@dalvik.annotation.Signature (value =(Ljava/lang/String;)Ljava/lang/Class<*>; )
protected final java.lang.Class findSystemClass(
java.lang.String)

 boolean getClassAssertionStatus(
java.lang.String)

 boolean getDefaultAssertionStatus()

protected java.lang.Package getPackage(
java.lang.String)

 boolean getPackageAssertionStatus(
java.lang.String)

protected java.lang.Package[] getPackages()

public final java.lang.ClassLoader getParent()

public java.net.URL getResource(
java.lang.String)

public java.io.InputStream getResourceAsStream(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
@dalvik.annotation.Signature (value =(Ljava/lang/String;)Ljava/util/Enumeration<Ljava/net/URL;>; )
public java.util.Enumeration getResources(
java.lang.String)
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;)[Ljava/lang/Object; )
final java.lang.Object[] getSigners(
java.lang.Class)

final boolean isAncestorOf(
java.lang.ClassLoader)

final boolean isSystemClassLoader()
@dalvik.annotation.Signature (value =(Ljava/lang/String;)Ljava/lang/Class<*>; )
@dalvik.annotation.Throws (value =Ljava/lang/ClassNotFoundException; )
public java.lang.Class loadClass(
java.lang.String)
@dalvik.annotation.Signature (value =(Ljava/lang/String;Z)Ljava/lang/Class<*>; )
@dalvik.annotation.Throws (value =Ljava/lang/ClassNotFoundException; )
protected java.lang.Class loadClass(
java.lang.String
boolean)
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;)V )
protected final void resolveClass(
java.lang.Class)

public void setClassAssertionStatus(
java.lang.String
boolean)

public void setDefaultAssertionStatus(
boolean)

public void setPackageAssertionStatus(
java.lang.String
boolean)
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;[Ljava/lang/Object;)V )
protected final void setSigners(
java.lang.Class
java.lang.Object[])

________________CLASS________________


public class dalvik.system.PathClassLoader extends java.lang.ClassLoader

----------------FIELDS----------------

private boolean initialized

private final java.lang.String libPath

private dalvik.system.DexFile[] mDexs

private java.io.File[] mFiles

private java.lang.String[] mLibPaths

private java.lang.String[] mPaths

private java.util.zip.ZipFile[] mZips

private final java.lang.String path
----------------METHODS----------------

public void <init>(
java.lang.String
java.lang.ClassLoader)

public void <init>(
java.lang.String
java.lang.String
java.lang.ClassLoader)

private void ensureInit()

private boolean isInArchive(
java.util.zip.ZipFile
java.lang.String)

private byte[] loadFromArchive(
java.util.zip.ZipFile
java.lang.String)

private byte[] loadFromDirectory(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/lang/ClassNotFoundException; )
@dalvik.annotation.Signature (value =(Ljava/lang/String;)Ljava/lang/Class<*>; )
protected java.lang.Class findClass(
java.lang.String)

protected java.lang.String findLibrary(
java.lang.String)

protected java.net.URL findResource(
java.lang.String)

protected java.lang.Package getPackage(
java.lang.String)

________________CLASS________________


public class dalvik.system.PotentialDeadlockError extends java.lang.VirtualMachineError

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class dalvik.system.StaleDexCacheError extends java.lang.VirtualMachineError

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class dalvik.system.TemporaryDirectory extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.String PATH_NAME

private static final java.lang.String PROPERTY

private static boolean configured
----------------METHODS----------------

static void <clinit>()

public void <init>()

public static void setUpDirectory(
java.io.File)

public static void setUpDirectory(
java.lang.String)

________________CLASS________________


public abstract interface class java.io.FilenameFilter extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract boolean accept(
java.io.File
java.lang.String)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
final class dalvik.system.TouchDex$1 extends java.lang.Object implements java.io.FilenameFilter

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public boolean accept(
java.io.File
java.lang.String)

________________CLASS________________


public class dalvik.system.TouchDex extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

private static java.lang.String expandDirectories(
java.lang.String)

public static void main(
java.lang.String[])

private static void prepFiles(
java.lang.String)

public static int start(
java.lang.String)

private static native int trampoline(
java.lang.String
java.lang.String)

________________CLASS________________


 class dalvik.system.TouchDexLoader extends java.lang.ClassLoader

----------------FIELDS----------------

private boolean initialized

private dalvik.system.DexFile[] mDexs

private java.io.File[] mFiles

private java.lang.String[] mLibPaths

private java.lang.String[] mPaths

private java.util.zip.ZipFile[] mZips

private java.lang.String path
----------------METHODS----------------

public void <init>(
java.lang.String
java.lang.ClassLoader)

private void ensureInit()

private boolean isInArchive(
java.util.zip.ZipFile
java.lang.String)

private byte[] loadFromArchive(
java.util.zip.ZipFile
java.lang.String)

private byte[] loadFromDirectory(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/lang/ClassNotFoundException; )
@dalvik.annotation.Signature (value =(Ljava/lang/String;)Ljava/lang/Class<*>; )
protected java.lang.Class findClass(
java.lang.String)

protected java.lang.String findLibrary(
java.lang.String)

protected java.net.URL findResource(
java.lang.String)

________________CLASS________________


public final class dalvik.system.VMDebug extends java.lang.Object

----------------FIELDS----------------

public static final java.lang.String DEFAULT_METHOD_TRACE_FILE_NAME

private static final int KIND_ALLOCATED_BYTES

private static final int KIND_ALLOCATED_OBJECTS

public static final int KIND_ALL_COUNTS

private static final int KIND_EXT_ALLOCATED_BYTES

private static final int KIND_EXT_ALLOCATED_OBJECTS

private static final int KIND_EXT_FREED_BYTES

private static final int KIND_EXT_FREED_OBJECTS

private static final int KIND_FREED_BYTES

private static final int KIND_FREED_OBJECTS

private static final int KIND_GC_INVOCATIONS

public static final int KIND_GLOBAL_ALLOCATED_BYTES

public static final int KIND_GLOBAL_ALLOCATED_OBJECTS

public static final int KIND_GLOBAL_EXT_ALLOCATED_BYTES

public static final int KIND_GLOBAL_EXT_ALLOCATED_OBJECTS

public static final int KIND_GLOBAL_EXT_FREED_BYTES

public static final int KIND_GLOBAL_EXT_FREED_OBJECTS

public static final int KIND_GLOBAL_FREED_BYTES

public static final int KIND_GLOBAL_FREED_OBJECTS

public static final int KIND_GLOBAL_GC_INVOCATIONS

public static final int KIND_THREAD_ALLOCATED_BYTES

public static final int KIND_THREAD_ALLOCATED_OBJECTS

public static final int KIND_THREAD_EXT_ALLOCATED_BYTES

public static final int KIND_THREAD_EXT_ALLOCATED_OBJECTS

public static final int KIND_THREAD_EXT_FREED_BYTES

public static final int KIND_THREAD_EXT_FREED_OBJECTS

public static final int KIND_THREAD_FREED_BYTES

public static final int KIND_THREAD_FREED_OBJECTS

public static final int KIND_THREAD_GC_INVOCATIONS

public static final int TRACE_COUNT_ALLOCS
----------------METHODS----------------

private void <init>()

public static native int getAllocCount(
int)

public static native void getInstructionCount(
int[])

public static native int getLoadedClassCount()

public static native boolean isDebuggerConnected()

public static native long lastDebuggerActivity()

public static native void printLoadedClasses(
int)

static native void printThis(
java.lang.Object
int
int)

public static native void resetAllocCount(
int)

public static native void resetInstructionCount()

public static native int setAllocationLimit(
int)

public static native int setGlobalAllocationLimit(
int)

public static native void startAllocCounting()

private static void startClassPrep()

public static native void startEmulatorTracing()

private static void startGC()

public static native void startInstructionCounting()

public static void startMethodTracing()

public static native void startMethodTracing(
java.lang.String
int
int)

public static native void stopAllocCounting()

public static native void stopEmulatorTracing()

public static native void stopInstructionCounting()

public static native void stopMethodTracing()

public static native long threadCpuTimeNanos()

________________CLASS________________


public final class dalvik.system.VMRuntime extends java.lang.Object

----------------FIELDS----------------

private static final dalvik.system.VMRuntime THE_ONE
----------------METHODS----------------

static void <clinit>()

private void <init>()

public static dalvik.system.VMRuntime getRuntime()

private native long nativeMinimumHeapSize(
long
boolean)

private native void nativeSetTargetHeapUtilization(
float)

public native void gcSoftReferences()

public native long getExternalBytesAllocated()

public long getMinimumHeapSize()

public native float getTargetHeapUtilization()

public native void runFinalizationSync()

public long setMinimumHeapSize(
long)

public float setTargetHeapUtilization(
float)

public native boolean trackExternalAllocation(
long)

public native void trackExternalFree(
long)

________________CLASS________________


public final class dalvik.system.VMStack extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public static native java.lang.ClassLoader getCallingClassLoader()

public static native java.lang.ClassLoader getCallingClassLoader2()
@dalvik.annotation.Signature (value =(IZ)[Ljava/lang/Class<*>; )
public static native java.lang.Class[] getClasses(
int
boolean)

public static native java.lang.StackTraceElement[] getThreadStackTrace(
java.lang.Thread)

________________CLASS________________


public class dalvik.system.Zygote extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

private void <init>()

public static native int fork()

public static native int forkAndSpecialize(
int
int
int[]
boolean
int[][])

public static native int forkSystemServer(
int
int
int[]
boolean
int[][])

________________CLASS________________


public final class java.awt.font.NumericShaper extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------

public static final int ALL_RANGES

public static final int ARABIC

public static final int BENGALI

public static final int DEVANAGARI

public static final int EASTERN_ARABIC

public static final int ETHIOPIC

public static final int EUROPEAN

public static final int GUJARATI

public static final int GURMUKHI

private static final int INDEX_ARABIC

private static final int INDEX_BENGALI

private static final int INDEX_DEVANAGARI

private static final int INDEX_EASTERN_ARABIC

private static final int INDEX_ETHIOPIC

private static final int INDEX_EUROPEAN

private static final int INDEX_GUJARATI

private static final int INDEX_GURMUKHI

private static final int INDEX_KANNADA

private static final int INDEX_KHMER

private static final int INDEX_LAO

private static final int INDEX_MALAYALAM

private static final int INDEX_MONGOLIAN

private static final int INDEX_MYANMAR

private static final int INDEX_ORIYA

private static final int INDEX_TAMIL

private static final int INDEX_TELUGU

private static final int INDEX_THAI

private static final int INDEX_TIBETAN

public static final int KANNADA

public static final int KHMER

public static final int LAO

public static final int MALAYALAM

private static final int MAX_INDEX

public static final int MONGOLIAN

public static final int MYANMAR

public static final int ORIYA

private static final int[] STRONG_TEXT_FLAGS

public static final int TAMIL

public static final int TELUGU

public static final int THAI

public static final int TIBETAN

private static final long serialVersionUID

private final java.lang.String[] contexts

private final int[] digitsLowRanges

private boolean fContextual

private int fDefaultContextIndex

private int fRanges

private int fSingleRangeIndex

private int key

private int mask

private final int[] scriptsRanges
----------------METHODS----------------

static void <clinit>()

private void <init>(
int
int
boolean)

private void contextualShape(
char[]
int
int
int)

private int getCharIndex(
char)

public static java.awt.font.NumericShaper getContextualShaper(
int)

public static java.awt.font.NumericShaper getContextualShaper(
int
int)

private int getIndexFromRange(
int)

private int getRangeFromIndex(
int)

public static java.awt.font.NumericShaper getShaper(
int)

private boolean isCharStrong(
int)

private void nonContextualShape(
char[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)

private static void throwRange(
int)

private void updateKeyMaskFields()

private void updateRangesFields()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

public boolean equals(
java.lang.Object)

public int getRanges()

public int hashCode()

public boolean isContextual()

public void shape(
char[]
int
int)

public void shape(
char[]
int
int
int)

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/text/AttributedCharacterIterator; )
@dalvik.annotation.InnerClass (accessFlags =9 name =Attribute )
public class java.text.AttributedCharacterIterator$Attribute extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------

public static final java.text.AttributedCharacterIterator$Attribute INPUT_METHOD_SEGMENT

public static final java.text.AttributedCharacterIterator$Attribute LANGUAGE

public static final java.text.AttributedCharacterIterator$Attribute READING

private static final long serialVersionUID

private java.lang.String name
----------------METHODS----------------

static void <clinit>()

protected void <init>(
java.lang.String)

public final boolean equals(
java.lang.Object)

protected java.lang.String getName()

public final int hashCode()
@dalvik.annotation.Throws (value =Ljava/io/InvalidObjectException; )
protected java.lang.Object readResolve()

public java.lang.String toString()

________________CLASS________________


public final class java.awt.font.TextAttribute extends java.text.AttributedCharacterIterator$Attribute

----------------FIELDS----------------

public static final java.awt.font.TextAttribute BACKGROUND

public static final java.awt.font.TextAttribute BIDI_EMBEDDING

public static final java.awt.font.TextAttribute CHAR_REPLACEMENT

public static final java.awt.font.TextAttribute FAMILY

public static final java.awt.font.TextAttribute FONT

public static final java.awt.font.TextAttribute FOREGROUND

public static final java.awt.font.TextAttribute INPUT_METHOD_HIGHLIGHT

public static final java.awt.font.TextAttribute INPUT_METHOD_UNDERLINE

public static final java.awt.font.TextAttribute JUSTIFICATION

public static final java.lang.Float JUSTIFICATION_FULL

public static final java.lang.Float JUSTIFICATION_NONE

public static final java.awt.font.TextAttribute NUMERIC_SHAPING

public static final java.awt.font.TextAttribute POSTURE

public static final java.lang.Float POSTURE_OBLIQUE

public static final java.lang.Float POSTURE_REGULAR

public static final java.awt.font.TextAttribute RUN_DIRECTION

public static final java.lang.Boolean RUN_DIRECTION_LTR

public static final java.lang.Boolean RUN_DIRECTION_RTL

public static final java.awt.font.TextAttribute SIZE

public static final java.awt.font.TextAttribute STRIKETHROUGH

public static final java.lang.Boolean STRIKETHROUGH_ON

public static final java.awt.font.TextAttribute SUPERSCRIPT

public static final java.lang.Integer SUPERSCRIPT_SUB

public static final java.lang.Integer SUPERSCRIPT_SUPER

public static final java.awt.font.TextAttribute SWAP_COLORS

public static final java.lang.Boolean SWAP_COLORS_ON

public static final java.awt.font.TextAttribute TRANSFORM

public static final java.awt.font.TextAttribute UNDERLINE

public static final java.lang.Integer UNDERLINE_LOW_DASHED

public static final java.lang.Integer UNDERLINE_LOW_DOTTED

public static final java.lang.Integer UNDERLINE_LOW_GRAY

public static final java.lang.Integer UNDERLINE_LOW_ONE_PIXEL

public static final java.lang.Integer UNDERLINE_LOW_TWO_PIXEL

public static final java.lang.Integer UNDERLINE_ON

public static final java.awt.font.TextAttribute WEIGHT

public static final java.lang.Float WEIGHT_BOLD

public static final java.lang.Float WEIGHT_DEMIBOLD

public static final java.lang.Float WEIGHT_DEMILIGHT

public static final java.lang.Float WEIGHT_EXTRABOLD

public static final java.lang.Float WEIGHT_EXTRA_LIGHT

public static final java.lang.Float WEIGHT_HEAVY

public static final java.lang.Float WEIGHT_LIGHT

public static final java.lang.Float WEIGHT_MEDIUM

public static final java.lang.Float WEIGHT_REGULAR

public static final java.lang.Float WEIGHT_SEMIBOLD

public static final java.lang.Float WEIGHT_ULTRABOLD

public static final java.awt.font.TextAttribute WIDTH

public static final java.lang.Float WIDTH_CONDENSED

public static final java.lang.Float WIDTH_EXTENDED

public static final java.lang.Float WIDTH_REGULAR

public static final java.lang.Float WIDTH_SEMI_CONDENSED

public static final java.lang.Float WIDTH_SEMI_EXTENDED
@dalvik.annotation.Signature (value =Ljava/util/Map<Ljava/lang/String;Ljava/awt/font/TextAttribute;>; )
private static final java.util.Map attrMap

private static final long serialVersionUID
----------------METHODS----------------

static void <clinit>()

protected void <init>(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/InvalidObjectException; )
protected java.lang.Object readResolve()

________________CLASS________________


public class java.io.FilterInputStream extends java.io.InputStream

----------------FIELDS----------------

protected volatile java.io.InputStream in
----------------METHODS----------------

protected void <init>(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int available()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()

public void mark(
int)

public boolean markSupported()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void reset()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long skip(
long)

________________CLASS________________


public class java.io.BufferedInputStream extends java.io.FilterInputStream

----------------FIELDS----------------

protected volatile byte[] buf

private boolean closed

protected int count

protected int marklimit

protected int markpos

protected int pos
----------------METHODS----------------

public void <init>(
java.io.InputStream)

public void <init>(
java.io.InputStream
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private int fillbuf()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int available()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()

public void mark(
int)

public boolean markSupported()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void reset()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long skip(
long)

________________CLASS________________


public class java.io.FilterOutputStream extends java.io.OutputStream

----------------FIELDS----------------

protected java.io.OutputStream out
----------------METHODS----------------

public void <init>(
java.io.OutputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void flush()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
byte[]
int
int)

________________CLASS________________


public class java.io.BufferedOutputStream extends java.io.FilterOutputStream

----------------FIELDS----------------

protected byte[] buf

protected int count
----------------METHODS----------------

public void <init>(
java.io.OutputStream)

public void <init>(
java.io.OutputStream
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void flush()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
byte[]
int
int)

________________CLASS________________


public abstract interface class java.lang.Readable extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int read(
java.nio.CharBuffer)

________________CLASS________________


public abstract class java.io.Reader extends java.lang.Object implements java.lang.Readable, java.io.Closeable

----------------FIELDS----------------

protected java.lang.Object lock
----------------METHODS----------------

protected void <init>()

protected void <init>(
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void mark(
int)

public boolean markSupported()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
java.nio.CharBuffer)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
char[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int read(
char[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public boolean ready()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void reset()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long skip(
long)

________________CLASS________________


public class java.io.BufferedReader extends java.io.Reader

----------------FIELDS----------------

private char[] buf

private int count

private java.io.Reader in

private int marklimit

private int markpos

private int pos
----------------METHODS----------------

public void <init>(
java.io.Reader)

public void <init>(
java.io.Reader
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private int fillbuf()

private boolean isClosed()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void mark(
int)

public boolean markSupported()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
char[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.String readLine()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public boolean ready()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void reset()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long skip(
long)

________________CLASS________________


public abstract interface class java.lang.Appendable extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract java.lang.Appendable append(
char)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract java.lang.Appendable append(
java.lang.CharSequence)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract java.lang.Appendable append(
java.lang.CharSequence
int
int)

________________CLASS________________


public abstract class java.io.Writer extends java.lang.Object implements java.lang.Appendable, java.io.Closeable, java.io.Flushable

----------------FIELDS----------------

static final java.lang.String TOKEN_NULL

protected java.lang.Object lock
----------------METHODS----------------

protected void <init>()

protected void <init>(
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.io.Writer append(
char)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.io.Writer append(
java.lang.CharSequence)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.io.Writer append(
java.lang.CharSequence
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public volatile java.lang.Appendable append(
char)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public volatile java.lang.Appendable append(
java.lang.CharSequence)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public volatile java.lang.Appendable append(
java.lang.CharSequence
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void flush()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
java.lang.String
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
char[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void write(
char[]
int
int)

________________CLASS________________


public class java.io.BufferedWriter extends java.io.Writer

----------------FIELDS----------------

private char[] buf

private final java.lang.String lineSeparator

private java.io.Writer out

private int pos
----------------METHODS----------------

public void <init>(
java.io.Writer)

public void <init>(
java.io.Writer
int)

private boolean isClosed()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void flush()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void newLine()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
java.lang.String
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
char[]
int
int)

________________CLASS________________


public class java.io.ByteArrayInputStream extends java.io.InputStream

----------------FIELDS----------------

protected byte[] buf

protected int count

protected int mark

protected int pos
----------------METHODS----------------

public void <init>(
byte[])

public void <init>(
byte[]
int
int)

public int available()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()

public void mark(
int)

public boolean markSupported()

public int read()

public int read(
byte[]
int
int)

public void reset()

public long skip(
long)

________________CLASS________________


public class java.io.ByteArrayOutputStream extends java.io.OutputStream

----------------FIELDS----------------

protected byte[] buf

protected int count
----------------METHODS----------------

public void <init>()

public void <init>(
int)

private void expand(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()

public void reset()

public int size()

public byte[] toByteArray()

public java.lang.String toString()
@java.lang.Deprecated
public java.lang.String toString(
int)
@dalvik.annotation.Throws (value =Ljava/io/UnsupportedEncodingException; )
public java.lang.String toString(
java.lang.String)

public void write(
int)

public void write(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void writeTo(
java.io.OutputStream)

________________CLASS________________


public class java.io.CharArrayReader extends java.io.Reader

----------------FIELDS----------------

protected char[] buf

protected int count

protected int markedPos

protected int pos
----------------METHODS----------------

public void <init>(
char[])

public void <init>(
char[]
int
int)

private boolean isClosed()

private boolean isOpen()

public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void mark(
int)

public boolean markSupported()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
char[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public boolean ready()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void reset()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long skip(
long)

________________CLASS________________


public class java.io.CharArrayWriter extends java.io.Writer

----------------FIELDS----------------

protected char[] buf

protected int count
----------------METHODS----------------

public void <init>()

public void <init>(
int)

private void expand(
int)

public java.io.CharArrayWriter append(
char)

public java.io.CharArrayWriter append(
java.lang.CharSequence)

public java.io.CharArrayWriter append(
java.lang.CharSequence
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public volatile java.io.Writer append(
char)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public volatile java.io.Writer append(
java.lang.CharSequence)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public volatile java.io.Writer append(
java.lang.CharSequence
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public volatile java.lang.Appendable append(
char)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public volatile java.lang.Appendable append(
java.lang.CharSequence)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public volatile java.lang.Appendable append(
java.lang.CharSequence
int
int)

public void close()

public void flush()

public void reset()

public int size()

public char[] toCharArray()

public java.lang.String toString()

public void write(
int)

public void write(
java.lang.String
int
int)

public void write(
char[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void writeTo(
java.io.Writer)

________________CLASS________________


public class java.io.IOException extends java.lang.Exception

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class java.io.CharConversionException extends java.io.IOException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public abstract interface class java.io.DataInput extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract boolean readBoolean()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract byte readByte()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract char readChar()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract double readDouble()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract float readFloat()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void readFully(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void readFully(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int readInt()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract java.lang.String readLine()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract long readLong()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract short readShort()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract java.lang.String readUTF()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int readUnsignedByte()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int readUnsignedShort()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int skipBytes(
int)

________________CLASS________________


public class java.io.DataInputStream extends java.io.FilterInputStream implements java.io.DataInput

----------------FIELDS----------------
----------------METHODS----------------

public void <init>(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static final java.lang.String readUTF(
java.io.DataInput)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 java.lang.String decodeUTF(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final int read(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final int read(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final boolean readBoolean()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final byte readByte()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final char readChar()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final double readDouble()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final float readFloat()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final void readFully(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final void readFully(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final int readInt()
@java.lang.Deprecated
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final java.lang.String readLine()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final long readLong()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final short readShort()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final java.lang.String readUTF()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final int readUnsignedByte()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final int readUnsignedShort()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final int skipBytes(
int)

________________CLASS________________


public abstract interface class java.io.DataOutput extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void write(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void write(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void write(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void writeBoolean(
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void writeByte(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void writeBytes(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void writeChar(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void writeChars(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void writeDouble(
double)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void writeFloat(
float)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void writeInt(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void writeLong(
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void writeShort(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void writeUTF(
java.lang.String)

________________CLASS________________


public class java.io.DataOutputStream extends java.io.FilterOutputStream implements java.io.DataOutput

----------------FIELDS----------------

static final int MAX_BUF_SIZE

protected int written
----------------METHODS----------------

public void <init>(
java.io.OutputStream)

 long countUTFBytes(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void flush()

public final int size()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final void writeBoolean(
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final void writeByte(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final void writeBytes(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final void writeChar(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final void writeChars(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final void writeDouble(
double)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final void writeFloat(
float)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final void writeInt(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final void writeLong(
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final void writeShort(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final void writeUTF(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void writeUTFBytes(
java.lang.String
long)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/lang/Thread$UncaughtExceptionHandler;Ljava/lang/Thread$State;Ljava/lang/Thread$ParkState; )
public class java.lang.Thread extends java.lang.Object implements java.lang.Runnable

----------------FIELDS----------------

public static final int MAX_PRIORITY

public static final int MIN_PRIORITY

public static final int NORM_PRIORITY

private static int count

private static java.lang.Thread$UncaughtExceptionHandler defaultUncaughtHandler

private java.lang.ClassLoader contextClassLoader

volatile boolean daemon

volatile java.lang.ThreadGroup group

 boolean hasBeenStarted

private long id

 java.lang.ThreadLocal$Values inheritableValues

private java.lang.Runnable interruptAction

 java.lang.ThreadLocal$Values localValues

volatile java.lang.String name

private int parkState

volatile int priority

volatile long stackSize

 java.lang.Runnable target

private java.lang.Thread$UncaughtExceptionHandler uncaughtHandler

volatile java.lang.VMThread vmThread
----------------METHODS----------------

static void <clinit>()

public void <init>()

public void <init>(
java.lang.Runnable)

public void <init>(
java.lang.Runnable
java.lang.String)

public void <init>(
java.lang.String)

public void <init>(
java.lang.ThreadGroup
java.lang.Runnable)

public void <init>(
java.lang.ThreadGroup
java.lang.Runnable
java.lang.String)

public void <init>(
java.lang.ThreadGroup
java.lang.Runnable
java.lang.String
long)

public void <init>(
java.lang.ThreadGroup
java.lang.String)

 void <init>(
java.lang.ThreadGroup
java.lang.String
int
boolean)

public static int activeCount()

private void create(
java.lang.ThreadGroup
java.lang.Runnable
java.lang.String
long)

public static java.lang.Thread currentThread()

public static void dumpStack()

public static int enumerate(
java.lang.Thread[])
@dalvik.annotation.Signature (value =()Ljava/util/Map<Ljava/lang/Thread;[Ljava/lang/StackTraceElement;>; )
public static java.util.Map getAllStackTraces()

public static java.lang.Thread$UncaughtExceptionHandler getDefaultUncaughtExceptionHandler()

public static boolean holdsLock(
java.lang.Object)

public static boolean interrupted()

public static void setDefaultUncaughtExceptionHandler(
java.lang.Thread$UncaughtExceptionHandler)

private void setInterruptAction(
java.lang.Runnable)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public static void sleep(
long)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public static void sleep(
long
int)

public static void yield()

public final void checkAccess()
@java.lang.Deprecated
public int countStackFrames()
@java.lang.Deprecated
public void destroy()

public java.lang.ClassLoader getContextClassLoader()

public long getId()

public final java.lang.String getName()

public final int getPriority()

public java.lang.StackTraceElement[] getStackTrace()

public java.lang.Thread$State getState()

public final java.lang.ThreadGroup getThreadGroup()

public java.lang.Thread$UncaughtExceptionHandler getUncaughtExceptionHandler()

public void interrupt()

public final boolean isAlive()

public final boolean isDaemon()

public boolean isInterrupted()
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public final void join()
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public final void join(
long)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public final void join(
long
int)

 void parkFor(
long)

 void parkUntil(
long)
@java.lang.Deprecated
public final void resume()

public void run()

public void setContextClassLoader(
java.lang.ClassLoader)

public final void setDaemon(
boolean)

public final void setName(
java.lang.String)

public final void setPriority(
int)

public void setUncaughtExceptionHandler(
java.lang.Thread$UncaughtExceptionHandler)

public void start()
@java.lang.Deprecated
public final void stop()
@java.lang.Deprecated
public final void stop(
java.lang.Throwable)
@java.lang.Deprecated
public final void suspend()

public java.lang.String toString()

 void unpark()

________________CLASS________________


 class java.io.DeleteOnExit extends java.lang.Thread

----------------FIELDS----------------

private static java.io.DeleteOnExit instance
@dalvik.annotation.Signature (value =Ljava/util/ArrayList<Ljava/lang/String;>; )
private java.util.ArrayList files
----------------METHODS----------------

 void <init>()

public static java.io.DeleteOnExit getInstance()

public void addFile(
java.lang.String)

public void run()

________________CLASS________________


public class java.io.EOFException extends java.io.IOException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/io/EmulatedFields; )
@dalvik.annotation.InnerClass (accessFlags =8 name =ObjectSlot )
 class java.io.EmulatedFields$ObjectSlot extends java.lang.Object

----------------FIELDS----------------

 boolean defaulted

 java.io.ObjectStreamField field

 java.lang.Object fieldValue
----------------METHODS----------------

 void <init>()

public java.io.ObjectStreamField getField()

public java.lang.Object getFieldValue()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/io/EmulatedFields$ObjectSlot; )
 class java.io.EmulatedFields extends java.lang.Object

----------------FIELDS----------------

private java.io.ObjectStreamField[] declaredFields

private java.io.EmulatedFields$ObjectSlot[] slotsToSerialize
----------------METHODS----------------

public void <init>(
java.io.ObjectStreamField[]
java.io.ObjectStreamField[])

private void buildSlots(
java.io.ObjectStreamField[])
@dalvik.annotation.Signature (value =(Ljava/lang/String;Ljava/lang/Class<*>;)Ljava/io/EmulatedFields$ObjectSlot; )
private java.io.EmulatedFields$ObjectSlot findSlot(
java.lang.String
java.lang.Class)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public boolean defaulted(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public byte get(
java.lang.String
byte)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public char get(
java.lang.String
char)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public double get(
java.lang.String
double)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public float get(
java.lang.String
float)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public int get(
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public long get(
java.lang.String
long)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public java.lang.Object get(
java.lang.String
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public short get(
java.lang.String
short)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public boolean get(
java.lang.String
boolean)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public void put(
java.lang.String
byte)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public void put(
java.lang.String
char)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public void put(
java.lang.String
double)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public void put(
java.lang.String
float)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public void put(
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public void put(
java.lang.String
long)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public void put(
java.lang.String
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public void put(
java.lang.String
short)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public void put(
java.lang.String
boolean)

public java.io.EmulatedFields$ObjectSlot[] slots()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =1033 name =PutField )
@dalvik.annotation.EnclosingClass (value =Ljava/io/ObjectOutputStream; )
public abstract class java.io.ObjectOutputStream$PutField extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public abstract void put(
java.lang.String
byte)

public abstract void put(
java.lang.String
char)

public abstract void put(
java.lang.String
double)

public abstract void put(
java.lang.String
float)

public abstract void put(
java.lang.String
int)

public abstract void put(
java.lang.String
long)

public abstract void put(
java.lang.String
java.lang.Object)

public abstract void put(
java.lang.String
short)

public abstract void put(
java.lang.String
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
@java.lang.Deprecated
public abstract void write(
java.io.ObjectOutput)

________________CLASS________________


 class java.io.EmulatedFieldsForDumping extends java.io.ObjectOutputStream$PutField

----------------FIELDS----------------

private java.io.EmulatedFields emulatedFields
----------------METHODS----------------

 void <init>(
java.io.ObjectStreamClass)

 java.io.EmulatedFields emulatedFields()

public void put(
java.lang.String
byte)

public void put(
java.lang.String
char)

public void put(
java.lang.String
double)

public void put(
java.lang.String
float)

public void put(
java.lang.String
int)

public void put(
java.lang.String
long)

public void put(
java.lang.String
java.lang.Object)

public void put(
java.lang.String
short)

public void put(
java.lang.String
boolean)
@java.lang.Deprecated
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
java.io.ObjectOutput)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =1033 name =GetField )
@dalvik.annotation.EnclosingClass (value =Ljava/io/ObjectInputStream; )
public abstract class java.io.ObjectInputStream$GetField extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/IllegalArgumentException; )
public abstract boolean defaulted(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/IllegalArgumentException; )
public abstract byte get(
java.lang.String
byte)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/IllegalArgumentException; )
public abstract char get(
java.lang.String
char)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/IllegalArgumentException; )
public abstract double get(
java.lang.String
double)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/IllegalArgumentException; )
public abstract float get(
java.lang.String
float)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/IllegalArgumentException; )
public abstract int get(
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/IllegalArgumentException; )
public abstract long get(
java.lang.String
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/IllegalArgumentException; )
public abstract java.lang.Object get(
java.lang.String
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/IllegalArgumentException; )
public abstract short get(
java.lang.String
short)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/IllegalArgumentException; )
public abstract boolean get(
java.lang.String
boolean)

public abstract java.io.ObjectStreamClass getObjectStreamClass()

________________CLASS________________


 class java.io.EmulatedFieldsForLoading extends java.io.ObjectInputStream$GetField

----------------FIELDS----------------

private java.io.EmulatedFields emulatedFields

private java.io.ObjectStreamClass streamClass
----------------METHODS----------------

 void <init>(
java.io.ObjectStreamClass)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/IllegalArgumentException; )
public boolean defaulted(
java.lang.String)

 java.io.EmulatedFields emulatedFields()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/IllegalArgumentException; )
public byte get(
java.lang.String
byte)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/IllegalArgumentException; )
public char get(
java.lang.String
char)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/IllegalArgumentException; )
public double get(
java.lang.String
double)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/IllegalArgumentException; )
public float get(
java.lang.String
float)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/IllegalArgumentException; )
public int get(
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/IllegalArgumentException; )
public long get(
java.lang.String
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/IllegalArgumentException; )
public java.lang.Object get(
java.lang.String
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/IllegalArgumentException; )
public short get(
java.lang.String
short)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/IllegalArgumentException; )
public boolean get(
java.lang.String
boolean)

public java.io.ObjectStreamClass getObjectStreamClass()

________________CLASS________________


public abstract interface class java.io.Externalizable extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
public abstract void readExternal(
java.io.ObjectInput)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void writeExternal(
java.io.ObjectOutput)

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/io/Serializable;Ljava/lang/Comparable<Ljava/io/File;>; )
public class java.io.File extends java.lang.Object implements java.io.Serializable, java.lang.Comparable

----------------FIELDS----------------

private static boolean caseSensitive

private static int counter

public static final java.lang.String pathSeparator

public static final char pathSeparatorChar

public static final java.lang.String separator

public static final char separatorChar

private static final long serialVersionUID

private java.lang.String path

transient byte[] properPath
----------------METHODS----------------

static void <clinit>()

public void <init>(
java.io.File
java.lang.String)

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.String)

public void <init>(
java.net.URI)

private java.lang.String calculatePath(
java.lang.String
java.lang.String)

private void checkURI(
java.net.URI)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static java.io.File createTempFile(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static java.io.File createTempFile(
java.lang.String
java.lang.String
java.io.File)

private native boolean deleteDirImpl(
byte[])

private native boolean deleteFileImpl(
byte[])

private native boolean existsImpl(
byte[])

private java.lang.String fixSlashes(
java.lang.String)

private static java.io.File genTempFile(
java.lang.String
java.lang.String
java.io.File)

private java.lang.String getAbsoluteName()

private native byte[] getCanonImpl(
byte[])

private native byte[] getLinkImpl(
byte[])

private static native boolean isCaseSensitiveImpl()

private native boolean isDirectoryImpl(
byte[])

private native boolean isFileImpl(
byte[])

private native boolean isHiddenImpl(
byte[])

private native boolean isReadOnlyImpl(
byte[])

private native boolean isWriteOnlyImpl(
byte[])

private native long lastModifiedImpl(
byte[])

private native long lengthImpl(
byte[])

private static synchronized native byte[][] listImpl(
byte[])

public static java.io.File[] listRoots()

private native boolean mkdirImpl(
byte[])

private native int newFileImpl(
byte[])

private static native void oneTimeInitialization()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)

private native boolean renameToImpl(
byte[]
byte[])

private static native byte[][] rootsImpl()

private native boolean setLastModifiedImpl(
byte[]
long)

private native boolean setReadOnlyImpl(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

public boolean canRead()

public boolean canWrite()

public int compareTo(
java.io.File)

public volatile int compareTo(
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public boolean createNewFile()

public boolean delete()

public void deleteOnExit()

public boolean equals(
java.lang.Object)

public boolean exists()

public java.io.File getAbsoluteFile()

public java.lang.String getAbsolutePath()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.io.File getCanonicalFile()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.String getCanonicalPath()

public java.lang.String getName()

public java.lang.String getParent()

public java.io.File getParentFile()

public java.lang.String getPath()

public int hashCode()

public boolean isAbsolute()

public boolean isDirectory()

public boolean isFile()

public boolean isHidden()

public long lastModified()

public long length()

public java.lang.String[] list()

public java.lang.String[] list(
java.io.FilenameFilter)

public java.io.File[] listFiles()

public java.io.File[] listFiles(
java.io.FileFilter)

public java.io.File[] listFiles(
java.io.FilenameFilter)

public boolean mkdir()

public boolean mkdirs()

 byte[] properPath(
boolean)

public boolean renameTo(
java.io.File)

public boolean setLastModified(
long)

public boolean setReadOnly()

public java.lang.String toString()

public java.net.URI toURI()
@dalvik.annotation.Throws (value =Ljava/net/MalformedURLException; )
public java.net.URL toURL()

________________CLASS________________


public final class java.io.FileDescriptor extends java.lang.Object

----------------FIELDS----------------

public static final java.io.FileDescriptor err

public static final java.io.FileDescriptor in

public static final java.io.FileDescriptor out

 int descriptor

 boolean readOnly
----------------METHODS----------------

static void <clinit>()

public void <init>()

private static native void oneTimeInitialization()
@dalvik.annotation.Throws (value =Ljava/io/SyncFailedException; )
private native void syncImpl()
@dalvik.annotation.Throws (value =Ljava/io/SyncFailedException; )
public void sync()

public native boolean valid()

________________CLASS________________


public abstract interface class java.io.FileFilter extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract boolean accept(
java.io.File)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/io/FileInputStream; )
@dalvik.annotation.InnerClass (accessFlags =4104 name =null )
 class java.io.FileInputStream$1 extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =10 name =RepositioningLock )
@dalvik.annotation.EnclosingClass (value =Ljava/io/FileInputStream; )
 class java.io.FileInputStream$RepositioningLock extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

private void <init>()

 void <init>(
java.io.FileInputStream$1)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/io/FileInputStream$1;Ljava/io/FileInputStream$RepositioningLock; )
public class java.io.FileInputStream extends java.io.InputStream implements java.io.Closeable

----------------FIELDS----------------

private java.nio.channels.FileChannel channel

 java.io.FileDescriptor fd

private org.apache.harmony.luni.platform.IFileSystem fileSystem

 boolean innerFD

private java.lang.Object repositioningLock
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/FileNotFoundException; )
public void <init>(
java.io.File)

public void <init>(
java.io.FileDescriptor)
@dalvik.annotation.Throws (value =Ljava/io/FileNotFoundException; )
public void <init>(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void openCheck()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int available()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void finalize()

public java.nio.channels.FileChannel getChannel()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final java.io.FileDescriptor getFD()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long skip(
long)

________________CLASS________________


public class java.io.FileNotFoundException extends java.io.IOException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class java.io.FileOutputStream extends java.io.OutputStream implements java.io.Closeable

----------------FIELDS----------------

private java.nio.channels.FileChannel channel

 java.io.FileDescriptor fd

private org.apache.harmony.luni.platform.IFileSystem fileSystem

 boolean innerFD
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/FileNotFoundException; )
public void <init>(
java.io.File)
@dalvik.annotation.Throws (value =Ljava/io/FileNotFoundException; )
public void <init>(
java.io.File
boolean)

public void <init>(
java.io.FileDescriptor)
@dalvik.annotation.Throws (value =Ljava/io/FileNotFoundException; )
public void <init>(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/FileNotFoundException; )
public void <init>(
java.lang.String
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void openCheck()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void finalize()

public java.nio.channels.FileChannel getChannel()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final java.io.FileDescriptor getFD()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
byte[]
int
int)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/String;>; )
@dalvik.annotation.EnclosingMethod (value =null )
 class java.io.FilePermission$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final java.io.FilePermission this$0

final java.lang.String val$path
----------------METHODS----------------

 void <init>(
java.io.FilePermission
java.lang.String)

public volatile java.lang.Object run()

public java.lang.String run()

________________CLASS________________


public abstract interface class java.security.Guard extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/lang/SecurityException; )
public abstract void checkGuard(
java.lang.Object)

________________CLASS________________


public abstract class java.security.Permission extends java.lang.Object implements java.security.Guard, java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

private final java.lang.String name
----------------METHODS----------------

public void <init>(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/lang/SecurityException; )
public void checkGuard(
java.lang.Object)

public abstract boolean equals(
java.lang.Object)

public abstract java.lang.String getActions()

public final java.lang.String getName()

public abstract int hashCode()

public abstract boolean implies(
java.security.Permission)

public java.security.PermissionCollection newPermissionCollection()

public java.lang.String toString()

________________CLASS________________


public final class java.io.FilePermission extends java.security.Permission implements java.io.Serializable

----------------FIELDS----------------

private static final java.lang.String[] actionList

private static final long serialVersionUID

private java.lang.String actions

private transient boolean allDir

private transient boolean allSubdir

private transient java.lang.String canonPath

private transient boolean includeAll

transient int mask
----------------METHODS----------------

static void <clinit>()

public void <init>(
java.lang.String
java.lang.String)

private int getMask(
java.lang.String)

private void init(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)

private java.lang.String toCanonicalActionString(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

public boolean equals(
java.lang.Object)

public java.lang.String getActions()

public int hashCode()

public boolean implies(
java.security.Permission)

 int impliesMask(
java.security.Permission)

public java.security.PermissionCollection newPermissionCollection()

________________CLASS________________


public abstract class java.security.PermissionCollection extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

private boolean readOnly
----------------METHODS----------------

public void <init>()

public abstract void add(
java.security.Permission)
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<Ljava/security/Permission;>; )
public abstract java.util.Enumeration elements()

public abstract boolean implies(
java.security.Permission)

public boolean isReadOnly()

public void setReadOnly()

public java.lang.String toString()

________________CLASS________________


final class java.io.FilePermissionCollection extends java.security.PermissionCollection implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID
@dalvik.annotation.Signature (value =Ljava/util/Vector<Ljava/security/Permission;>; )
 java.util.Vector permissions
----------------METHODS----------------

public void <init>()

public void add(
java.security.Permission)
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<Ljava/security/Permission;>; )
public java.util.Enumeration elements()

public boolean implies(
java.security.Permission)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/io/InputStreamReader$HistoricalNamesUtil; )
public class java.io.InputStreamReader extends java.io.Reader

----------------FIELDS----------------

private static final int BUFFER_SIZE

 java.nio.ByteBuffer bytes

 java.nio.charset.CharsetDecoder decoder

private boolean endOfInput

private java.io.InputStream in
----------------METHODS----------------

public void <init>(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/io/UnsupportedEncodingException; )
public void <init>(
java.io.InputStream
java.lang.String)

public void <init>(
java.io.InputStream
java.nio.charset.Charset)

public void <init>(
java.io.InputStream
java.nio.charset.CharsetDecoder)

private boolean isOpen()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()

public java.lang.String getEncoding()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
char[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public boolean ready()

________________CLASS________________


public class java.io.FileReader extends java.io.InputStreamReader

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/FileNotFoundException; )
public void <init>(
java.io.File)

public void <init>(
java.io.FileDescriptor)
@dalvik.annotation.Throws (value =Ljava/io/FileNotFoundException; )
public void <init>(
java.lang.String)

________________CLASS________________


public class java.io.OutputStreamWriter extends java.io.Writer

----------------FIELDS----------------

private java.nio.ByteBuffer bytes

private java.nio.charset.CharsetEncoder encoder

private java.io.OutputStream out
----------------METHODS----------------

public void <init>(
java.io.OutputStream)
@dalvik.annotation.Throws (value =Ljava/io/UnsupportedEncodingException; )
public void <init>(
java.io.OutputStream
java.lang.String)

public void <init>(
java.io.OutputStream
java.nio.charset.Charset)

public void <init>(
java.io.OutputStream
java.nio.charset.CharsetEncoder)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void checkStatus()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void convert(
java.nio.CharBuffer)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void flush()

public java.lang.String getEncoding()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
java.lang.String
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
char[]
int
int)

________________CLASS________________


public class java.io.FileWriter extends java.io.OutputStreamWriter

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.io.File)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.io.File
boolean)

public void <init>(
java.io.FileDescriptor)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.lang.String
boolean)

________________CLASS________________


public abstract class java.io.FilterReader extends java.io.Reader

----------------FIELDS----------------

protected java.io.Reader in
----------------METHODS----------------

protected void <init>(
java.io.Reader)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void mark(
int)

public boolean markSupported()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
char[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public boolean ready()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void reset()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long skip(
long)

________________CLASS________________


public abstract class java.io.FilterWriter extends java.io.Writer

----------------FIELDS----------------

protected java.io.Writer out
----------------METHODS----------------

protected void <init>(
java.io.Writer)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void flush()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
java.lang.String
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
char[]
int
int)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =HistoricalNamesUtil )
@dalvik.annotation.EnclosingClass (value =Ljava/io/InputStreamReader; )
 class java.io.InputStreamReader$HistoricalNamesUtil extends java.lang.Object

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/HashMap<Ljava/lang/String;Ljava/lang/String;>; )
private static java.util.HashMap historicalNames
----------------METHODS----------------

static void <clinit>()

 void <init>()

public static java.lang.String getHistoricalName(
java.lang.String)

________________CLASS________________


public class java.io.InterruptedIOException extends java.io.IOException

----------------FIELDS----------------

private static final long serialVersionUID

public int bytesTransferred
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public abstract class java.io.ObjectStreamException extends java.io.IOException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

protected void <init>()

protected void <init>(
java.lang.String)

________________CLASS________________


public class java.io.InvalidClassException extends java.io.ObjectStreamException

----------------FIELDS----------------

private static final long serialVersionUID

public java.lang.String classname
----------------METHODS----------------

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.String)

public java.lang.String getMessage()

________________CLASS________________


public class java.io.InvalidObjectException extends java.io.ObjectStreamException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>(
java.lang.String)

________________CLASS________________

@java.lang.Deprecated
public class java.io.LineNumberInputStream extends java.io.FilterInputStream

----------------FIELDS----------------

private int lastChar

private int lineNumber

private int markedLastChar

private int markedLineNumber
----------------METHODS----------------

public void <init>(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int available()

public int getLineNumber()

public void mark(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void reset()

public void setLineNumber(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long skip(
long)

________________CLASS________________


public class java.io.LineNumberReader extends java.io.BufferedReader

----------------FIELDS----------------

private boolean lastWasCR

private int lineNumber

private boolean markedLastWasCR

private int markedLineNumber
----------------METHODS----------------

public void <init>(
java.io.Reader)

public void <init>(
java.io.Reader
int)

public int getLineNumber()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void mark(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
char[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.String readLine()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void reset()

public void setLineNumber(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long skip(
long)

________________CLASS________________


public class java.io.NotActiveException extends java.io.ObjectStreamException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class java.io.NotSerializableException extends java.io.ObjectStreamException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public abstract interface class java.io.ObjectInput extends java.lang.Object implements java.io.DataInput

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int available()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int read(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int read(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/lang/ClassNotFoundException;Ljava/io/IOException; )
public abstract java.lang.Object readObject()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract long skip(
long)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/Boolean;>; )
@dalvik.annotation.EnclosingMethod (value =null )
 class java.io.ObjectInputStream$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final java.io.ObjectInputStream this$0

final java.lang.Class val$implementationClass

final java.lang.Class val$thisClass
----------------METHODS----------------

 void <init>(
java.io.ObjectInputStream
java.lang.Class
java.lang.Class)

public java.lang.Boolean run()

public volatile java.lang.Object run()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =InputValidationDesc )
@dalvik.annotation.EnclosingClass (value =Ljava/io/ObjectInputStream; )
 class java.io.ObjectInputStream$InputValidationDesc extends java.lang.Object

----------------FIELDS----------------

 int priority

 java.io.ObjectInputValidation validator
----------------METHODS----------------

 void <init>()

________________CLASS________________


public abstract interface class java.io.ObjectStreamConstants extends java.lang.Object

----------------FIELDS----------------

public static final int PROTOCOL_VERSION_1

public static final int PROTOCOL_VERSION_2

public static final byte SC_BLOCK_DATA

public static final byte SC_ENUM

public static final byte SC_EXTERNALIZABLE

public static final byte SC_SERIALIZABLE

public static final byte SC_WRITE_METHOD

public static final short STREAM_MAGIC

public static final short STREAM_VERSION

public static final java.io.SerializablePermission SUBCLASS_IMPLEMENTATION_PERMISSION

public static final java.io.SerializablePermission SUBSTITUTION_PERMISSION

public static final byte TC_ARRAY

public static final byte TC_BASE

public static final byte TC_BLOCKDATA

public static final byte TC_BLOCKDATALONG

public static final byte TC_CLASS

public static final byte TC_CLASSDESC

public static final byte TC_ENDBLOCKDATA

public static final byte TC_ENUM

public static final byte TC_EXCEPTION

public static final byte TC_LONGSTRING

public static final byte TC_MAX

public static final byte TC_NULL

public static final byte TC_OBJECT

public static final byte TC_PROXYCLASSDESC

public static final byte TC_REFERENCE

public static final byte TC_RESET

public static final byte TC_STRING

public static final int baseWireHandle
----------------METHODS----------------

static void <clinit>()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/io/ObjectInputStream$GetField;Ljava/io/ObjectInputStream$InputValidationDesc; )
public class java.io.ObjectInputStream extends java.io.InputStream implements java.io.ObjectInput, java.io.ObjectStreamConstants

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Hashtable<Ljava/lang/String;Ljava/lang/Class<*>;>; )
private static final java.util.Hashtable PRIMITIVE_CLASSES

private static final java.lang.Object UNSHARED_OBJ

private static final java.lang.ClassLoader bootstrapLoader

private static java.io.InputStream emptyStream

private static final java.lang.ClassLoader systemLoader

private java.lang.ClassLoader callerClassLoader

private java.io.ObjectStreamClass currentClass

private int currentHandle

private java.lang.Object currentObject

private java.lang.Integer descriptorHandle

private boolean enableResolve

private boolean hasPushbackTC

private java.io.DataInputStream input

private boolean mustResolve

private int nestedLevels
@dalvik.annotation.Signature (value =Ljava/util/Hashtable<Ljava/lang/Integer;Ljava/lang/Object;>; )
private java.util.Hashtable objectsRead

private java.io.InputStream primitiveData

private java.io.DataInputStream primitiveTypes

private byte pushbackTC
@dalvik.annotation.Signature (value =Ljava/util/IdentityHashMap<Ljava/lang/Class<*>;Ljava/lang/Object;>; )
private java.util.IdentityHashMap readResolveCache

private boolean subclassOverridingImplementation

private java.io.ObjectInputStream$InputValidationDesc[] validations
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/SecurityException; )
protected void <init>()
@dalvik.annotation.Throws (value =Ljava/io/StreamCorruptedException;Ljava/io/IOException; )
public void <init>(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void checkReadPrimitiveTypes()
@dalvik.annotation.Throws (value =Ljava/io/StreamCorruptedException; )
private static void checkedSetSuperClassDesc(
java.io.ObjectStreamClass
java.io.ObjectStreamClass)
@dalvik.annotation.Throws (value =Ljava/lang/ClassNotFoundException;Ljava/io/IOException; )
private void discardData()
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;Ljava/util/ArrayList<Ljava/io/ObjectStreamClass;>;I)I )
private int findStreamSuperclass(
java.lang.Class
java.util.ArrayList
int)

private static java.lang.String getBaseName(
java.lang.String)

private static java.lang.ClassLoader getClosestUserClassLoader()
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;Ljava/lang/Class<*>;)Z )
private boolean inSamePackage(
java.lang.Class
java.lang.Class)
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;Ljava/lang/Class<*>;)Ljava/lang/Object; )
private static native java.lang.Object newInstance(
java.lang.Class
java.lang.Class)

private int nextHandle()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private byte nextTC()
@dalvik.annotation.Throws (value =Ljava/lang/NoSuchFieldError; )
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Class<*>;Ljava/lang/String;Ljava/lang/String;Ljava/lang/Object;)V )
private static native void objSetField(
java.lang.Object
java.lang.Class
java.lang.String
java.lang.String
java.lang.Object)

private void pushbackTC()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private byte[] readBlockData()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private byte[] readBlockDataLong()
@dalvik.annotation.Throws (value =Ljava/lang/ClassNotFoundException;Ljava/io/IOException; )
private java.io.ObjectStreamClass readClassDesc()
@dalvik.annotation.Throws (value =Ljava/lang/ClassNotFoundException;Ljava/io/IOException; )
private java.lang.Object readContent(
byte)
@dalvik.annotation.Throws (value =Ljava/io/InvalidObjectException;Ljava/io/IOException; )
private java.lang.Object readCyclicReference()
@dalvik.annotation.Throws (value =Ljava/io/OptionalDataException;Ljava/lang/ClassNotFoundException;Ljava/io/IOException; )
private java.lang.Object readEnum(
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private java.io.ObjectStreamClass readEnumDesc()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private java.io.ObjectStreamClass readEnumDescInternal()
@dalvik.annotation.Throws (value =Ljava/io/WriteAbortedException;Ljava/io/OptionalDataException;Ljava/lang/ClassNotFoundException;Ljava/io/IOException; )
private java.lang.Exception readException()
@dalvik.annotation.Throws (value =Ljava/lang/ClassNotFoundException;Ljava/io/IOException; )
private void readFieldDescriptors(
java.io.ObjectStreamClass)
@dalvik.annotation.Throws (value =Ljava/io/OptionalDataException;Ljava/io/InvalidClassException;Ljava/io/IOException; )
private void readFieldValues(
java.io.EmulatedFieldsForLoading)
@dalvik.annotation.Throws (value =Ljava/io/OptionalDataException;Ljava/lang/ClassNotFoundException;Ljava/io/IOException; )
private void readFieldValues(
java.lang.Object
java.io.ObjectStreamClass)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException;Ljava/io/NotActiveException; )
private void readHierarchy(
java.lang.Object
java.io.ObjectStreamClass)
@dalvik.annotation.Throws (value =Ljava/io/OptionalDataException;Ljava/lang/ClassNotFoundException;Ljava/io/IOException; )
private java.lang.Object readNewArray(
boolean)
@dalvik.annotation.Throws (value =Ljava/lang/ClassNotFoundException;Ljava/io/IOException; )
@dalvik.annotation.Signature (value =(Z)Ljava/lang/Class<*>; )
private java.lang.Class readNewClass(
boolean)
@dalvik.annotation.Throws (value =Ljava/lang/ClassNotFoundException;Ljava/io/IOException; )
private java.io.ObjectStreamClass readNewClassDesc(
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private java.lang.Integer readNewHandle()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private java.lang.Object readNewLongString(
boolean)
@dalvik.annotation.Throws (value =Ljava/io/OptionalDataException;Ljava/lang/ClassNotFoundException;Ljava/io/IOException; )
private java.lang.Object readNewObject(
boolean)
@dalvik.annotation.Signature (value =()Ljava/lang/Class<*>; )
@dalvik.annotation.Throws (value =Ljava/lang/ClassNotFoundException;Ljava/io/IOException; )
private java.lang.Class readNewProxyClassDesc()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private java.lang.Object readNewString(
boolean)
@dalvik.annotation.Throws (value =Ljava/lang/ClassNotFoundException;Ljava/io/IOException; )
private java.lang.Object readNonPrimitiveContent(
boolean)
@dalvik.annotation.Throws (value =Ljava/io/OptionalDataException;Ljava/lang/ClassNotFoundException;Ljava/io/IOException; )
private java.lang.Object readObject(
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException;Ljava/io/NotActiveException; )
private void readObjectForClass(
java.lang.Object
java.io.ObjectStreamClass)
@dalvik.annotation.Throws (value =Ljava/io/ObjectStreamException; )
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Class<*>;)V )
private void readObjectNoData(
java.lang.Object
java.lang.Class)

private void registerObjectRead(
java.lang.Object
java.lang.Integer
boolean)
@dalvik.annotation.Throws (value =Ljava/io/InvalidObjectException; )
private java.lang.Object registeredObjectRead(
java.lang.Integer)

private void resetSeenObjects()

private void resetState()
@dalvik.annotation.Throws (value =Ljava/lang/NoSuchFieldError; )
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Class<*>;Ljava/lang/String;B)V )
private static native void setField(
java.lang.Object
java.lang.Class
java.lang.String
byte)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Class<*>;Ljava/lang/String;C)V )
@dalvik.annotation.Throws (value =Ljava/lang/NoSuchFieldError; )
private static native void setField(
java.lang.Object
java.lang.Class
java.lang.String
char)
@dalvik.annotation.Throws (value =Ljava/lang/NoSuchFieldError; )
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Class<*>;Ljava/lang/String;D)V )
private static native void setField(
java.lang.Object
java.lang.Class
java.lang.String
double)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Class<*>;Ljava/lang/String;F)V )
@dalvik.annotation.Throws (value =Ljava/lang/NoSuchFieldError; )
private static native void setField(
java.lang.Object
java.lang.Class
java.lang.String
float)
@dalvik.annotation.Throws (value =Ljava/lang/NoSuchFieldError; )
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Class<*>;Ljava/lang/String;I)V )
private static native void setField(
java.lang.Object
java.lang.Class
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/lang/NoSuchFieldError; )
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Class<*>;Ljava/lang/String;J)V )
private static native void setField(
java.lang.Object
java.lang.Class
java.lang.String
long)
@dalvik.annotation.Throws (value =Ljava/lang/NoSuchFieldError; )
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Class<*>;Ljava/lang/String;S)V )
private static native void setField(
java.lang.Object
java.lang.Class
java.lang.String
short)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Class<*>;Ljava/lang/String;Z)V )
@dalvik.annotation.Throws (value =Ljava/lang/NoSuchFieldError; )
private static native void setField(
java.lang.Object
java.lang.Class
java.lang.String
boolean)
@dalvik.annotation.Throws (value =Ljava/io/InvalidClassException; )
private void verifyBaseName(
java.io.ObjectStreamClass)
@dalvik.annotation.Throws (value =Ljava/io/InvalidClassException; )
private void verifySUID(
java.io.ObjectStreamClass)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int available()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException;Ljava/io/NotActiveException; )
public void defaultReadObject()
@dalvik.annotation.Throws (value =Ljava/lang/SecurityException; )
protected boolean enableResolveObject(
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public boolean readBoolean()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public byte readByte()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public char readChar()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
protected java.io.ObjectStreamClass readClassDescriptor()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public double readDouble()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException;Ljava/io/NotActiveException; )
public java.io.ObjectInputStream$GetField readFields()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public float readFloat()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void readFully(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void readFully(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int readInt()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
@java.lang.Deprecated
public java.lang.String readLine()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long readLong()
@dalvik.annotation.Throws (value =Ljava/io/OptionalDataException;Ljava/lang/ClassNotFoundException;Ljava/io/IOException; )
public final java.lang.Object readObject()
@dalvik.annotation.Throws (value =Ljava/io/OptionalDataException;Ljava/lang/ClassNotFoundException;Ljava/io/IOException; )
protected java.lang.Object readObjectOverride()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public short readShort()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/io/StreamCorruptedException; )
protected void readStreamHeader()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.String readUTF()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
public java.lang.Object readUnshared()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int readUnsignedByte()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int readUnsignedShort()
@dalvik.annotation.Throws (value =Ljava/io/NotActiveException;Ljava/io/InvalidObjectException; )
public void registerValidation(
java.io.ObjectInputValidation
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
@dalvik.annotation.Signature (value =(Ljava/io/ObjectStreamClass;)Ljava/lang/Class<*>; )
protected java.lang.Class resolveClass(
java.io.ObjectStreamClass)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected java.lang.Object resolveObject(
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
@dalvik.annotation.Signature (value =([Ljava/lang/String;)Ljava/lang/Class<*>; )
protected java.lang.Class resolveProxyClass(
java.lang.String[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int skipBytes(
int)

________________CLASS________________


public abstract interface class java.io.ObjectInputValidation extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/InvalidObjectException; )
public abstract void validateObject()

________________CLASS________________


public abstract interface class java.io.ObjectOutput extends java.lang.Object implements java.io.DataOutput

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void flush()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void write(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void write(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void write(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void writeObject(
java.lang.Object)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/io/ObjectOutputStream$PutField; )
public class java.io.ObjectOutputStream extends java.io.OutputStream implements java.io.ObjectOutput, java.io.ObjectStreamConstants

----------------FIELDS----------------

private java.io.ObjectStreamClass currentClass

private int currentHandle

private java.lang.Object currentObject

private java.io.EmulatedFieldsForDumping currentPutField

private boolean enableReplace

private java.io.StreamCorruptedException nestedException

private int nestedLevels
@dalvik.annotation.Signature (value =Ljava/util/IdentityHashMap<Ljava/lang/Object;Ljava/lang/Integer;>; )
private java.util.IdentityHashMap objectsWritten

private java.io.DataOutputStream output

private java.io.DataOutputStream primitiveTypes

private java.io.ByteArrayOutputStream primitiveTypesBuffer

private int protocolVersion

private boolean subclassOverridingImplementation
@dalvik.annotation.Signature (value =Ljava/util/IdentityHashMap<Ljava/lang/Class<*>;Ljava/lang/Object;>; )
private java.util.IdentityHashMap writeReplaceCache
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/SecurityException; )
protected void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.io.OutputStream)

private void checkWritePrimitiveTypes()

private void computePutField()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private java.lang.Integer dumpCycle(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Class<*>;Ljava/lang/String;)Z )
private static native boolean getFieldBool(
java.lang.Object
java.lang.Class
java.lang.String)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Class<*>;Ljava/lang/String;)B )
private static native byte getFieldByte(
java.lang.Object
java.lang.Class
java.lang.String)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Class<*>;Ljava/lang/String;)C )
private static native char getFieldChar(
java.lang.Object
java.lang.Class
java.lang.String)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Class<*>;Ljava/lang/String;)D )
private static native double getFieldDouble(
java.lang.Object
java.lang.Class
java.lang.String)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Class<*>;Ljava/lang/String;)F )
private static native float getFieldFloat(
java.lang.Object
java.lang.Class
java.lang.String)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Class<*>;Ljava/lang/String;)I )
private static native int getFieldInt(
java.lang.Object
java.lang.Class
java.lang.String)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Class<*>;Ljava/lang/String;)J )
private static native long getFieldLong(
java.lang.Object
java.lang.Class
java.lang.String)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Class<*>;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object; )
private static native java.lang.Object getFieldObj(
java.lang.Object
java.lang.Class
java.lang.String
java.lang.String)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Class<*>;Ljava/lang/String;)S )
private static native short getFieldShort(
java.lang.Object
java.lang.Class
java.lang.String)

private int nextHandle()

private java.lang.Integer registerObjectWritten(
java.lang.Object)

private void registerObjectWritten(
java.lang.Object
java.lang.Integer)

private java.lang.Integer registeredObjectHandleFor(
java.lang.Object)

private void removeUnsharedReference(
java.lang.Object
java.lang.Integer)

private void resetSeenObjects()

private void resetState()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private java.lang.Integer writeClassDesc(
java.io.ObjectStreamClass
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;)Ljava/lang/Integer; )
private java.lang.Integer writeClassDescForClass(
java.lang.Class)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeCyclicReference(
java.lang.Integer)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;Z)Ljava/io/ObjectStreamClass; )
private java.io.ObjectStreamClass writeEnumDesc(
java.lang.Class
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeFieldDescriptors(
java.io.ObjectStreamClass
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeFieldValues(
java.io.EmulatedFieldsForDumping)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeFieldValues(
java.lang.Object
java.io.ObjectStreamClass)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/io/NotActiveException; )
private void writeHierarchy(
java.lang.Object
java.io.ObjectStreamClass)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Class<*>;Ljava/lang/Class<*>;Z)Ljava/lang/Integer; )
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private java.lang.Integer writeNewArray(
java.lang.Object
java.lang.Class
java.lang.Class
boolean)
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;Z)Ljava/lang/Integer; )
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private java.lang.Integer writeNewClass(
java.lang.Class
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeNewClassDesc(
java.io.ObjectStreamClass)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Class<*>;Z)Ljava/lang/Integer; )
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private java.lang.Integer writeNewEnum(
java.lang.Object
java.lang.Class
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeNewException(
java.lang.Exception)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Class<*>;Z)Ljava/lang/Integer; )
private java.lang.Integer writeNewObject(
java.lang.Object
java.lang.Class
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private java.lang.Integer writeNewString(
java.lang.String
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeNull()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.lang.Object
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private java.lang.Integer writeObjectInternal(
java.lang.Object
boolean
boolean
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;)V )
protected void annotateClass(
java.lang.Class)
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;)V )
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void annotateProxyClass(
java.lang.Class)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void defaultWriteObject()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void drain()
@dalvik.annotation.Throws (value =Ljava/lang/SecurityException; )
protected boolean enableReplaceObject(
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void flush()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.io.ObjectOutputStream$PutField putFields()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected java.lang.Object replaceObject(
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void reset()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void useProtocolVersion(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void writeBoolean(
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void writeByte(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void writeBytes(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void writeChar(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void writeChars(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void writeClassDescriptor(
java.io.ObjectStreamClass)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void writeDouble(
double)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void writeFields()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void writeFloat(
float)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void writeInt(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void writeLong(
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final void writeObject(
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void writeObjectOverride(
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void writeShort(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void writeStreamHeader()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void writeUTF(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void writeUnshared(
java.lang.Object)

________________CLASS________________

@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>Ljava/lang/Object; )
public abstract interface class java.util.Comparator extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =(TT;TT;)I )
public abstract int compare(
java.lang.Object
java.lang.Object)

public abstract boolean equals(
java.lang.Object)

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Comparator<Ljava/lang/Class<*>;>; )
final class java.io.ObjectStreamClass$1 extends java.lang.Object implements java.util.Comparator

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;Ljava/lang/Class<*>;)I )
public int compare(
java.lang.Class
java.lang.Class)

public volatile int compare(
java.lang.Object
java.lang.Object)

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Comparator<Ljava/lang/reflect/Field;>; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
final class java.io.ObjectStreamClass$2 extends java.lang.Object implements java.util.Comparator

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public volatile int compare(
java.lang.Object
java.lang.Object)

public int compare(
java.lang.reflect.Field
java.lang.reflect.Field)

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Comparator<Ljava/lang/reflect/Constructor<*>;>; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class java.io.ObjectStreamClass$3 extends java.lang.Object implements java.util.Comparator

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public volatile int compare(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/lang/reflect/Constructor<*>;Ljava/lang/reflect/Constructor<*>;)I )
public int compare(
java.lang.reflect.Constructor
java.lang.reflect.Constructor)

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Comparator<Ljava/lang/reflect/Method;>; )
final class java.io.ObjectStreamClass$4 extends java.lang.Object implements java.util.Comparator

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public volatile int compare(
java.lang.Object
java.lang.Object)

public int compare(
java.lang.reflect.Method
java.lang.reflect.Method)

________________CLASS________________


public class java.io.ObjectStreamClass extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/lang/Class<*>; )
static final java.lang.Class ARRAY_OF_FIELDS
@dalvik.annotation.Signature (value =Ljava/lang/Class<*>; )
static final java.lang.Class CLASSCLASS

private static final int CLASS_MODIFIERS_MASK

private static final int CLINIT_MODIFIERS

private static final java.lang.String CLINIT_NAME

private static final java.lang.String CLINIT_SIGNATURE
@dalvik.annotation.Signature (value =[Ljava/lang/Class<*>; )
static final java.lang.Class[] EMPTY_CONSTRUCTOR_PARAM_TYPES
@dalvik.annotation.Signature (value =Ljava/lang/Class<Ljava/io/Externalizable;>; )
private static final java.lang.Class EXTERNALIZABLE

private static final int FIELD_MODIFIERS_MASK

private static final int METHOD_MODIFIERS_MASK

public static final java.io.ObjectStreamField[] NO_FIELDS
@dalvik.annotation.Signature (value =Ljava/lang/Class<Ljava/io/ObjectStreamClass;>; )
static final java.lang.Class OBJECTSTREAMCLASSCLASS
@dalvik.annotation.Signature (value =[Ljava/lang/Class<*>; )
private static final java.lang.Class[] READ_PARAM_TYPES
@dalvik.annotation.Signature (value =Ljava/lang/Class<Ljava/io/Serializable;>; )
private static final java.lang.Class SERIALIZABLE
@dalvik.annotation.Signature (value =Ljava/lang/Class<Ljava/lang/String;>; )
static final java.lang.Class STRINGCLASS

private static final java.lang.String UID_FIELD_NAME
@dalvik.annotation.Signature (value =[Ljava/lang/Class<*>; )
static final java.lang.Class[] UNSHARED_PARAM_TYPES
@dalvik.annotation.Signature (value =Ljava/lang/Class<Ljava/lang/Void;>; )
private static final java.lang.Class VOID_CLASS
@dalvik.annotation.Signature (value =[Ljava/lang/Class<*>; )
private static final java.lang.Class[] WRITE_PARAM_TYPES
@dalvik.annotation.Signature (value =Ljava/util/WeakHashMap<Ljava/lang/Class<*>;Ljava/io/ObjectStreamClass;>; )
private static final java.util.WeakHashMap classesAndDescriptors

private static final long serialVersionUID

private transient java.lang.String className

private transient java.io.ObjectStreamField[] fields

private transient byte flags

private transient java.io.ObjectStreamField[] loadFields
@dalvik.annotation.Signature (value =Ljava/lang/ref/WeakReference<Ljava/lang/Class<*>;>; )
private transient java.lang.ref.WeakReference resolvedClass

private transient java.io.ObjectStreamClass superclass

private transient long svUID
----------------METHODS----------------

static void <clinit>()

 void <init>()
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;Z)Ljava/io/ObjectStreamClass; )
private static java.io.ObjectStreamClass addToCache(
java.lang.Class
boolean)
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;[Ljava/lang/reflect/Field;)J )
private static long computeSerialVersionUID(
java.lang.Class
java.lang.reflect.Field[])

private void copyFieldAttributes()

private static java.lang.String descriptorForFieldSignature(
java.lang.String)

private static java.lang.String descriptorForSignature(
java.lang.String)
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;)Ljava/lang/reflect/Field; )
static java.lang.reflect.Field fieldSerialPersistentFields(
java.lang.Class)
@dalvik.annotation.Signature (value =(Ljava/lang/reflect/Constructor<*>;)Ljava/lang/String; )
static native java.lang.String getConstructorSignature(
java.lang.reflect.Constructor)

private static native java.lang.String getFieldSignature(
java.lang.reflect.Field)

static native java.lang.String getMethodSignature(
java.lang.reflect.Method)
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;)Ljava/lang/reflect/Method; )
static java.lang.reflect.Method getPrivateReadObjectMethod(
java.lang.Class)
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;)Ljava/lang/reflect/Method; )
static java.lang.reflect.Method getPrivateReadObjectNoDataMethod(
java.lang.Class)
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;)Ljava/lang/reflect/Method; )
static java.lang.reflect.Method getPrivateWriteObjectMethod(
java.lang.Class)
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;)Z )
private static native boolean hasClinit(
java.lang.Class)
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;)Z )
static boolean isExternalizable(
java.lang.Class)

static boolean isPrimitiveType(
char)
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;)Z )
static boolean isSerializable(
java.lang.Class)

private static long littleEndianLongAt(
byte[]
int)
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;)Ljava/io/ObjectStreamClass; )
public static java.io.ObjectStreamClass lookup(
java.lang.Class)
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;)Ljava/io/ObjectStreamClass; )
static java.io.ObjectStreamClass lookupStreamClass(
java.lang.Class)
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;Z)Ljava/io/ObjectStreamClass; )
private static java.io.ObjectStreamClass lookupStreamClass(
java.lang.Class
boolean)
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;)Ljava/lang/reflect/Method; )
static java.lang.reflect.Method methodReadResolve(
java.lang.Class)
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;)Ljava/lang/reflect/Method; )
static java.lang.reflect.Method methodWriteReplace(
java.lang.Class)

private static native void oneTimeInitialization()
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;)I )
private int primitiveSize(
java.lang.Class)

 void buildFieldDescriptors(
java.lang.reflect.Field[])

 java.io.ObjectStreamField[] fields()
@dalvik.annotation.Signature (value =()Ljava/lang/Class<*>; )
public java.lang.Class forClass()

public java.io.ObjectStreamField getField(
java.lang.String)

public java.io.ObjectStreamField[] getFields()

 byte getFlags()

 java.io.ObjectStreamField[] getLoadFields()

public java.lang.String getName()

public long getSerialVersionUID()

 java.io.ObjectStreamClass getSuperclass()
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;)V )
 void setClass(
java.lang.Class)

 void setFields(
java.io.ObjectStreamField[])

 void setFlags(
byte)

 void setLoadFields(
java.io.ObjectStreamField[])

 void setName(
java.lang.String)

 void setSerialVersionUID(
long)

 void setSuperclass(
java.io.ObjectStreamClass)

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Comparator<Ljava/io/ObjectStreamField;>; )
final class java.io.ObjectStreamField$1 extends java.lang.Object implements java.util.Comparator

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public int compare(
java.io.ObjectStreamField
java.io.ObjectStreamField)

public volatile int compare(
java.lang.Object
java.lang.Object)

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/lang/Comparable<Ljava/lang/Object;>; )
public class java.io.ObjectStreamField extends java.lang.Object implements java.lang.Comparable

----------------FIELDS----------------

private boolean isDeserialized

private java.lang.String name

 int offset

private java.lang.Object type

private java.lang.String typeString

private boolean unshared
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/lang/String;Ljava/lang/Class<*>;)V )
public void <init>(
java.lang.String
java.lang.Class)
@dalvik.annotation.Signature (value =(Ljava/lang/String;Ljava/lang/Class<*>;Z)V )
public void <init>(
java.lang.String
java.lang.Class
boolean)

 void <init>(
java.lang.String
java.lang.String)

static void sortFields(
java.io.ObjectStreamField[])

public int compareTo(
java.lang.Object)

public boolean equals(
java.lang.Object)

public java.lang.String getName()

public int getOffset()
@dalvik.annotation.Signature (value =()Ljava/lang/Class<*>; )
public java.lang.Class getType()

public char getTypeCode()
@dalvik.annotation.Signature (value =()Ljava/lang/Class<*>; )
 java.lang.Class getTypeInternal()

public java.lang.String getTypeString()

public int hashCode()

public boolean isPrimitive()

public boolean isUnshared()

 void resolve(
java.lang.ClassLoader)

protected void setOffset(
int)

 void setUnshared(
boolean)

public java.lang.String toString()

________________CLASS________________


public class java.io.OptionalDataException extends java.io.ObjectStreamException

----------------FIELDS----------------

private static final long serialVersionUID

public boolean eof

public int length
----------------METHODS----------------

 void <init>()

 void <init>(
java.lang.String)

________________CLASS________________


public class java.io.PipedInputStream extends java.io.InputStream

----------------FIELDS----------------

protected static final int PIPE_SIZE

protected byte[] buffer

protected int in

private boolean isClosed

 boolean isConnected

private java.lang.Thread lastReader

private java.lang.Thread lastWriter

protected int out
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.io.PipedOutputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int available()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void connect(
java.io.PipedOutputStream)

 void done()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void receive(
int)

________________CLASS________________


public class java.io.PipedOutputStream extends java.io.OutputStream

----------------FIELDS----------------

private java.io.PipedInputStream dest
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.io.PipedInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void connect(
java.io.PipedInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void flush()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
byte[]
int
int)

________________CLASS________________


public class java.io.PipedReader extends java.io.Reader

----------------FIELDS----------------

private static final int PIPE_SIZE

private char[] data

private int in

private boolean isClosed

private boolean isConnected

private java.lang.Thread lastReader

private java.lang.Thread lastWriter

private int out
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.io.PipedWriter)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void connect(
java.io.PipedWriter)

 void done()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void establishConnection()

 void flush()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
char[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public boolean ready()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void receive(
char)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void receive(
char[]
int
int)

________________CLASS________________


public class java.io.PipedWriter extends java.io.Writer

----------------FIELDS----------------

private boolean closed

private java.io.PipedReader dest
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.io.PipedReader)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void connect(
java.io.PipedReader)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void flush()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
char[]
int
int)

________________CLASS________________


public class java.io.PrintStream extends java.io.FilterOutputStream implements java.lang.Appendable, java.io.Closeable

----------------FIELDS----------------

private static final java.lang.String TOKEN_NULL

private boolean autoflush

private java.lang.String encoding

private boolean ioError

private final java.lang.String lineSeparator
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/FileNotFoundException; )
public void <init>(
java.io.File)
@dalvik.annotation.Throws (value =Ljava/io/FileNotFoundException;Ljava/io/UnsupportedEncodingException; )
public void <init>(
java.io.File
java.lang.String)

public void <init>(
java.io.OutputStream)

public void <init>(
java.io.OutputStream
boolean)
@dalvik.annotation.Throws (value =Ljava/io/UnsupportedEncodingException; )
public void <init>(
java.io.OutputStream
boolean
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/FileNotFoundException; )
public void <init>(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/FileNotFoundException;Ljava/io/UnsupportedEncodingException; )
public void <init>(
java.lang.String
java.lang.String)

private void newline()

public java.io.PrintStream append(
char)

public java.io.PrintStream append(
java.lang.CharSequence)

public java.io.PrintStream append(
java.lang.CharSequence
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public volatile java.lang.Appendable append(
char)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public volatile java.lang.Appendable append(
java.lang.CharSequence)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public volatile java.lang.Appendable append(
java.lang.CharSequence
int
int)

public boolean checkError()

public void close()

public void flush()

public transient java.io.PrintStream format(
java.lang.String
java.lang.Object[])

public transient java.io.PrintStream format(
java.util.Locale
java.lang.String
java.lang.Object[])

public void print(
char)

public void print(
double)

public void print(
float)

public void print(
int)

public void print(
long)

public void print(
java.lang.Object)

public void print(
java.lang.String)

public void print(
boolean)

public void print(
char[])

public transient java.io.PrintStream printf(
java.lang.String
java.lang.Object[])

public transient java.io.PrintStream printf(
java.util.Locale
java.lang.String
java.lang.Object[])

public void println()

public void println(
char)

public void println(
double)

public void println(
float)

public void println(
int)

public void println(
long)

public void println(
java.lang.Object)

public void println(
java.lang.String)

public void println(
boolean)

public void println(
char[])

protected void setError()

public void write(
int)

public void write(
byte[]
int
int)

________________CLASS________________


public class java.io.PrintWriter extends java.io.Writer

----------------FIELDS----------------

private boolean autoflush

private boolean ioError

private final java.lang.String lineSeparator

protected java.io.Writer out
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/FileNotFoundException; )
public void <init>(
java.io.File)
@dalvik.annotation.Throws (value =Ljava/io/FileNotFoundException;Ljava/io/UnsupportedEncodingException; )
public void <init>(
java.io.File
java.lang.String)

public void <init>(
java.io.OutputStream)

public void <init>(
java.io.OutputStream
boolean)

public void <init>(
java.io.Writer)

public void <init>(
java.io.Writer
boolean)
@dalvik.annotation.Throws (value =Ljava/io/FileNotFoundException; )
public void <init>(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/FileNotFoundException;Ljava/io/UnsupportedEncodingException; )
public void <init>(
java.lang.String
java.lang.String)

private final void doWrite(
char[]
int
int)

private void newline()

public java.io.PrintWriter append(
char)

public java.io.PrintWriter append(
java.lang.CharSequence)

public java.io.PrintWriter append(
java.lang.CharSequence
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public volatile java.io.Writer append(
char)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public volatile java.io.Writer append(
java.lang.CharSequence)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public volatile java.io.Writer append(
java.lang.CharSequence
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public volatile java.lang.Appendable append(
char)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public volatile java.lang.Appendable append(
java.lang.CharSequence)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public volatile java.lang.Appendable append(
java.lang.CharSequence
int
int)

public boolean checkError()

public void close()

public void flush()

public transient java.io.PrintWriter format(
java.lang.String
java.lang.Object[])

public transient java.io.PrintWriter format(
java.util.Locale
java.lang.String
java.lang.Object[])

public void print(
char)

public void print(
double)

public void print(
float)

public void print(
int)

public void print(
long)

public void print(
java.lang.Object)

public void print(
java.lang.String)

public void print(
boolean)

public void print(
char[])

public transient java.io.PrintWriter printf(
java.lang.String
java.lang.Object[])

public transient java.io.PrintWriter printf(
java.util.Locale
java.lang.String
java.lang.Object[])

public void println()

public void println(
char)

public void println(
double)

public void println(
float)

public void println(
int)

public void println(
long)

public void println(
java.lang.Object)

public void println(
java.lang.String)

public void println(
boolean)

public void println(
char[])

protected void setError()

public void write(
int)

public void write(
java.lang.String)

public void write(
java.lang.String
int
int)

public void write(
char[])

public void write(
char[]
int
int)

________________CLASS________________


public class java.io.PushbackInputStream extends java.io.FilterInputStream

----------------FIELDS----------------

protected byte[] buf

protected int pos
----------------METHODS----------------

public void <init>(
java.io.InputStream)

public void <init>(
java.io.InputStream
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int available()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()

public void mark(
int)

public boolean markSupported()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void reset()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long skip(
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void unread(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void unread(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void unread(
byte[]
int
int)

________________CLASS________________


public class java.io.PushbackReader extends java.io.FilterReader

----------------FIELDS----------------

 char[] buf

 int pos
----------------METHODS----------------

public void <init>(
java.io.Reader)

public void <init>(
java.io.Reader
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void mark(
int)

public boolean markSupported()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
char[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public boolean ready()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void reset()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long skip(
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void unread(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void unread(
char[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void unread(
char[]
int
int)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/io/RandomAccessFile; )
@dalvik.annotation.InnerClass (accessFlags =4104 name =null )
 class java.io.RandomAccessFile$1 extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/io/RandomAccessFile; )
@dalvik.annotation.InnerClass (accessFlags =10 name =RepositionLock )
 class java.io.RandomAccessFile$RepositionLock extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

private void <init>()

 void <init>(
java.io.RandomAccessFile$1)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/io/RandomAccessFile$1;Ljava/io/RandomAccessFile$RepositionLock; )
public class java.io.RandomAccessFile extends java.lang.Object implements java.io.DataInput, java.io.DataOutput, java.io.Closeable

----------------FIELDS----------------

private java.nio.channels.FileChannel channel

private java.io.FileDescriptor fd

private org.apache.harmony.luni.platform.IFileSystem fileSystem

private boolean isReadOnly

private java.lang.Object repositionLock

private boolean syncMetadata
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/FileNotFoundException; )
public void <init>(
java.io.File
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/FileNotFoundException; )
public void <init>(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void openCheck()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()

public final java.nio.channels.FileChannel getChannel()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final java.io.FileDescriptor getFD()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long getFilePointer()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long length()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final boolean readBoolean()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final byte readByte()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final char readChar()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final double readDouble()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final float readFloat()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final void readFully(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final void readFully(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final int readInt()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final java.lang.String readLine()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final long readLong()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final short readShort()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final java.lang.String readUTF()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final int readUnsignedByte()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final int readUnsignedShort()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void seek(
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void setLength(
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int skipBytes(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final void writeBoolean(
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final void writeByte(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final void writeBytes(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final void writeChar(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final void writeChars(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final void writeDouble(
double)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final void writeFloat(
float)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final void writeInt(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final void writeLong(
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final void writeShort(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final void writeUTF(
java.lang.String)

________________CLASS________________


public class java.io.SequenceInputStream extends java.io.InputStream

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Enumeration<+Ljava/io/InputStream;>; )
private java.util.Enumeration e

private java.io.InputStream in
----------------METHODS----------------

public void <init>(
java.io.InputStream
java.io.InputStream)
@dalvik.annotation.Signature (value =(Ljava/util/Enumeration<+Ljava/io/InputStream;>;)V )
public void <init>(
java.util.Enumeration)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void nextStream()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int available()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[]
int
int)

________________CLASS________________


public abstract class java.security.BasicPermission extends java.security.Permission implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.String)

private final void checkName(
java.lang.String)

static boolean nameImplies(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)

public boolean equals(
java.lang.Object)

public java.lang.String getActions()

public int hashCode()

public boolean implies(
java.security.Permission)

public java.security.PermissionCollection newPermissionCollection()

________________CLASS________________


public final class java.io.SerializablePermission extends java.security.BasicPermission

----------------FIELDS----------------

private static final long serialVersionUID

private java.lang.String actions
----------------METHODS----------------

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.String)

________________CLASS________________


public class java.io.StreamCorruptedException extends java.io.ObjectStreamException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class java.io.StreamTokenizer extends java.lang.Object

----------------FIELDS----------------

private static final byte TOKEN_COMMENT

private static final byte TOKEN_DIGIT

private static final byte TOKEN_QUOTE

private static final byte TOKEN_WHITE

private static final byte TOKEN_WORD

public static final int TT_EOF

public static final int TT_EOL

public static final int TT_NUMBER

private static final int TT_UNKNOWN

public static final int TT_WORD

private boolean forceLowercase

private java.io.Reader inReader

private java.io.InputStream inStream

private boolean isEOLSignificant

private boolean lastCr

private int lineNumber

public double nval

private int peekChar

private boolean pushBackToken

private boolean slashSlashComments

private boolean slashStarComments

public java.lang.String sval

private byte[] tokenTypes

public int ttype
----------------METHODS----------------

private void <init>()
@java.lang.Deprecated
public void <init>(
java.io.InputStream)

public void <init>(
java.io.Reader)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private int read()

public void commentChar(
int)

public void eolIsSignificant(
boolean)

public int lineno()

public void lowerCaseMode(
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int nextToken()

public void ordinaryChar(
int)

public void ordinaryChars(
int
int)

public void parseNumbers()

public void pushBack()

public void quoteChar(
int)

public void resetSyntax()

public void slashSlashComments(
boolean)

public void slashStarComments(
boolean)

public java.lang.String toString()

public void whitespaceChars(
int
int)

public void wordChars(
int
int)

________________CLASS________________

@java.lang.Deprecated
public class java.io.StringBufferInputStream extends java.io.InputStream

----------------FIELDS----------------

protected java.lang.String buffer

protected int count

protected int pos
----------------METHODS----------------

public void <init>(
java.lang.String)

public int available()

public int read()

public int read(
byte[]
int
int)

public void reset()

public long skip(
long)

________________CLASS________________


public class java.io.StringReader extends java.io.Reader

----------------FIELDS----------------

private int count

private int markpos

private int pos

private java.lang.String str
----------------METHODS----------------

public void <init>(
java.lang.String)

private boolean isClosed()

public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void mark(
int)

public boolean markSupported()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
char[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public boolean ready()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void reset()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long skip(
long)

________________CLASS________________


public class java.io.StringWriter extends java.io.Writer

----------------FIELDS----------------

private java.lang.StringBuffer buf
----------------METHODS----------------

public void <init>()

public void <init>(
int)

public java.io.StringWriter append(
char)

public java.io.StringWriter append(
java.lang.CharSequence)

public java.io.StringWriter append(
java.lang.CharSequence
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public volatile java.io.Writer append(
char)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public volatile java.io.Writer append(
java.lang.CharSequence)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public volatile java.io.Writer append(
java.lang.CharSequence
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public volatile java.lang.Appendable append(
char)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public volatile java.lang.Appendable append(
java.lang.CharSequence)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public volatile java.lang.Appendable append(
java.lang.CharSequence
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()

public void flush()

public java.lang.StringBuffer getBuffer()

public java.lang.String toString()

public void write(
int)

public void write(
java.lang.String)

public void write(
java.lang.String
int
int)

public void write(
char[]
int
int)

________________CLASS________________


public class java.io.SyncFailedException extends java.io.IOException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>(
java.lang.String)

________________CLASS________________


public class java.io.UTFDataFormatException extends java.io.IOException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class java.io.UnsupportedEncodingException extends java.io.IOException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class java.io.WriteAbortedException extends java.io.ObjectStreamException

----------------FIELDS----------------

private static final long serialVersionUID

public java.lang.Exception detail
----------------METHODS----------------

public void <init>(
java.lang.String
java.lang.Exception)

public java.lang.Throwable getCause()

public java.lang.String getMessage()

________________CLASS________________


public class java.lang.LinkageError extends java.lang.Error

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class java.lang.IncompatibleClassChangeError extends java.lang.LinkageError

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class java.lang.AbstractMethodError extends java.lang.IncompatibleClassChangeError

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


abstract class java.lang.AbstractStringBuilder extends java.lang.Object

----------------FIELDS----------------

static final int INITIAL_CAPACITY

private int count

private boolean shared

private char[] value
----------------METHODS----------------

 void <init>()

 void <init>(
int)

 void <init>(
java.lang.String)

private void enlargeBuffer(
int)

private void move(
int
int)

final void append0(
char)

final void append0(
java.lang.CharSequence
int
int)

final void append0(
java.lang.String)

final void append0(
char[])

final void append0(
char[]
int
int)

final void appendNull()

public int capacity()

public char charAt(
int)

public int codePointAt(
int)

public int codePointBefore(
int)

public int codePointCount(
int
int)

final void delete0(
int
int)

final void deleteCharAt0(
int)

public void ensureCapacity(
int)

public void getChars(
int
int
char[]
int)

final char[] getValue()

public int indexOf(
java.lang.String)

public int indexOf(
java.lang.String
int)

final void insert0(
int
char)

final void insert0(
int
java.lang.CharSequence
int
int)

final void insert0(
int
java.lang.String)

final void insert0(
int
char[])

final void insert0(
int
char[]
int
int)

public int lastIndexOf(
java.lang.String)

public int lastIndexOf(
java.lang.String
int)

public int length()

public int offsetByCodePoints(
int
int)

final void replace0(
int
int
java.lang.String)

final void reverse0()
@dalvik.annotation.Throws (value =Ljava/io/InvalidObjectException; )
final void set(
char[]
int)

public void setCharAt(
int
char)

public void setLength(
int)

final char[] shareValue()

public java.lang.CharSequence subSequence(
int
int)

public java.lang.String substring(
int)

public java.lang.String substring(
int
int)

public java.lang.String toString()

public void trimToSize()

________________CLASS________________


public class java.lang.RuntimeException extends java.lang.Exception

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.Throwable)

public void <init>(
java.lang.Throwable)

________________CLASS________________


public class java.lang.ArithmeticException extends java.lang.RuntimeException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class java.lang.IndexOutOfBoundsException extends java.lang.RuntimeException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class java.lang.ArrayIndexOutOfBoundsException extends java.lang.IndexOutOfBoundsException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
int)

public void <init>(
java.lang.String)

________________CLASS________________


public class java.lang.ArrayStoreException extends java.lang.RuntimeException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class java.lang.AssertionError extends java.lang.Error

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
char)

public void <init>(
double)

public void <init>(
float)

public void <init>(
int)

public void <init>(
long)

public void <init>(
java.lang.Object)

public void <init>(
boolean)

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/io/Serializable;Ljava/lang/Comparable<Ljava/lang/Boolean;>; )
public final class java.lang.Boolean extends java.lang.Object implements java.io.Serializable, java.lang.Comparable

----------------FIELDS----------------

public static final java.lang.Boolean FALSE

public static final java.lang.Boolean TRUE
@dalvik.annotation.Signature (value =Ljava/lang/Class<Ljava/lang/Boolean;>; )
public static final java.lang.Class TYPE

private static final long serialVersionUID

private final boolean value
----------------METHODS----------------

static void <clinit>()

public void <init>(
java.lang.String)

public void <init>(
boolean)

public static boolean getBoolean(
java.lang.String)

public static boolean parseBoolean(
java.lang.String)

public static java.lang.String toString(
boolean)

public static java.lang.Boolean valueOf(
java.lang.String)

public static java.lang.Boolean valueOf(
boolean)

public boolean booleanValue()

public int compareTo(
java.lang.Boolean)

public volatile int compareTo(
java.lang.Object)

public boolean equals(
java.lang.Object)

public int hashCode()

public java.lang.String toString()

________________CLASS________________


 class java.lang.BootClassLoader extends java.lang.ClassLoader

----------------FIELDS----------------

static java.lang.BootClassLoader instance
----------------METHODS----------------

public void <init>()

public static java.lang.BootClassLoader getInstance()
@dalvik.annotation.Throws (value =Ljava/lang/ClassNotFoundException; )
@dalvik.annotation.Signature (value =(Ljava/lang/String;)Ljava/lang/Class<*>; )
protected java.lang.Class findClass(
java.lang.String)

protected java.net.URL findResource(
java.lang.String)
@dalvik.annotation.Signature (value =(Ljava/lang/String;)Ljava/util/Enumeration<Ljava/net/URL;>; )
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected java.util.Enumeration findResources(
java.lang.String)

protected java.lang.Package getPackage(
java.lang.String)

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Number;Ljava/lang/Comparable<Ljava/lang/Byte;>; )
public final class java.lang.Byte extends java.lang.Number implements java.lang.Comparable

----------------FIELDS----------------

private static final java.lang.Byte[] CACHE

public static final byte MAX_VALUE

public static final byte MIN_VALUE

public static final int SIZE
@dalvik.annotation.Signature (value =Ljava/lang/Class<Ljava/lang/Byte;>; )
public static final java.lang.Class TYPE

private static final long serialVersionUID

private final byte value
----------------METHODS----------------

static void <clinit>()

public void <init>(
byte)
@dalvik.annotation.Throws (value =Ljava/lang/NumberFormatException; )
public void <init>(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/lang/NumberFormatException; )
public static java.lang.Byte decode(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/lang/NumberFormatException; )
public static byte parseByte(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/lang/NumberFormatException; )
public static byte parseByte(
java.lang.String
int)

public static java.lang.String toString(
byte)

public static java.lang.Byte valueOf(
byte)
@dalvik.annotation.Throws (value =Ljava/lang/NumberFormatException; )
public static java.lang.Byte valueOf(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/lang/NumberFormatException; )
public static java.lang.Byte valueOf(
java.lang.String
int)

public byte byteValue()

public int compareTo(
java.lang.Byte)

public volatile int compareTo(
java.lang.Object)

public double doubleValue()

public boolean equals(
java.lang.Object)

public float floatValue()

public int hashCode()

public int intValue()

public long longValue()

public short shortValue()

public java.lang.String toString()

________________CLASS________________


public abstract interface class java.lang.CharSequence extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract char charAt(
int)

public abstract int length()

public abstract java.lang.CharSequence subSequence(
int
int)

public abstract java.lang.String toString()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =Subset )
@dalvik.annotation.EnclosingClass (value =Ljava/lang/Character; )
public class java.lang.Character$Subset extends java.lang.Object

----------------FIELDS----------------

 java.lang.String name
----------------METHODS----------------

protected void <init>(
java.lang.String)

public final boolean equals(
java.lang.Object)

public final int hashCode()

public final java.lang.String toString()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/lang/Character; )
@dalvik.annotation.InnerClass (accessFlags =25 name =UnicodeBlock )
public final class java.lang.Character$UnicodeBlock extends java.lang.Character$Subset

----------------FIELDS----------------

public static final java.lang.Character$UnicodeBlock AEGEAN_NUMBERS

public static final java.lang.Character$UnicodeBlock ALPHABETIC_PRESENTATION_FORMS

public static final java.lang.Character$UnicodeBlock ARABIC

public static final java.lang.Character$UnicodeBlock ARABIC_PRESENTATION_FORMS_A

public static final java.lang.Character$UnicodeBlock ARABIC_PRESENTATION_FORMS_B

public static final java.lang.Character$UnicodeBlock ARMENIAN

public static final java.lang.Character$UnicodeBlock ARROWS

public static final java.lang.Character$UnicodeBlock BASIC_LATIN

public static final java.lang.Character$UnicodeBlock BENGALI

private static java.lang.Character$UnicodeBlock[] BLOCKS

public static final java.lang.Character$UnicodeBlock BLOCK_ELEMENTS

public static final java.lang.Character$UnicodeBlock BOPOMOFO

public static final java.lang.Character$UnicodeBlock BOPOMOFO_EXTENDED

public static final java.lang.Character$UnicodeBlock BOX_DRAWING

public static final java.lang.Character$UnicodeBlock BRAILLE_PATTERNS

public static final java.lang.Character$UnicodeBlock BUHID

public static final java.lang.Character$UnicodeBlock BYZANTINE_MUSICAL_SYMBOLS

public static final java.lang.Character$UnicodeBlock CHEROKEE

public static final java.lang.Character$UnicodeBlock CJK_COMPATIBILITY

public static final java.lang.Character$UnicodeBlock CJK_COMPATIBILITY_FORMS

public static final java.lang.Character$UnicodeBlock CJK_COMPATIBILITY_IDEOGRAPHS

public static final java.lang.Character$UnicodeBlock CJK_COMPATIBILITY_IDEOGRAPHS_SUPPLEMENT

public static final java.lang.Character$UnicodeBlock CJK_RADICALS_SUPPLEMENT

public static final java.lang.Character$UnicodeBlock CJK_SYMBOLS_AND_PUNCTUATION

public static final java.lang.Character$UnicodeBlock CJK_UNIFIED_IDEOGRAPHS

public static final java.lang.Character$UnicodeBlock CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A

public static final java.lang.Character$UnicodeBlock CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B

public static final java.lang.Character$UnicodeBlock COMBINING_DIACRITICAL_MARKS

public static final java.lang.Character$UnicodeBlock COMBINING_HALF_MARKS

public static final java.lang.Character$UnicodeBlock COMBINING_MARKS_FOR_SYMBOLS

public static final java.lang.Character$UnicodeBlock CONTROL_PICTURES

public static final java.lang.Character$UnicodeBlock CURRENCY_SYMBOLS

public static final java.lang.Character$UnicodeBlock CYPRIOT_SYLLABARY

public static final java.lang.Character$UnicodeBlock CYRILLIC

public static final java.lang.Character$UnicodeBlock CYRILLIC_SUPPLEMENTARY

public static final java.lang.Character$UnicodeBlock DESERET

public static final java.lang.Character$UnicodeBlock DEVANAGARI

public static final java.lang.Character$UnicodeBlock DINGBATS

public static final java.lang.Character$UnicodeBlock ENCLOSED_ALPHANUMERICS

public static final java.lang.Character$UnicodeBlock ENCLOSED_CJK_LETTERS_AND_MONTHS

public static final java.lang.Character$UnicodeBlock ETHIOPIC

public static final java.lang.Character$UnicodeBlock GENERAL_PUNCTUATION

public static final java.lang.Character$UnicodeBlock GEOMETRIC_SHAPES

public static final java.lang.Character$UnicodeBlock GEORGIAN

public static final java.lang.Character$UnicodeBlock GOTHIC

public static final java.lang.Character$UnicodeBlock GREEK

public static final java.lang.Character$UnicodeBlock GREEK_EXTENDED

public static final java.lang.Character$UnicodeBlock GUJARATI

public static final java.lang.Character$UnicodeBlock GURMUKHI

public static final java.lang.Character$UnicodeBlock HALFWIDTH_AND_FULLWIDTH_FORMS

public static final java.lang.Character$UnicodeBlock HANGUL_COMPATIBILITY_JAMO

public static final java.lang.Character$UnicodeBlock HANGUL_JAMO

public static final java.lang.Character$UnicodeBlock HANGUL_SYLLABLES

public static final java.lang.Character$UnicodeBlock HANUNOO

public static final java.lang.Character$UnicodeBlock HEBREW

public static final java.lang.Character$UnicodeBlock HIGH_PRIVATE_USE_SURROGATES

public static final java.lang.Character$UnicodeBlock HIGH_SURROGATES

public static final java.lang.Character$UnicodeBlock HIRAGANA

public static final java.lang.Character$UnicodeBlock IDEOGRAPHIC_DESCRIPTION_CHARACTERS

public static final java.lang.Character$UnicodeBlock IPA_EXTENSIONS

public static final java.lang.Character$UnicodeBlock KANBUN

public static final java.lang.Character$UnicodeBlock KANGXI_RADICALS

public static final java.lang.Character$UnicodeBlock KANNADA

public static final java.lang.Character$UnicodeBlock KATAKANA

public static final java.lang.Character$UnicodeBlock KATAKANA_PHONETIC_EXTENSIONS

public static final java.lang.Character$UnicodeBlock KHMER

public static final java.lang.Character$UnicodeBlock KHMER_SYMBOLS

public static final java.lang.Character$UnicodeBlock LAO

public static final java.lang.Character$UnicodeBlock LATIN_1_SUPPLEMENT

public static final java.lang.Character$UnicodeBlock LATIN_EXTENDED_A

public static final java.lang.Character$UnicodeBlock LATIN_EXTENDED_ADDITIONAL

public static final java.lang.Character$UnicodeBlock LATIN_EXTENDED_B

public static final java.lang.Character$UnicodeBlock LETTERLIKE_SYMBOLS

public static final java.lang.Character$UnicodeBlock LIMBU

public static final java.lang.Character$UnicodeBlock LINEAR_B_IDEOGRAMS

public static final java.lang.Character$UnicodeBlock LINEAR_B_SYLLABARY

public static final java.lang.Character$UnicodeBlock LOW_SURROGATES

public static final java.lang.Character$UnicodeBlock MALAYALAM

public static final java.lang.Character$UnicodeBlock MATHEMATICAL_ALPHANUMERIC_SYMBOLS

public static final java.lang.Character$UnicodeBlock MATHEMATICAL_OPERATORS

public static final java.lang.Character$UnicodeBlock MISCELLANEOUS_MATHEMATICAL_SYMBOLS_A

public static final java.lang.Character$UnicodeBlock MISCELLANEOUS_MATHEMATICAL_SYMBOLS_B

public static final java.lang.Character$UnicodeBlock MISCELLANEOUS_SYMBOLS

public static final java.lang.Character$UnicodeBlock MISCELLANEOUS_SYMBOLS_AND_ARROWS

public static final java.lang.Character$UnicodeBlock MISCELLANEOUS_TECHNICAL

public static final java.lang.Character$UnicodeBlock MONGOLIAN

public static final java.lang.Character$UnicodeBlock MUSICAL_SYMBOLS

public static final java.lang.Character$UnicodeBlock MYANMAR

public static final java.lang.Character$UnicodeBlock NUMBER_FORMS

public static final java.lang.Character$UnicodeBlock OGHAM

public static final java.lang.Character$UnicodeBlock OLD_ITALIC

public static final java.lang.Character$UnicodeBlock OPTICAL_CHARACTER_RECOGNITION

public static final java.lang.Character$UnicodeBlock ORIYA

public static final java.lang.Character$UnicodeBlock OSMANYA

public static final java.lang.Character$UnicodeBlock PHONETIC_EXTENSIONS

public static final java.lang.Character$UnicodeBlock PRIVATE_USE_AREA

public static final java.lang.Character$UnicodeBlock RUNIC

public static final java.lang.Character$UnicodeBlock SHAVIAN

public static final java.lang.Character$UnicodeBlock SINHALA

public static final java.lang.Character$UnicodeBlock SMALL_FORM_VARIANTS

public static final java.lang.Character$UnicodeBlock SPACING_MODIFIER_LETTERS

public static final java.lang.Character$UnicodeBlock SPECIALS

public static final java.lang.Character$UnicodeBlock SUPERSCRIPTS_AND_SUBSCRIPTS

public static final java.lang.Character$UnicodeBlock SUPPLEMENTAL_ARROWS_A

public static final java.lang.Character$UnicodeBlock SUPPLEMENTAL_ARROWS_B

public static final java.lang.Character$UnicodeBlock SUPPLEMENTAL_MATHEMATICAL_OPERATORS

public static final java.lang.Character$UnicodeBlock SUPPLEMENTARY_PRIVATE_USE_AREA_A

public static final java.lang.Character$UnicodeBlock SUPPLEMENTARY_PRIVATE_USE_AREA_B
@java.lang.Deprecated
public static final java.lang.Character$UnicodeBlock SURROGATES_AREA

public static final java.lang.Character$UnicodeBlock SYRIAC

public static final java.lang.Character$UnicodeBlock TAGALOG

public static final java.lang.Character$UnicodeBlock TAGBANWA

public static final java.lang.Character$UnicodeBlock TAGS

public static final java.lang.Character$UnicodeBlock TAI_LE

public static final java.lang.Character$UnicodeBlock TAI_XUAN_JING_SYMBOLS

public static final java.lang.Character$UnicodeBlock TAMIL

public static final java.lang.Character$UnicodeBlock TELUGU

public static final java.lang.Character$UnicodeBlock THAANA

public static final java.lang.Character$UnicodeBlock THAI

public static final java.lang.Character$UnicodeBlock TIBETAN

public static final java.lang.Character$UnicodeBlock UGARITIC

public static final java.lang.Character$UnicodeBlock UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS

public static final java.lang.Character$UnicodeBlock VARIATION_SELECTORS

public static final java.lang.Character$UnicodeBlock VARIATION_SELECTORS_SUPPLEMENT

public static final java.lang.Character$UnicodeBlock YIJING_HEXAGRAM_SYMBOLS

public static final java.lang.Character$UnicodeBlock YI_RADICALS

public static final java.lang.Character$UnicodeBlock YI_SYLLABLES
----------------METHODS----------------

static void <clinit>()

private void <init>(
java.lang.String)

public static java.lang.Character$UnicodeBlock forName(
java.lang.String)

public static java.lang.Character$UnicodeBlock of(
char)

public static java.lang.Character$UnicodeBlock of(
int)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =valueOfCache )
@dalvik.annotation.EnclosingClass (value =Ljava/lang/Character; )
 class java.lang.Character$valueOfCache extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.Character[] CACHE
----------------METHODS----------------

static void <clinit>()

 void <init>()

static java.lang.Character[] access$000()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/io/Serializable;Ljava/lang/Comparable<Ljava/lang/Character;>; )
@dalvik.annotation.MemberClasses (value =Ljava/lang/Character$valueOfCache;Ljava/lang/Character$UnicodeBlock;Ljava/lang/Character$Subset; )
public final class java.lang.Character extends java.lang.Object implements java.io.Serializable, java.lang.Comparable

----------------FIELDS----------------

static final boolean $assertionsDisabled

private static final int CACHE_LEN

public static final byte COMBINING_SPACING_MARK

public static final byte CONNECTOR_PUNCTUATION

public static final byte CONTROL

public static final byte CURRENCY_SYMBOL

public static final byte DASH_PUNCTUATION

public static final byte DECIMAL_DIGIT_NUMBER

private static final byte[] DIRECTIONALITY

public static final byte DIRECTIONALITY_ARABIC_NUMBER

public static final byte DIRECTIONALITY_BOUNDARY_NEUTRAL

public static final byte DIRECTIONALITY_COMMON_NUMBER_SEPARATOR

public static final byte DIRECTIONALITY_EUROPEAN_NUMBER

public static final byte DIRECTIONALITY_EUROPEAN_NUMBER_SEPARATOR

public static final byte DIRECTIONALITY_EUROPEAN_NUMBER_TERMINATOR

public static final byte DIRECTIONALITY_LEFT_TO_RIGHT

public static final byte DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING

public static final byte DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE

public static final byte DIRECTIONALITY_NONSPACING_MARK

public static final byte DIRECTIONALITY_OTHER_NEUTRALS

public static final byte DIRECTIONALITY_PARAGRAPH_SEPARATOR

public static final byte DIRECTIONALITY_POP_DIRECTIONAL_FORMAT

public static final byte DIRECTIONALITY_RIGHT_TO_LEFT

public static final byte DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC

public static final byte DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING

public static final byte DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE

public static final byte DIRECTIONALITY_SEGMENT_SEPARATOR

public static final byte DIRECTIONALITY_UNDEFINED

public static final byte DIRECTIONALITY_WHITESPACE

public static final byte ENCLOSING_MARK

public static final byte END_PUNCTUATION

public static final byte FINAL_QUOTE_PUNCTUATION

public static final byte FORMAT

public static final byte INITIAL_QUOTE_PUNCTUATION

private static final int ISJAVAPART

private static final int ISJAVASTART

public static final byte LETTER_NUMBER

public static final byte LINE_SEPARATOR

public static final byte LOWERCASE_LETTER

public static final byte MATH_SYMBOL

public static final int MAX_CODE_POINT

public static final char MAX_HIGH_SURROGATE

public static final char MAX_LOW_SURROGATE

public static final int MAX_RADIX

public static final char MAX_SURROGATE

public static final char MAX_VALUE

public static final int MIN_CODE_POINT

public static final char MIN_HIGH_SURROGATE

public static final char MIN_LOW_SURROGATE

public static final int MIN_RADIX

public static final int MIN_SUPPLEMENTARY_CODE_POINT

public static final char MIN_SURROGATE

public static final char MIN_VALUE

public static final byte MODIFIER_LETTER

public static final byte MODIFIER_SYMBOL

public static final byte NON_SPACING_MARK

public static final byte OTHER_LETTER

public static final byte OTHER_NUMBER

public static final byte OTHER_PUNCTUATION

public static final byte OTHER_SYMBOL

public static final byte PARAGRAPH_SEPARATOR

public static final byte PRIVATE_USE

public static final int SIZE

public static final byte SPACE_SEPARATOR

public static final byte START_PUNCTUATION

public static final byte SURROGATE

public static final byte TITLECASE_LETTER
@dalvik.annotation.Signature (value =Ljava/lang/Class<Ljava/lang/Character;>; )
public static final java.lang.Class TYPE

public static final byte UNASSIGNED

public static final byte UPPERCASE_LETTER

private static final long serialVersionUID

private static final char[] typeTags

private final char value
----------------METHODS----------------

static void <clinit>()

public void <init>(
char)

public static int charCount(
int)

public static int codePointAt(
java.lang.CharSequence
int)

public static int codePointAt(
char[]
int)

public static int codePointAt(
char[]
int
int)

public static int codePointBefore(
java.lang.CharSequence
int)

public static int codePointBefore(
char[]
int)

public static int codePointBefore(
char[]
int
int)

public static int codePointCount(
java.lang.CharSequence
int
int)

public static int codePointCount(
char[]
int
int)

public static int digit(
char
int)

public static int digit(
int
int)

public static char forDigit(
int
int)

public static byte getDirectionality(
char)

public static byte getDirectionality(
int)

public static int getNumericValue(
char)

public static int getNumericValue(
int)

public static int getType(
char)

public static int getType(
int)

public static boolean isDefined(
char)

public static boolean isDefined(
int)

public static boolean isDigit(
char)

public static boolean isDigit(
int)

public static boolean isHighSurrogate(
char)

public static boolean isISOControl(
char)

public static boolean isISOControl(
int)

public static boolean isIdentifierIgnorable(
char)

public static boolean isIdentifierIgnorable(
int)

public static boolean isJavaIdentifierPart(
char)

public static boolean isJavaIdentifierPart(
int)

public static boolean isJavaIdentifierStart(
char)

public static boolean isJavaIdentifierStart(
int)
@java.lang.Deprecated
public static boolean isJavaLetter(
char)
@java.lang.Deprecated
public static boolean isJavaLetterOrDigit(
char)

public static boolean isLetter(
char)

public static boolean isLetter(
int)

public static boolean isLetterOrDigit(
char)

public static boolean isLetterOrDigit(
int)

public static boolean isLowSurrogate(
char)

public static boolean isLowerCase(
char)

public static boolean isLowerCase(
int)

public static boolean isMirrored(
char)

public static boolean isMirrored(
int)
@java.lang.Deprecated
public static boolean isSpace(
char)

public static boolean isSpaceChar(
char)

public static boolean isSpaceChar(
int)

public static boolean isSupplementaryCodePoint(
int)

public static boolean isSurrogatePair(
char
char)

public static boolean isTitleCase(
char)

public static boolean isTitleCase(
int)

public static boolean isUnicodeIdentifierPart(
char)

public static boolean isUnicodeIdentifierPart(
int)

public static boolean isUnicodeIdentifierStart(
char)

public static boolean isUnicodeIdentifierStart(
int)

public static boolean isUpperCase(
char)

public static boolean isUpperCase(
int)

public static boolean isValidCodePoint(
int)

public static boolean isWhitespace(
char)

public static boolean isWhitespace(
int)

public static int offsetByCodePoints(
java.lang.CharSequence
int
int)

public static int offsetByCodePoints(
char[]
int
int
int
int)

public static char reverseBytes(
char)

public static int toChars(
int
char[]
int)

public static char[] toChars(
int)

public static int toCodePoint(
char
char)

public static char toLowerCase(
char)

public static int toLowerCase(
int)

public static java.lang.String toString(
char)

public static char toTitleCase(
char)

public static int toTitleCase(
int)

public static char toUpperCase(
char)

public static int toUpperCase(
int)

public static java.lang.Character valueOf(
char)

public char charValue()

public int compareTo(
java.lang.Character)

public volatile int compareTo(
java.lang.Object)

public boolean equals(
java.lang.Object)

public int hashCode()

public java.lang.String toString()

________________CLASS________________


public abstract interface class java.lang.reflect.AnnotatedElement extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =<T::Ljava/lang/annotation/Annotation;>(Ljava/lang/Class<TT;>;)TT; )
public abstract java.lang.annotation.Annotation getAnnotation(
java.lang.Class)

public abstract java.lang.annotation.Annotation[] getAnnotations()

public abstract java.lang.annotation.Annotation[] getDeclaredAnnotations()
@dalvik.annotation.Signature (value =(Ljava/lang/Class<+Ljava/lang/annotation/Annotation;>;)Z )
public abstract boolean isAnnotationPresent(
java.lang.Class)

________________CLASS________________


public abstract interface class java.lang.reflect.GenericDeclaration extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =()[Ljava/lang/reflect/TypeVariable<*>; )
public abstract java.lang.reflect.TypeVariable[] getTypeParameters()

________________CLASS________________


public abstract interface class java.lang.reflect.Type extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>Ljava/lang/Object;Ljava/io/Serializable;Ljava/lang/reflect/AnnotatedElement;Ljava/lang/reflect/GenericDeclaration;Ljava/lang/reflect/Type; )
public final class java.lang.Class extends java.lang.Object implements java.io.Serializable, java.lang.reflect.AnnotatedElement, java.lang.reflect.GenericDeclaration, java.lang.reflect.Type

----------------FIELDS----------------

private static final long serialVersionUID
@dalvik.annotation.Signature (value =Ljava/lang/ref/SoftReference<Ljava/lang/ClassCache<TT;>;>; )
private volatile java.lang.ref.SoftReference cacheRef

private java.security.ProtectionDomain pd
----------------METHODS----------------

private void <init>()
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>([TT;[TT;[TT;)[TT; )
private static java.lang.Object[] arraycopy(
java.lang.Object[]
java.lang.Object[]
java.lang.Object[])

private void checkDeclaredMemberAccess()
@dalvik.annotation.Signature (value =(Ljava/lang/String;ZLjava/lang/ClassLoader;)Ljava/lang/Class<*>; )
@dalvik.annotation.Throws (value =Ljava/lang/ClassNotFoundException; )
static native java.lang.Class classForName(
java.lang.String
boolean
java.lang.ClassLoader)
@dalvik.annotation.Signature (value =(Ljava/lang/String;)Ljava/lang/Class<*>; )
@dalvik.annotation.Throws (value =Ljava/lang/ClassNotFoundException; )
public static java.lang.Class forName(
java.lang.String)
@dalvik.annotation.Signature (value =(Ljava/lang/String;ZLjava/lang/ClassLoader;)Ljava/lang/Class<*>; )
@dalvik.annotation.Throws (value =Ljava/lang/ClassNotFoundException; )
public static java.lang.Class forName(
java.lang.String
boolean
java.lang.ClassLoader)
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;)Ljava/lang/ClassLoader; )
private static native java.lang.ClassLoader getClassLoader(
java.lang.Class)
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;Z)[Ljava/lang/Class<*>; )
private static native java.lang.Class[] getDeclaredClasses(
java.lang.Class
boolean)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/lang/Class<TT;>;Z)[Ljava/lang/reflect/Constructor<TT;>; )
private static native java.lang.reflect.Constructor[] getDeclaredConstructors(
java.lang.Class
boolean)
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;Z)[Ljava/lang/reflect/Field; )
static native java.lang.reflect.Field[] getDeclaredFields(
java.lang.Class
boolean)
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;Z)[Ljava/lang/reflect/Method; )
static native java.lang.reflect.Method[] getDeclaredMethods(
java.lang.Class
boolean)
@dalvik.annotation.Signature (value =(Z)[Ljava/lang/Class<*>; )
private java.lang.Class[] getFullListOfClasses(
boolean)

private java.lang.reflect.Field[] getFullListOfFields(
boolean)

private native java.lang.String getInnerClassName()
@dalvik.annotation.Throws (value =Ljava/lang/NoSuchMethodException; )
@dalvik.annotation.Signature (value =([Ljava/lang/reflect/Constructor<TT;>;[Ljava/lang/Class<*>;)Ljava/lang/reflect/Constructor<TT;>; )
private java.lang.reflect.Constructor getMatchingConstructor(
java.lang.reflect.Constructor[]
java.lang.Class[])
@dalvik.annotation.Throws (value =Ljava/lang/NoSuchFieldException; )
private static java.lang.reflect.Field getMatchingField(
java.lang.reflect.Field[]
java.lang.String)
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;Z)I )
private static native int getModifiers(
java.lang.Class
boolean)

private native java.lang.Object[] getSignatureAnnotation()

private java.lang.String getSignatureAttribute()
@dalvik.annotation.Signature (value =(IZ)[Ljava/lang/Class<*>; )
static final java.lang.Class[] getStackClasses(
int
boolean)

static native void setAccessibleNoCheck(
java.lang.reflect.AccessibleObject
boolean)
@dalvik.annotation.Signature (value =<U:Ljava/lang/Object;>(Ljava/lang/Class<TU;>;)Ljava/lang/Class<+TU;>; )
public java.lang.Class asSubclass(
java.lang.Class)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;)TT; )
public java.lang.Object cast(
java.lang.Object)

 void checkPublicMemberAccess()

public native boolean desiredAssertionStatus()
@dalvik.annotation.Signature (value =<A::Ljava/lang/annotation/Annotation;>(Ljava/lang/Class<TA;>;)TA; )
public java.lang.annotation.Annotation getAnnotation(
java.lang.Class)

public java.lang.annotation.Annotation[] getAnnotations()

public java.lang.String getCanonicalName()
@dalvik.annotation.Signature (value =()Ljava/lang/ClassCache<TT;>; )
 java.lang.ClassCache getClassCache()

public java.lang.ClassLoader getClassLoader()

 java.lang.ClassLoader getClassLoaderImpl()
@dalvik.annotation.Signature (value =()[Ljava/lang/Class<*>; )
public java.lang.Class[] getClasses()
@dalvik.annotation.Signature (value =()Ljava/lang/Class<*>; )
public native java.lang.Class getComponentType()
@dalvik.annotation.Throws (value =Ljava/lang/NoSuchMethodException;Ljava/lang/SecurityException; )
@dalvik.annotation.Signature (value =([Ljava/lang/Class;)Ljava/lang/reflect/Constructor<TT;>; )
public transient java.lang.reflect.Constructor getConstructor(
java.lang.Class[])
@dalvik.annotation.Throws (value =Ljava/lang/SecurityException; )
@dalvik.annotation.Signature (value =()[Ljava/lang/reflect/Constructor<TT;>; )
public java.lang.reflect.Constructor[] getConstructors()

public native java.lang.annotation.Annotation[] getDeclaredAnnotations()
@dalvik.annotation.Signature (value =()[Ljava/lang/Class<*>; )
@dalvik.annotation.Throws (value =Ljava/lang/SecurityException; )
public java.lang.Class[] getDeclaredClasses()
@dalvik.annotation.Signature (value =([Ljava/lang/Class;)Ljava/lang/reflect/Constructor<TT;>; )
@dalvik.annotation.Throws (value =Ljava/lang/NoSuchMethodException;Ljava/lang/SecurityException; )
public transient java.lang.reflect.Constructor getDeclaredConstructor(
java.lang.Class[])
@dalvik.annotation.Throws (value =Ljava/lang/SecurityException; )
@dalvik.annotation.Signature (value =()[Ljava/lang/reflect/Constructor<TT;>; )
public java.lang.reflect.Constructor[] getDeclaredConstructors()
@dalvik.annotation.Throws (value =Ljava/lang/NoSuchFieldException;Ljava/lang/SecurityException; )
public java.lang.reflect.Field getDeclaredField(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/lang/SecurityException; )
public java.lang.reflect.Field[] getDeclaredFields()
@dalvik.annotation.Throws (value =Ljava/lang/NoSuchMethodException;Ljava/lang/SecurityException; )
public transient java.lang.reflect.Method getDeclaredMethod(
java.lang.String
java.lang.Class[])
@dalvik.annotation.Throws (value =Ljava/lang/SecurityException; )
public java.lang.reflect.Method[] getDeclaredMethods()
@dalvik.annotation.Signature (value =()Ljava/lang/Class<*>; )
public native java.lang.Class getDeclaringClass()
@dalvik.annotation.Signature (value =()Ljava/lang/Class<*>; )
public native java.lang.Class getEnclosingClass()
@dalvik.annotation.Signature (value =()Ljava/lang/reflect/Constructor<*>; )
public native java.lang.reflect.Constructor getEnclosingConstructor()

public native java.lang.reflect.Method getEnclosingMethod()
@dalvik.annotation.Signature (value =()[TT; )
public java.lang.Object[] getEnumConstants()
@dalvik.annotation.Throws (value =Ljava/lang/NoSuchFieldException;Ljava/lang/SecurityException; )
public java.lang.reflect.Field getField(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/lang/SecurityException; )
public java.lang.reflect.Field[] getFields()

public java.lang.reflect.Type[] getGenericInterfaces()

public java.lang.reflect.Type getGenericSuperclass()
@dalvik.annotation.Signature (value =()[Ljava/lang/Class<*>; )
public native java.lang.Class[] getInterfaces()
@dalvik.annotation.Throws (value =Ljava/lang/NoSuchMethodException;Ljava/lang/SecurityException; )
public transient java.lang.reflect.Method getMethod(
java.lang.String
java.lang.Class[])
@dalvik.annotation.Throws (value =Ljava/lang/SecurityException; )
public java.lang.reflect.Method[] getMethods()

public int getModifiers()

public native java.lang.String getName()

public java.lang.Package getPackage()

public java.security.ProtectionDomain getProtectionDomain()

public java.net.URL getResource(
java.lang.String)

public java.io.InputStream getResourceAsStream(
java.lang.String)

public java.lang.Object[] getSigners()

public java.lang.String getSimpleName()
@dalvik.annotation.Signature (value =()Ljava/lang/Class<-TT;>; )
public native java.lang.Class getSuperclass()
@dalvik.annotation.Signature (value =()[Ljava/lang/reflect/TypeVariable<Ljava/lang/Class<TT;>;>; )
public java.lang.reflect.TypeVariable[] getTypeParameters()

public boolean isAnnotation()
@dalvik.annotation.Signature (value =(Ljava/lang/Class<+Ljava/lang/annotation/Annotation;>;)Z )
public boolean isAnnotationPresent(
java.lang.Class)

public native boolean isAnonymousClass()

public boolean isArray()
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;)Z )
public native boolean isAssignableFrom(
java.lang.Class)

public boolean isEnum()

public native boolean isInstance(
java.lang.Object)

public native boolean isInterface()

public boolean isLocalClass()

public boolean isMemberClass()

public native boolean isPrimitive()

public boolean isSynthetic()
@dalvik.annotation.Throws (value =Ljava/lang/IllegalAccessException;Ljava/lang/InstantiationException; )
@dalvik.annotation.Signature (value =()TT; )
public native java.lang.Object newInstance()

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/lang/ClassCache; )
@dalvik.annotation.InnerClass (accessFlags =4104 name =null )
 class java.lang.ClassCache$1 extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Comparator<Ljava/lang/Enum<*>;>; )
@dalvik.annotation.InnerClass (accessFlags =10 name =EnumComparator )
@dalvik.annotation.EnclosingClass (value =Ljava/lang/ClassCache; )
 class java.lang.ClassCache$EnumComparator extends java.lang.Object implements java.util.Comparator

----------------FIELDS----------------
----------------METHODS----------------

private void <init>()

 void <init>(
java.lang.ClassCache$1)
@dalvik.annotation.Signature (value =(Ljava/lang/Enum<*>;Ljava/lang/Enum<*>;)I )
public int compare(
java.lang.Enum
java.lang.Enum)

public volatile int compare(
java.lang.Object
java.lang.Object)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/lang/ClassCache$1;Ljava/lang/ClassCache$EnumComparator; )
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>Ljava/lang/Object; )
 class java.lang.ClassCache extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.ClassCache$EnumComparator ENUM_COMPARATOR

static final org.apache.harmony.kernel.vm.ReflectionAccess REFLECT

private volatile java.lang.reflect.Method[] allMethods

private volatile java.lang.reflect.Method[] allPublicMethods
@dalvik.annotation.Signature (value =Ljava/lang/Class<TT;>; )
private final java.lang.Class clazz

private volatile java.lang.reflect.Method[] declaredMethods

private volatile java.lang.reflect.Method[] declaredPublicMethods
@dalvik.annotation.Signature (value =[TT; )
private volatile java.lang.Object[] enumValuesByName
@dalvik.annotation.Signature (value =[TT; )
private volatile java.lang.Object[] enumValuesInOrder
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Signature (value =(Ljava/lang/Class<TT;>;)V )
 void <init>(
java.lang.Class)
@dalvik.annotation.Signature (value =()[TT; )
private java.lang.Object[] callEnumValues()
@dalvik.annotation.Signature (value =([Ljava/lang/Class<*>;[Ljava/lang/Class<*>;)Z )
public static boolean compareClassLists(
java.lang.Class[]
java.lang.Class[])

public static java.lang.reflect.Method[] deepCopy(
java.lang.reflect.Method[])
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;Ljava/util/ArrayList<Ljava/lang/reflect/Method;>;Ljava/util/HashSet<Ljava/lang/String;>;Z)V )
private static void getFullListOfMethods(
java.lang.Class
java.util.ArrayList
java.util.HashSet
boolean)

private java.lang.reflect.Method[] getFullListOfMethods(
boolean)
@dalvik.annotation.Throws (value =Ljava/lang/NoSuchMethodException; )
@dalvik.annotation.Signature (value =([Ljava/lang/reflect/Method;Ljava/lang/String;[Ljava/lang/Class<*>;)Ljava/lang/reflect/Method; )
public static java.lang.reflect.Method getMatchingMethod(
java.lang.reflect.Method[]
java.lang.String
java.lang.Class[])

private static org.apache.harmony.kernel.vm.ReflectionAccess getReflectionAccess()

public java.lang.reflect.Method[] getAllMethods()

public java.lang.reflect.Method[] getAllPublicMethods()

public java.lang.reflect.Method[] getDeclaredMethods()

public java.lang.reflect.Method[] getDeclaredMethods(
boolean)

public java.lang.reflect.Method[] getDeclaredPublicMethods()
@dalvik.annotation.Signature (value =(Ljava/lang/String;)TT; )
public java.lang.Object getEnumValue(
java.lang.String)
@dalvik.annotation.Signature (value =()[TT; )
public java.lang.Object[] getEnumValuesByName()
@dalvik.annotation.Signature (value =()[TT; )
public java.lang.Object[] getEnumValuesInOrder()

________________CLASS________________


public class java.lang.ClassCastException extends java.lang.RuntimeException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;Ljava/lang/Class<*>;)V )
 void <init>(
java.lang.Class
java.lang.Class)

public void <init>(
java.lang.String)

________________CLASS________________


public class java.lang.ClassCircularityError extends java.lang.LinkageError

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class java.lang.ClassFormatError extends java.lang.LinkageError

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/lang/ClassLoader; )
@dalvik.annotation.InnerClass (accessFlags =10 name =SystemClassLoader )
 class java.lang.ClassLoader$SystemClassLoader extends java.lang.Object

----------------FIELDS----------------

public static java.lang.ClassLoader loader
----------------METHODS----------------

static void <clinit>()

private void <init>()

________________CLASS________________


public class java.lang.ClassNotFoundException extends java.lang.Exception

----------------FIELDS----------------

private static final long serialVersionUID

private java.lang.Throwable ex
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.Throwable)

public java.lang.Throwable getCause()

public java.lang.Throwable getException()

________________CLASS________________


public class java.lang.CloneNotSupportedException extends java.lang.Exception

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public final class java.lang.Compiler extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

private void <init>()

public static java.lang.Object command(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;)Z )
public static boolean compileClass(
java.lang.Class)

public static boolean compileClasses(
java.lang.String)

public static void disable()

public static void enable()

________________CLASS________________

@java.lang.annotation.Documented
@java.lang.annotation.Retention (value =Ljava/lang/annotation/RetentionPolicy;!RUNTIME )
public abstract interface class java.lang.Deprecated extends java.lang.Object implements java.lang.annotation.Annotation

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Number;Ljava/lang/Comparable<Ljava/lang/Double;>; )
public final class java.lang.Double extends java.lang.Number implements java.lang.Comparable

----------------FIELDS----------------

public static final double MAX_VALUE

public static final double MIN_VALUE

public static final double NEGATIVE_INFINITY

public static final double NaN

public static final double POSITIVE_INFINITY

public static final int SIZE
@dalvik.annotation.Signature (value =Ljava/lang/Class<Ljava/lang/Double;>; )
public static final java.lang.Class TYPE

private static final long serialVersionUID

private final double value
----------------METHODS----------------

static void <clinit>()

public void <init>(
double)
@dalvik.annotation.Throws (value =Ljava/lang/NumberFormatException; )
public void <init>(
java.lang.String)

public static int compare(
double
double)

public static native long doubleToLongBits(
double)

public static native long doubleToRawLongBits(
double)

public static boolean isInfinite(
double)

public static boolean isNaN(
double)

public static native double longBitsToDouble(
long)
@dalvik.annotation.Throws (value =Ljava/lang/NumberFormatException; )
public static double parseDouble(
java.lang.String)

public static java.lang.String toHexString(
double)

public static java.lang.String toString(
double)

public static java.lang.Double valueOf(
double)
@dalvik.annotation.Throws (value =Ljava/lang/NumberFormatException; )
public static java.lang.Double valueOf(
java.lang.String)

public byte byteValue()

public int compareTo(
java.lang.Double)

public volatile int compareTo(
java.lang.Object)

public double doubleValue()

public boolean equals(
java.lang.Object)

public float floatValue()

public int hashCode()

public int intValue()

public boolean isInfinite()

public boolean isNaN()

public long longValue()

public short shortValue()

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Enumeration<Ljava/net/URL;>;Ljava/io/Serializable; )
final class java.lang.EmptyEnumeration extends java.lang.Object implements java.util.Enumeration, java.io.Serializable

----------------FIELDS----------------

private static final java.lang.EmptyEnumeration mInst
----------------METHODS----------------

static void <clinit>()

private void <init>()

public static java.lang.EmptyEnumeration getInstance()

public boolean hasMoreElements()

public volatile java.lang.Object nextElement()

public java.net.URL nextElement()

________________CLASS________________

@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>Ljava/lang/Object; )
public abstract interface class java.security.PrivilegedExceptionAction extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =()TT; )
@dalvik.annotation.Throws (value =Ljava/lang/Exception; )
public abstract java.lang.Object run()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedExceptionAction<Ljava/lang/reflect/Method;>; )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class java.lang.Enum$1 extends java.lang.Object implements java.security.PrivilegedExceptionAction

----------------FIELDS----------------

final java.lang.Class val$enumType
----------------METHODS----------------

 void <init>(
java.lang.Class)
@dalvik.annotation.Throws (value =Ljava/lang/Exception; )
public volatile java.lang.Object run()
@dalvik.annotation.Throws (value =Ljava/lang/Exception; )
public java.lang.reflect.Method run()

________________CLASS________________


public class java.lang.EnumConstantNotPresentException extends java.lang.RuntimeException

----------------FIELDS----------------

private static final long serialVersionUID

private final java.lang.String constantName
@dalvik.annotation.Signature (value =Ljava/lang/Class<+Ljava/lang/Enum;>; )
private final java.lang.Class enumType
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/lang/Class<+Ljava/lang/Enum;>;Ljava/lang/String;)V )
public void <init>(
java.lang.Class
java.lang.String)

public java.lang.String constantName()
@dalvik.annotation.Signature (value =()Ljava/lang/Class<+Ljava/lang/Enum;>; )
public java.lang.Class enumType()

________________CLASS________________


public class java.lang.ExceptionInInitializerError extends java.lang.LinkageError

----------------FIELDS----------------

private static final long serialVersionUID

private java.lang.Throwable exception
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.Throwable)

public java.lang.Throwable getCause()

public java.lang.Throwable getException()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Number;Ljava/lang/Comparable<Ljava/lang/Float;>; )
public final class java.lang.Float extends java.lang.Number implements java.lang.Comparable

----------------FIELDS----------------

public static final float MAX_VALUE

public static final float MIN_VALUE

public static final float NEGATIVE_INFINITY

public static final float NaN

public static final float POSITIVE_INFINITY

public static final int SIZE
@dalvik.annotation.Signature (value =Ljava/lang/Class<Ljava/lang/Float;>; )
public static final java.lang.Class TYPE

private static final long serialVersionUID

private final float value
----------------METHODS----------------

static void <clinit>()

public void <init>(
double)

public void <init>(
float)
@dalvik.annotation.Throws (value =Ljava/lang/NumberFormatException; )
public void <init>(
java.lang.String)

public static int compare(
float
float)

public static native int floatToIntBits(
float)

public static native int floatToRawIntBits(
float)

public static native float intBitsToFloat(
int)

public static boolean isInfinite(
float)

public static boolean isNaN(
float)
@dalvik.annotation.Throws (value =Ljava/lang/NumberFormatException; )
public static float parseFloat(
java.lang.String)

public static java.lang.String toHexString(
float)

public static java.lang.String toString(
float)

public static java.lang.Float valueOf(
float)
@dalvik.annotation.Throws (value =Ljava/lang/NumberFormatException; )
public static java.lang.Float valueOf(
java.lang.String)

public byte byteValue()

public int compareTo(
java.lang.Float)

public volatile int compareTo(
java.lang.Object)

public double doubleValue()

public boolean equals(
java.lang.Object)

public float floatValue()

public int hashCode()

public int intValue()

public boolean isInfinite()

public boolean isNaN()

public long longValue()

public short shortValue()

public java.lang.String toString()

________________CLASS________________


public class java.lang.IllegalAccessError extends java.lang.IncompatibleClassChangeError

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class java.lang.IllegalAccessException extends java.lang.Exception

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class java.lang.IllegalArgumentException extends java.lang.RuntimeException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.Throwable)

public void <init>(
java.lang.Throwable)

________________CLASS________________


public class java.lang.IllegalMonitorStateException extends java.lang.RuntimeException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class java.lang.IllegalStateException extends java.lang.RuntimeException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.Throwable)

public void <init>(
java.lang.Throwable)

________________CLASS________________


public class java.lang.IllegalThreadStateException extends java.lang.IllegalArgumentException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________

@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>Ljava/lang/Object; )
@dalvik.annotation.MemberClasses (value =Ljava/lang/ThreadLocal$Values; )
public class java.lang.ThreadLocal extends java.lang.Object

----------------FIELDS----------------

private static java.util.concurrent.atomic.AtomicInteger hashCounter

private final int hash
@dalvik.annotation.Signature (value =Ljava/lang/ref/Reference<Ljava/lang/ThreadLocal<TT;>;>; )
private final java.lang.ref.Reference reference
----------------METHODS----------------

static void <clinit>()

public void <init>()

static int access$200(
java.lang.ThreadLocal)

static java.lang.ref.Reference access$300(
java.lang.ThreadLocal)
@dalvik.annotation.Signature (value =()TT; )
public java.lang.Object get()
@dalvik.annotation.Signature (value =()TT; )
protected java.lang.Object initialValue()

 java.lang.ThreadLocal$Values initializeValues(
java.lang.Thread)

public void remove()
@dalvik.annotation.Signature (value =(TT;)V )
public void set(
java.lang.Object)

 java.lang.ThreadLocal$Values values(
java.lang.Thread)

________________CLASS________________

@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>Ljava/lang/ThreadLocal<TT;>; )
public class java.lang.InheritableThreadLocal extends java.lang.ThreadLocal

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Signature (value =(TT;)TT; )
protected java.lang.Object childValue(
java.lang.Object)

 java.lang.ThreadLocal$Values initializeValues(
java.lang.Thread)

 java.lang.ThreadLocal$Values values(
java.lang.Thread)

________________CLASS________________


public class java.lang.InstantiationError extends java.lang.IncompatibleClassChangeError

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;)V )
 void <init>(
java.lang.Class)

public void <init>(
java.lang.String)

________________CLASS________________


public class java.lang.InstantiationException extends java.lang.Exception

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;)V )
 void <init>(
java.lang.Class)

public void <init>(
java.lang.String)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =valueOfCache )
@dalvik.annotation.EnclosingClass (value =Ljava/lang/Integer; )
 class java.lang.Integer$valueOfCache extends java.lang.Object

----------------FIELDS----------------

static final java.lang.Integer[] CACHE
----------------METHODS----------------

static void <clinit>()

 void <init>()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Number;Ljava/lang/Comparable<Ljava/lang/Integer;>; )
@dalvik.annotation.MemberClasses (value =Ljava/lang/Integer$valueOfCache; )
public final class java.lang.Integer extends java.lang.Number implements java.lang.Comparable

----------------FIELDS----------------

public static final int MAX_VALUE

public static final int MIN_VALUE

public static final int SIZE
@dalvik.annotation.Signature (value =Ljava/lang/Class<Ljava/lang/Integer;>; )
public static final java.lang.Class TYPE

private static final long serialVersionUID

private final int value
----------------METHODS----------------

static void <clinit>()

public void <init>(
int)
@dalvik.annotation.Throws (value =Ljava/lang/NumberFormatException; )
public void <init>(
java.lang.String)

public static int bitCount(
int)
@dalvik.annotation.Throws (value =Ljava/lang/NumberFormatException; )
public static java.lang.Integer decode(
java.lang.String)

public static java.lang.Integer getInteger(
java.lang.String)

public static java.lang.Integer getInteger(
java.lang.String
int)

public static java.lang.Integer getInteger(
java.lang.String
java.lang.Integer)

public static int highestOneBit(
int)

public static int lowestOneBit(
int)

public static int numberOfLeadingZeros(
int)

public static int numberOfTrailingZeros(
int)
@dalvik.annotation.Throws (value =Ljava/lang/NumberFormatException; )
private static int parse(
java.lang.String
int
int
boolean)
@dalvik.annotation.Throws (value =Ljava/lang/NumberFormatException; )
public static int parseInt(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/lang/NumberFormatException; )
public static int parseInt(
java.lang.String
int)

public static int reverse(
int)

public static int reverseBytes(
int)

public static int rotateLeft(
int
int)

public static int rotateRight(
int
int)

public static int signum(
int)

public static java.lang.String toBinaryString(
int)

public static java.lang.String toHexString(
int)

public static java.lang.String toOctalString(
int)

public static java.lang.String toString(
int)

public static java.lang.String toString(
int
int)

public static java.lang.Integer valueOf(
int)
@dalvik.annotation.Throws (value =Ljava/lang/NumberFormatException; )
public static java.lang.Integer valueOf(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/lang/NumberFormatException; )
public static java.lang.Integer valueOf(
java.lang.String
int)

public byte byteValue()

public int compareTo(
java.lang.Integer)

public volatile int compareTo(
java.lang.Object)

public double doubleValue()

public boolean equals(
java.lang.Object)

public float floatValue()

public int hashCode()

public int intValue()

public long longValue()

public short shortValue()

public java.lang.String toString()

________________CLASS________________


public class java.lang.InternalError extends java.lang.VirtualMachineError

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class java.lang.InterruptedException extends java.lang.Exception

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________

@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>Ljava/lang/Object; )
public abstract interface class java.lang.Iterable extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TT;>; )
public abstract java.util.Iterator iterator()

________________CLASS________________


public abstract class org.apache.harmony.kernel.vm.LangAccess extends java.lang.Object

----------------FIELDS----------------

private static org.apache.harmony.kernel.vm.LangAccess theInstance
----------------METHODS----------------

static void <clinit>()

public void <init>()

public static org.apache.harmony.kernel.vm.LangAccess getInstance()

public static void setInstance(
org.apache.harmony.kernel.vm.LangAccess)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/lang/Class<TT;>;)[TT; )
public abstract java.lang.Object[] getEnumValuesInOrder(
java.lang.Class)

public abstract void parkFor(
long)

public abstract void parkUntil(
long)

public abstract void unpark(
java.lang.Thread)

________________CLASS________________


final class java.lang.LangAccessImpl extends org.apache.harmony.kernel.vm.LangAccess

----------------FIELDS----------------

static final java.lang.LangAccessImpl THE_ONE
----------------METHODS----------------

static void <clinit>()

private void <init>()
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/lang/Class<TT;>;)[TT; )
public java.lang.Object[] getEnumValuesInOrder(
java.lang.Class)

public void parkFor(
long)

public void parkUntil(
long)

public void unpark(
java.lang.Thread)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =valueOfCache )
@dalvik.annotation.EnclosingClass (value =Ljava/lang/Long; )
 class java.lang.Long$valueOfCache extends java.lang.Object

----------------FIELDS----------------

static final java.lang.Long[] CACHE
----------------METHODS----------------

static void <clinit>()

 void <init>()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Number;Ljava/lang/Comparable<Ljava/lang/Long;>; )
@dalvik.annotation.MemberClasses (value =Ljava/lang/Long$valueOfCache; )
public final class java.lang.Long extends java.lang.Number implements java.lang.Comparable

----------------FIELDS----------------

public static final long MAX_VALUE

public static final long MIN_VALUE

public static final int SIZE
@dalvik.annotation.Signature (value =Ljava/lang/Class<Ljava/lang/Long;>; )
public static final java.lang.Class TYPE

private static final long serialVersionUID

private final long value
----------------METHODS----------------

static void <clinit>()

public void <init>(
long)
@dalvik.annotation.Throws (value =Ljava/lang/NumberFormatException; )
public void <init>(
java.lang.String)

public static int bitCount(
long)
@dalvik.annotation.Throws (value =Ljava/lang/NumberFormatException; )
public static java.lang.Long decode(
java.lang.String)

public static java.lang.Long getLong(
java.lang.String)

public static java.lang.Long getLong(
java.lang.String
long)

public static java.lang.Long getLong(
java.lang.String
java.lang.Long)

public static long highestOneBit(
long)

public static long lowestOneBit(
long)

public static int numberOfLeadingZeros(
long)

public static int numberOfTrailingZeros(
long)

private static long parse(
java.lang.String
int
int
boolean)
@dalvik.annotation.Throws (value =Ljava/lang/NumberFormatException; )
public static long parseLong(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/lang/NumberFormatException; )
public static long parseLong(
java.lang.String
int)

public static long reverse(
long)

public static long reverseBytes(
long)

public static long rotateLeft(
long
int)

public static long rotateRight(
long
int)

public static int signum(
long)

public static java.lang.String toBinaryString(
long)

public static java.lang.String toHexString(
long)

public static java.lang.String toOctalString(
long)

public static java.lang.String toString(
long)

public static java.lang.String toString(
long
int)

public static java.lang.Long valueOf(
long)
@dalvik.annotation.Throws (value =Ljava/lang/NumberFormatException; )
public static java.lang.Long valueOf(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/lang/NumberFormatException; )
public static java.lang.Long valueOf(
java.lang.String
int)

public byte byteValue()

public int compareTo(
java.lang.Long)

public volatile int compareTo(
java.lang.Object)

public double doubleValue()

public boolean equals(
java.lang.Object)

public float floatValue()

public int hashCode()

public int intValue()

public long longValue()

public short shortValue()

public java.lang.String toString()

________________CLASS________________


public final class java.lang.Math extends java.lang.Object

----------------FIELDS----------------

public static final double E

public static final double PI

private static java.util.Random random
----------------METHODS----------------

private void <init>()

public static native double IEEEremainder(
double
double)

public static double abs(
double)

public static float abs(
float)

public static int abs(
int)

public static long abs(
long)

public static native double acos(
double)

public static native double asin(
double)

public static native double atan(
double)

public static native double atan2(
double
double)

public static native double cbrt(
double)

public static native double ceil(
double)

public static native double cos(
double)

public static native double cosh(
double)

public static native double exp(
double)

public static native double expm1(
double)

public static native double floor(
double)

public static native double hypot(
double
double)

public static native double log(
double)

public static native double log10(
double)

public static native double log1p(
double)

public static double max(
double
double)

public static float max(
float
float)

public static int max(
int
int)

public static long max(
long
long)

public static double min(
double
double)

public static float min(
float
float)

public static int min(
int
int)

public static long min(
long
long)

private static native double nextafter(
double
double)

private static native float nextafterf(
float
float)

public static native double pow(
double
double)

public static double random()

public static native double rint(
double)

public static int round(
float)

public static long round(
double)

public static double signum(
double)

public static float signum(
float)

public static native double sin(
double)

public static native double sinh(
double)

public static native double sqrt(
double)

public static native double tan(
double)

public static native double tanh(
double)

public static double toDegrees(
double)

public static double toRadians(
double)

public static double ulp(
double)

public static float ulp(
float)

________________CLASS________________


public class java.lang.NegativeArraySizeException extends java.lang.RuntimeException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class java.lang.NoClassDefFoundError extends java.lang.LinkageError

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class java.lang.NoSuchFieldError extends java.lang.IncompatibleClassChangeError

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class java.lang.NoSuchFieldException extends java.lang.Exception

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class java.lang.NoSuchMethodError extends java.lang.IncompatibleClassChangeError

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class java.lang.NoSuchMethodException extends java.lang.Exception

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class java.lang.NullPointerException extends java.lang.RuntimeException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class java.lang.NumberFormatException extends java.lang.IllegalArgumentException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class java.lang.OutOfMemoryError extends java.lang.VirtualMachineError

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________

@java.lang.annotation.Retention (value =Ljava/lang/annotation/RetentionPolicy;!SOURCE )
@java.lang.annotation.Target (value =Ljava/lang/annotation/ElementType;!METHOD )
public abstract interface class java.lang.Override extends java.lang.Object implements java.lang.annotation.Annotation

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________


public class java.lang.Package extends java.lang.Object implements java.lang.reflect.AnnotatedElement

----------------FIELDS----------------

private final java.lang.String implTitle

private final java.lang.String implVendor

private final java.lang.String implVersion

private final java.lang.String name

private final java.net.URL sealBase

private final java.lang.String specTitle

private final java.lang.String specVendor

private final java.lang.String specVersion
----------------METHODS----------------

 void <init>(
java.lang.String
java.lang.String
java.lang.String
java.lang.String
java.lang.String
java.lang.String
java.lang.String
java.net.URL)

private static native java.lang.annotation.Annotation[] getDeclaredAnnotations(
java.lang.Package
boolean)

public static java.lang.Package getPackage(
java.lang.String)

public static java.lang.Package[] getPackages()
@dalvik.annotation.Signature (value =<T::Ljava/lang/annotation/Annotation;>(Ljava/lang/Class<TT;>;)TT; )
public java.lang.annotation.Annotation getAnnotation(
java.lang.Class)

public java.lang.annotation.Annotation[] getAnnotations()

public java.lang.annotation.Annotation[] getDeclaredAnnotations()

public java.lang.String getImplementationTitle()

public java.lang.String getImplementationVendor()

public java.lang.String getImplementationVersion()

public java.lang.String getName()

public java.lang.String getSpecificationTitle()

public java.lang.String getSpecificationVendor()

public java.lang.String getSpecificationVersion()

public int hashCode()
@dalvik.annotation.Signature (value =(Ljava/lang/Class<+Ljava/lang/annotation/Annotation;>;)Z )
public boolean isAnnotationPresent(
java.lang.Class)
@dalvik.annotation.Throws (value =Ljava/lang/NumberFormatException; )
public boolean isCompatibleWith(
java.lang.String)

public boolean isSealed()

public boolean isSealed(
java.net.URL)

public java.lang.String toString()

________________CLASS________________


public abstract class java.lang.Process extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public abstract void destroy()

public abstract int exitValue()

public abstract java.io.InputStream getErrorStream()

public abstract java.io.InputStream getInputStream()

public abstract java.io.OutputStream getOutputStream()
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public abstract int waitFor()

________________CLASS________________


public final class java.lang.ProcessBuilder extends java.lang.Object

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/List<Ljava/lang/String;>; )
private java.util.List command

private java.io.File directory
@dalvik.annotation.Signature (value =Ljava/util/Map<Ljava/lang/String;Ljava/lang/String;>; )
private java.util.Map environment

private boolean redirectErrorStream
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/List<Ljava/lang/String;>;)V )
public void <init>(
java.util.List)

public transient void <init>(
java.lang.String[])
@dalvik.annotation.Signature (value =([Ljava/lang/String;)Ljava/util/List<Ljava/lang/String;>; )
private static java.util.List toList(
java.lang.String[])
@dalvik.annotation.Signature (value =(Ljava/util/List<Ljava/lang/String;>;)Ljava/lang/ProcessBuilder; )
public java.lang.ProcessBuilder command(
java.util.List)

public transient java.lang.ProcessBuilder command(
java.lang.String[])
@dalvik.annotation.Signature (value =()Ljava/util/List<Ljava/lang/String;>; )
public java.util.List command()

public java.io.File directory()

public java.lang.ProcessBuilder directory(
java.io.File)
@dalvik.annotation.Signature (value =()Ljava/util/Map<Ljava/lang/String;Ljava/lang/String;>; )
public java.util.Map environment()

public java.lang.ProcessBuilder redirectErrorStream(
boolean)

public boolean redirectErrorStream()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Process start()

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
 class java.lang.ProcessManager$1 extends java.lang.Thread

----------------FIELDS----------------

final java.lang.ProcessManager this$0
----------------METHODS----------------

 void <init>(
java.lang.ProcessManager
java.lang.String)

public void run()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =ProcessImpl )
@dalvik.annotation.EnclosingClass (value =Ljava/lang/ProcessManager; )
 class java.lang.ProcessManager$ProcessImpl extends java.lang.Process

----------------FIELDS----------------

final java.io.InputStream errorStream

 java.lang.Integer exitValue

final java.lang.Object exitValueMutex

final int id

final java.io.InputStream inputStream

final java.io.OutputStream outputStream
----------------METHODS----------------

 void <init>(
int
java.io.FileDescriptor
java.io.FileDescriptor
java.io.FileDescriptor)

public void destroy()

public int exitValue()

public java.io.InputStream getErrorStream()

public java.io.InputStream getInputStream()

public java.io.OutputStream getOutputStream()

 void setExitValue(
int)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public int waitFor()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =10 name =ProcessInputStream )
@dalvik.annotation.EnclosingClass (value =Ljava/lang/ProcessManager; )
 class java.lang.ProcessManager$ProcessInputStream extends java.io.FileInputStream

----------------FIELDS----------------

private java.io.FileDescriptor fd
----------------METHODS----------------

private void <init>(
java.io.FileDescriptor)

 void <init>(
java.io.FileDescriptor
java.lang.ProcessManager$1)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/lang/ProcessManager; )
@dalvik.annotation.InnerClass (accessFlags =10 name =ProcessOutputStream )
 class java.lang.ProcessManager$ProcessOutputStream extends java.io.FileOutputStream

----------------FIELDS----------------

private java.io.FileDescriptor fd
----------------METHODS----------------

private void <init>(
java.io.FileDescriptor)

 void <init>(
java.io.FileDescriptor
java.lang.ProcessManager$1)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()

________________CLASS________________

@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>Ljava/lang/Object; )
public abstract class java.lang.ref.Reference extends java.lang.Object

----------------FIELDS----------------

 java.lang.ref.ReferenceQueue queue

 java.lang.ref.Reference queueNext
@dalvik.annotation.Signature (value =TT; )
 java.lang.Object referent

private int vmData
----------------METHODS----------------

 void <init>()

private boolean enqueueInternal()

public void clear()

public boolean enqueue()
@dalvik.annotation.Signature (value =()TT; )
public java.lang.Object get()

public boolean isEnqueued()

________________CLASS________________

@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>Ljava/lang/ref/Reference<TT;>; )
public class java.lang.ref.WeakReference extends java.lang.ref.Reference

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =(TT;)V )
public void <init>(
java.lang.Object)
@dalvik.annotation.Signature (value =(TT;Ljava/lang/ref/ReferenceQueue<-TT;>;)V )
public void <init>(
java.lang.Object
java.lang.ref.ReferenceQueue)

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/ref/WeakReference<Ljava/lang/ProcessManager$ProcessImpl;>; )
@dalvik.annotation.InnerClass (accessFlags =8 name =ProcessReference )
@dalvik.annotation.EnclosingClass (value =Ljava/lang/ProcessManager; )
 class java.lang.ProcessManager$ProcessReference extends java.lang.ref.WeakReference

----------------FIELDS----------------

final int processId
----------------METHODS----------------

public void <init>(
java.lang.ProcessManager$ProcessImpl
java.lang.ProcessManager$ProcessReferenceQueue)

________________CLASS________________

@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>Ljava/lang/Object; )
public class java.lang.ref.ReferenceQueue extends java.lang.Object

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/lang/ref/Reference<+TT;>; )
private java.lang.ref.Reference head
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Signature (value =(Ljava/lang/ref/Reference<+TT;>;)V )
 void enqueue(
java.lang.ref.Reference)
@dalvik.annotation.Signature (value =()Ljava/lang/ref/Reference<+TT;>; )
public java.lang.ref.Reference poll()
@dalvik.annotation.Signature (value =()Ljava/lang/ref/Reference<+TT;>; )
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public java.lang.ref.Reference remove()
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException;Ljava/lang/InterruptedException; )
@dalvik.annotation.Signature (value =(J)Ljava/lang/ref/Reference<+TT;>; )
public java.lang.ref.Reference remove(
long)

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/ref/ReferenceQueue<Ljava/lang/ProcessManager$ProcessImpl;>; )
@dalvik.annotation.InnerClass (accessFlags =8 name =ProcessReferenceQueue )
@dalvik.annotation.EnclosingClass (value =Ljava/lang/ProcessManager; )
 class java.lang.ProcessManager$ProcessReferenceQueue extends java.lang.ref.ReferenceQueue

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public java.lang.ProcessManager$ProcessReference poll()

public volatile java.lang.ref.Reference poll()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/lang/ProcessManager$ProcessOutputStream;Ljava/lang/ProcessManager$ProcessInputStream;Ljava/lang/ProcessManager$ProcessReferenceQueue;Ljava/lang/ProcessManager$ProcessReference;Ljava/lang/ProcessManager$ProcessImpl; )
final class java.lang.ProcessManager extends java.lang.Object

----------------FIELDS----------------

private static final int WAIT_STATUS_NO_CHILDREN

private static final int WAIT_STATUS_STRANGE_ERRNO

private static final int WAIT_STATUS_UNKNOWN

static final java.lang.ProcessManager instance

private int childCount
@dalvik.annotation.Signature (value =Ljava/util/Map<Ljava/lang/Integer;Ljava/lang/ProcessManager$ProcessReference;>; )
private final java.util.Map processReferences

private final java.lang.ProcessManager$ProcessReferenceQueue referenceQueue
----------------METHODS----------------

static void <clinit>()

private void <init>()

static void access$200(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
static void access$300(
java.io.FileDescriptor)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private static native void close(
java.io.FileDescriptor)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
static native int exec(
java.lang.String[]
java.lang.String[]
java.lang.String
java.io.FileDescriptor
java.io.FileDescriptor
java.io.FileDescriptor)

static java.lang.ProcessManager getInstance()

private static native void kill(
int)

static native void staticInitialize()

 void cleanUp()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 java.lang.Process exec(
java.lang.String[]
java.lang.String[]
java.io.File)

 void onExit(
int
int)

native void watchChildren()

________________CLASS________________


 class java.lang.ReaderInputStream extends java.io.InputStream

----------------FIELDS----------------

private byte[] bytes

private int nextByte

private int numBytes

private java.io.Reader reader
----------------METHODS----------------

public void <init>(
java.io.Reader)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void readBuffer()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()

________________CLASS________________


public class java.lang.Runtime extends java.lang.Object

----------------FIELDS----------------

private static boolean finalizeOnExit

private static final java.lang.Runtime mRuntime

private final java.lang.String[] mLibPaths
@dalvik.annotation.Signature (value =Ljava/util/List<Ljava/lang/Thread;>; )
private java.util.List shutdownHooks

private boolean shuttingDown

private boolean tracingMethods
----------------METHODS----------------

static void <clinit>()

private void <init>()

public static java.lang.Runtime getRuntime()

private static native void nativeExit(
int
boolean)

private static native boolean nativeLoad(
java.lang.String
java.lang.ClassLoader)

private native void runFinalization(
boolean)
@java.lang.Deprecated
public static void runFinalizersOnExit(
boolean)

public void addShutdownHook(
java.lang.Thread)

public int availableProcessors()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Process exec(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Process exec(
java.lang.String
java.lang.String[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Process exec(
java.lang.String
java.lang.String[]
java.io.File)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Process exec(
java.lang.String[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Process exec(
java.lang.String[]
java.lang.String[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Process exec(
java.lang.String[]
java.lang.String[]
java.io.File)

public void exit(
int)

public native long freeMemory()

public native void gc()
@java.lang.Deprecated
public java.io.InputStream getLocalizedInputStream(
java.io.InputStream)
@java.lang.Deprecated
public java.io.OutputStream getLocalizedOutputStream(
java.io.OutputStream)

public void halt(
int)

public void load(
java.lang.String)

 void load(
java.lang.String
java.lang.ClassLoader)

public void loadLibrary(
java.lang.String)

 void loadLibrary(
java.lang.String
java.lang.ClassLoader)

public native long maxMemory()

public boolean removeShutdownHook(
java.lang.Thread)

public void runFinalization()

public native long totalMemory()

public void traceInstructions(
boolean)

public void traceMethodCalls(
boolean)

________________CLASS________________


public final class java.lang.RuntimePermission extends java.security.BasicPermission

----------------FIELDS----------------

static final java.lang.RuntimePermission permissionToCreateClassLoader

static final java.lang.RuntimePermission permissionToCreateSecurityManager

static final java.lang.RuntimePermission permissionToExitVM

static final java.lang.RuntimePermission permissionToGetClassLoader

static final java.lang.RuntimePermission permissionToGetProtectionDomain

static final java.lang.RuntimePermission permissionToModifyThread

static final java.lang.RuntimePermission permissionToModifyThreadGroup

static final java.lang.RuntimePermission permissionToQueuePrintJob

static final java.lang.RuntimePermission permissionToReadFileDescriptor

static final java.lang.RuntimePermission permissionToSetContextClassLoader

static final java.lang.RuntimePermission permissionToSetFactory

static final java.lang.RuntimePermission permissionToSetIO

static final java.lang.RuntimePermission permissionToSetSecurityManager

static final java.lang.RuntimePermission permissionToStopThread

static final java.lang.RuntimePermission permissionToWriteFileDescriptor

private static final long serialVersionUID
----------------METHODS----------------

static void <clinit>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.String)

________________CLASS________________


public class java.lang.SecurityException extends java.lang.RuntimeException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.Throwable)

public void <init>(
java.lang.Throwable)

________________CLASS________________


public class java.lang.SecurityManager extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.String PKG_ACC_KEY

private static final java.lang.String PKG_DEF_KEY

private static final java.util.PropertyPermission READ_WRITE_ALL_PROPERTIES_PERMISSION
@java.lang.Deprecated
protected boolean inCheck
----------------METHODS----------------

static void <clinit>()

public void <init>()

private static boolean checkPackageProperty(
java.lang.String
java.lang.String)

public void checkAccept(
java.lang.String
int)

public void checkAccess(
java.lang.Thread)

public void checkAccess(
java.lang.ThreadGroup)

public void checkAwtEventQueueAccess()

public void checkConnect(
java.lang.String
int)

public void checkConnect(
java.lang.String
int
java.lang.Object)

public void checkCreateClassLoader()

public void checkDelete(
java.lang.String)

public void checkExec(
java.lang.String)

public void checkExit(
int)

public void checkLink(
java.lang.String)

public void checkListen(
int)
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;I)V )
public void checkMemberAccess(
java.lang.Class
int)

public void checkMulticast(
java.net.InetAddress)
@java.lang.Deprecated
public void checkMulticast(
java.net.InetAddress
byte)

public void checkPackageAccess(
java.lang.String)

public void checkPackageDefinition(
java.lang.String)

public void checkPermission(
java.security.Permission)

public void checkPermission(
java.security.Permission
java.lang.Object)

public void checkPrintJobAccess()

public void checkPropertiesAccess()

public void checkPropertyAccess(
java.lang.String)

public void checkRead(
java.io.FileDescriptor)

public void checkRead(
java.lang.String)

public void checkRead(
java.lang.String
java.lang.Object)

public void checkSecurityAccess(
java.lang.String)

public void checkSetFactory()

public void checkSystemClipboardAccess()

public boolean checkTopLevelWindow(
java.lang.Object)

public void checkWrite(
java.io.FileDescriptor)

public void checkWrite(
java.lang.String)
@java.lang.Deprecated
protected int classDepth(
java.lang.String)
@java.lang.Deprecated
protected int classLoaderDepth()
@java.lang.Deprecated
protected java.lang.ClassLoader currentClassLoader()
@java.lang.Deprecated
@dalvik.annotation.Signature (value =()Ljava/lang/Class<*>; )
protected java.lang.Class currentLoadedClass()

protected java.lang.Class[] getClassContext()
@java.lang.Deprecated
public boolean getInCheck()

public java.lang.Object getSecurityContext()

public java.lang.ThreadGroup getThreadGroup()
@java.lang.Deprecated
protected boolean inClass(
java.lang.String)
@java.lang.Deprecated
protected boolean inClassLoader()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/lang/Short; )
@dalvik.annotation.InnerClass (accessFlags =8 name =valueOfCache )
 class java.lang.Short$valueOfCache extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.Short[] CACHE
----------------METHODS----------------

static void <clinit>()

 void <init>()

static java.lang.Short[] access$000()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Number;Ljava/lang/Comparable<Ljava/lang/Short;>; )
@dalvik.annotation.MemberClasses (value =Ljava/lang/Short$valueOfCache; )
public final class java.lang.Short extends java.lang.Number implements java.lang.Comparable

----------------FIELDS----------------

public static final short MAX_VALUE

public static final short MIN_VALUE

public static final int SIZE
@dalvik.annotation.Signature (value =Ljava/lang/Class<Ljava/lang/Short;>; )
public static final java.lang.Class TYPE

private static final long serialVersionUID

private final short value
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Throws (value =Ljava/lang/NumberFormatException; )
public void <init>(
java.lang.String)

public void <init>(
short)
@dalvik.annotation.Throws (value =Ljava/lang/NumberFormatException; )
public static java.lang.Short decode(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/lang/NumberFormatException; )
public static short parseShort(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/lang/NumberFormatException; )
public static short parseShort(
java.lang.String
int)

public static short reverseBytes(
short)

public static java.lang.String toString(
short)
@dalvik.annotation.Throws (value =Ljava/lang/NumberFormatException; )
public static java.lang.Short valueOf(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/lang/NumberFormatException; )
public static java.lang.Short valueOf(
java.lang.String
int)

public static java.lang.Short valueOf(
short)

public byte byteValue()

public volatile int compareTo(
java.lang.Object)

public int compareTo(
java.lang.Short)

public double doubleValue()

public boolean equals(
java.lang.Object)

public float floatValue()

public int hashCode()

public int intValue()

public long longValue()

public short shortValue()

public java.lang.String toString()

________________CLASS________________


public class java.lang.StackOverflowError extends java.lang.VirtualMachineError

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public final class java.lang.StackTraceElement extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------

private static final int NATIVE_LINE_NUMBER

private static final long serialVersionUID

 java.lang.String declaringClass

 java.lang.String fileName

 int lineNumber

 java.lang.String methodName
----------------METHODS----------------

private void <init>()

public void <init>(
java.lang.String
java.lang.String
java.lang.String
int)

public boolean equals(
java.lang.Object)

public java.lang.String getClassName()

public java.lang.String getFileName()

public int getLineNumber()

public java.lang.String getMethodName()

public int hashCode()

public boolean isNativeMethod()

public java.lang.String toString()

________________CLASS________________


public final class java.lang.StrictMath extends java.lang.Object

----------------FIELDS----------------

public static final double E

public static final double PI

private static java.util.Random random
----------------METHODS----------------

private void <init>()

public static native double IEEEremainder(
double
double)

public static double abs(
double)

public static float abs(
float)

public static int abs(
int)

public static long abs(
long)

public static native double acos(
double)

public static native double asin(
double)

public static native double atan(
double)

public static native double atan2(
double
double)

public static native double cbrt(
double)

public static native double ceil(
double)

public static native double cos(
double)

public static native double cosh(
double)

public static native double exp(
double)

public static native double expm1(
double)

public static native double floor(
double)

public static native double hypot(
double
double)

public static native double log(
double)

public static native double log10(
double)

public static native double log1p(
double)

public static double max(
double
double)

public static float max(
float
float)

public static int max(
int
int)

public static long max(
long
long)

public static double min(
double
double)

public static float min(
float
float)

public static int min(
int
int)

public static long min(
long
long)

private static native double nextafter(
double
double)

private static native float nextafterf(
float
float)

public static native double pow(
double
double)

public static double random()

public static native double rint(
double)

public static int round(
float)

public static long round(
double)

public static double signum(
double)

public static float signum(
float)

public static native double sin(
double)

public static native double sinh(
double)

public static native double sqrt(
double)

public static native double tan(
double)

public static native double tanh(
double)

public static double toDegrees(
double)

public static double toRadians(
double)

public static double ulp(
double)

public static float ulp(
float)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =4104 name =null )
@dalvik.annotation.EnclosingClass (value =Ljava/lang/String; )
 class java.lang.String$1 extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/lang/String; )
@dalvik.annotation.InnerClass (accessFlags =26 name =CaseInsensitiveComparator )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Comparator<Ljava/lang/String;>;Ljava/io/Serializable; )
final class java.lang.String$CaseInsensitiveComparator extends java.lang.Object implements java.util.Comparator, java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

private void <init>()

 void <init>(
java.lang.String$1)

public volatile int compare(
java.lang.Object
java.lang.Object)

public int compare(
java.lang.String
java.lang.String)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/lang/String; )
@dalvik.annotation.InnerClass (accessFlags =8 name =ConsolePrintStream )
 class java.lang.String$ConsolePrintStream extends java.io.PrintStream

----------------FIELDS----------------

private static java.lang.String charset
----------------METHODS----------------

static void <clinit>()

public void <init>(
java.io.OutputStream)

public void print(
java.lang.String)

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/io/Serializable;Ljava/lang/Comparable<Ljava/lang/String;>;Ljava/lang/CharSequence; )
@dalvik.annotation.MemberClasses (value =Ljava/lang/String$1;Ljava/lang/String$CaseInsensitiveComparator;Ljava/lang/String$ConsolePrintStream; )
public final class java.lang.String extends java.lang.Object implements java.io.Serializable, java.lang.Comparable, java.lang.CharSequence

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Comparator<Ljava/lang/String;>; )
public static final java.util.Comparator CASE_INSENSITIVE_ORDER

private static java.nio.charset.Charset DefaultCharset

private static final char REPLACEMENT_CHAR

private static final char[] ascii

private static java.nio.charset.Charset lastCharset

private static final long serialVersionUID

private static final char[] upperValues

private final int count

private int hashCode

private final int offset

private final char[] value
----------------METHODS----------------

static void <clinit>()

public void <init>()

 void <init>(
int
int
char[])

public void <init>(
java.lang.String)

private void <init>(
java.lang.String
char)

private void <init>(
java.lang.String
int)

public void <init>(
java.lang.StringBuffer)

public void <init>(
java.lang.StringBuilder)

public void <init>(
byte[])
@java.lang.Deprecated
public void <init>(
byte[]
int)

public void <init>(
byte[]
int
int)
@java.lang.Deprecated
public void <init>(
byte[]
int
int
int)
@dalvik.annotation.Throws (value =Ljava/io/UnsupportedEncodingException; )
public void <init>(
byte[]
int
int
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/UnsupportedEncodingException; )
public void <init>(
byte[]
java.lang.String)

public void <init>(
char[])

public void <init>(
char[]
int
int)

public void <init>(
int[]
int
int)

public static java.lang.String copyValueOf(
char[])

public static java.lang.String copyValueOf(
char[]
int
int)

private java.nio.charset.Charset defaultCharset()

public static transient java.lang.String format(
java.lang.String
java.lang.Object[])

public static transient java.lang.String format(
java.util.Locale
java.lang.String
java.lang.Object[])
@dalvik.annotation.Throws (value =Ljava/io/UnsupportedEncodingException; )
private java.nio.charset.Charset getCharset(
java.lang.String)

private static int indexOf(
java.lang.String
java.lang.String
int
int
char)

private int upperIndex(
int)

public static java.lang.String valueOf(
char)

public static java.lang.String valueOf(
double)

public static java.lang.String valueOf(
float)

public static java.lang.String valueOf(
int)

public static java.lang.String valueOf(
long)

public static java.lang.String valueOf(
java.lang.Object)

public static java.lang.String valueOf(
boolean)

public static java.lang.String valueOf(
char[])

public static java.lang.String valueOf(
char[]
int
int)

 void _getChars(
int
int
char[]
int)

public char charAt(
int)

public int codePointAt(
int)

public int codePointBefore(
int)

public int codePointCount(
int
int)

public volatile int compareTo(
java.lang.Object)

public int compareTo(
java.lang.String)

public int compareToIgnoreCase(
java.lang.String)

public java.lang.String concat(
java.lang.String)

public boolean contains(
java.lang.CharSequence)

public boolean contentEquals(
java.lang.CharSequence)

public boolean contentEquals(
java.lang.StringBuffer)

public boolean endsWith(
java.lang.String)

public boolean equals(
java.lang.Object)

public boolean equalsIgnoreCase(
java.lang.String)
@java.lang.Deprecated
public void getBytes(
int
int
byte[]
int)

public byte[] getBytes()
@dalvik.annotation.Throws (value =Ljava/io/UnsupportedEncodingException; )
public byte[] getBytes(
java.lang.String)

public void getChars(
int
int
char[]
int)

 char[] getValue()

public int hashCode()

public int indexOf(
int)

public int indexOf(
int
int)

public int indexOf(
java.lang.String)

public int indexOf(
java.lang.String
int)

public native java.lang.String intern()

public int lastIndexOf(
int)

public int lastIndexOf(
int
int)

public int lastIndexOf(
java.lang.String)

public int lastIndexOf(
java.lang.String
int)

public int length()

public boolean matches(
java.lang.String)

public int offsetByCodePoints(
int
int)

public boolean regionMatches(
int
java.lang.String
int
int)

public boolean regionMatches(
boolean
int
java.lang.String
int
int)

public java.lang.String replace(
char
char)

public java.lang.String replace(
java.lang.CharSequence
java.lang.CharSequence)

public java.lang.String replaceAll(
java.lang.String
java.lang.String)

public java.lang.String replaceFirst(
java.lang.String
java.lang.String)

public java.lang.String[] split(
java.lang.String)

public java.lang.String[] split(
java.lang.String
int)

public boolean startsWith(
java.lang.String)

public boolean startsWith(
java.lang.String
int)

public java.lang.CharSequence subSequence(
int
int)

public java.lang.String substring(
int)

public java.lang.String substring(
int
int)

public char[] toCharArray()

public java.lang.String toLowerCase()

public java.lang.String toLowerCase(
java.util.Locale)

public java.lang.String toString()

public java.lang.String toUpperCase()

public java.lang.String toUpperCase(
java.util.Locale)

public java.lang.String trim()

________________CLASS________________


public final class java.lang.StringBuffer extends java.lang.AbstractStringBuilder implements java.lang.Appendable, java.io.Serializable, java.lang.CharSequence

----------------FIELDS----------------

private static final java.io.ObjectStreamField[] serialPersistentFields

private static final long serialVersionUID
----------------METHODS----------------

static void <clinit>()

public void <init>()

public void <init>(
int)

public void <init>(
java.lang.CharSequence)

public void <init>(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public volatile java.lang.Appendable append(
char)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public volatile java.lang.Appendable append(
java.lang.CharSequence)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public volatile java.lang.Appendable append(
java.lang.CharSequence
int
int)

public java.lang.StringBuffer append(
char)

public java.lang.StringBuffer append(
double)

public java.lang.StringBuffer append(
float)

public java.lang.StringBuffer append(
int)

public java.lang.StringBuffer append(
long)

public java.lang.StringBuffer append(
java.lang.CharSequence)

public java.lang.StringBuffer append(
java.lang.CharSequence
int
int)

public java.lang.StringBuffer append(
java.lang.Object)

public java.lang.StringBuffer append(
java.lang.String)

public java.lang.StringBuffer append(
java.lang.StringBuffer)

public java.lang.StringBuffer append(
boolean)

public java.lang.StringBuffer append(
char[])

public java.lang.StringBuffer append(
char[]
int
int)

public java.lang.StringBuffer appendCodePoint(
int)

public volatile int capacity()

public char charAt(
int)

public int codePointAt(
int)

public int codePointBefore(
int)

public int codePointCount(
int
int)

public java.lang.StringBuffer delete(
int
int)

public java.lang.StringBuffer deleteCharAt(
int)

public void ensureCapacity(
int)

public void getChars(
int
int
char[]
int)

public volatile int indexOf(
java.lang.String)

public int indexOf(
java.lang.String
int)

public java.lang.StringBuffer insert(
int
char)

public java.lang.StringBuffer insert(
int
double)

public java.lang.StringBuffer insert(
int
float)

public java.lang.StringBuffer insert(
int
int)

public java.lang.StringBuffer insert(
int
long)

public java.lang.StringBuffer insert(
int
java.lang.CharSequence)

public java.lang.StringBuffer insert(
int
java.lang.CharSequence
int
int)

public java.lang.StringBuffer insert(
int
java.lang.Object)

public java.lang.StringBuffer insert(
int
java.lang.String)

public java.lang.StringBuffer insert(
int
boolean)

public java.lang.StringBuffer insert(
int
char[])

public java.lang.StringBuffer insert(
int
char[]
int
int)

public volatile int lastIndexOf(
java.lang.String)

public int lastIndexOf(
java.lang.String
int)

public volatile int length()

public int offsetByCodePoints(
int
int)

public java.lang.StringBuffer replace(
int
int
java.lang.String)

public java.lang.StringBuffer reverse()

public void setCharAt(
int
char)

public void setLength(
int)

public java.lang.CharSequence subSequence(
int
int)

public java.lang.String substring(
int)

public java.lang.String substring(
int
int)

public java.lang.String toString()

public void trimToSize()

________________CLASS________________


public final class java.lang.StringBuilder extends java.lang.AbstractStringBuilder implements java.lang.Appendable, java.lang.CharSequence, java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
int)

public void <init>(
java.lang.CharSequence)

public void <init>(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public volatile java.lang.Appendable append(
char)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public volatile java.lang.Appendable append(
java.lang.CharSequence)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public volatile java.lang.Appendable append(
java.lang.CharSequence
int
int)

public java.lang.StringBuilder append(
char)

public java.lang.StringBuilder append(
double)

public java.lang.StringBuilder append(
float)

public java.lang.StringBuilder append(
int)

public java.lang.StringBuilder append(
long)

public java.lang.StringBuilder append(
java.lang.CharSequence)

public java.lang.StringBuilder append(
java.lang.CharSequence
int
int)

public java.lang.StringBuilder append(
java.lang.Object)

public java.lang.StringBuilder append(
java.lang.String)

public java.lang.StringBuilder append(
java.lang.StringBuffer)

public java.lang.StringBuilder append(
boolean)

public java.lang.StringBuilder append(
char[])

public java.lang.StringBuilder append(
char[]
int
int)

public java.lang.StringBuilder appendCodePoint(
int)

public volatile int capacity()

public volatile char charAt(
int)

public volatile int codePointAt(
int)

public volatile int codePointBefore(
int)

public volatile int codePointCount(
int
int)

public java.lang.StringBuilder delete(
int
int)

public java.lang.StringBuilder deleteCharAt(
int)

public volatile void ensureCapacity(
int)

public volatile void getChars(
int
int
char[]
int)

public volatile int indexOf(
java.lang.String)

public volatile int indexOf(
java.lang.String
int)

public java.lang.StringBuilder insert(
int
char)

public java.lang.StringBuilder insert(
int
double)

public java.lang.StringBuilder insert(
int
float)

public java.lang.StringBuilder insert(
int
int)

public java.lang.StringBuilder insert(
int
long)

public java.lang.StringBuilder insert(
int
java.lang.CharSequence)

public java.lang.StringBuilder insert(
int
java.lang.CharSequence
int
int)

public java.lang.StringBuilder insert(
int
java.lang.Object)

public java.lang.StringBuilder insert(
int
java.lang.String)

public java.lang.StringBuilder insert(
int
boolean)

public java.lang.StringBuilder insert(
int
char[])

public java.lang.StringBuilder insert(
int
char[]
int
int)

public volatile int lastIndexOf(
java.lang.String)

public volatile int lastIndexOf(
java.lang.String
int)

public volatile int length()

public volatile int offsetByCodePoints(
int
int)

public java.lang.StringBuilder replace(
int
int
java.lang.String)

public java.lang.StringBuilder reverse()

public volatile void setCharAt(
int
char)

public volatile void setLength(
int)

public volatile java.lang.CharSequence subSequence(
int
int)

public volatile java.lang.String substring(
int)

public volatile java.lang.String substring(
int
int)

public java.lang.String toString()

public volatile void trimToSize()

________________CLASS________________


public class java.lang.StringIndexOutOfBoundsException extends java.lang.IndexOutOfBoundsException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
int)

public void <init>(
java.lang.String)

________________CLASS________________

@java.lang.annotation.Target (value =Ljava/lang/annotation/ElementType;!TYPELjava/lang/annotation/ElementType;!FIELDLjava/lang/annotation/ElementType;!METHODLjava/lang/annotation/ElementType;!PARAMETERLjava/lang/annotation/ElementType;!CONSTRUCTORLjava/lang/annotation/ElementType;!LOCAL_VARIABLE )
@java.lang.annotation.Retention (value =Ljava/lang/annotation/RetentionPolicy;!SOURCE )
public abstract interface class java.lang.SuppressWarnings extends java.lang.Object implements java.lang.annotation.Annotation

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.lang.String[] value()

________________CLASS________________


public final class java.lang.System extends java.lang.Object

----------------FIELDS----------------

public static final java.io.PrintStream err

public static final java.io.InputStream in

public static final java.io.PrintStream out

private static java.lang.SecurityManager securityManager

private static java.util.Properties systemProperties
----------------METHODS----------------

static void <clinit>()

private void <init>()

public static native void arraycopy(
java.lang.Object
int
java.lang.Object
int
int)

public static java.lang.String clearProperty(
java.lang.String)

public static native long currentTimeMillis()

public static void exit(
int)

public static void gc()

private static native java.lang.String getEnvByIndex(
int)

private static native java.lang.String getEnvByName(
java.lang.String)

public static java.util.Properties getProperties()

public static java.lang.String getProperty(
java.lang.String)

public static java.lang.String getProperty(
java.lang.String
java.lang.String)

public static java.lang.SecurityManager getSecurityManager()

public static java.lang.String getenv(
java.lang.String)
@dalvik.annotation.Signature (value =()Ljava/util/Map<Ljava/lang/String;Ljava/lang/String;>; )
public static java.util.Map getenv()

public static native int identityHashCode(
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static java.nio.channels.Channel inheritedChannel()

static java.util.Properties internalGetProperties()

public static void load(
java.lang.String)

public static void loadLibrary(
java.lang.String)

public static native java.lang.String mapLibraryName(
java.lang.String)

public static native long nanoTime()

public static void runFinalization()
@java.lang.Deprecated
public static void runFinalizersOnExit(
boolean)

public static void setErr(
java.io.PrintStream)

private static native void setFieldImpl(
java.lang.String
java.lang.String
java.lang.Object)

public static void setIn(
java.io.InputStream)

public static void setOut(
java.io.PrintStream)

public static void setProperties(
java.util.Properties)

public static java.lang.String setProperty(
java.lang.String
java.lang.String)

public static void setSecurityManager(
java.lang.SecurityManager)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/Map$Entry; )
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/lang/Object; )
public abstract interface class java.util.Map extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract void clear()

public abstract boolean containsKey(
java.lang.Object)

public abstract boolean containsValue(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/util/Map$Entry<TK;TV;>;>; )
public abstract java.util.Set entrySet()

public abstract boolean equals(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;)TV; )
public abstract java.lang.Object get(
java.lang.Object)

public abstract int hashCode()

public abstract boolean isEmpty()
@dalvik.annotation.Signature (value =()Ljava/util/Set<TK;>; )
public abstract java.util.Set keySet()
@dalvik.annotation.Signature (value =(TK;TV;)TV; )
public abstract java.lang.Object put(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Map<+TK;+TV;>;)V )
public abstract void putAll(
java.util.Map)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;)TV; )
public abstract java.lang.Object remove(
java.lang.Object)

public abstract int size()
@dalvik.annotation.Signature (value =()Ljava/util/Collection<TV;>; )
public abstract java.util.Collection values()

________________CLASS________________


 class java.lang.SystemEnvironment extends java.lang.Object implements java.util.Map

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Map<Ljava/lang/String;Ljava/lang/String;>; )
private java.util.Map map
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/Map<Ljava/lang/String;Ljava/lang/String;>;)V )
public void <init>(
java.util.Map)

public void clear()

public boolean containsKey(
java.lang.Object)

public boolean containsValue(
java.lang.Object)

public java.util.Set entrySet()

public volatile java.lang.Object get(
java.lang.Object)

public java.lang.String get(
java.lang.Object)

public boolean isEmpty()
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/lang/String;>; )
public java.util.Set keySet()

public volatile java.lang.Object put(
java.lang.Object
java.lang.Object)

public java.lang.String put(
java.lang.Object
java.lang.Object)

public void putAll(
java.util.Map)

public volatile java.lang.Object remove(
java.lang.Object)

public java.lang.String remove(
java.lang.Object)

public int size()

public java.util.Collection values()

________________CLASS________________

@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/lang/Object; )
public abstract class java.util.Dictionary extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<TV;>; )
public abstract java.util.Enumeration elements()
@dalvik.annotation.Signature (value =(Ljava/lang/Object;)TV; )
public abstract java.lang.Object get(
java.lang.Object)

public abstract boolean isEmpty()
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<TK;>; )
public abstract java.util.Enumeration keys()
@dalvik.annotation.Signature (value =(TK;TV;)TV; )
public abstract java.lang.Object put(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;)TV; )
public abstract java.lang.Object remove(
java.lang.Object)

public abstract int size()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/Hashtable$HashEnumerator;Ljava/util/Hashtable$HashIterator;Ljava/util/Hashtable$Entry; )
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/util/Dictionary<TK;TV;>;Ljava/util/Map<TK;TV;>;Ljava/lang/Cloneable;Ljava/io/Serializable; )
public class java.util.Hashtable extends java.util.Dictionary implements java.util.Map, java.lang.Cloneable, java.io.Serializable

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Enumeration<*>; )
private static final java.util.Enumeration EMPTY_ENUMERATION

private static final long serialVersionUID

transient int elementCount
@dalvik.annotation.Signature (value =[Ljava/util/Hashtable$Entry<TK;TV;>; )
transient java.util.Hashtable$Entry[] elementData

transient int firstSlot

transient int lastSlot

private float loadFactor

transient int modCount

private int threshold
----------------METHODS----------------

static void <clinit>()

public void <init>()

public void <init>(
int)

public void <init>(
int
float)
@dalvik.annotation.Signature (value =(Ljava/util/Map<+TK;+TV;>;)V )
public void <init>(
java.util.Map)

private void computeMaxSize()
@dalvik.annotation.Signature (value =(I)[Ljava/util/Hashtable$Entry<TK;TV;>; )
private java.util.Hashtable$Entry[] newElementArray(
int)
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>(TK;TV;I)Ljava/util/Hashtable$Entry<TK;TV;>; )
private static java.util.Hashtable$Entry newEntry(
java.lang.Object
java.lang.Object
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

public void clear()

public java.lang.Object clone()

public boolean contains(
java.lang.Object)

public boolean containsKey(
java.lang.Object)

public boolean containsValue(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<TV;>; )
public java.util.Enumeration elements()
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/util/Map$Entry<TK;TV;>;>; )
public java.util.Set entrySet()

public boolean equals(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;)TV; )
public java.lang.Object get(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;)Ljava/util/Hashtable$Entry<TK;TV;>; )
 java.util.Hashtable$Entry getEntry(
java.lang.Object)

public int hashCode()

public boolean isEmpty()
@dalvik.annotation.Signature (value =()Ljava/util/Set<TK;>; )
public java.util.Set keySet()
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<TK;>; )
public java.util.Enumeration keys()
@dalvik.annotation.Signature (value =(TK;TV;)TV; )
public java.lang.Object put(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Map<+TK;+TV;>;)V )
public void putAll(
java.util.Map)

protected void rehash()
@dalvik.annotation.Signature (value =(Ljava/lang/Object;)TV; )
public java.lang.Object remove(
java.lang.Object)

public int size()

public java.lang.String toString()
@dalvik.annotation.Signature (value =()Ljava/util/Collection<TV;>; )
public java.util.Collection values()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/util/Hashtable<Ljava/lang/Object;Ljava/lang/Object;>; )
public class java.util.Properties extends java.util.Hashtable

----------------FIELDS----------------

private static final int CONTINUE

private static final int IGNORE

private static final int KEY_DONE

private static final int NONE

private static final java.lang.String PROP_DTD

private static final java.lang.String PROP_DTD_NAME

private static final int SLASH

private static final int UNICODE

private static java.lang.String lineSeparator

private static final long serialVersionUID

private transient javax.xml.parsers.DocumentBuilder builder

protected java.util.Properties defaults
----------------METHODS----------------

public void <init>()

public void <init>(
java.util.Properties)

private void dumpString(
java.lang.StringBuilder
java.lang.String
boolean)

private java.lang.String getTextContent(
org.w3c.dom.Node)

private java.lang.String substitutePredefinedEntries(
java.lang.String)

public java.lang.String getProperty(
java.lang.String)

public java.lang.String getProperty(
java.lang.String
java.lang.String)

public void list(
java.io.PrintStream)

public void list(
java.io.PrintWriter)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void load(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/util/InvalidPropertiesFormatException; )
public void loadFromXML(
java.io.InputStream)
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<*>; )
public java.util.Enumeration propertyNames()
@java.lang.Deprecated
public void save(
java.io.OutputStream
java.lang.String)

public java.lang.Object setProperty(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void store(
java.io.OutputStream
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void storeToXML(
java.io.OutputStream
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void storeToXML(
java.io.OutputStream
java.lang.String
java.lang.String)

________________CLASS________________


 class java.lang.SystemProperties extends java.util.Properties

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

native void postInit()

native void preInit()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =10 name =ParkState )
@dalvik.annotation.EnclosingClass (value =Ljava/lang/Thread; )
 class java.lang.Thread$ParkState extends java.lang.Object

----------------FIELDS----------------

private static final int PARKED

private static final int PREEMPTIVELY_UNPARKED

private static final int UNPARKED
----------------METHODS----------------

private void <init>()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Enum<Ljava/lang/Thread$State;>; )
@dalvik.annotation.EnclosingClass (value =Ljava/lang/Thread; )
@dalvik.annotation.InnerClass (accessFlags =16409 name =State )
public final class java.lang.Thread$State extends java.lang.Enum

----------------FIELDS----------------

private static final java.lang.Thread$State[] $VALUES

public static final java.lang.Thread$State BLOCKED

public static final java.lang.Thread$State NEW

public static final java.lang.Thread$State RUNNABLE

public static final java.lang.Thread$State TERMINATED

public static final java.lang.Thread$State TIMED_WAITING

public static final java.lang.Thread$State WAITING
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Signature (value =()V )
private void <init>(
java.lang.String
int)

public static java.lang.Thread$State valueOf(
java.lang.String)

public static java.lang.Thread$State[] values()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =1545 name =UncaughtExceptionHandler )
@dalvik.annotation.EnclosingClass (value =Ljava/lang/Thread; )
public abstract interface class java.lang.Thread$UncaughtExceptionHandler extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract void uncaughtException(
java.lang.Thread
java.lang.Throwable)

________________CLASS________________


public class java.lang.ThreadDeath extends java.lang.Error

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =4104 name =null )
@dalvik.annotation.EnclosingClass (value =Ljava/lang/ThreadGroup; )
 class java.lang.ThreadGroup$1 extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/lang/ThreadGroup; )
@dalvik.annotation.InnerClass (accessFlags =2 name =ChildrenGroupsLock )
 class java.lang.ThreadGroup$ChildrenGroupsLock extends java.lang.Object

----------------FIELDS----------------

final java.lang.ThreadGroup this$0
----------------METHODS----------------

private void <init>(
java.lang.ThreadGroup)

 void <init>(
java.lang.ThreadGroup
java.lang.ThreadGroup$1)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =2 name =ChildrenThreadsLock )
@dalvik.annotation.EnclosingClass (value =Ljava/lang/ThreadGroup; )
 class java.lang.ThreadGroup$ChildrenThreadsLock extends java.lang.Object

----------------FIELDS----------------

final java.lang.ThreadGroup this$0
----------------METHODS----------------

private void <init>(
java.lang.ThreadGroup)

 void <init>(
java.lang.ThreadGroup
java.lang.ThreadGroup$1)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/lang/ThreadGroup$1;Ljava/lang/ThreadGroup$ChildrenThreadsLock;Ljava/lang/ThreadGroup$ChildrenGroupsLock; )
public class java.lang.ThreadGroup extends java.lang.Object implements java.lang.Thread$UncaughtExceptionHandler

----------------FIELDS----------------

static java.lang.ThreadGroup mMain

static java.lang.ThreadGroup mSystem

private java.lang.ThreadGroup[] childrenGroups

private java.lang.Object childrenGroupsLock

private java.lang.Thread[] childrenThreads

private java.lang.Object childrenThreadsLock

private boolean isDaemon

private boolean isDestroyed

private int maxPriority

private java.lang.String name

 int numGroups

 int numThreads

 java.lang.ThreadGroup parent
----------------METHODS----------------

static void <clinit>()

 void <init>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.ThreadGroup
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalThreadStateException; )
private void add(
java.lang.ThreadGroup)

private void destroyIfEmptyDaemon()

private int enumerateGeneric(
java.lang.Object[]
boolean
int
boolean)

private void list(
int)

private void remove(
java.lang.ThreadGroup)

private void setParent(
java.lang.ThreadGroup)
@java.lang.Deprecated
private final boolean stopHelper()
@java.lang.Deprecated
private final boolean suspendHelper()

public int activeCount()

public int activeGroupCount()
@dalvik.annotation.Throws (value =Ljava/lang/IllegalThreadStateException; )
final void add(
java.lang.Thread)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalThreadStateException; )
 void addThread(
java.lang.Thread)
@java.lang.Deprecated
public boolean allowThreadSuspension(
boolean)

public final void checkAccess()

public final void destroy()

public int enumerate(
java.lang.Thread[])

public int enumerate(
java.lang.Thread[]
boolean)

public int enumerate(
java.lang.ThreadGroup[])

public int enumerate(
java.lang.ThreadGroup[]
boolean)

public final int getMaxPriority()

public final java.lang.String getName()

public final java.lang.ThreadGroup getParent()

public final void interrupt()

public final boolean isDaemon()

public boolean isDestroyed()

public void list()

public final boolean parentOf(
java.lang.ThreadGroup)

final void remove(
java.lang.Thread)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalThreadStateException; )
 void removeThread(
java.lang.Thread)
@java.lang.Deprecated
public final void resume()

public final void setDaemon(
boolean)

public final void setMaxPriority(
int)
@java.lang.Deprecated
public final void stop()
@java.lang.Deprecated
public final void suspend()

public java.lang.String toString()

public void uncaughtException(
java.lang.Thread
java.lang.Throwable)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =Values )
@dalvik.annotation.EnclosingClass (value =Ljava/lang/ThreadLocal; )
 class java.lang.ThreadLocal$Values extends java.lang.Object

----------------FIELDS----------------

private static final int INITIAL_SIZE

private static final java.lang.Object TOMBSTONE

private int clean

private int mask

private int maximumLoad

private int size

private java.lang.Object[] table

private int tombstones
----------------METHODS----------------

static void <clinit>()

 void <init>()

 void <init>(
java.lang.ThreadLocal$Values)

static java.lang.Object[] access$000(
java.lang.ThreadLocal$Values)

static int access$100(
java.lang.ThreadLocal$Values)

private void cleanUp()

private void inheritValues(
java.lang.ThreadLocal$Values)

private void initializeTable(
int)

private int next(
int)

private boolean rehash()
@dalvik.annotation.Signature (value =(Ljava/lang/ThreadLocal<*>;Ljava/lang/Object;)V )
 void add(
java.lang.ThreadLocal
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/lang/ThreadLocal<*>;)Ljava/lang/Object; )
 java.lang.Object getAfterMiss(
java.lang.ThreadLocal)
@dalvik.annotation.Signature (value =(Ljava/lang/ThreadLocal<*>;Ljava/lang/Object;)V )
 void put(
java.lang.ThreadLocal
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/lang/ThreadLocal<*>;)V )
 void remove(
java.lang.ThreadLocal)

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Enumeration<Ljava/net/URL;>; )
 class java.lang.TwoEnumerationsInOne extends java.lang.Object implements java.util.Enumeration

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Enumeration<Ljava/net/URL;>; )
private java.util.Enumeration first
@dalvik.annotation.Signature (value =Ljava/util/Enumeration<Ljava/net/URL;>; )
private java.util.Enumeration second
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/Enumeration<Ljava/net/URL;>;Ljava/util/Enumeration<Ljava/net/URL;>;)V )
public void <init>(
java.util.Enumeration
java.util.Enumeration)

public boolean hasMoreElements()

public volatile java.lang.Object nextElement()

public java.net.URL nextElement()

________________CLASS________________


public class java.lang.TypeNotPresentException extends java.lang.RuntimeException

----------------FIELDS----------------

private static final long serialVersionUID

private java.lang.String typeName
----------------METHODS----------------

public void <init>(
java.lang.String
java.lang.Throwable)

public java.lang.String typeName()

________________CLASS________________


public class java.lang.UnknownError extends java.lang.VirtualMachineError

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class java.lang.UnsatisfiedLinkError extends java.lang.LinkageError

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class java.lang.UnsupportedClassVersionError extends java.lang.ClassFormatError

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class java.lang.UnsupportedOperationException extends java.lang.RuntimeException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.Throwable)

public void <init>(
java.lang.Throwable)

________________CLASS________________

@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Enumeration<TT;>; )
@dalvik.annotation.EnclosingClass (value =Ljava/lang/VMClassLoader; )
@dalvik.annotation.InnerClass (accessFlags =10 name =EnumerateListArray )
 class java.lang.VMClassLoader$EnumerateListArray extends java.lang.Object implements java.util.Enumeration

----------------FIELDS----------------

private int i

private final java.util.ArrayList mList
----------------METHODS----------------

 void <init>(
java.util.ArrayList)

public boolean hasMoreElements()
@dalvik.annotation.Signature (value =()TT; )
public java.lang.Object nextElement()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/lang/VMClassLoader$EnumerateListArray; )
 class java.lang.VMClassLoader extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()
@dalvik.annotation.Throws (value =Ljava/lang/ClassFormatError; )
static native java.lang.Class defineClass(
java.lang.ClassLoader
java.lang.String
byte[]
int
int
java.security.ProtectionDomain)
@dalvik.annotation.Throws (value =Ljava/lang/ClassFormatError; )
static native java.lang.Class defineClass(
java.lang.ClassLoader
byte[]
int
int
java.security.ProtectionDomain)

static native java.lang.Class findLoadedClass(
java.lang.ClassLoader
java.lang.String)

private static native java.lang.String getBootClassPathResource(
java.lang.String
int)

private static native int getBootClassPathSize()

static native java.lang.Class getPrimitiveClass(
char)

static java.net.URL getResource(
java.lang.String)
@dalvik.annotation.Signature (value =(Ljava/lang/String;)Ljava/util/Enumeration<Ljava/net/URL;>; )
static java.util.Enumeration getResources(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/lang/ClassNotFoundException; )
static native java.lang.Class loadClass(
java.lang.String
boolean)

________________CLASS________________


 class java.lang.VMThread extends java.lang.Object

----------------FIELDS----------------

static final java.lang.Thread$State[] STATE_MAP

 java.lang.Thread thread

 int vmData
----------------METHODS----------------

static void <clinit>()

 void <init>(
java.lang.Thread)

static native void create(
java.lang.Thread
long)

static native java.lang.Thread currentThread()

static native boolean interrupted()
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
static native void sleep(
long
int)

static native void yield()

native int getStatus()

native boolean holdsLock(
java.lang.Object)

native void interrupt()

native boolean isInterrupted()

native void nameChanged(
java.lang.String)

 void resume()

native void setPriority(
int)

 void start(
long)

 void stop(
java.lang.Throwable)

 void suspend()

________________CLASS________________


public class java.lang.VerifyError extends java.lang.LinkageError

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public final class java.lang.Void extends java.lang.Object

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/lang/Class<Ljava/lang/Void;>; )
public static final java.lang.Class TYPE
----------------METHODS----------------

static void <clinit>()

private void <init>()
@dalvik.annotation.Signature (value =()Ljava/lang/Class<Ljava/lang/Void;>; )
private static java.lang.Class lookupType()

________________CLASS________________


 class java.lang.WriterOutputStream extends java.io.OutputStream

----------------FIELDS----------------

private byte[] bytes

private int numBytes

private java.io.Writer writer
----------------METHODS----------------

public void <init>(
java.io.Writer)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeBuffer()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void flush()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
int)

________________CLASS________________


public class java.lang.annotation.AnnotationFormatError extends java.lang.Error

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.Throwable)

public void <init>(
java.lang.Throwable)

________________CLASS________________


public class java.lang.annotation.AnnotationTypeMismatchException extends java.lang.RuntimeException

----------------FIELDS----------------

private static final long serialVersionUID

private java.lang.reflect.Method element

private java.lang.String foundType
----------------METHODS----------------

public void <init>(
java.lang.reflect.Method
java.lang.String)

public java.lang.reflect.Method element()

public java.lang.String foundType()

________________CLASS________________

@java.lang.annotation.Retention (value =Ljava/lang/annotation/RetentionPolicy;!RUNTIME )
@java.lang.annotation.Target (value =Ljava/lang/annotation/ElementType;!ANNOTATION_TYPE )
@java.lang.annotation.Documented
public abstract interface class java.lang.annotation.Documented extends java.lang.Object implements java.lang.annotation.Annotation

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Enum<Ljava/lang/annotation/ElementType;>; )
public final class java.lang.annotation.ElementType extends java.lang.Enum

----------------FIELDS----------------

private static final java.lang.annotation.ElementType[] $VALUES

public static final java.lang.annotation.ElementType ANNOTATION_TYPE

public static final java.lang.annotation.ElementType CONSTRUCTOR

public static final java.lang.annotation.ElementType FIELD

public static final java.lang.annotation.ElementType LOCAL_VARIABLE

public static final java.lang.annotation.ElementType METHOD

public static final java.lang.annotation.ElementType PACKAGE

public static final java.lang.annotation.ElementType PARAMETER

public static final java.lang.annotation.ElementType TYPE
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Signature (value =()V )
private void <init>(
java.lang.String
int)

public static java.lang.annotation.ElementType valueOf(
java.lang.String)

public static java.lang.annotation.ElementType[] values()

________________CLASS________________


public class java.lang.annotation.IncompleteAnnotationException extends java.lang.RuntimeException

----------------FIELDS----------------

private static final long serialVersionUID
@dalvik.annotation.Signature (value =Ljava/lang/Class<+Ljava/lang/annotation/Annotation;>; )
private java.lang.Class annotationType

private java.lang.String elementName
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/lang/Class<+Ljava/lang/annotation/Annotation;>;Ljava/lang/String;)V )
public void <init>(
java.lang.Class
java.lang.String)
@dalvik.annotation.Signature (value =()Ljava/lang/Class<+Ljava/lang/annotation/Annotation;>; )
public java.lang.Class annotationType()

public java.lang.String elementName()

________________CLASS________________

@java.lang.annotation.Target (value =Ljava/lang/annotation/ElementType;!ANNOTATION_TYPE )
@java.lang.annotation.Documented
@java.lang.annotation.Retention (value =Ljava/lang/annotation/RetentionPolicy;!RUNTIME )
public abstract interface class java.lang.annotation.Inherited extends java.lang.Object implements java.lang.annotation.Annotation

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@java.lang.annotation.Retention (value =Ljava/lang/annotation/RetentionPolicy;!RUNTIME )
@dalvik.annotation.AnnotationDefault (value =Ljava/lang/annotation/Retention;:[value =Ljava/lang/annotation/RetentionPolicy;!CLASS] )
@java.lang.annotation.Target (value =Ljava/lang/annotation/ElementType;!ANNOTATION_TYPE )
@java.lang.annotation.Documented
public abstract interface class java.lang.annotation.Retention extends java.lang.Object implements java.lang.annotation.Annotation

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.lang.annotation.RetentionPolicy value()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Enum<Ljava/lang/annotation/RetentionPolicy;>; )
public final class java.lang.annotation.RetentionPolicy extends java.lang.Enum

----------------FIELDS----------------

private static final java.lang.annotation.RetentionPolicy[] $VALUES

public static final java.lang.annotation.RetentionPolicy CLASS

public static final java.lang.annotation.RetentionPolicy RUNTIME

public static final java.lang.annotation.RetentionPolicy SOURCE
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Signature (value =()V )
private void <init>(
java.lang.String
int)

public static java.lang.annotation.RetentionPolicy valueOf(
java.lang.String)

public static java.lang.annotation.RetentionPolicy[] values()

________________CLASS________________

@java.lang.annotation.Documented
@java.lang.annotation.Target (value =Ljava/lang/annotation/ElementType;!ANNOTATION_TYPE )
@java.lang.annotation.Retention (value =Ljava/lang/annotation/RetentionPolicy;!RUNTIME )
public abstract interface class java.lang.annotation.Target extends java.lang.Object implements java.lang.annotation.Annotation

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.lang.annotation.ElementType[] value()

________________CLASS________________

@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>Ljava/lang/ref/Reference<TT;>; )
public class java.lang.ref.PhantomReference extends java.lang.ref.Reference

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =(TT;Ljava/lang/ref/ReferenceQueue<-TT;>;)V )
public void <init>(
java.lang.Object
java.lang.ref.ReferenceQueue)
@dalvik.annotation.Signature (value =()TT; )
public java.lang.Object get()

________________CLASS________________

@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>Ljava/lang/ref/Reference<TT;>; )
public class java.lang.ref.SoftReference extends java.lang.ref.Reference

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =(TT;)V )
public void <init>(
java.lang.Object)
@dalvik.annotation.Signature (value =(TT;Ljava/lang/ref/ReferenceQueue<-TT;>;)V )
public void <init>(
java.lang.Object
java.lang.ref.ReferenceQueue)

________________CLASS________________


public class java.lang.reflect.AccessibleObject extends java.lang.Object implements java.lang.reflect.AnnotatedElement

----------------FIELDS----------------

private static final java.lang.String DIMENSION_1

private static final java.lang.String DIMENSION_2

private static final java.lang.String DIMENSION_3
@dalvik.annotation.Signature (value =Ljava/util/Hashtable<Ljava/lang/String;Ljava/lang/String;>; )
static java.util.Hashtable trans

 boolean flag
----------------METHODS----------------

static void <clinit>()

protected void <init>()

private static native java.lang.Object[] getClassSignatureAnnotation(
java.lang.Class)

static java.lang.String getClassSignatureAttribute(
java.lang.Class)

static org.apache.harmony.kernel.vm.ReflectionAccess getReflectionAccess()
@dalvik.annotation.Throws (value =Ljava/lang/SecurityException; )
public static void setAccessible(
java.lang.reflect.AccessibleObject[]
boolean)

 void appendArrayGenericType(
java.lang.StringBuilder
java.lang.reflect.Type[])
@dalvik.annotation.Signature (value =(Ljava/lang/StringBuilder;Ljava/lang/Class<*>;)V )
 void appendArrayType(
java.lang.StringBuilder
java.lang.Class)

 void appendArrayType(
java.lang.StringBuilder
java.lang.Class[])

 void appendGenericType(
java.lang.StringBuilder
java.lang.reflect.Type)
@dalvik.annotation.Signature (value =(Ljava/lang/StringBuilder;[Ljava/lang/Class<*>;)V )
 void appendSimpleType(
java.lang.StringBuilder
java.lang.Class[])
@dalvik.annotation.Signature (value =<T::Ljava/lang/annotation/Annotation;>(Ljava/lang/Class<TT;>;)TT; )
public java.lang.annotation.Annotation getAnnotation(
java.lang.Class)

public java.lang.annotation.Annotation[] getAnnotations()

public java.lang.annotation.Annotation[] getDeclaredAnnotations()
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;)Ljava/lang/String; )
 java.lang.String getSignature(
java.lang.Class)

 java.lang.String getSignatureAttribute()

public boolean isAccessible()
@dalvik.annotation.Signature (value =(Ljava/lang/Class<+Ljava/lang/annotation/Annotation;>;)Z )
public boolean isAnnotationPresent(
java.lang.Class)
@dalvik.annotation.Throws (value =Ljava/lang/SecurityException; )
public void setAccessible(
boolean)

 void setAccessibleNoCheck(
boolean)
@dalvik.annotation.Signature (value =([Ljava/lang/Class<*>;)Ljava/lang/String; )
 java.lang.String toString(
java.lang.Class[])

________________CLASS________________


public final class java.lang.reflect.Array extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

private void <init>()
@dalvik.annotation.Throws (value =Ljava/lang/NegativeArraySizeException; )
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;[I)Ljava/lang/Object; )
private static native java.lang.Object createMultiArray(
java.lang.Class
int[])
@dalvik.annotation.Throws (value =Ljava/lang/NegativeArraySizeException; )
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;I)Ljava/lang/Object; )
private static native java.lang.Object createObjectArray(
java.lang.Class
int)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException;Ljava/lang/ArrayIndexOutOfBoundsException; )
public static java.lang.Object get(
java.lang.Object
int)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException;Ljava/lang/ArrayIndexOutOfBoundsException; )
public static boolean getBoolean(
java.lang.Object
int)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException;Ljava/lang/ArrayIndexOutOfBoundsException; )
public static byte getByte(
java.lang.Object
int)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException;Ljava/lang/ArrayIndexOutOfBoundsException; )
public static char getChar(
java.lang.Object
int)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException;Ljava/lang/ArrayIndexOutOfBoundsException; )
public static double getDouble(
java.lang.Object
int)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException;Ljava/lang/ArrayIndexOutOfBoundsException; )
public static float getFloat(
java.lang.Object
int)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException;Ljava/lang/ArrayIndexOutOfBoundsException; )
public static int getInt(
java.lang.Object
int)

public static int getLength(
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException;Ljava/lang/ArrayIndexOutOfBoundsException; )
public static long getLong(
java.lang.Object
int)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException;Ljava/lang/ArrayIndexOutOfBoundsException; )
public static short getShort(
java.lang.Object
int)
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;I)Ljava/lang/Object; )
@dalvik.annotation.Throws (value =Ljava/lang/NegativeArraySizeException; )
public static java.lang.Object newInstance(
java.lang.Class
int)
@dalvik.annotation.Throws (value =Ljava/lang/NegativeArraySizeException;Ljava/lang/IllegalArgumentException; )
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;[I)Ljava/lang/Object; )
public static java.lang.Object newInstance(
java.lang.Class
int[])
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException;Ljava/lang/ArrayIndexOutOfBoundsException; )
public static void set(
java.lang.Object
int
java.lang.Object)

public static void setBoolean(
java.lang.Object
int
boolean)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException;Ljava/lang/ArrayIndexOutOfBoundsException; )
public static void setByte(
java.lang.Object
int
byte)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException;Ljava/lang/ArrayIndexOutOfBoundsException; )
public static void setChar(
java.lang.Object
int
char)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException;Ljava/lang/ArrayIndexOutOfBoundsException; )
public static void setDouble(
java.lang.Object
int
double)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException;Ljava/lang/ArrayIndexOutOfBoundsException; )
public static void setFloat(
java.lang.Object
int
float)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException;Ljava/lang/ArrayIndexOutOfBoundsException; )
public static void setInt(
java.lang.Object
int
int)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException;Ljava/lang/ArrayIndexOutOfBoundsException; )
public static void setLong(
java.lang.Object
int
long)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException;Ljava/lang/ArrayIndexOutOfBoundsException; )
public static void setShort(
java.lang.Object
int
short)

________________CLASS________________


public abstract interface class java.lang.reflect.Member extends java.lang.Object

----------------FIELDS----------------

public static final int DECLARED

public static final int PUBLIC
----------------METHODS----------------

public abstract java.lang.Class getDeclaringClass()

public abstract int getModifiers()

public abstract java.lang.String getName()

public abstract boolean isSynthetic()

________________CLASS________________

@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>Ljava/lang/reflect/AccessibleObject;Ljava/lang/reflect/GenericDeclaration;Ljava/lang/reflect/Member; )
public final class java.lang.reflect.Constructor extends java.lang.reflect.AccessibleObject implements java.lang.reflect.GenericDeclaration, java.lang.reflect.Member

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/lang/Class<TT;>; )
 java.lang.Class declaringClass
@dalvik.annotation.Signature (value =[Ljava/lang/Class<*>; )
 java.lang.Class[] exceptionTypes
@dalvik.annotation.Signature (value =[Ljava/lang/reflect/TypeVariable<Ljava/lang/reflect/Constructor<TT;>;>; )
 java.lang.reflect.TypeVariable[] formalTypeParameters

 org.apache.harmony.luni.lang.reflect.ListOfTypes genericExceptionTypes

 org.apache.harmony.luni.lang.reflect.ListOfTypes genericParameterTypes

private volatile boolean genericTypesAreInitialized
@dalvik.annotation.Signature (value =[Ljava/lang/Class<*>; )
 java.lang.Class[] parameterTypes

 int slot
----------------METHODS----------------

private void <init>()
@dalvik.annotation.Signature (value =(Ljava/lang/Class<TT;>;[Ljava/lang/Class<*>;[Ljava/lang/Class<*>;I)V )
private void <init>(
java.lang.Class
java.lang.Class[]
java.lang.Class[]
int)
@dalvik.annotation.Throws (value =Ljava/lang/InstantiationException;Ljava/lang/IllegalAccessException;Ljava/lang/reflect/InvocationTargetException; )
@dalvik.annotation.Signature (value =([Ljava/lang/Object;Ljava/lang/Class<TT;>;[Ljava/lang/Class<*>;IZ)TT; )
private native java.lang.Object constructNative(
java.lang.Object[]
java.lang.Class
java.lang.Class[]
int
boolean)
@dalvik.annotation.Signature (value =(Ljava/lang/Class<TT;>;I)I )
private native int getConstructorModifiers(
java.lang.Class
int)

private native java.lang.annotation.Annotation[] getDeclaredAnnotations(
java.lang.Class
int)

private native java.lang.annotation.Annotation[][] getParameterAnnotations(
java.lang.Class
int)

private java.lang.String getSignature()

private native java.lang.Object[] getSignatureAnnotation(
java.lang.Class
int)

private void initGenericTypes()

public boolean equals(
java.lang.Object)

public java.lang.annotation.Annotation[] getDeclaredAnnotations()
@dalvik.annotation.Signature (value =()Ljava/lang/Class<TT;>; )
public java.lang.Class getDeclaringClass()
@dalvik.annotation.Signature (value =()[Ljava/lang/Class<*>; )
public java.lang.Class[] getExceptionTypes()

public java.lang.reflect.Type[] getGenericExceptionTypes()

public java.lang.reflect.Type[] getGenericParameterTypes()

public int getModifiers()

public java.lang.String getName()

public java.lang.annotation.Annotation[][] getParameterAnnotations()
@dalvik.annotation.Signature (value =()[Ljava/lang/Class<*>; )
public java.lang.Class[] getParameterTypes()

 java.lang.String getSignatureAttribute()
@dalvik.annotation.Signature (value =()[Ljava/lang/reflect/TypeVariable<Ljava/lang/reflect/Constructor<TT;>;>; )
public java.lang.reflect.TypeVariable[] getTypeParameters()

public int hashCode()

public boolean isSynthetic()

public boolean isVarArgs()
@dalvik.annotation.Throws (value =Ljava/lang/InstantiationException;Ljava/lang/IllegalAccessException;Ljava/lang/IllegalArgumentException;Ljava/lang/reflect/InvocationTargetException; )
@dalvik.annotation.Signature (value =([Ljava/lang/Object;)TT; )
public transient java.lang.Object newInstance(
java.lang.Object[])

public java.lang.String toGenericString()

public java.lang.String toString()

________________CLASS________________


public final class java.lang.reflect.Field extends java.lang.reflect.AccessibleObject implements java.lang.reflect.Member

----------------FIELDS----------------

private static final int TYPE_BOOLEAN

private static final int TYPE_BYTE

private static final int TYPE_CHAR

private static final int TYPE_DOUBLE

private static final int TYPE_FLOAT

private static final int TYPE_INTEGER

private static final int TYPE_LONG

private static final int TYPE_SHORT
@dalvik.annotation.Signature (value =Ljava/lang/Class<*>; )
private java.lang.Class declaringClass

private java.lang.reflect.Type genericType

private volatile boolean genericTypesAreInitialized

private java.lang.String name

private int slot
@dalvik.annotation.Signature (value =Ljava/lang/Class<*>; )
private java.lang.Class type
----------------METHODS----------------

private void <init>()
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;Ljava/lang/Class<*>;Ljava/lang/String;I)V )
private void <init>(
java.lang.Class
java.lang.Class
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalAccessException; )
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Class<*>;Ljava/lang/Class<*>;IZI)B )
private native byte getBField(
java.lang.Object
java.lang.Class
java.lang.Class
int
boolean
int)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalAccessException; )
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Class<*>;Ljava/lang/Class<*>;IZI)C )
private native char getCField(
java.lang.Object
java.lang.Class
java.lang.Class
int
boolean
int)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalAccessException; )
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Class<*>;Ljava/lang/Class<*>;IZI)D )
private native double getDField(
java.lang.Object
java.lang.Class
java.lang.Class
int
boolean
int)

private native java.lang.annotation.Annotation[] getDeclaredAnnotations(
java.lang.Class
int)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Class<*>;Ljava/lang/Class<*>;IZI)F )
@dalvik.annotation.Throws (value =Ljava/lang/IllegalAccessException; )
private native float getFField(
java.lang.Object
java.lang.Class
java.lang.Class
int
boolean
int)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Class<*>;Ljava/lang/Class<*>;IZ)Ljava/lang/Object; )
@dalvik.annotation.Throws (value =Ljava/lang/IllegalAccessException; )
private native java.lang.Object getField(
java.lang.Object
java.lang.Class
java.lang.Class
int
boolean)
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;I)I )
private native int getFieldModifiers(
java.lang.Class
int)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Class<*>;Ljava/lang/Class<*>;IZI)I )
@dalvik.annotation.Throws (value =Ljava/lang/IllegalAccessException; )
private native int getIField(
java.lang.Object
java.lang.Class
java.lang.Class
int
boolean
int)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Class<*>;Ljava/lang/Class<*>;IZI)J )
@dalvik.annotation.Throws (value =Ljava/lang/IllegalAccessException; )
private native long getJField(
java.lang.Object
java.lang.Class
java.lang.Class
int
boolean
int)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Class<*>;Ljava/lang/Class<*>;IZI)S )
@dalvik.annotation.Throws (value =Ljava/lang/IllegalAccessException; )
private native short getSField(
java.lang.Object
java.lang.Class
java.lang.Class
int
boolean
int)

private java.lang.String getSignature()

private native java.lang.Object[] getSignatureAnnotation(
java.lang.Class
int)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Class<*>;Ljava/lang/Class<*>;IZI)Z )
@dalvik.annotation.Throws (value =Ljava/lang/IllegalAccessException; )
private native boolean getZField(
java.lang.Object
java.lang.Class
java.lang.Class
int
boolean
int)

private void initGenericType()
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Class<*>;Ljava/lang/Class<*>;IZIB)V )
@dalvik.annotation.Throws (value =Ljava/lang/IllegalAccessException; )
private native void setBField(
java.lang.Object
java.lang.Class
java.lang.Class
int
boolean
int
byte)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Class<*>;Ljava/lang/Class<*>;IZIC)V )
@dalvik.annotation.Throws (value =Ljava/lang/IllegalAccessException; )
private native void setCField(
java.lang.Object
java.lang.Class
java.lang.Class
int
boolean
int
char)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalAccessException; )
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Class<*>;Ljava/lang/Class<*>;IZID)V )
private native void setDField(
java.lang.Object
java.lang.Class
java.lang.Class
int
boolean
int
double)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Class<*>;Ljava/lang/Class<*>;IZIF)V )
@dalvik.annotation.Throws (value =Ljava/lang/IllegalAccessException; )
private native void setFField(
java.lang.Object
java.lang.Class
java.lang.Class
int
boolean
int
float)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Class<*>;Ljava/lang/Class<*>;IZLjava/lang/Object;)V )
@dalvik.annotation.Throws (value =Ljava/lang/IllegalAccessException; )
private native void setField(
java.lang.Object
java.lang.Class
java.lang.Class
int
boolean
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Class<*>;Ljava/lang/Class<*>;IZII)V )
@dalvik.annotation.Throws (value =Ljava/lang/IllegalAccessException; )
private native void setIField(
java.lang.Object
java.lang.Class
java.lang.Class
int
boolean
int
int)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Class<*>;Ljava/lang/Class<*>;IZIJ)V )
@dalvik.annotation.Throws (value =Ljava/lang/IllegalAccessException; )
private native void setJField(
java.lang.Object
java.lang.Class
java.lang.Class
int
boolean
int
long)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalAccessException; )
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Class<*>;Ljava/lang/Class<*>;IZIS)V )
private native void setSField(
java.lang.Object
java.lang.Class
java.lang.Class
int
boolean
int
short)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalAccessException; )
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Class<*>;Ljava/lang/Class<*>;IZIZ)V )
private native void setZField(
java.lang.Object
java.lang.Class
java.lang.Class
int
boolean
int
boolean)

public boolean equals(
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalAccessException;Ljava/lang/IllegalArgumentException; )
public java.lang.Object get(
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalAccessException;Ljava/lang/IllegalArgumentException; )
public boolean getBoolean(
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalAccessException;Ljava/lang/IllegalArgumentException; )
public byte getByte(
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalAccessException;Ljava/lang/IllegalArgumentException; )
public char getChar(
java.lang.Object)

public java.lang.annotation.Annotation[] getDeclaredAnnotations()
@dalvik.annotation.Signature (value =()Ljava/lang/Class<*>; )
public java.lang.Class getDeclaringClass()
@dalvik.annotation.Throws (value =Ljava/lang/IllegalAccessException;Ljava/lang/IllegalArgumentException; )
public double getDouble(
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalAccessException;Ljava/lang/IllegalArgumentException; )
public float getFloat(
java.lang.Object)

public java.lang.reflect.Type getGenericType()
@dalvik.annotation.Throws (value =Ljava/lang/IllegalAccessException;Ljava/lang/IllegalArgumentException; )
public int getInt(
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalAccessException;Ljava/lang/IllegalArgumentException; )
public long getLong(
java.lang.Object)

public int getModifiers()

public java.lang.String getName()
@dalvik.annotation.Throws (value =Ljava/lang/IllegalAccessException;Ljava/lang/IllegalArgumentException; )
public short getShort(
java.lang.Object)

 java.lang.String getSignatureAttribute()
@dalvik.annotation.Signature (value =()Ljava/lang/Class<*>; )
public java.lang.Class getType()

public int hashCode()

public boolean isEnumConstant()

public boolean isSynthetic()
@dalvik.annotation.Throws (value =Ljava/lang/IllegalAccessException;Ljava/lang/IllegalArgumentException; )
public void set(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalAccessException;Ljava/lang/IllegalArgumentException; )
public void setBoolean(
java.lang.Object
boolean)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalAccessException;Ljava/lang/IllegalArgumentException; )
public void setByte(
java.lang.Object
byte)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalAccessException;Ljava/lang/IllegalArgumentException; )
public void setChar(
java.lang.Object
char)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalAccessException;Ljava/lang/IllegalArgumentException; )
public void setDouble(
java.lang.Object
double)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalAccessException;Ljava/lang/IllegalArgumentException; )
public void setFloat(
java.lang.Object
float)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalAccessException;Ljava/lang/IllegalArgumentException; )
public void setInt(
java.lang.Object
int)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalAccessException;Ljava/lang/IllegalArgumentException; )
public void setLong(
java.lang.Object
long)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalAccessException;Ljava/lang/IllegalArgumentException; )
public void setShort(
java.lang.Object
short)

public java.lang.String toGenericString()

public java.lang.String toString()

________________CLASS________________


public abstract interface class java.lang.reflect.GenericArrayType extends java.lang.Object implements java.lang.reflect.Type

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.lang.reflect.Type getGenericComponentType()

________________CLASS________________


public class java.lang.reflect.GenericSignatureFormatError extends java.lang.ClassFormatError

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

________________CLASS________________


public abstract interface class java.lang.reflect.InvocationHandler extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/lang/Throwable; )
public abstract java.lang.Object invoke(
java.lang.Object
java.lang.reflect.Method
java.lang.Object[])

________________CLASS________________


public class java.lang.reflect.InvocationTargetException extends java.lang.Exception

----------------FIELDS----------------

private static final long serialVersionUID

private java.lang.Throwable target
----------------METHODS----------------

protected void <init>()

public void <init>(
java.lang.Throwable)

public void <init>(
java.lang.Throwable
java.lang.String)

public java.lang.Throwable getCause()

public java.lang.Throwable getTargetException()

________________CLASS________________


public class java.lang.reflect.MalformedParameterizedTypeException extends java.lang.RuntimeException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

________________CLASS________________


public final class java.lang.reflect.Method extends java.lang.reflect.AccessibleObject implements java.lang.reflect.GenericDeclaration, java.lang.reflect.Member

----------------FIELDS----------------

private static final java.lang.annotation.Annotation[] NO_ANNOTATIONS
@dalvik.annotation.Signature (value =Ljava/lang/Class<*>; )
private java.lang.Class declaringClass
@dalvik.annotation.Signature (value =[Ljava/lang/Class<*>; )
private java.lang.Class[] exceptionTypes
@dalvik.annotation.Signature (value =[Ljava/lang/reflect/TypeVariable<Ljava/lang/reflect/Method;>; )
private java.lang.reflect.TypeVariable[] formalTypeParameters

private org.apache.harmony.luni.lang.reflect.ListOfTypes genericExceptionTypes

private org.apache.harmony.luni.lang.reflect.ListOfTypes genericParameterTypes

private java.lang.reflect.Type genericReturnType

private volatile boolean genericTypesAreInitialized

private java.lang.String name
@dalvik.annotation.Signature (value =[Ljava/lang/Class<*>; )
private java.lang.Class[] parameterTypes
@dalvik.annotation.Signature (value =Ljava/lang/Class<*>; )
private java.lang.Class returnType

private int slot
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;[Ljava/lang/Class<*>;[Ljava/lang/Class<*>;Ljava/lang/Class<*>;Ljava/lang/String;I)V )
private void <init>(
java.lang.Class
java.lang.Class[]
java.lang.Class[]
java.lang.Class
java.lang.String
int)

 void <init>(
java.lang.reflect.Method)

private native java.lang.annotation.Annotation[] getDeclaredAnnotations(
java.lang.Class
int)

private native java.lang.Object getDefaultValue(
java.lang.Class
int)
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;I)I )
private native int getMethodModifiers(
java.lang.Class
int)

private native java.lang.annotation.Annotation[][] getParameterAnnotations(
java.lang.Class
int)

private java.lang.String getSignature()

private native java.lang.Object[] getSignatureAnnotation(
java.lang.Class
int)

private void initGenericTypes()
@dalvik.annotation.Throws (value =Ljava/lang/IllegalAccessException;Ljava/lang/IllegalArgumentException;Ljava/lang/reflect/InvocationTargetException; )
@dalvik.annotation.Signature (value =(Ljava/lang/Object;[Ljava/lang/Object;Ljava/lang/Class<*>;[Ljava/lang/Class<*>;Ljava/lang/Class<*>;IZ)Ljava/lang/Object; )
private native java.lang.Object invokeNative(
java.lang.Object
java.lang.Object[]
java.lang.Class
java.lang.Class[]
java.lang.Class
int
boolean)

static java.lang.annotation.Annotation[][] noAnnotations(
int)

public boolean equals(
java.lang.Object)

public java.lang.annotation.Annotation[] getDeclaredAnnotations()
@dalvik.annotation.Signature (value =()Ljava/lang/Class<*>; )
public java.lang.Class getDeclaringClass()

public java.lang.Object getDefaultValue()
@dalvik.annotation.Signature (value =()[Ljava/lang/Class<*>; )
public java.lang.Class[] getExceptionTypes()

public java.lang.reflect.Type[] getGenericExceptionTypes()

public java.lang.reflect.Type[] getGenericParameterTypes()

public java.lang.reflect.Type getGenericReturnType()

public int getModifiers()

public java.lang.String getName()

public java.lang.annotation.Annotation[][] getParameterAnnotations()
@dalvik.annotation.Signature (value =()[Ljava/lang/Class<*>; )
public java.lang.Class[] getParameterTypes()
@dalvik.annotation.Signature (value =()Ljava/lang/Class<*>; )
public java.lang.Class getReturnType()

 java.lang.String getSignatureAttribute()
@dalvik.annotation.Signature (value =()[Ljava/lang/reflect/TypeVariable<Ljava/lang/reflect/Method;>; )
public java.lang.reflect.TypeVariable[] getTypeParameters()

public int hashCode()
@dalvik.annotation.Throws (value =Ljava/lang/IllegalAccessException;Ljava/lang/IllegalArgumentException;Ljava/lang/reflect/InvocationTargetException; )
public transient java.lang.Object invoke(
java.lang.Object
java.lang.Object[])

public boolean isBridge()

public boolean isSynthetic()

public boolean isVarArgs()

public java.lang.String toGenericString()

public java.lang.String toString()

________________CLASS________________


public class java.lang.reflect.Modifier extends java.lang.Object

----------------FIELDS----------------

public static final int ABSTRACT

static final int ANNOTATION

static final int BRIDGE

static final int ENUM

public static final int FINAL

public static final int INTERFACE

public static final int NATIVE

public static final int PRIVATE

public static final int PROTECTED

public static final int PUBLIC

public static final int STATIC

public static final int STRICT

public static final int SYNCHRONIZED

static final int SYNTHETIC

public static final int TRANSIENT

static final int VARARGS

public static final int VOLATILE
----------------METHODS----------------

public void <init>()

public static boolean isAbstract(
int)

public static boolean isFinal(
int)

public static boolean isInterface(
int)

public static boolean isNative(
int)

public static boolean isPrivate(
int)

public static boolean isProtected(
int)

public static boolean isPublic(
int)

public static boolean isStatic(
int)

public static boolean isStrict(
int)

public static boolean isSynchronized(
int)

public static boolean isTransient(
int)

public static boolean isVolatile(
int)

public static java.lang.String toString(
int)

________________CLASS________________


public abstract interface class java.lang.reflect.ParameterizedType extends java.lang.Object implements java.lang.reflect.Type

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.lang.reflect.Type[] getActualTypeArguments()

public abstract java.lang.reflect.Type getOwnerType()

public abstract java.lang.reflect.Type getRawType()

________________CLASS________________


public class java.lang.reflect.Proxy extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------

private static int NextClassNameIndex
@dalvik.annotation.Signature (value =Ljava/util/Map<Ljava/lang/ClassLoader;Ljava/util/Map<Ljava/lang/String;Ljava/lang/ref/WeakReference<Ljava/lang/Class<*>;>;>;>; )
private static final java.util.Map loaderCache
@dalvik.annotation.Signature (value =Ljava/util/Map<Ljava/lang/Class<*>;Ljava/lang/String;>; )
private static final java.util.Map proxyCache

private static final long serialVersionUID

protected java.lang.reflect.InvocationHandler h
----------------METHODS----------------

static void <clinit>()

private void <init>()

protected void <init>(
java.lang.reflect.InvocationHandler)

private static native void constructorPrototype(
java.lang.reflect.InvocationHandler)

private static native java.lang.Class generateProxy(
java.lang.String
java.lang.Class[]
java.lang.ClassLoader)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public static java.lang.reflect.InvocationHandler getInvocationHandler(
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
@dalvik.annotation.Signature (value =(Ljava/lang/ClassLoader;[Ljava/lang/Class<*>;)Ljava/lang/Class<*>; )
public static transient java.lang.Class getProxyClass(
java.lang.ClassLoader
java.lang.Class[])
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;)Z )
public static boolean isProxyClass(
java.lang.Class)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
@dalvik.annotation.Signature (value =(Ljava/lang/ClassLoader;[Ljava/lang/Class<*>;Ljava/lang/reflect/InvocationHandler;)Ljava/lang/Object; )
public static java.lang.Object newProxyInstance(
java.lang.ClassLoader
java.lang.Class[]
java.lang.reflect.InvocationHandler)

________________CLASS________________


public final class java.lang.reflect.ReflectPermission extends java.security.BasicPermission

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.String)

________________CLASS________________


public abstract interface class org.apache.harmony.kernel.vm.ReflectionAccess extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.lang.reflect.Method accessibleClone(
java.lang.reflect.Method)

public abstract java.lang.reflect.Method clone(
java.lang.reflect.Method)

public abstract void setAccessibleNoCheck(
java.lang.reflect.AccessibleObject
boolean)

________________CLASS________________


final class java.lang.reflect.ReflectionAccessImpl extends java.lang.Object implements org.apache.harmony.kernel.vm.ReflectionAccess

----------------FIELDS----------------

static final java.lang.reflect.ReflectionAccessImpl THE_ONE
----------------METHODS----------------

static void <clinit>()

private void <init>()

public java.lang.reflect.Method accessibleClone(
java.lang.reflect.Method)

public java.lang.reflect.Method clone(
java.lang.reflect.Method)

public void setAccessibleNoCheck(
java.lang.reflect.AccessibleObject
boolean)

________________CLASS________________

@dalvik.annotation.Signature (value =<D::Ljava/lang/reflect/GenericDeclaration;>Ljava/lang/Object;Ljava/lang/reflect/Type; )
public abstract interface class java.lang.reflect.TypeVariable extends java.lang.Object implements java.lang.reflect.Type

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.lang.reflect.Type[] getBounds()
@dalvik.annotation.Signature (value =()TD; )
public abstract java.lang.reflect.GenericDeclaration getGenericDeclaration()

public abstract java.lang.String getName()

________________CLASS________________


public class java.lang.reflect.UndeclaredThrowableException extends java.lang.RuntimeException

----------------FIELDS----------------

private static final long serialVersionUID

private java.lang.Throwable undeclaredThrowable
----------------METHODS----------------

public void <init>(
java.lang.Throwable)

public void <init>(
java.lang.Throwable
java.lang.String)

public java.lang.Throwable getCause()

public java.lang.Throwable getUndeclaredThrowable()

________________CLASS________________


public abstract interface class java.lang.reflect.WildcardType extends java.lang.Object implements java.lang.reflect.Type

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.lang.reflect.Type[] getLowerBounds()

public abstract java.lang.reflect.Type[] getUpperBounds()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =4104 name =null )
@dalvik.annotation.EnclosingClass (value =Ljava/math/BigDecimal; )
 class java.math.BigDecimal$1 extends java.lang.Object

----------------FIELDS----------------

static final int[] $SwitchMap$java$math$RoundingMode
----------------METHODS----------------

static void <clinit>()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Number;Ljava/lang/Comparable<Ljava/math/BigDecimal;>;Ljava/io/Serializable; )
@dalvik.annotation.MemberClasses (value =Ljava/math/BigDecimal$1; )
public class java.math.BigDecimal extends java.lang.Number implements java.lang.Comparable, java.io.Serializable

----------------FIELDS----------------

private static final java.math.BigDecimal[] BI_SCALED_BY_ZERO

private static final int BI_SCALED_BY_ZERO_LENGTH

private static final char[] CH_ZEROS

private static final java.math.BigInteger[] FIVE_POW

private static final double LOG10_2

private static final long[] LONG_FIVE_POW

private static final int[] LONG_FIVE_POW_BIT_LENGTH

private static final long[] LONG_TEN_POW

private static final int[] LONG_TEN_POW_BIT_LENGTH

public static final java.math.BigDecimal ONE

public static final int ROUND_CEILING

public static final int ROUND_DOWN

public static final int ROUND_FLOOR

public static final int ROUND_HALF_DOWN

public static final int ROUND_HALF_EVEN

public static final int ROUND_HALF_UP

public static final int ROUND_UNNECESSARY

public static final int ROUND_UP

public static final java.math.BigDecimal TEN

private static final java.math.BigInteger[] TEN_POW

public static final java.math.BigDecimal ZERO

private static final java.math.BigDecimal[] ZERO_SCALED_BY

private static final long serialVersionUID

private transient int bitLength

private transient int hashCode

private java.math.BigInteger intVal

private transient int precision

private int scale

private transient long smallValue

private transient java.lang.String toStringImage
----------------METHODS----------------

static void <clinit>()

public void <init>(
double)

public void <init>(
double
java.math.MathContext)

public void <init>(
int)

private void <init>(
int
int)

public void <init>(
int
java.math.MathContext)

public void <init>(
long)

private void <init>(
long
int)

public void <init>(
long
java.math.MathContext)

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.math.MathContext)

public void <init>(
java.math.BigInteger)

public void <init>(
java.math.BigInteger
int)

public void <init>(
java.math.BigInteger
int
java.math.MathContext)

public void <init>(
java.math.BigInteger
java.math.MathContext)

public void <init>(
char[])

public void <init>(
char[]
int
int)

public void <init>(
char[]
int
int
java.math.MathContext)

public void <init>(
char[]
java.math.MathContext)

private static java.math.BigDecimal addAndMult10(
java.math.BigDecimal
java.math.BigDecimal
int)

private int aproxPrecision()

private static int bitLength(
int)

private static int bitLength(
long)

private static java.math.BigDecimal divideBigIntegers(
java.math.BigInteger
java.math.BigInteger
int
java.math.RoundingMode)

private static java.math.BigDecimal dividePrimitiveLongs(
long
long
int
java.math.RoundingMode)

private java.math.BigInteger getUnscaledValue()

private void inplaceRound(
java.math.MathContext)

private boolean isZero()

private static int longCompareTo(
long
long)

private java.math.BigDecimal movePoint(
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)

private static int roundingBehavior(
int
int
java.math.RoundingMode)

private void setUnscaledValue(
java.math.BigInteger)

private void smallRound(
java.math.MathContext
int)

private static int toIntScale(
long)

private long valueExact(
int)

public static java.math.BigDecimal valueOf(
double)

public static java.math.BigDecimal valueOf(
long)

public static java.math.BigDecimal valueOf(
long
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

private static java.math.BigDecimal zeroScaledBy(
long)

public java.math.BigDecimal abs()

public java.math.BigDecimal abs(
java.math.MathContext)

public java.math.BigDecimal add(
java.math.BigDecimal)

public java.math.BigDecimal add(
java.math.BigDecimal
java.math.MathContext)

public byte byteValueExact()

public volatile int compareTo(
java.lang.Object)

public int compareTo(
java.math.BigDecimal)

public java.math.BigDecimal divide(
java.math.BigDecimal)

public java.math.BigDecimal divide(
java.math.BigDecimal
int)

public java.math.BigDecimal divide(
java.math.BigDecimal
int
int)

public java.math.BigDecimal divide(
java.math.BigDecimal
int
java.math.RoundingMode)

public java.math.BigDecimal divide(
java.math.BigDecimal
java.math.MathContext)

public java.math.BigDecimal divide(
java.math.BigDecimal
java.math.RoundingMode)

public java.math.BigDecimal[] divideAndRemainder(
java.math.BigDecimal)

public java.math.BigDecimal[] divideAndRemainder(
java.math.BigDecimal
java.math.MathContext)

public java.math.BigDecimal divideToIntegralValue(
java.math.BigDecimal)

public java.math.BigDecimal divideToIntegralValue(
java.math.BigDecimal
java.math.MathContext)

public double doubleValue()

public boolean equals(
java.lang.Object)

public float floatValue()

public int hashCode()

public int intValue()

public int intValueExact()

public long longValue()

public long longValueExact()

public java.math.BigDecimal max(
java.math.BigDecimal)

public java.math.BigDecimal min(
java.math.BigDecimal)

public java.math.BigDecimal movePointLeft(
int)

public java.math.BigDecimal movePointRight(
int)

public java.math.BigDecimal multiply(
java.math.BigDecimal)

public java.math.BigDecimal multiply(
java.math.BigDecimal
java.math.MathContext)

public java.math.BigDecimal negate()

public java.math.BigDecimal negate(
java.math.MathContext)

public java.math.BigDecimal plus()

public java.math.BigDecimal plus(
java.math.MathContext)

public java.math.BigDecimal pow(
int)

public java.math.BigDecimal pow(
int
java.math.MathContext)

public int precision()

public java.math.BigDecimal remainder(
java.math.BigDecimal)

public java.math.BigDecimal remainder(
java.math.BigDecimal
java.math.MathContext)

public java.math.BigDecimal round(
java.math.MathContext)

public int scale()

public java.math.BigDecimal scaleByPowerOfTen(
int)

public java.math.BigDecimal setScale(
int)

public java.math.BigDecimal setScale(
int
int)

public java.math.BigDecimal setScale(
int
java.math.RoundingMode)

public short shortValueExact()

public int signum()

public java.math.BigDecimal stripTrailingZeros()

public java.math.BigDecimal subtract(
java.math.BigDecimal)

public java.math.BigDecimal subtract(
java.math.BigDecimal
java.math.MathContext)

public java.math.BigInteger toBigInteger()

public java.math.BigInteger toBigIntegerExact()

public java.lang.String toEngineeringString()

public java.lang.String toPlainString()

public java.lang.String toString()

public java.math.BigDecimal ulp()

public java.math.BigInteger unscaledValue()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/math/BigInt; )
@dalvik.annotation.InnerClass (accessFlags =0 name =Context )
 class java.math.BigInt$Context extends java.lang.Object

----------------FIELDS----------------

 int bnctx

final java.math.BigInt this$0
----------------METHODS----------------

 void <init>(
java.math.BigInt)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/math/BigInt$Context; )
 class java.math.BigInt extends java.lang.Object

----------------FIELDS----------------

static java.math.BigInt$Context defaultContext

static java.math.BigInt dummy

private static final long serialVersionUID

transient int bignum
----------------METHODS----------------

static void <clinit>()

 void <init>()

private static void Check(
boolean)

public static java.math.BigInt addition(
java.math.BigInt
java.math.BigInt)

public static java.math.BigInt bigExp(
java.math.BigInt
java.math.BigInt
java.math.BigInt$Context)

public static int cmp(
java.math.BigInt
java.math.BigInt)

public static int consumeErrors(
java.lang.StringBuilder)

public static void division(
java.math.BigInt
java.math.BigInt
java.math.BigInt$Context
java.math.BigInt
java.math.BigInt)

public static java.math.BigInt exp(
java.math.BigInt
int
java.math.BigInt$Context)

public static java.math.BigInt gcd(
java.math.BigInt
java.math.BigInt
java.math.BigInt$Context)

public static java.math.BigInt generatePrimeDefault(
int
java.util.Random
java.math.BigInt$Context)

static int getCtx(
java.math.BigInt$Context)

private void makeValid()

public static java.math.BigInt modExp(
java.math.BigInt
java.math.BigInt
java.math.BigInt
java.math.BigInt$Context)

public static java.math.BigInt modInverse(
java.math.BigInt
java.math.BigInt
java.math.BigInt$Context)

public static java.math.BigInt modulus(
java.math.BigInt
java.math.BigInt
java.math.BigInt$Context)

private static java.math.BigInt newBigInt()

public static java.math.BigInt product(
java.math.BigInt
java.math.BigInt
java.math.BigInt$Context)

public static int remainderByPositiveInt(
java.math.BigInt
int)

public static java.math.BigInt shift(
java.math.BigInt
int)

public static java.math.BigInt subtraction(
java.math.BigInt
java.math.BigInt)

public void add(
java.math.BigInt)

public void addPositiveInt(
int)

public byte[] bigEndianMagnitude()

public byte[] bigEndianTwosComplement()

public int bitLength()

public java.math.BigInt copy()

public java.lang.String decString()

public void dispose()

public int divideByPositiveInt(
int)

protected void finalize()

public int getNativeBIGNUM()

public java.lang.String hexString()

public boolean isBitSet(
int)

public boolean isPrime(
int
java.util.Random
java.math.BigInt$Context)

public int[] littleEndianIntsMagnitude()

public long longInt()

public void modifyBit(
int
int)

public void multiplyBy(
java.math.BigInt
java.math.BigInt$Context)

public void multiplyByPositiveInt(
int)

public void putBigEndian(
byte[]
boolean)

public void putBigEndianTwosComplement(
byte[])

public void putCopy(
java.math.BigInt)

public void putDecString(
java.lang.String)

public void putHexString(
java.lang.String)

public void putLittleEndianInts(
int[]
boolean)

public void putLongInt(
long)

public void putULongInt(
long
boolean)

public void setSign(
int)

public void shift(
int)

public int sign()

public void subtractPositiveInt(
int)

public java.lang.String toString()

public boolean twosCompFitsIntoBytes(
int)

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Number;Ljava/lang/Comparable<Ljava/math/BigInteger;>;Ljava/io/Serializable; )
public class java.math.BigInteger extends java.lang.Number implements java.lang.Comparable, java.io.Serializable

----------------FIELDS----------------

static final int EQUALS

static final int GREATER

static final int LESS

static final java.math.BigInteger MINUS_ONE

public static final java.math.BigInteger ONE

static final java.math.BigInteger[] SMALL_VALUES

public static final java.math.BigInteger TEN

public static final java.math.BigInteger ZERO

private static final long serialVersionUID

transient java.math.BigInt bigInt

private transient boolean bigIntIsValid

transient int[] digits

private transient int firstNonzeroDigit

private transient int hashCode

private byte[] magnitude

transient int numberLength

private transient boolean oldReprIsValid

transient int sign

private int signum
----------------METHODS----------------

static void <clinit>()

public void <init>(
int
int
java.util.Random)

 void <init>(
int
int
int[])

 void <init>(
int
long)

public void <init>(
int
java.util.Random)

public void <init>(
int
byte[])

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
int)

 void <init>(
java.math.BigInt)

public void <init>(
byte[])

static int inplaceAdd(
int[]
int
int)

static int multiplyByInt(
int[]
int[]
int
int)

public static java.math.BigInteger probablePrime(
int
java.util.Random)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)

private static void setFromString(
java.math.BigInteger
java.lang.String
int)

private byte[] twosComplement()

static void validate1(
java.lang.String
java.math.BigInteger)

static void validate2(
java.lang.String
java.math.BigInteger
java.math.BigInteger)

static void validate3(
java.lang.String
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger)

static void validate4(
java.lang.String
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger)

public static java.math.BigInteger valueOf(
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

public java.math.BigInteger abs()

public java.math.BigInteger add(
java.math.BigInteger)

public java.math.BigInteger and(
java.math.BigInteger)

public java.math.BigInteger andNot(
java.math.BigInteger)

public int bitCount()

public int bitLength()

public java.math.BigInteger clearBit(
int)

public volatile int compareTo(
java.lang.Object)

public int compareTo(
java.math.BigInteger)

 java.math.BigInteger copy()

final void cutOffLeadingZeroes()

public java.math.BigInteger divide(
java.math.BigInteger)

public java.math.BigInteger[] divideAndRemainder(
java.math.BigInteger)

public double doubleValue()

public boolean equals(
java.lang.Object)

 void establishOldRepresentation(
java.lang.String)

public java.math.BigInteger flipBit(
int)

public float floatValue()

public java.math.BigInteger gcd(
java.math.BigInteger)

 int getFirstNonzeroDigit()

public int getLowestSetBit()

public int hashCode()

public int intValue()

 boolean isOne()

public boolean isProbablePrime(
int)

public long longValue()

public java.math.BigInteger max(
java.math.BigInteger)

public java.math.BigInteger min(
java.math.BigInteger)

public java.math.BigInteger mod(
java.math.BigInteger)

public java.math.BigInteger modInverse(
java.math.BigInteger)

public java.math.BigInteger modPow(
java.math.BigInteger
java.math.BigInteger)

public java.math.BigInteger multiply(
java.math.BigInteger)

public java.math.BigInteger negate()

public java.math.BigInteger nextProbablePrime()

public java.math.BigInteger not()

public java.math.BigInteger or(
java.math.BigInteger)

public java.math.BigInteger pow(
int)

public java.math.BigInteger remainder(
java.math.BigInteger)

public java.math.BigInteger setBit(
int)

public java.math.BigInteger shiftLeft(
int)

public java.math.BigInteger shiftRight(
int)

public int signum()

public java.math.BigInteger subtract(
java.math.BigInteger)

public boolean testBit(
int)

public byte[] toByteArray()

public java.lang.String toString()

public java.lang.String toString(
int)

 void unCache()

 void validate(
java.lang.String
java.lang.String)

 java.math.BigInteger withNewRepresentation(
java.lang.String)

public java.math.BigInteger xor(
java.math.BigInteger)

________________CLASS________________


 class java.math.BitLevel extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

private void <init>()

static int bitCount(
java.math.BigInteger)

static int bitLength(
java.math.BigInteger)

static java.math.BigInteger flipBit(
java.math.BigInteger
int)

static void inplaceShiftRight(
java.math.BigInteger
int)

static boolean nonZeroDroppedBits(
int
int[])

static java.math.BigInteger shiftRight(
java.math.BigInteger
int)

static boolean shiftRight(
int[]
int
int[]
int
int)

static boolean testBit(
java.math.BigInteger
int)

________________CLASS________________


 class java.math.Conversion extends java.lang.Object

----------------FIELDS----------------

static final int[] bigRadices

static final int[] digitFitInInt
----------------METHODS----------------

static void <clinit>()

private void <init>()

static double bigInteger2Double(
java.math.BigInteger)

static java.lang.String bigInteger2String(
java.math.BigInteger
int)

static long divideLongByBillion(
long)

static java.lang.String toDecimalScaledString(
long
int)

static java.lang.String toDecimalScaledString(
java.math.BigInteger
int)

________________CLASS________________


 class java.math.Division extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

static java.math.BigInteger[] divideAndRemainderByInteger(
java.math.BigInteger
int
int)

static int divideArrayByInt(
int[]
int[]
int
int)

static long divideLongByInt(
long
int)

static int remainder(
java.math.BigInteger
int)

static int remainderArrayByInt(
int[]
int
int)

________________CLASS________________


 class java.math.Logical extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

private void <init>()

static java.math.BigInteger and(
java.math.BigInteger
java.math.BigInteger)

static java.math.BigInteger andDiffSigns(
java.math.BigInteger
java.math.BigInteger)

static java.math.BigInteger andNegative(
java.math.BigInteger
java.math.BigInteger)

static java.math.BigInteger andNot(
java.math.BigInteger
java.math.BigInteger)

static java.math.BigInteger andNotNegative(
java.math.BigInteger
java.math.BigInteger)

static java.math.BigInteger andNotNegativePositive(
java.math.BigInteger
java.math.BigInteger)

static java.math.BigInteger andNotPositive(
java.math.BigInteger
java.math.BigInteger)

static java.math.BigInteger andNotPositiveNegative(
java.math.BigInteger
java.math.BigInteger)

static java.math.BigInteger andPositive(
java.math.BigInteger
java.math.BigInteger)

static java.math.BigInteger not(
java.math.BigInteger)

static java.math.BigInteger or(
java.math.BigInteger
java.math.BigInteger)

static java.math.BigInteger orDiffSigns(
java.math.BigInteger
java.math.BigInteger)

static java.math.BigInteger orNegative(
java.math.BigInteger
java.math.BigInteger)

static java.math.BigInteger orPositive(
java.math.BigInteger
java.math.BigInteger)

static java.math.BigInteger xor(
java.math.BigInteger
java.math.BigInteger)

static java.math.BigInteger xorDiffSigns(
java.math.BigInteger
java.math.BigInteger)

static java.math.BigInteger xorNegative(
java.math.BigInteger
java.math.BigInteger)

static java.math.BigInteger xorPositive(
java.math.BigInteger
java.math.BigInteger)

________________CLASS________________


public final class java.math.MathContext extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------

public static final java.math.MathContext DECIMAL128

public static final java.math.MathContext DECIMAL32

public static final java.math.MathContext DECIMAL64

public static final java.math.MathContext UNLIMITED

private static final char[] chPrecision

private static final char[] chRoundingMode

private static final long serialVersionUID

private int precision

private java.math.RoundingMode roundingMode
----------------METHODS----------------

static void <clinit>()

public void <init>(
int)

public void <init>(
int
java.math.RoundingMode)

public void <init>(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)

public boolean equals(
java.lang.Object)

public int getPrecision()

public java.math.RoundingMode getRoundingMode()

public int hashCode()

public java.lang.String toString()

________________CLASS________________


 class java.math.Multiplication extends java.lang.Object

----------------FIELDS----------------

static final java.math.BigInteger[] bigFivePows

static final java.math.BigInteger[] bigTenPows

static final int[] fivePows

static final int[] tenPows
----------------METHODS----------------

static void <clinit>()

private void <init>()

static java.math.BigInteger multiplyByFivePow(
java.math.BigInteger
int)

static java.math.BigInteger multiplyByPositiveInt(
java.math.BigInteger
int)

static java.math.BigInteger multiplyByTenPow(
java.math.BigInteger
long)

static java.math.BigInteger powerOf10(
long)

________________CLASS________________


 class java.math.Primality extends java.lang.Object

----------------FIELDS----------------

private static final java.math.BigInteger[] BIprimes

private static final int[] primes
----------------METHODS----------------

static void <clinit>()

private void <init>()

static java.math.BigInteger nextProbablePrime(
java.math.BigInteger)

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Enum<Ljava/math/RoundingMode;>; )
public final class java.math.RoundingMode extends java.lang.Enum

----------------FIELDS----------------

private static final java.math.RoundingMode[] $VALUES

public static final java.math.RoundingMode CEILING

public static final java.math.RoundingMode DOWN

public static final java.math.RoundingMode FLOOR

public static final java.math.RoundingMode HALF_DOWN

public static final java.math.RoundingMode HALF_EVEN

public static final java.math.RoundingMode HALF_UP

public static final java.math.RoundingMode UNNECESSARY

public static final java.math.RoundingMode UP

private final int bigDecimalRM
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Signature (value =(I)V )
private void <init>(
java.lang.String
int
int)

public static java.math.RoundingMode valueOf(
int)

public static java.math.RoundingMode valueOf(
java.lang.String)

public static java.math.RoundingMode[] values()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =16409 name =RequestorType )
@dalvik.annotation.EnclosingClass (value =Ljava/net/Authenticator; )
@dalvik.annotation.Signature (value =Ljava/lang/Enum<Ljava/net/Authenticator$RequestorType;>; )
public final class java.net.Authenticator$RequestorType extends java.lang.Enum

----------------FIELDS----------------

private static final java.net.Authenticator$RequestorType[] $VALUES

public static final java.net.Authenticator$RequestorType PROXY

public static final java.net.Authenticator$RequestorType SERVER
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Signature (value =()V )
private void <init>(
java.lang.String
int)

public static java.net.Authenticator$RequestorType valueOf(
java.lang.String)

public static java.net.Authenticator$RequestorType[] values()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/net/Authenticator$RequestorType; )
public abstract class java.net.Authenticator extends java.lang.Object

----------------FIELDS----------------

private static final java.net.NetPermission requestPasswordAuthenticationPermission

private static final java.net.NetPermission setDefaultAuthenticatorPermission

private static java.net.Authenticator thisAuthenticator

private java.net.InetAddress addr

private java.lang.String host

private int port

private java.lang.String prompt

private java.lang.String protocol

private java.net.Authenticator$RequestorType rt

private java.lang.String scheme

private java.net.URL url
----------------METHODS----------------

static void <clinit>()

public void <init>()

public static java.net.PasswordAuthentication requestPasswordAuthentication(
java.lang.String
java.net.InetAddress
int
java.lang.String
java.lang.String
java.lang.String)

public static java.net.PasswordAuthentication requestPasswordAuthentication(
java.lang.String
java.net.InetAddress
int
java.lang.String
java.lang.String
java.lang.String
java.net.URL
java.net.Authenticator$RequestorType)

public static java.net.PasswordAuthentication requestPasswordAuthentication(
java.net.InetAddress
int
java.lang.String
java.lang.String
java.lang.String)

public static void setDefault(
java.net.Authenticator)

protected java.net.PasswordAuthentication getPasswordAuthentication()

protected final java.lang.String getRequestingHost()

protected final int getRequestingPort()

protected final java.lang.String getRequestingPrompt()

protected final java.lang.String getRequestingProtocol()

protected final java.lang.String getRequestingScheme()

protected final java.net.InetAddress getRequestingSite()

protected java.net.URL getRequestingURL()

protected java.net.Authenticator$RequestorType getRequestorType()

________________CLASS________________


public class java.net.SocketException extends java.io.IOException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class java.net.BindException extends java.net.SocketException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public abstract class java.net.CacheRequest extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public abstract void abort()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract java.io.OutputStream getBody()

________________CLASS________________


public abstract class java.net.CacheResponse extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract java.io.InputStream getBody()
@dalvik.annotation.Signature (value =()Ljava/util/Map<Ljava/lang/String;Ljava/util/List<Ljava/lang/String;>;>; )
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract java.util.Map getHeaders()

________________CLASS________________


public class java.net.ConnectException extends java.net.SocketException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public abstract class java.net.ContentHandler extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract java.lang.Object getContent(
java.net.URLConnection)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object getContent(
java.net.URLConnection
java.lang.Class[])

________________CLASS________________


public abstract interface class java.net.ContentHandlerFactory extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.net.ContentHandler createContentHandler(
java.lang.String)

________________CLASS________________


public abstract class java.net.CookieHandler extends java.lang.Object

----------------FIELDS----------------

private static final java.net.NetPermission getCookieHandlerPermission

private static final java.net.NetPermission setCookieHandlerPermission

private static java.net.CookieHandler systemWideCookieHandler
----------------METHODS----------------

static void <clinit>()

public void <init>()

public static java.net.CookieHandler getDefault()

public static void setDefault(
java.net.CookieHandler)
@dalvik.annotation.Signature (value =(Ljava/net/URI;Ljava/util/Map<Ljava/lang/String;Ljava/util/List<Ljava/lang/String;>;>;)Ljava/util/Map<Ljava/lang/String;Ljava/util/List<Ljava/lang/String;>;>; )
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract java.util.Map get(
java.net.URI
java.util.Map)
@dalvik.annotation.Signature (value =(Ljava/net/URI;Ljava/util/Map<Ljava/lang/String;Ljava/util/List<Ljava/lang/String;>;>;)V )
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void put(
java.net.URI
java.util.Map)

________________CLASS________________


public final class java.net.DatagramPacket extends java.lang.Object

----------------FIELDS----------------

 java.net.InetAddress address

 byte[] data

 int length

 int offset

 int port
----------------METHODS----------------

public void <init>(
byte[]
int)

public void <init>(
byte[]
int
int)

public void <init>(
byte[]
int
int
java.net.InetAddress
int)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void <init>(
byte[]
int
int
java.net.SocketAddress)

public void <init>(
byte[]
int
java.net.InetAddress
int)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void <init>(
byte[]
int
java.net.SocketAddress)

public java.net.InetAddress getAddress()

public byte[] getData()

public int getLength()

public int getOffset()

public int getPort()

public java.net.SocketAddress getSocketAddress()

public void setAddress(
java.net.InetAddress)

public void setData(
byte[])

public void setData(
byte[]
int
int)

public void setLength(
int)

public void setPort(
int)

public void setSocketAddress(
java.net.SocketAddress)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =4104 name =null )
@dalvik.annotation.EnclosingClass (value =Ljava/net/DatagramSocket; )
 class java.net.DatagramSocket$1 extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =10 name =Lock )
@dalvik.annotation.EnclosingClass (value =Ljava/net/DatagramSocket; )
 class java.net.DatagramSocket$Lock extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

private void <init>()

 void <init>(
java.net.DatagramSocket$1)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/net/DatagramSocket$1;Ljava/net/DatagramSocket$Lock; )
public class java.net.DatagramSocket extends java.lang.Object

----------------FIELDS----------------

static java.net.DatagramSocketImplFactory factory

 java.net.InetAddress address

 java.net.DatagramSocketImpl impl

 boolean isBound

private boolean isClosed

private boolean isConnected

private java.lang.Object lock

 int port
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void <init>()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void <init>(
int)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void <init>(
int
java.net.InetAddress)

protected void <init>(
java.net.DatagramSocketImpl)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void <init>(
java.net.SocketAddress)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static void setDatagramSocketImplFactory(
java.net.DatagramSocketImplFactory)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void bind(
java.net.SocketAddress)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
 void checkClosedAndBind(
boolean)

 void checkListen(
int)

public void close()

public void connect(
java.net.InetAddress
int)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void connect(
java.net.SocketAddress)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
 void createSocket(
int
java.net.InetAddress)

public void disconnect()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public boolean getBroadcast()

public java.nio.channels.DatagramChannel getChannel()

public java.net.InetAddress getInetAddress()

public java.net.InetAddress getLocalAddress()

public int getLocalPort()

public java.net.SocketAddress getLocalSocketAddress()

public int getPort()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public int getReceiveBufferSize()

public java.net.SocketAddress getRemoteSocketAddress()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public boolean getReuseAddress()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public int getSendBufferSize()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public int getSoTimeout()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public int getTrafficClass()

public boolean isBound()

public boolean isClosed()

public boolean isConnected()

 boolean isMulticastSocket()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void receive(
java.net.DatagramPacket)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void send(
java.net.DatagramPacket)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void setBroadcast(
boolean)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void setReceiveBufferSize(
int)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void setReuseAddress(
boolean)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void setSendBufferSize(
int)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void setSoTimeout(
int)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void setTrafficClass(
int)

________________CLASS________________


public abstract interface class java.net.SocketOptions extends java.lang.Object

----------------FIELDS----------------

public static final int IP_MULTICAST_IF

public static final int IP_MULTICAST_IF2

public static final int IP_MULTICAST_LOOP

public static final int IP_TOS

public static final int SO_BINDADDR

public static final int SO_BROADCAST

public static final int SO_KEEPALIVE

public static final int SO_LINGER

public static final int SO_OOBINLINE

public static final int SO_RCVBUF

public static final int SO_REUSEADDR

public static final int SO_SNDBUF

public static final int SO_TIMEOUT

public static final int TCP_NODELAY
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public abstract java.lang.Object getOption(
int)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public abstract void setOption(
int
java.lang.Object)

________________CLASS________________


public abstract class java.net.DatagramSocketImpl extends java.lang.Object implements java.net.SocketOptions

----------------FIELDS----------------

protected java.io.FileDescriptor fd

protected int localPort
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
protected abstract void bind(
int
java.net.InetAddress)

protected abstract void close()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
protected void connect(
java.net.InetAddress
int)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
protected abstract void create()

protected void disconnect()

protected java.io.FileDescriptor getFileDescriptor()

 java.net.InetAddress getLocalAddress()

protected int getLocalPort()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public abstract java.lang.Object getOption(
int)
@java.lang.Deprecated
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected abstract byte getTTL()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected abstract int getTimeToLive()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected abstract void join(
java.net.InetAddress)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected abstract void joinGroup(
java.net.SocketAddress
java.net.NetworkInterface)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected abstract void leave(
java.net.InetAddress)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected abstract void leaveGroup(
java.net.SocketAddress
java.net.NetworkInterface)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected abstract int peek(
java.net.InetAddress)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected abstract int peekData(
java.net.DatagramPacket)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected abstract void receive(
java.net.DatagramPacket)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected abstract void send(
java.net.DatagramPacket)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public abstract void setOption(
int
java.lang.Object)
@java.lang.Deprecated
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected abstract void setTTL(
byte)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected abstract void setTimeToLive(
int)

________________CLASS________________


public abstract interface class java.net.DatagramSocketImplFactory extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.net.DatagramSocketImpl createDatagramSocketImpl()

________________CLASS________________


public abstract interface class java.net.FileNameMap extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.lang.String getContentTypeFor(
java.lang.String)

________________CLASS________________


public class java.net.HttpRetryException extends java.io.IOException

----------------FIELDS----------------

private static final long serialVersionUID

private java.lang.String location

private int responseCode
----------------METHODS----------------

public void <init>(
java.lang.String
int)

public void <init>(
java.lang.String
int
java.lang.String)

public java.lang.String getLocation()

public java.lang.String getReason()

public int responseCode()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/net/URLConnection$DefaultContentHandler; )
public abstract class java.net.URLConnection extends java.lang.Object

----------------FIELDS----------------

private static java.net.ContentHandlerFactory contentHandlerFactory
@dalvik.annotation.Signature (value =Ljava/util/Hashtable<Ljava/lang/String;Ljava/lang/Object;>; )
static java.util.Hashtable contentHandlers

private static boolean defaultAllowUserInteraction

private static boolean defaultUseCaches

private static java.net.FileNameMap fileNameMap

protected boolean allowUserInteraction

private int connectTimeout

protected boolean connected

private java.lang.String contentType

 java.net.ContentHandler defaultHandler

protected boolean doInput

protected boolean doOutput

protected long ifModifiedSince

private long lastModified

private int readTimeout

protected java.net.URL url

protected boolean useCaches
----------------METHODS----------------

static void <clinit>()

protected void <init>(
java.net.URL)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private java.net.ContentHandler getContentHandler(
java.lang.String)

public static boolean getDefaultAllowUserInteraction()
@java.lang.Deprecated
public static java.lang.String getDefaultRequestProperty(
java.lang.String)

public static java.net.FileNameMap getFileNameMap()

public static java.lang.String guessContentTypeFromName(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static java.lang.String guessContentTypeFromStream(
java.io.InputStream)

private java.lang.String parseTypeString(
java.lang.String)

public static void setContentHandlerFactory(
java.net.ContentHandlerFactory)

public static void setDefaultAllowUserInteraction(
boolean)
@java.lang.Deprecated
public static void setDefaultRequestProperty(
java.lang.String
java.lang.String)

public static void setFileNameMap(
java.net.FileNameMap)

public void addRequestProperty(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void connect()

public boolean getAllowUserInteraction()

public int getConnectTimeout()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object getContent()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object getContent(
java.lang.Class[])

public java.lang.String getContentEncoding()

public int getContentLength()

public java.lang.String getContentType()

public long getDate()

public boolean getDefaultUseCaches()

public boolean getDoInput()

public boolean getDoOutput()

public long getExpiration()

public java.lang.String getHeaderField(
int)

public java.lang.String getHeaderField(
java.lang.String)

public long getHeaderFieldDate(
java.lang.String
long)

public int getHeaderFieldInt(
java.lang.String
int)

public java.lang.String getHeaderFieldKey(
int)
@dalvik.annotation.Signature (value =()Ljava/util/Map<Ljava/lang/String;Ljava/util/List<Ljava/lang/String;>;>; )
public java.util.Map getHeaderFields()

public long getIfModifiedSince()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.io.InputStream getInputStream()

public long getLastModified()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.io.OutputStream getOutputStream()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.security.Permission getPermission()

public int getReadTimeout()
@dalvik.annotation.Signature (value =()Ljava/util/Map<Ljava/lang/String;Ljava/util/List<Ljava/lang/String;>;>; )
public java.util.Map getRequestProperties()

public java.lang.String getRequestProperty(
java.lang.String)

public java.net.URL getURL()

public boolean getUseCaches()

public void setAllowUserInteraction(
boolean)

public void setConnectTimeout(
int)

public void setDefaultUseCaches(
boolean)

public void setDoInput(
boolean)

public void setDoOutput(
boolean)

public void setIfModifiedSince(
long)

public void setReadTimeout(
int)

public void setRequestProperty(
java.lang.String
java.lang.String)

public void setUseCaches(
boolean)

public java.lang.String toString()

________________CLASS________________


public abstract class java.net.HttpURLConnection extends java.net.URLConnection

----------------FIELDS----------------

private static final int DEFAULT_CHUNK_LENGTH

public static final int HTTP_ACCEPTED

public static final int HTTP_BAD_GATEWAY

public static final int HTTP_BAD_METHOD

public static final int HTTP_BAD_REQUEST

public static final int HTTP_CLIENT_TIMEOUT

public static final int HTTP_CONFLICT

public static final int HTTP_CREATED

public static final int HTTP_ENTITY_TOO_LARGE

public static final int HTTP_FORBIDDEN

public static final int HTTP_GATEWAY_TIMEOUT

public static final int HTTP_GONE

public static final int HTTP_INTERNAL_ERROR

public static final int HTTP_LENGTH_REQUIRED

public static final int HTTP_MOVED_PERM

public static final int HTTP_MOVED_TEMP

public static final int HTTP_MULT_CHOICE

public static final int HTTP_NOT_ACCEPTABLE

public static final int HTTP_NOT_AUTHORITATIVE

public static final int HTTP_NOT_FOUND

public static final int HTTP_NOT_IMPLEMENTED

public static final int HTTP_NOT_MODIFIED

public static final int HTTP_NO_CONTENT

public static final int HTTP_OK

public static final int HTTP_PARTIAL

public static final int HTTP_PAYMENT_REQUIRED

public static final int HTTP_PRECON_FAILED

public static final int HTTP_PROXY_AUTH

public static final int HTTP_REQ_TOO_LONG

public static final int HTTP_RESET

public static final int HTTP_SEE_OTHER
@java.lang.Deprecated
public static final int HTTP_SERVER_ERROR

public static final int HTTP_UNAUTHORIZED

public static final int HTTP_UNAVAILABLE

public static final int HTTP_UNSUPPORTED_TYPE

public static final int HTTP_USE_PROXY

public static final int HTTP_VERSION

private static boolean followRedirects

protected int chunkLength

protected int fixedContentLength

protected boolean instanceFollowRedirects

protected java.lang.String method

private java.lang.String[] methodTokens

protected int responseCode

protected java.lang.String responseMessage
----------------METHODS----------------

static void <clinit>()

protected void <init>(
java.net.URL)

public static boolean getFollowRedirects()

public static void setFollowRedirects(
boolean)

public abstract void disconnect()

public java.io.InputStream getErrorStream()

public long getHeaderFieldDate(
java.lang.String
long)

public boolean getInstanceFollowRedirects()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.security.Permission getPermission()

public java.lang.String getRequestMethod()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int getResponseCode()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.String getResponseMessage()

public void setChunkedStreamingMode(
int)

public void setFixedLengthStreamingMode(
int)

public void setInstanceFollowRedirects(
boolean)
@dalvik.annotation.Throws (value =Ljava/net/ProtocolException; )
public void setRequestMethod(
java.lang.String)

public abstract boolean usingProxy()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/net/InetAddress$Cache;Ljava/net/InetAddress$CacheElement;Ljava/net/InetAddress$WaitReachable; )
public class java.net.InetAddress extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------

static java.net.InetAddress ANY

private static final java.lang.String ERRMSG_CONNECTION_REFUSED

static final java.net.InetAddress LOOPBACK

private static final org.apache.harmony.luni.platform.INetworkSystem NETIMPL

static final byte[] any_bytes

static final byte[] localhost_bytes

private static final java.io.ObjectStreamField[] serialPersistentFields

private static final long serialVersionUID

private int addrCount

 int family

 java.lang.String hostName

 byte[] ipaddress

private boolean reached

private transient java.lang.Object waitReachable
----------------METHODS----------------

static void <clinit>()

 void <init>()

 void <init>(
byte[])

 void <init>(
byte[]
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
static boolean access$100(
java.net.InetAddress
java.net.InetAddress
java.net.InetAddress
int)

static java.lang.Object access$200(
java.net.InetAddress)

static boolean access$302(
java.net.InetAddress
boolean)

static int access$400(
java.net.InetAddress)

static int access$410(
java.net.InetAddress)

static byte[] addressOf(
int)

static int bytesToInt(
byte[]
int)
@dalvik.annotation.Throws (value =Ljava/net/UnknownHostException; )
static java.net.InetAddress createHostNameFromIPAddress(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/net/UnknownHostException; )
static java.net.InetAddress[] getAliasesByNameImpl(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/net/UnknownHostException; )
public static java.net.InetAddress[] getAllByName(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/net/UnknownHostException; )
public static java.net.InetAddress getByAddress(
java.lang.String
byte[])
@dalvik.annotation.Throws (value =Ljava/net/UnknownHostException; )
public static java.net.InetAddress getByAddress(
byte[])
@dalvik.annotation.Throws (value =Ljava/net/UnknownHostException; )
static java.net.InetAddress getByAddress(
byte[]
int)
@dalvik.annotation.Throws (value =Ljava/net/UnknownHostException; )
static java.net.InetAddress getByAddressInternal(
java.lang.String
byte[]
int)
@dalvik.annotation.Throws (value =Ljava/net/UnknownHostException; )
public static java.net.InetAddress getByName(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/net/UnknownHostException; )
static java.net.InetAddress getHostByAddrImpl(
byte[])
@dalvik.annotation.Throws (value =Ljava/net/UnknownHostException; )
static java.net.InetAddress getHostByNameImpl(
java.lang.String
boolean)

static java.lang.String getHostNameImpl()
@dalvik.annotation.Throws (value =Ljava/net/UnknownHostException; )
static java.lang.String getHostNameInternal(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/net/UnknownHostException; )
public static java.net.InetAddress getLocalHost()

private static native java.lang.String[] getaliasesbyname(
java.lang.String)

private static native java.lang.String gethostbyaddr(
java.lang.String)

private static native boolean gethostbyname(
java.lang.String
byte[])

private static native java.lang.String gethostname()
@dalvik.annotation.Throws (value =Ljava/net/UnknownHostException; )
static int inetAddr(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/net/UnknownHostException; )
static int inetAddrImpl(
java.lang.String)

static java.lang.String inetNtoaImpl(
int)

static void intToBytes(
int
byte[]
int)

private static boolean isHostName(
java.lang.String)

private static boolean isIPv4MappedAddress(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private boolean isReachableByMultiThread(
java.net.NetworkInterface
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private boolean isReachableByTCP(
java.net.InetAddress
java.net.InetAddress
int)
@dalvik.annotation.Throws (value =Ljava/net/UnknownHostException; )
static java.net.InetAddress lookupHostByName(
java.lang.String)

static boolean preferIPv6Addresses()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)
@dalvik.annotation.Throws (value =Ljava/io/ObjectStreamException; )
private java.lang.Object readResolve()

private static int secondsToNanos(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

 java.net.InetAddress$CacheElement cacheElement()

public boolean equals(
java.lang.Object)

public byte[] getAddress()

public java.lang.String getCanonicalHostName()

public java.lang.String getHostAddress()

public java.lang.String getHostName()

public int hashCode()

public boolean isAnyLocalAddress()

public boolean isLinkLocalAddress()

public boolean isLoopbackAddress()

public boolean isMCGlobal()

public boolean isMCLinkLocal()

public boolean isMCNodeLocal()

public boolean isMCOrgLocal()

public boolean isMCSiteLocal()

public boolean isMulticastAddress()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public boolean isReachable(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public boolean isReachable(
java.net.NetworkInterface
int
int)

public boolean isSiteLocalAddress()

public java.lang.String toString()

________________CLASS________________


public final class java.net.Inet4Address extends java.net.InetAddress

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

 void <init>(
byte[])

 void <init>(
byte[]
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/ObjectStreamException; )
private java.lang.Object writeReplace()

public boolean equals(
java.lang.Object)

public java.lang.String getHostAddress()

public int hashCode()

public boolean isAnyLocalAddress()

public boolean isLinkLocalAddress()

public boolean isLoopbackAddress()

public boolean isMCGlobal()

public boolean isMCLinkLocal()

public boolean isMCNodeLocal()

public boolean isMCOrgLocal()

public boolean isMCSiteLocal()

public boolean isMulticastAddress()

public boolean isSiteLocalAddress()

________________CLASS________________


public final class java.net.Inet6Address extends java.net.InetAddress

----------------FIELDS----------------

static final java.net.InetAddress ANY

static final java.net.InetAddress LOOPBACK

static final byte[] any_bytes

static final byte[] localhost_bytes

private static final java.io.ObjectStreamField[] serialPersistentFields

private static final long serialVersionUID

 java.lang.String ifname

 int scope_id

 boolean scope_id_set

 boolean scope_ifname_set

transient java.net.NetworkInterface scopedIf
----------------METHODS----------------

static void <clinit>()

 void <init>(
byte[])

 void <init>(
byte[]
int)

 void <init>(
byte[]
java.lang.String)

 void <init>(
byte[]
java.lang.String
int)

private boolean compareLocalType(
java.net.Inet6Address)
@dalvik.annotation.Throws (value =Ljava/net/UnknownHostException; )
public static java.net.Inet6Address getByAddress(
java.lang.String
byte[]
int)
@dalvik.annotation.Throws (value =Ljava/net/UnknownHostException; )
public static java.net.Inet6Address getByAddress(
java.lang.String
byte[]
java.net.NetworkInterface)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

public boolean equals(
java.lang.Object)

public java.lang.String getHostAddress()

public int getScopeId()

public java.net.NetworkInterface getScopedInterface()

public int hashCode()

public boolean isAnyLocalAddress()

public boolean isIPv4CompatibleAddress()

public boolean isLinkLocalAddress()

public boolean isLoopbackAddress()

public boolean isMCGlobal()

public boolean isMCLinkLocal()

public boolean isMCNodeLocal()

public boolean isMCOrgLocal()

public boolean isMCSiteLocal()

public boolean isMulticastAddress()

public boolean isSiteLocalAddress()

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
 class java.net.InetAddress$1 extends java.lang.Thread

----------------FIELDS----------------

final java.net.InetAddress this$0

final java.net.InetAddress val$addr

final int val$timeout
----------------METHODS----------------

 void <init>(
java.net.InetAddress
java.net.InetAddress
int)

public void run()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/net/InetAddress; )
@dalvik.annotation.InnerClass (accessFlags =8 name =Cache )
 class java.net.InetAddress$Cache extends java.lang.Object

----------------FIELDS----------------

private static java.net.InetAddress$CacheElement head

static int maxSize

private static int size
----------------METHODS----------------

static void <clinit>()

 void <init>()

static void add(
java.net.InetAddress)

static void clear()

private static void deleteTail()

static java.net.InetAddress$CacheElement get(
java.lang.String)

private static void moveToHead(
java.net.InetAddress$CacheElement
java.net.InetAddress$CacheElement)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =CacheElement )
@dalvik.annotation.EnclosingClass (value =Ljava/net/InetAddress; )
 class java.net.InetAddress$CacheElement extends java.lang.Object

----------------FIELDS----------------

 long nanoTimeAdded

 java.net.InetAddress$CacheElement next

final java.net.InetAddress this$0
----------------METHODS----------------

public void <init>(
java.net.InetAddress)

 java.lang.String hostName()

 java.net.InetAddress inetAddress()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/net/InetAddress; )
@dalvik.annotation.InnerClass (accessFlags =10 name =WaitReachable )
 class java.net.InetAddress$WaitReachable extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

private void <init>()

 void <init>(
java.net.InetAddress$1)

________________CLASS________________


public abstract class java.net.SocketAddress extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________


public class java.net.InetSocketAddress extends java.net.SocketAddress

----------------FIELDS----------------

private static final long serialVersionUID

private java.net.InetAddress addr

private java.lang.String hostname

private int port
----------------METHODS----------------

public void <init>(
int)

public void <init>(
java.lang.String
int)

 void <init>(
java.lang.String
int
boolean)

public void <init>(
java.net.InetAddress
int)

public static java.net.InetSocketAddress createUnresolved(
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)

public final boolean equals(
java.lang.Object)

public final java.net.InetAddress getAddress()

public final java.lang.String getHostName()

public final int getPort()

public final int hashCode()

public final boolean isUnresolved()

public java.lang.String toString()

________________CLASS________________


public abstract class java.net.JarURLConnection extends java.net.URLConnection

----------------FIELDS----------------

private java.lang.String entryName

private java.lang.String file

private java.net.URL fileURL

protected java.net.URLConnection jarFileURLConnection
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/net/MalformedURLException; )
protected void <init>(
java.net.URL)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.util.jar.Attributes getAttributes()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.security.cert.Certificate[] getCertificates()

public java.lang.String getEntryName()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.util.jar.JarEntry getJarEntry()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract java.util.jar.JarFile getJarFile()

public java.net.URL getJarFileURL()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.util.jar.Attributes getMainAttributes()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.util.jar.Manifest getManifest()

________________CLASS________________


public class java.net.MalformedURLException extends java.io.IOException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class java.net.MulticastSocket extends java.net.DatagramSocket

----------------FIELDS----------------

static final int SO_REUSEPORT

private java.net.InetAddress interfaceSet
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.net.SocketAddress)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
 void createSocket(
int
java.net.InetAddress)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public java.net.InetAddress getInterface()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public boolean getLoopbackMode()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public java.net.NetworkInterface getNetworkInterface()
@java.lang.Deprecated
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public byte getTTL()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int getTimeToLive()

 boolean isMulticastSocket()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void joinGroup(
java.net.InetAddress)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void joinGroup(
java.net.SocketAddress
java.net.NetworkInterface)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void leaveGroup(
java.net.InetAddress)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void leaveGroup(
java.net.SocketAddress
java.net.NetworkInterface)
@java.lang.Deprecated
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void send(
java.net.DatagramPacket
byte)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void setInterface(
java.net.InetAddress)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void setLoopbackMode(
boolean)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void setNetworkInterface(
java.net.NetworkInterface)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
@java.lang.Deprecated
public void setTTL(
byte)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void setTimeToLive(
int)

________________CLASS________________


 class java.net.NegCacheElement extends java.lang.Object

----------------FIELDS----------------

 java.lang.String hostName

 long nanoTimeAdded
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

 java.lang.String hostName()

________________CLASS________________

@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Map<TK;TV;>; )
public abstract class java.util.AbstractMap extends java.lang.Object implements java.util.Map

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Set<TK;>; )
 java.util.Set keySet
@dalvik.annotation.Signature (value =Ljava/util/Collection<TV;>; )
 java.util.Collection valuesCollection
----------------METHODS----------------

protected void <init>()

public void clear()
@dalvik.annotation.Throws (value =Ljava/lang/CloneNotSupportedException; )
protected java.lang.Object clone()

public boolean containsKey(
java.lang.Object)

public boolean containsValue(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/util/Map$Entry<TK;TV;>;>; )
public abstract java.util.Set entrySet()

public boolean equals(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;)TV; )
public java.lang.Object get(
java.lang.Object)

public int hashCode()

public boolean isEmpty()
@dalvik.annotation.Signature (value =()Ljava/util/Set<TK;>; )
public java.util.Set keySet()
@dalvik.annotation.Signature (value =(TK;TV;)TV; )
public java.lang.Object put(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Map<+TK;+TV;>;)V )
public void putAll(
java.util.Map)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;)TV; )
public java.lang.Object remove(
java.lang.Object)

public int size()

public java.lang.String toString()
@dalvik.annotation.Signature (value =()Ljava/util/Collection<TV;>; )
public java.util.Collection values()

________________CLASS________________

@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/util/AbstractMap<TK;TV;>;Ljava/util/Map<TK;TV;>;Ljava/lang/Cloneable;Ljava/io/Serializable; )
@dalvik.annotation.MemberClasses (value =Ljava/util/HashMap$HashMapEntrySet;Ljava/util/HashMap$HashMapIterator;Ljava/util/HashMap$Entry; )
public class java.util.HashMap extends java.util.AbstractMap implements java.util.Map, java.lang.Cloneable, java.io.Serializable

----------------FIELDS----------------

private static final int DEFAULT_SIZE

private static final long serialVersionUID

transient int elementCount
@dalvik.annotation.Signature (value =[Ljava/util/HashMap$Entry<TK;TV;>; )
transient java.util.HashMap$Entry[] elementData

final float loadFactor

transient int modCount

 int threshold
----------------METHODS----------------

public void <init>()

public void <init>(
int)

public void <init>(
int
float)
@dalvik.annotation.Signature (value =(Ljava/util/Map<+TK;+TV;>;)V )
public void <init>(
java.util.Map)

private void computeMaxSize()
@dalvik.annotation.Signature (value =(Ljava/util/Map<+TK;+TV;>;)V )
private void putAllImpl(
java.util.Map)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

public void clear()

public java.lang.Object clone()

public boolean containsKey(
java.lang.Object)

public boolean containsValue(
java.lang.Object)
@dalvik.annotation.Signature (value =(TK;ITV;)Ljava/util/HashMap$Entry<TK;TV;>; )
 java.util.HashMap$Entry createEntry(
java.lang.Object
int
java.lang.Object)
@dalvik.annotation.Signature (value =(TK;II)Ljava/util/HashMap$Entry<TK;TV;>; )
 java.util.HashMap$Entry createHashedEntry(
java.lang.Object
int
int)
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/util/Map$Entry<TK;TV;>;>; )
public java.util.Set entrySet()
@dalvik.annotation.Signature (value =(Ljava/lang/Object;II)Ljava/util/HashMap$Entry<TK;TV;>; )
final java.util.HashMap$Entry findNonNullKeyEntry(
java.lang.Object
int
int)
@dalvik.annotation.Signature (value =()Ljava/util/HashMap$Entry<TK;TV;>; )
final java.util.HashMap$Entry findNullKeyEntry()
@dalvik.annotation.Signature (value =(Ljava/lang/Object;)TV; )
public java.lang.Object get(
java.lang.Object)

public boolean isEmpty()
@dalvik.annotation.Signature (value =()Ljava/util/Set<TK;>; )
public java.util.Set keySet()
@dalvik.annotation.Signature (value =(I)[Ljava/util/HashMap$Entry<TK;TV;>; )
 java.util.HashMap$Entry[] newElementArray(
int)
@dalvik.annotation.Signature (value =(TK;TV;)TV; )
public java.lang.Object put(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Map<+TK;+TV;>;)V )
public void putAll(
java.util.Map)
@dalvik.annotation.Signature (value =(TK;TV;)TV; )
 java.lang.Object putImpl(
java.lang.Object
java.lang.Object)

 void rehash()

 void rehash(
int)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;)TV; )
public java.lang.Object remove(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;)Ljava/util/HashMap$Entry<TK;TV;>; )
 java.util.HashMap$Entry removeEntry(
java.lang.Object)

public int size()
@dalvik.annotation.Signature (value =()Ljava/util/Collection<TV;>; )
public java.util.Collection values()

________________CLASS________________

@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/util/HashMap<TK;TV;>; )
@dalvik.annotation.MemberClasses (value =Ljava/util/LinkedHashMap$LinkedHashMapEntry;Ljava/util/LinkedHashMap$LinkedHashMapEntrySet;Ljava/util/LinkedHashMap$LinkedHashIterator; )
public class java.util.LinkedHashMap extends java.util.HashMap

----------------FIELDS----------------

private static final long serialVersionUID

private final boolean accessOrder
@dalvik.annotation.Signature (value =Ljava/util/LinkedHashMap$LinkedHashMapEntry<TK;TV;>; )
private transient java.util.LinkedHashMap$LinkedHashMapEntry head
@dalvik.annotation.Signature (value =Ljava/util/LinkedHashMap$LinkedHashMapEntry<TK;TV;>; )
private transient java.util.LinkedHashMap$LinkedHashMapEntry tail
----------------METHODS----------------

public void <init>()

public void <init>(
int)

public void <init>(
int
float)

public void <init>(
int
float
boolean)
@dalvik.annotation.Signature (value =(Ljava/util/Map<+TK;+TV;>;)V )
public void <init>(
java.util.Map)

static java.util.LinkedHashMap$LinkedHashMapEntry access$000(
java.util.LinkedHashMap)

static java.util.LinkedHashMap$LinkedHashMapEntry access$002(
java.util.LinkedHashMap
java.util.LinkedHashMap$LinkedHashMapEntry)

static java.util.LinkedHashMap$LinkedHashMapEntry access$102(
java.util.LinkedHashMap
java.util.LinkedHashMap$LinkedHashMapEntry)

public void clear()
@dalvik.annotation.Signature (value =(TK;ITV;)Ljava/util/HashMap$Entry<TK;TV;>; )
 java.util.HashMap$Entry createEntry(
java.lang.Object
int
java.lang.Object)
@dalvik.annotation.Signature (value =(TK;II)Ljava/util/HashMap$Entry<TK;TV;>; )
 java.util.HashMap$Entry createHashedEntry(
java.lang.Object
int
int)
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/util/Map$Entry<TK;TV;>;>; )
public java.util.Set entrySet()
@dalvik.annotation.Signature (value =(Ljava/lang/Object;)TV; )
public java.lang.Object get(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Set<TK;>; )
public java.util.Set keySet()
@dalvik.annotation.Signature (value =(Ljava/util/LinkedHashMap$LinkedHashMapEntry<TK;TV;>;)V )
 void linkEntry(
java.util.LinkedHashMap$LinkedHashMapEntry)
@dalvik.annotation.Signature (value =(I)[Ljava/util/HashMap$Entry<TK;TV;>; )
 java.util.HashMap$Entry[] newElementArray(
int)
@dalvik.annotation.Signature (value =(TK;TV;)TV; )
public java.lang.Object put(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(TK;TV;)TV; )
 java.lang.Object putImpl(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;)TV; )
public java.lang.Object remove(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Map$Entry<TK;TV;>;)Z )
protected boolean removeEldestEntry(
java.util.Map$Entry)
@dalvik.annotation.Signature (value =()Ljava/util/Collection<TV;>; )
public java.util.Collection values()

________________CLASS________________

@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/util/LinkedHashMap<TK;TV;>; )
 class java.net.NegativeCache extends java.util.LinkedHashMap

----------------FIELDS----------------

static final float LOADING

static final int MAX_NEGATIVE_ENTRIES
@dalvik.annotation.Signature (value =Ljava/net/NegativeCache<Ljava/lang/String;Ljava/net/NegCacheElement;>; )
static java.net.NegativeCache negCache

private static final long serialVersionUID
----------------METHODS----------------

 void <init>(
int
float
boolean)

static void checkCacheExists()

static java.lang.String getFailedMessage(
java.lang.String)

static void put(
java.lang.String
java.lang.String)

private static int secondsToNanos(
int)
@dalvik.annotation.Signature (value =(Ljava/util/Map$Entry<TK;TV;>;)Z )
protected boolean removeEldestEntry(
java.util.Map$Entry)

________________CLASS________________


public final class java.net.NetPermission extends java.security.BasicPermission

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.String)

________________CLASS________________


public final class java.net.NetworkInterface extends java.lang.Object

----------------FIELDS----------------

private static final int CHECK_CONNECT_NO_PORT

static final int NO_INTERFACE_INDEX

static final int UNSET_INTERFACE_INDEX

 java.net.InetAddress[] addresses

private java.lang.String displayName

private int hashCode

private int interfaceIndex

private java.lang.String name
----------------METHODS----------------

 void <init>(
java.lang.String
java.lang.String
java.net.InetAddress[]
int)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public static java.net.NetworkInterface getByInetAddress(
java.net.InetAddress)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public static java.net.NetworkInterface getByName(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<Ljava/net/NetworkInterface;>; )
public static java.util.Enumeration getNetworkInterfaces()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
private static native java.net.NetworkInterface[] getNetworkInterfacesImpl()

public boolean equals(
java.lang.Object)

public java.lang.String getDisplayName()

 java.net.InetAddress getFirstAddress()

 int getIndex()
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<Ljava/net/InetAddress;>; )
public java.util.Enumeration getInetAddresses()

public java.lang.String getName()

public int hashCode()

public java.lang.String toString()

________________CLASS________________


public class java.net.NoRouteToHostException extends java.net.SocketException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public final class java.net.PasswordAuthentication extends java.lang.Object

----------------FIELDS----------------

private char[] password

private java.lang.String userName
----------------METHODS----------------

public void <init>(
java.lang.String
char[])

public char[] getPassword()

public java.lang.String getUserName()

________________CLASS________________


public class java.net.PortUnreachableException extends java.net.SocketException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class java.net.ProtocolException extends java.io.IOException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =16409 name =Type )
@dalvik.annotation.Signature (value =Ljava/lang/Enum<Ljava/net/Proxy$Type;>; )
@dalvik.annotation.EnclosingClass (value =Ljava/net/Proxy; )
public final class java.net.Proxy$Type extends java.lang.Enum

----------------FIELDS----------------

private static final java.net.Proxy$Type[] $VALUES

public static final java.net.Proxy$Type DIRECT

public static final java.net.Proxy$Type HTTP

public static final java.net.Proxy$Type SOCKS
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Signature (value =()V )
private void <init>(
java.lang.String
int)

public static java.net.Proxy$Type valueOf(
java.lang.String)

public static java.net.Proxy$Type[] values()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/net/Proxy$Type; )
public class java.net.Proxy extends java.lang.Object

----------------FIELDS----------------

public static final java.net.Proxy NO_PROXY

private java.net.SocketAddress address

private java.net.Proxy$Type type
----------------METHODS----------------

static void <clinit>()

private void <init>()

public void <init>(
java.net.Proxy$Type
java.net.SocketAddress)

public java.net.SocketAddress address()

public final boolean equals(
java.lang.Object)

public final int hashCode()

public java.lang.String toString()

public java.net.Proxy$Type type()

________________CLASS________________


public abstract class java.net.ProxySelector extends java.lang.Object

----------------FIELDS----------------

private static java.net.ProxySelector defaultSelector

private static final java.net.NetPermission getProxySelectorPermission

private static final java.net.NetPermission setProxySelectorPermission
----------------METHODS----------------

static void <clinit>()

public void <init>()

public static java.net.ProxySelector getDefault()

public static void setDefault(
java.net.ProxySelector)

public abstract void connectFailed(
java.net.URI
java.net.SocketAddress
java.io.IOException)
@dalvik.annotation.Signature (value =(Ljava/net/URI;)Ljava/util/List<Ljava/net/Proxy;>; )
public abstract java.util.List select(
java.net.URI)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Ljava/net/ProxySelectorImpl; )
final class java.net.ProxySelectorImpl$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public java.lang.Object run()

________________CLASS________________


 class java.net.ProxySelectorImpl extends java.net.ProxySelector

----------------FIELDS----------------

private static final int FTP_PROXY_PORT

private static final int HTTPS_PROXY_PORT

private static final int HTTP_PROXY_PORT

private static final int SOCKS_PROXY_PORT

private static java.util.Properties netProps
----------------METHODS----------------

static void <clinit>()

public void <init>()

static java.util.Properties access$000()

static java.util.Properties access$002(
java.util.Properties)

private java.net.Proxy createProxy(
java.net.Proxy$Type
java.lang.String
java.lang.String
int)

private java.lang.String getSystemProperty(
java.lang.String)

private java.lang.String getSystemProperty(
java.lang.String
java.lang.String)

private java.lang.String getSystemPropertyOrAlternative(
java.lang.String
java.lang.String
java.lang.String)

private boolean isNonProxyHost(
java.lang.String
java.lang.String)

private java.net.Proxy selectFtpProxy(
java.lang.String)

private java.net.Proxy selectHttpProxy(
java.lang.String)

private java.net.Proxy selectHttpsProxy()

private java.net.Proxy selectSocksProxy()

public void connectFailed(
java.net.URI
java.net.SocketAddress
java.io.IOException)
@dalvik.annotation.Signature (value =(Ljava/net/URI;)Ljava/util/List<Ljava/net/Proxy;>; )
public java.util.List select(
java.net.URI)

________________CLASS________________


public abstract class java.net.ResponseCache extends java.lang.Object

----------------FIELDS----------------

private static java.net.ResponseCache _defaultResponseCache

private static java.net.NetPermission getResponseCachepermission

private static java.net.NetPermission setResponseCachepermission
----------------METHODS----------------

static void <clinit>()

public void <init>()

private static void checkGetResponseCachePermission()

private static void checkSetResponseCachePermission()

public static java.net.ResponseCache getDefault()

public static void setDefault(
java.net.ResponseCache)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
@dalvik.annotation.Signature (value =(Ljava/net/URI;Ljava/lang/String;Ljava/util/Map<Ljava/lang/String;Ljava/util/List<Ljava/lang/String;>;>;)Ljava/net/CacheResponse; )
public abstract java.net.CacheResponse get(
java.net.URI
java.lang.String
java.util.Map)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract java.net.CacheRequest put(
java.net.URI
java.net.URLConnection)

________________CLASS________________


public abstract class java.net.SecureCacheResponse extends java.net.CacheResponse

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public abstract java.lang.String getCipherSuite()
@dalvik.annotation.Signature (value =()Ljava/util/List<Ljava/security/cert/Certificate;>; )
public abstract java.util.List getLocalCertificateChain()

public abstract java.security.Principal getLocalPrincipal()
@dalvik.annotation.Throws (value =Ljavax/net/ssl/SSLPeerUnverifiedException; )
public abstract java.security.Principal getPeerPrincipal()
@dalvik.annotation.Signature (value =()Ljava/util/List<Ljava/security/cert/Certificate;>; )
@dalvik.annotation.Throws (value =Ljavax/net/ssl/SSLPeerUnverifiedException; )
public abstract java.util.List getServerCertificateChain()

________________CLASS________________


public class java.net.ServerSocket extends java.lang.Object

----------------FIELDS----------------

static java.net.SocketImplFactory factory

 java.net.SocketImpl impl

private boolean isBound

private boolean isClosed

private volatile boolean isCreated
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
int
int
java.net.InetAddress)

protected void <init>(
java.net.SocketImpl)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
private void checkClosedAndCreate(
boolean)

static int defaultBacklog()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static void setSocketFactory(
java.net.SocketImplFactory)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.net.Socket accept()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void bind(
java.net.SocketAddress)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void bind(
java.net.SocketAddress
int)

 void checkListen(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()

public java.nio.channels.ServerSocketChannel getChannel()

public java.net.InetAddress getInetAddress()

public int getLocalPort()

public java.net.SocketAddress getLocalSocketAddress()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public int getReceiveBufferSize()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public boolean getReuseAddress()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int getSoTimeout()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected final void implAccept(
java.net.Socket)

public boolean isBound()

public boolean isClosed()

public void setPerformancePreferences(
int
int
int)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void setReceiveBufferSize(
int)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void setReuseAddress(
boolean)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void setSoTimeout(
int)

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =4104 name =null )
@dalvik.annotation.EnclosingClass (value =Ljava/net/Socket; )
 class java.net.Socket$1 extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =10 name =ConnectLock )
@dalvik.annotation.EnclosingClass (value =Ljava/net/Socket; )
 class java.net.Socket$ConnectLock extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

private void <init>()

 void <init>(
java.net.Socket$1)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/net/Socket$1;Ljava/net/Socket$ConnectLock; )
public class java.net.Socket extends java.lang.Object

----------------FIELDS----------------

static final int FLAG_SHUTDOWN

static final int MULTICAST_IF

static final int MULTICAST_TTL

static final int TCP_NODELAY

static java.net.SocketImplFactory factory

private java.lang.Object connectLock

 java.net.SocketImpl impl

private boolean isBound

private boolean isClosed

private boolean isConnected

private volatile boolean isCreated

private boolean isInputShutdown

private boolean isOutputShutdown

private java.net.Proxy proxy
----------------METHODS----------------

static void <clinit>()

public void <init>()
@dalvik.annotation.Throws (value =Ljava/net/UnknownHostException;Ljava/io/IOException; )
public void <init>(
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.lang.String
int
java.net.InetAddress
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
@java.lang.Deprecated
public void <init>(
java.lang.String
int
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.net.InetAddress
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.net.InetAddress
int
java.net.InetAddress
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
@java.lang.Deprecated
public void <init>(
java.net.InetAddress
int
boolean)

public void <init>(
java.net.Proxy)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
protected void <init>(
java.net.SocketImpl)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
private void checkClosedAndCreate(
boolean)

private void checkConnectPermission(
java.lang.String
int)

static boolean preferIPv4Stack()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static void setSocketImplFactory(
java.net.SocketImplFactory)

 void accepted()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void bind(
java.net.SocketAddress)

 void checkDestination(
java.net.InetAddress
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void connect(
java.net.SocketAddress)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void connect(
java.net.SocketAddress
int)

public java.nio.channels.SocketChannel getChannel()

public java.net.InetAddress getInetAddress()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.io.InputStream getInputStream()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public boolean getKeepAlive()

public java.net.InetAddress getLocalAddress()

public int getLocalPort()

public java.net.SocketAddress getLocalSocketAddress()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public boolean getOOBInline()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.io.OutputStream getOutputStream()

public int getPort()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public int getReceiveBufferSize()

public java.net.SocketAddress getRemoteSocketAddress()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public boolean getReuseAddress()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public int getSendBufferSize()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public int getSoLinger()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public int getSoTimeout()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public boolean getTcpNoDelay()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public int getTrafficClass()

public boolean isBound()

public boolean isClosed()

public boolean isConnected()

public boolean isInputShutdown()

public boolean isOutputShutdown()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void sendUrgentData(
int)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void setKeepAlive(
boolean)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void setOOBInline(
boolean)

public void setPerformancePreferences(
int
int
int)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void setReceiveBufferSize(
int)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void setReuseAddress(
boolean)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void setSendBufferSize(
int)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void setSoLinger(
boolean
int)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void setSoTimeout(
int)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void setTcpNoDelay(
boolean)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void setTrafficClass(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void shutdownInput()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void shutdownOutput()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void startupSocket(
java.net.InetAddress
int
java.net.InetAddress
int
boolean)

public java.lang.String toString()

________________CLASS________________


public abstract class java.net.SocketImpl extends java.lang.Object implements java.net.SocketOptions

----------------FIELDS----------------

protected java.net.InetAddress address

protected java.io.FileDescriptor fd

protected int localport

 org.apache.harmony.luni.platform.INetworkSystem netImpl

protected int port

protected int receiveTimeout

 boolean shutdownInput

 boolean streaming
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected abstract void accept(
java.net.SocketImpl)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected abstract int available()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected abstract void bind(
java.net.InetAddress
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected abstract void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected abstract void connect(
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected abstract void connect(
java.net.InetAddress
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected abstract void connect(
java.net.SocketAddress
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected abstract void create(
boolean)

protected java.io.FileDescriptor getFileDescriptor()

protected java.net.InetAddress getInetAddress()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected abstract java.io.InputStream getInputStream()

protected int getLocalPort()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public abstract java.lang.Object getOption(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected abstract java.io.OutputStream getOutputStream()

protected int getPort()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected abstract void listen(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 int read(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected abstract void sendUrgentData(
int)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public abstract void setOption(
int
java.lang.Object)

protected void setPerformancePreferences(
int
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void shutdownInput()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void shutdownOutput()

protected boolean supportsUrgentData()

public java.lang.String toString()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 int write(
byte[]
int
int)

________________CLASS________________


public abstract interface class java.net.SocketImplFactory extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.net.SocketImpl createSocketImpl()

________________CLASS________________


public final class java.net.SocketPermission extends java.security.Permission implements java.io.Serializable

----------------FIELDS----------------

private static final int HIGHEST_PORT

private static final int LOWEST_PORT

static final int SP_ACCEPT

static final int SP_CONNECT

static final int SP_LISTEN

static final int SP_RESOLVE

private static final java.lang.String[] actionNames

private static final long serialVersionUID

private java.lang.String actions

transient int actionsMask

transient java.lang.String hostName

transient java.lang.String ipString

private transient boolean isPartialWild

private transient boolean isWild

transient int portMax

transient int portMin

transient boolean resolved
----------------METHODS----------------

static void <clinit>()

public void <init>(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
private java.lang.String getHostString(
java.lang.String)

private java.lang.String getIPString()
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
private void parsePort(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
private void setActions(
java.lang.String)

private java.lang.String toCanonicalActionString(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

 boolean checkHost(
java.net.SocketPermission)

public boolean equals(
java.lang.Object)

public java.lang.String getActions()

public int hashCode()

public boolean implies(
java.security.Permission)

public java.security.PermissionCollection newPermissionCollection()

________________CLASS________________


final class java.net.SocketPermissionCollection extends java.security.PermissionCollection

----------------FIELDS----------------

private static final long serialVersionUID
@dalvik.annotation.Signature (value =Ljava/util/Vector<Ljava/security/Permission;>; )
private java.util.Vector permissions
----------------METHODS----------------

public void <init>()

public void add(
java.security.Permission)
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<Ljava/security/Permission;>; )
public java.util.Enumeration elements()

public boolean implies(
java.security.Permission)

________________CLASS________________


public class java.net.SocketTimeoutException extends java.io.InterruptedIOException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/net/URI; )
@dalvik.annotation.InnerClass (accessFlags =4104 name =null )
 class java.net.URI$1 extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =2 name =Helper )
@dalvik.annotation.EnclosingClass (value =Ljava/net/URI; )
 class java.net.URI$Helper extends java.lang.Object

----------------FIELDS----------------

final java.net.URI this$0
----------------METHODS----------------

private void <init>(
java.net.URI)

 void <init>(
java.net.URI
java.net.URI$1)
@dalvik.annotation.Throws (value =Ljava/net/URISyntaxException; )
static void access$100(
java.net.URI$Helper
java.lang.String
boolean)
@dalvik.annotation.Throws (value =Ljava/net/URISyntaxException; )
static void access$1500(
java.net.URI$Helper
boolean)

private boolean isValidDomainName(
java.lang.String)

private boolean isValidHexChar(
char)
@dalvik.annotation.Throws (value =Ljava/net/URISyntaxException; )
private boolean isValidHost(
boolean
java.lang.String)

private boolean isValidIP4Word(
java.lang.String)

private boolean isValidIP6Address(
java.lang.String)

private boolean isValidIPv4Address(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/net/URISyntaxException; )
private void parseAuthority(
boolean)
@dalvik.annotation.Throws (value =Ljava/net/URISyntaxException; )
private void parseURI(
java.lang.String
boolean)
@dalvik.annotation.Throws (value =Ljava/net/URISyntaxException; )
private void validateAuthority(
java.lang.String
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/net/URISyntaxException; )
private void validateFragment(
java.lang.String
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/net/URISyntaxException; )
private void validatePath(
java.lang.String
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/net/URISyntaxException; )
private void validateQuery(
java.lang.String
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/net/URISyntaxException; )
private void validateScheme(
java.lang.String
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/net/URISyntaxException; )
private void validateSsp(
java.lang.String
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/net/URISyntaxException; )
private void validateUserinfo(
java.lang.String
java.lang.String
int)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/net/URI$1;Ljava/net/URI$Helper; )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/lang/Comparable<Ljava/net/URI;>;Ljava/io/Serializable; )
public final class java.net.URI extends java.lang.Object implements java.lang.Comparable, java.io.Serializable

----------------FIELDS----------------

static final java.lang.String allLegal

static final java.lang.String punct

static final java.lang.String reserved

private static final long serialVersionUID

static final java.lang.String someLegal

static final java.lang.String unreserved

private transient boolean absolute

private transient java.lang.String authority

private transient java.lang.String fragment

private transient int hash

private transient java.lang.String host

private transient boolean opaque

private transient java.lang.String path

private transient int port

private transient java.lang.String query

private transient java.lang.String scheme

private transient java.lang.String schemespecificpart

private transient boolean serverAuthority

private java.lang.String string

private transient java.lang.String userinfo
----------------METHODS----------------

private void <init>()
@dalvik.annotation.Throws (value =Ljava/net/URISyntaxException; )
public void <init>(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/net/URISyntaxException; )
public void <init>(
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/net/URISyntaxException; )
public void <init>(
java.lang.String
java.lang.String
java.lang.String
int
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/net/URISyntaxException; )
public void <init>(
java.lang.String
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/net/URISyntaxException; )
public void <init>(
java.lang.String
java.lang.String
java.lang.String
java.lang.String
java.lang.String)

static java.lang.String access$1000(
java.net.URI)

static java.lang.String access$1002(
java.net.URI
java.lang.String)

static java.lang.String access$1102(
java.net.URI
java.lang.String)

static java.lang.String access$1202(
java.net.URI
java.lang.String)

static int access$1302(
java.net.URI
int)

static boolean access$1402(
java.net.URI
boolean)

static java.lang.String access$202(
java.net.URI
java.lang.String)

static java.lang.String access$300(
java.net.URI)

static java.lang.String access$302(
java.net.URI
java.lang.String)

static boolean access$402(
java.net.URI
boolean)

static java.lang.String access$500(
java.net.URI)

static java.lang.String access$502(
java.net.URI
java.lang.String)

static java.lang.String access$600(
java.net.URI)

static java.lang.String access$602(
java.net.URI
java.lang.String)

static boolean access$702(
java.net.URI
boolean)

static java.lang.String access$800(
java.net.URI)

static java.lang.String access$802(
java.net.URI
java.lang.String)

static java.lang.String access$900(
java.net.URI)

static java.lang.String access$902(
java.net.URI
java.lang.String)

private java.lang.String convertHexToLowerCase(
java.lang.String)

public static java.net.URI create(
java.lang.String)

private java.lang.String decode(
java.lang.String)

private java.net.URI duplicate()

private java.lang.String encodeOthers(
java.lang.String)

private boolean equalsHexCaseInsensitive(
java.lang.String
java.lang.String)

private java.lang.String getHashString()

private java.lang.String normalize(
java.lang.String)

private java.lang.String quoteComponent(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)

private void setSchemeSpecificPart()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void writeObject(
java.io.ObjectOutputStream)

public volatile int compareTo(
java.lang.Object)

public int compareTo(
java.net.URI)

public boolean equals(
java.lang.Object)

public java.lang.String getAuthority()

public java.lang.String getFragment()

public java.lang.String getHost()

public java.lang.String getPath()

public int getPort()

public java.lang.String getQuery()

public java.lang.String getRawAuthority()

public java.lang.String getRawFragment()

public java.lang.String getRawPath()

public java.lang.String getRawQuery()

public java.lang.String getRawSchemeSpecificPart()

public java.lang.String getRawUserInfo()

public java.lang.String getScheme()

public java.lang.String getSchemeSpecificPart()

public java.lang.String getUserInfo()

public int hashCode()

public boolean isAbsolute()

public boolean isOpaque()

public java.net.URI normalize()
@dalvik.annotation.Throws (value =Ljava/net/URISyntaxException; )
public java.net.URI parseServerAuthority()

public java.net.URI relativize(
java.net.URI)

public java.net.URI resolve(
java.lang.String)

public java.net.URI resolve(
java.net.URI)

public java.lang.String toASCIIString()

public java.lang.String toString()
@dalvik.annotation.Throws (value =Ljava/net/MalformedURLException; )
public java.net.URL toURL()

________________CLASS________________


 class java.net.URIEncoderDecoder extends java.lang.Object

----------------FIELDS----------------

static final java.lang.String digits

static final java.lang.String encoding
----------------METHODS----------------

 void <init>()
@dalvik.annotation.Throws (value =Ljava/io/UnsupportedEncodingException; )
static java.lang.String decode(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/UnsupportedEncodingException; )
static java.lang.String encodeOthers(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/UnsupportedEncodingException; )
static java.lang.String quoteIllegal(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/net/URISyntaxException; )
static void validate(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/net/URISyntaxException; )
static void validateSimple(
java.lang.String
java.lang.String)

________________CLASS________________


public class java.net.URISyntaxException extends java.lang.Exception

----------------FIELDS----------------

private static final long serialVersionUID

private int index

private java.lang.String input
----------------METHODS----------------

public void <init>(
java.lang.String
java.lang.String)

public void <init>(
java.lang.String
java.lang.String
int)

public int getIndex()

public java.lang.String getInput()

public java.lang.String getMessage()

public java.lang.String getReason()

________________CLASS________________


public final class java.net.URL extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

private static final java.net.NetPermission specifyStreamHandlerPermission

private static java.net.URLStreamHandlerFactory streamHandlerFactory
@dalvik.annotation.Signature (value =Ljava/util/Hashtable<Ljava/lang/String;Ljava/net/URLStreamHandler;>; )
private static java.util.Hashtable streamHandlers

private java.lang.String authority

private java.lang.String file

private int hashCode

private java.lang.String host

private transient java.lang.String path

private int port

private java.lang.String protocol

private transient java.lang.String query

private java.lang.String ref

transient java.net.URLStreamHandler strmHandler

private transient java.lang.String userInfo
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Throws (value =Ljava/net/MalformedURLException; )
public void <init>(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/net/MalformedURLException; )
public void <init>(
java.lang.String
java.lang.String
int
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/net/MalformedURLException; )
public void <init>(
java.lang.String
java.lang.String
int
java.lang.String
java.net.URLStreamHandler)
@dalvik.annotation.Throws (value =Ljava/net/MalformedURLException; )
public void <init>(
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/net/MalformedURLException; )
public void <init>(
java.net.URL
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/net/MalformedURLException; )
public void <init>(
java.net.URL
java.lang.String
java.net.URLStreamHandler)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void readObject(
java.io.ObjectInputStream)

public static void setURLStreamHandlerFactory(
java.net.URLStreamHandlerFactory)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

public boolean equals(
java.lang.Object)

 void fixURL(
boolean)

public java.lang.String getAuthority()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final java.lang.Object getContent()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final java.lang.Object getContent(
java.lang.Class[])

public int getDefaultPort()

public java.lang.String getFile()

public java.lang.String getHost()

public java.lang.String getPath()

public int getPort()

public java.lang.String getProtocol()

public java.lang.String getQuery()

public java.lang.String getRef()

 java.net.URLStreamHandler getStreamHandler()

public java.lang.String getUserInfo()

public int hashCode()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.net.URLConnection openConnection()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.net.URLConnection openConnection(
java.net.Proxy)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final java.io.InputStream openStream()

public boolean sameFile(
java.net.URL)

protected void set(
java.lang.String
java.lang.String
int
java.lang.String
java.lang.String)

protected void set(
java.lang.String
java.lang.String
int
java.lang.String
java.lang.String
java.lang.String
java.lang.String
java.lang.String)

 void setupStreamHandler()

public java.lang.String toExternalForm()

public java.lang.String toString()
@dalvik.annotation.Throws (value =Ljava/net/URISyntaxException; )
public java.net.URI toURI()

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/util/Vector<Ljava/net/URL;>;>; )
 class java.net.URLClassLoader$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final java.net.URLClassLoader this$0

final java.lang.String val$name
----------------METHODS----------------

 void <init>(
java.net.URLClassLoader
java.lang.String)

public volatile java.lang.Object run()
@dalvik.annotation.Signature (value =()Ljava/util/Vector<Ljava/net/URL;>; )
public java.util.Vector run()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/net/URLClassLoader;>; )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class java.net.URLClassLoader$2 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final java.net.URL[] val$urls
----------------METHODS----------------

 void <init>(
java.net.URL[])

public volatile java.lang.Object run()

public java.net.URLClassLoader run()

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/net/URLClassLoader;>; )
final class java.net.URLClassLoader$3 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final java.lang.ClassLoader val$parentCl

final java.net.URL[] val$urls
----------------METHODS----------------

 void <init>(
java.net.URL[]
java.lang.ClassLoader)

public volatile java.lang.Object run()

public java.net.URLClassLoader run()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/Class<*>;>; )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
 class java.net.URLClassLoader$4 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final java.net.URLClassLoader this$0

final java.lang.String val$clsName
----------------METHODS----------------

 void <init>(
java.net.URLClassLoader
java.lang.String)
@dalvik.annotation.Signature (value =()Ljava/lang/Class<*>; )
public java.lang.Class run()

public volatile java.lang.Object run()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/net/URL;>; )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
 class java.net.URLClassLoader$5 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final java.net.URLClassLoader this$0

final java.lang.String val$name
----------------METHODS----------------

 void <init>(
java.net.URLClassLoader
java.lang.String)

public volatile java.lang.Object run()

public java.net.URL run()

________________CLASS________________


public class java.security.SecureClassLoader extends java.lang.ClassLoader

----------------FIELDS----------------

private java.util.HashMap pds
----------------METHODS----------------

protected void <init>()

protected void <init>(
java.lang.ClassLoader)

private java.security.ProtectionDomain getPD(
java.security.CodeSource)
@dalvik.annotation.Signature (value =(Ljava/lang/String;Ljava/nio/ByteBuffer;Ljava/security/CodeSource;)Ljava/lang/Class<*>; )
protected final java.lang.Class defineClass(
java.lang.String
java.nio.ByteBuffer
java.security.CodeSource)
@dalvik.annotation.Signature (value =(Ljava/lang/String;[BIILjava/security/CodeSource;)Ljava/lang/Class<*>; )
protected final java.lang.Class defineClass(
java.lang.String
byte[]
int
int
java.security.CodeSource)

protected java.security.PermissionCollection getPermissions(
java.security.CodeSource)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/net/URLClassLoader$SubURLClassLoader; )
public class java.net.URLClassLoader extends java.security.SecureClassLoader

----------------FIELDS----------------

private static java.net.URL[] NO_PATH

private java.security.AccessControlContext currentContext
@dalvik.annotation.Signature (value =Ljava/util/HashMap<Ljava/net/URL;[Ljava/net/URL;>; )
 java.util.HashMap extensions

private java.net.URLStreamHandlerFactory factory
@dalvik.annotation.Signature (value =[Ljava/util/Hashtable<Ljava/lang/String;[Ljava/net/URL;>; )
 java.util.Hashtable[] indexes
@dalvik.annotation.Signature (value =Ljava/util/Set<Ljava/net/URL;>; )
 java.util.Set invalidUrls

private java.lang.Object lock

 java.net.URL[] orgUrls
@dalvik.annotation.Signature (value =Ljava/util/Map<Ljava/net/URL;Ljava/util/jar/JarFile;>; )
private java.util.Map resCache

 java.net.URL[] urls
----------------METHODS----------------

static void <clinit>()

public void <init>(
java.net.URL[])

public void <init>(
java.net.URL[]
java.lang.ClassLoader)

public void <init>(
java.net.URL[]
java.lang.ClassLoader
java.net.URLStreamHandlerFactory)
@dalvik.annotation.Throws (value =Ljava/net/MalformedURLException; )
private java.net.URL createSearchURL(
java.net.URL)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private static byte[] getBytes(
java.io.InputStream
boolean)

private java.net.URL[] getInternalURLs(
java.net.URL
java.lang.String)

private static boolean isDirectory(
java.net.URL)

private boolean isSealed(
java.util.jar.Manifest
java.lang.String)
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>(I)[Ljava/util/Hashtable<TK;TV;>; )
private static java.util.Hashtable[] newHashtableArray(
int)

public static java.net.URLClassLoader newInstance(
java.net.URL[])

public static java.net.URLClassLoader newInstance(
java.net.URL[]
java.lang.ClassLoader)
@dalvik.annotation.Signature (value =(Ljava/io/InputStream;)Ljava/util/List<Ljava/lang/String;>; )
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private java.util.List readLines(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/net/MalformedURLException; )
private java.net.URL targetURL(
java.net.URL
java.lang.String)

protected void addURL(
java.net.URL)

 java.net.URL[] addURL(
java.net.URL[]
java.net.URL)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
protected java.lang.Package definePackage(
java.lang.String
java.util.jar.Manifest
java.net.URL)

 java.net.URL[] explore(
java.net.URL
int)
@dalvik.annotation.Throws (value =Ljava/lang/ClassNotFoundException; )
@dalvik.annotation.Signature (value =(Ljava/lang/String;)Ljava/lang/Class<*>; )
protected java.lang.Class findClass(
java.lang.String)
@dalvik.annotation.Signature (value =([Ljava/net/URL;Ljava/lang/String;)Ljava/lang/Class<*>; )
 java.lang.Class findClassImpl(
java.net.URL[]
java.lang.String)
@dalvik.annotation.Signature (value =([Ljava/net/URL;Ljava/lang/String;ILjava/util/Vector<Ljava/net/URL;>;Z)Ljava/lang/Object; )
 java.lang.Object findInExtensions(
java.net.URL[]
java.lang.String
int
java.util.Vector
boolean)
@dalvik.annotation.Signature (value =(ILjava/lang/String;Ljava/util/Vector<Ljava/net/URL;>;Z)Ljava/lang/Object; )
 java.lang.Object findInIndex(
int
java.lang.String
java.util.Vector
boolean)

public java.net.URL findResource(
java.lang.String)

 java.net.URL findResourceImpl(
java.net.URL[]
java.lang.String)
@dalvik.annotation.Signature (value =(Ljava/lang/String;)Ljava/util/Enumeration<Ljava/net/URL;>; )
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.util.Enumeration findResources(
java.lang.String)
@dalvik.annotation.Signature (value =([Ljava/net/URL;Ljava/lang/String;Ljava/util/Vector<Ljava/net/URL;>;)Ljava/util/Vector<Ljava/net/URL;>; )
 java.util.Vector findResources(
java.net.URL[]
java.lang.String
java.util.Vector)

protected java.security.PermissionCollection getPermissions(
java.security.CodeSource)

public java.net.URL[] getURLs()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =SubURLClassLoader )
@dalvik.annotation.EnclosingClass (value =Ljava/net/URLClassLoader; )
 class java.net.URLClassLoader$SubURLClassLoader extends java.net.URLClassLoader

----------------FIELDS----------------

private boolean checkingPackageAccess
----------------METHODS----------------

 void <init>(
java.net.URL[])

 void <init>(
java.net.URL[]
java.lang.ClassLoader)
@dalvik.annotation.Signature (value =(Ljava/lang/String;Z)Ljava/lang/Class<*>; )
@dalvik.annotation.Throws (value =Ljava/lang/ClassNotFoundException; )
protected java.lang.Class loadClass(
java.lang.String
boolean)

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/Object;>; )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
 class java.net.URLConnection$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final java.net.URLConnection this$0

final java.lang.String val$typeString
----------------METHODS----------------

 void <init>(
java.net.URLConnection
java.lang.String)

public java.lang.Object run()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/net/URLConnection; )
@dalvik.annotation.InnerClass (accessFlags =8 name =DefaultContentHandler )
 class java.net.URLConnection$DefaultContentHandler extends java.net.ContentHandler

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object getContent(
java.net.URLConnection)

________________CLASS________________


public class java.net.URLDecoder extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@java.lang.Deprecated
public static java.lang.String decode(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/UnsupportedEncodingException; )
public static java.lang.String decode(
java.lang.String
java.lang.String)

________________CLASS________________


public class java.net.URLEncoder extends java.lang.Object

----------------FIELDS----------------

static final java.lang.String digits
----------------METHODS----------------

private void <init>()
@dalvik.annotation.Throws (value =Ljava/io/UnsupportedEncodingException; )
private static void convert(
java.lang.String
java.lang.StringBuffer
java.lang.String)
@java.lang.Deprecated
public static java.lang.String encode(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/UnsupportedEncodingException; )
public static java.lang.String encode(
java.lang.String
java.lang.String)

________________CLASS________________


public abstract class java.net.URLStreamHandler extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

private static java.lang.String getHost(
java.net.URL)

protected boolean equals(
java.net.URL
java.net.URL)

protected int getDefaultPort()

protected java.net.InetAddress getHostAddress(
java.net.URL)

protected int hashCode(
java.net.URL)

protected boolean hostsEqual(
java.net.URL
java.net.URL)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected abstract java.net.URLConnection openConnection(
java.net.URL)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected java.net.URLConnection openConnection(
java.net.URL
java.net.Proxy)

protected void parseURL(
java.net.URL
java.lang.String
int
int)

protected boolean sameFile(
java.net.URL
java.net.URL)
@java.lang.Deprecated
protected void setURL(
java.net.URL
java.lang.String
java.lang.String
int
java.lang.String
java.lang.String)

protected void setURL(
java.net.URL
java.lang.String
java.lang.String
int
java.lang.String
java.lang.String
java.lang.String
java.lang.String
java.lang.String)

protected java.lang.String toExternalForm(
java.net.URL)

________________CLASS________________


public abstract interface class java.net.URLStreamHandlerFactory extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.net.URLStreamHandler createURLStreamHandler(
java.lang.String)

________________CLASS________________


public class java.net.UnknownHostException extends java.io.IOException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class java.net.UnknownServiceException extends java.io.IOException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public abstract class java.nio.Buffer extends java.lang.Object

----------------FIELDS----------------

static final int UNSET_MARK

 int _elementSizeShift

final int capacity

 int limit

 int mark

 int position
----------------METHODS----------------

 void <init>(
int)

 java.lang.Object _array()

 int _arrayOffset()

public final int capacity()

public final java.nio.Buffer clear()

public final java.nio.Buffer flip()

public final boolean hasRemaining()

public abstract boolean isReadOnly()

public final int limit()

public final java.nio.Buffer limit(
int)

public final java.nio.Buffer mark()

public final int position()

public final java.nio.Buffer position(
int)

public final int remaining()

public final java.nio.Buffer reset()

public final java.nio.Buffer rewind()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/nio/Buffer;Ljava/lang/Comparable<Ljava/nio/ByteBuffer;>; )
public abstract class java.nio.ByteBuffer extends java.nio.Buffer implements java.lang.Comparable

----------------FIELDS----------------

 org.apache.harmony.luni.platform.Endianness order
----------------METHODS----------------

 void <init>(
int)

public static java.nio.ByteBuffer allocate(
int)

public static java.nio.ByteBuffer allocateDirect(
int)

public static java.nio.ByteBuffer wrap(
byte[])

public static java.nio.ByteBuffer wrap(
byte[]
int
int)

 java.lang.Object _array()

 int _arrayOffset()

public final byte[] array()

public final int arrayOffset()

public abstract java.nio.CharBuffer asCharBuffer()

public abstract java.nio.DoubleBuffer asDoubleBuffer()

public abstract java.nio.FloatBuffer asFloatBuffer()

public abstract java.nio.IntBuffer asIntBuffer()

public abstract java.nio.LongBuffer asLongBuffer()

public abstract java.nio.ByteBuffer asReadOnlyBuffer()

public abstract java.nio.ShortBuffer asShortBuffer()

public abstract java.nio.ByteBuffer compact()

public volatile int compareTo(
java.lang.Object)

public int compareTo(
java.nio.ByteBuffer)

public abstract java.nio.ByteBuffer duplicate()

public boolean equals(
java.lang.Object)

public abstract byte get()

public abstract byte get(
int)

public java.nio.ByteBuffer get(
byte[])

public java.nio.ByteBuffer get(
byte[]
int
int)

public abstract char getChar()

public abstract char getChar(
int)

public abstract double getDouble()

public abstract double getDouble(
int)

public abstract float getFloat()

public abstract float getFloat(
int)

public abstract int getInt()

public abstract int getInt(
int)

public abstract long getLong()

public abstract long getLong(
int)

public abstract short getShort()

public abstract short getShort(
int)

public final boolean hasArray()

public int hashCode()

public abstract boolean isDirect()

public final java.nio.ByteBuffer order(
java.nio.ByteOrder)

public final java.nio.ByteOrder order()

 java.nio.ByteBuffer orderImpl(
java.nio.ByteOrder)

abstract byte[] protectedArray()

abstract int protectedArrayOffset()

abstract boolean protectedHasArray()

public abstract java.nio.ByteBuffer put(
byte)

public abstract java.nio.ByteBuffer put(
int
byte)

public java.nio.ByteBuffer put(
java.nio.ByteBuffer)

public final java.nio.ByteBuffer put(
byte[])

public java.nio.ByteBuffer put(
byte[]
int
int)

public abstract java.nio.ByteBuffer putChar(
char)

public abstract java.nio.ByteBuffer putChar(
int
char)

public abstract java.nio.ByteBuffer putDouble(
double)

public abstract java.nio.ByteBuffer putDouble(
int
double)

public abstract java.nio.ByteBuffer putFloat(
float)

public abstract java.nio.ByteBuffer putFloat(
int
float)

public abstract java.nio.ByteBuffer putInt(
int)

public abstract java.nio.ByteBuffer putInt(
int
int)

public abstract java.nio.ByteBuffer putLong(
int
long)

public abstract java.nio.ByteBuffer putLong(
long)

public abstract java.nio.ByteBuffer putShort(
int
short)

public abstract java.nio.ByteBuffer putShort(
short)

public abstract java.nio.ByteBuffer slice()

public java.lang.String toString()

________________CLASS________________


abstract class java.nio.BaseByteBuffer extends java.nio.ByteBuffer

----------------FIELDS----------------
----------------METHODS----------------

protected void <init>(
int)

public final java.nio.CharBuffer asCharBuffer()

public final java.nio.DoubleBuffer asDoubleBuffer()

public final java.nio.FloatBuffer asFloatBuffer()

public final java.nio.IntBuffer asIntBuffer()

public final java.nio.LongBuffer asLongBuffer()

public final java.nio.ShortBuffer asShortBuffer()

public final char getChar()

public final char getChar(
int)

public final java.nio.ByteBuffer putChar(
char)

public final java.nio.ByteBuffer putChar(
int
char)

________________CLASS________________


final class java.nio.BufferFactory extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public static java.nio.ByteBuffer newByteBuffer(
int)

public static java.nio.ByteBuffer newByteBuffer(
byte[])

public static java.nio.CharBuffer newCharBuffer(
int)

public static java.nio.CharBuffer newCharBuffer(
java.lang.CharSequence)

public static java.nio.CharBuffer newCharBuffer(
char[])

public static java.nio.ByteBuffer newDirectByteBuffer(
int)

public static java.nio.DoubleBuffer newDoubleBuffer(
int)

public static java.nio.DoubleBuffer newDoubleBuffer(
double[])

public static java.nio.FloatBuffer newFloatBuffer(
int)

public static java.nio.FloatBuffer newFloatBuffer(
float[])

public static java.nio.IntBuffer newIntBuffer(
int)

public static java.nio.IntBuffer newIntBuffer(
int[])

public static java.nio.LongBuffer newLongBuffer(
int)

public static java.nio.LongBuffer newLongBuffer(
long[])

public static java.nio.ShortBuffer newShortBuffer(
int)

public static java.nio.ShortBuffer newShortBuffer(
short[])

________________CLASS________________


public class java.nio.BufferOverflowException extends java.lang.RuntimeException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

________________CLASS________________


public class java.nio.BufferUnderflowException extends java.lang.RuntimeException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

________________CLASS________________


public final class java.nio.ByteOrder extends java.lang.Object

----------------FIELDS----------------

public static final java.nio.ByteOrder BIG_ENDIAN

public static final java.nio.ByteOrder LITTLE_ENDIAN

private static final java.nio.ByteOrder NATIVE_ORDER

private final java.lang.String name
----------------METHODS----------------

static void <clinit>()

private void <init>(
java.lang.String)

public static java.nio.ByteOrder nativeOrder()

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/nio/Buffer;Ljava/lang/Comparable<Ljava/nio/CharBuffer;>;Ljava/lang/CharSequence;Ljava/lang/Appendable;Ljava/lang/Readable; )
public abstract class java.nio.CharBuffer extends java.nio.Buffer implements java.lang.Comparable, java.lang.CharSequence, java.lang.Appendable, java.lang.Readable

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
int)

public static java.nio.CharBuffer allocate(
int)

public static java.nio.CharBuffer wrap(
java.lang.CharSequence)

public static java.nio.CharBuffer wrap(
java.lang.CharSequence
int
int)

public static java.nio.CharBuffer wrap(
char[])

public static java.nio.CharBuffer wrap(
char[]
int
int)

 java.lang.Object _array()

 int _arrayOffset()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public volatile java.lang.Appendable append(
char)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public volatile java.lang.Appendable append(
java.lang.CharSequence)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public volatile java.lang.Appendable append(
java.lang.CharSequence
int
int)

public java.nio.CharBuffer append(
char)

public java.nio.CharBuffer append(
java.lang.CharSequence)

public java.nio.CharBuffer append(
java.lang.CharSequence
int
int)

public final char[] array()

public final int arrayOffset()

public abstract java.nio.CharBuffer asReadOnlyBuffer()

public final char charAt(
int)

public abstract java.nio.CharBuffer compact()

public volatile int compareTo(
java.lang.Object)

public int compareTo(
java.nio.CharBuffer)

public abstract java.nio.CharBuffer duplicate()

public boolean equals(
java.lang.Object)

public abstract char get()

public abstract char get(
int)

public java.nio.CharBuffer get(
char[])

public java.nio.CharBuffer get(
char[]
int
int)

public final boolean hasArray()

public int hashCode()

public abstract boolean isDirect()

public final int length()

public abstract java.nio.ByteOrder order()

abstract char[] protectedArray()

abstract int protectedArrayOffset()

abstract boolean protectedHasArray()

public abstract java.nio.CharBuffer put(
char)

public abstract java.nio.CharBuffer put(
int
char)

public final java.nio.CharBuffer put(
java.lang.String)

public java.nio.CharBuffer put(
java.lang.String
int
int)

public java.nio.CharBuffer put(
java.nio.CharBuffer)

public final java.nio.CharBuffer put(
char[])

public java.nio.CharBuffer put(
char[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
java.nio.CharBuffer)

public abstract java.nio.CharBuffer slice()

public abstract java.lang.CharSequence subSequence(
int
int)

public java.lang.String toString()

________________CLASS________________


abstract class java.nio.CharArrayBuffer extends java.nio.CharBuffer

----------------FIELDS----------------

protected final char[] backingArray

protected final int offset
----------------METHODS----------------

 void <init>(
int)

 void <init>(
int
char[]
int)

 void <init>(
char[])

public final char get()

public final char get(
int)

public final java.nio.CharBuffer get(
char[]
int
int)

public final boolean isDirect()

public final java.nio.ByteOrder order()

public final java.lang.CharSequence subSequence(
int
int)

public final java.lang.String toString()

________________CLASS________________


final class java.nio.CharSequenceAdapter extends java.nio.CharBuffer

----------------FIELDS----------------

final java.lang.CharSequence sequence
----------------METHODS----------------

 void <init>(
java.lang.CharSequence)

static java.nio.CharSequenceAdapter copy(
java.nio.CharSequenceAdapter)

public java.nio.CharBuffer asReadOnlyBuffer()

public java.nio.CharBuffer compact()

public java.nio.CharBuffer duplicate()

public char get()

public char get(
int)

public final java.nio.CharBuffer get(
char[]
int
int)

public boolean isDirect()

public boolean isReadOnly()

public java.nio.ByteOrder order()

protected char[] protectedArray()

protected int protectedArrayOffset()

protected boolean protectedHasArray()

public java.nio.CharBuffer put(
char)

public java.nio.CharBuffer put(
int
char)

public java.nio.CharBuffer put(
java.lang.String
int
int)

public final java.nio.CharBuffer put(
char[]
int
int)

public java.nio.CharBuffer slice()

public java.lang.CharSequence subSequence(
int
int)

________________CLASS________________


public abstract interface class org.apache.harmony.nio.internal.DirectBuffer extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract void addressValidityCheck()

public abstract void free()

public abstract org.apache.harmony.luni.platform.PlatformAddress getBaseAddress()

public abstract int getByteCapacity()

public abstract org.apache.harmony.luni.platform.PlatformAddress getEffectiveAddress()

public abstract boolean isAddressValid()

________________CLASS________________


final class java.nio.CharToByteBufferAdapter extends java.nio.CharBuffer implements org.apache.harmony.nio.internal.DirectBuffer

----------------FIELDS----------------

static final boolean $assertionsDisabled

private final java.nio.ByteBuffer byteBuffer
----------------METHODS----------------

static void <clinit>()

 void <init>(
java.nio.ByteBuffer)

static java.nio.CharBuffer wrap(
java.nio.ByteBuffer)

public void addressValidityCheck()

public java.nio.CharBuffer asReadOnlyBuffer()

public java.nio.CharBuffer compact()

public java.nio.CharBuffer duplicate()

public void free()

public char get()

public char get(
int)

public org.apache.harmony.luni.platform.PlatformAddress getBaseAddress()

public int getByteCapacity()

public org.apache.harmony.luni.platform.PlatformAddress getEffectiveAddress()

public boolean isAddressValid()

public boolean isDirect()

public boolean isReadOnly()

public java.nio.ByteOrder order()

protected char[] protectedArray()

protected int protectedArrayOffset()

protected boolean protectedHasArray()

public java.nio.CharBuffer put(
char)

public java.nio.CharBuffer put(
int
char)

public java.nio.CharBuffer slice()

public java.lang.CharSequence subSequence(
int
int)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =24 name =SafeAddress )
@dalvik.annotation.EnclosingClass (value =Ljava/nio/DirectByteBuffer; )
final class java.nio.DirectByteBuffer$SafeAddress extends java.lang.Object

----------------FIELDS----------------

protected final org.apache.harmony.luni.platform.PlatformAddress address

protected volatile boolean isValid
----------------METHODS----------------

protected void <init>(
org.apache.harmony.luni.platform.PlatformAddress)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/nio/DirectByteBuffer$SafeAddress; )
abstract class java.nio.DirectByteBuffer extends java.nio.BaseByteBuffer implements org.apache.harmony.nio.internal.DirectBuffer

----------------FIELDS----------------

protected final int offset

protected final java.nio.DirectByteBuffer$SafeAddress safeAddress
----------------METHODS----------------

 void <init>(
int)

 void <init>(
java.nio.DirectByteBuffer$SafeAddress
int
int)

private void markAddressInvalid()

public final void addressValidityCheck()

public final void free()

public final byte get()

public final byte get(
int)

public final java.nio.ByteBuffer get(
byte[]
int
int)

public final org.apache.harmony.luni.platform.PlatformAddress getBaseAddress()

public final int getByteCapacity()

public final double getDouble()

public final double getDouble(
int)

public final org.apache.harmony.luni.platform.PlatformAddress getEffectiveAddress()

public final float getFloat()

public final float getFloat(
int)

public final int getInt()

public final int getInt(
int)

public final long getLong()

public final long getLong(
int)

public final short getShort()

public final short getShort(
int)

public final boolean isAddressValid()

public final boolean isDirect()

protected final byte[] protectedArray()

protected final int protectedArrayOffset()

protected final boolean protectedHasArray()

________________CLASS________________


 class java.nio.DirectByteBuffers extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public static void free(
java.nio.ByteBuffer)

public static org.apache.harmony.luni.platform.PlatformAddress getEffectiveAddress(
java.nio.ByteBuffer)

private static java.nio.DirectByteBuffer toDirectBuffer(
java.nio.ByteBuffer)

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/nio/Buffer;Ljava/lang/Comparable<Ljava/nio/DoubleBuffer;>; )
public abstract class java.nio.DoubleBuffer extends java.nio.Buffer implements java.lang.Comparable

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
int)

public static java.nio.DoubleBuffer allocate(
int)

public static java.nio.DoubleBuffer wrap(
double[])

public static java.nio.DoubleBuffer wrap(
double[]
int
int)

 java.lang.Object _array()

 int _arrayOffset()

public final double[] array()

public final int arrayOffset()

public abstract java.nio.DoubleBuffer asReadOnlyBuffer()

public abstract java.nio.DoubleBuffer compact()

public volatile int compareTo(
java.lang.Object)

public int compareTo(
java.nio.DoubleBuffer)

public abstract java.nio.DoubleBuffer duplicate()

public boolean equals(
java.lang.Object)

public abstract double get()

public abstract double get(
int)

public java.nio.DoubleBuffer get(
double[])

public java.nio.DoubleBuffer get(
double[]
int
int)

public final boolean hasArray()

public int hashCode()

public abstract boolean isDirect()

public abstract java.nio.ByteOrder order()

abstract double[] protectedArray()

abstract int protectedArrayOffset()

abstract boolean protectedHasArray()

public abstract java.nio.DoubleBuffer put(
double)

public abstract java.nio.DoubleBuffer put(
int
double)

public java.nio.DoubleBuffer put(
java.nio.DoubleBuffer)

public final java.nio.DoubleBuffer put(
double[])

public java.nio.DoubleBuffer put(
double[]
int
int)

public abstract java.nio.DoubleBuffer slice()

public java.lang.String toString()

________________CLASS________________


abstract class java.nio.DoubleArrayBuffer extends java.nio.DoubleBuffer

----------------FIELDS----------------

protected final double[] backingArray

protected final int offset
----------------METHODS----------------

 void <init>(
int)

 void <init>(
int
double[]
int)

 void <init>(
double[])

public final double get()

public final double get(
int)

public final java.nio.DoubleBuffer get(
double[]
int
int)

public final boolean isDirect()

public final java.nio.ByteOrder order()

________________CLASS________________


final class java.nio.DoubleToByteBufferAdapter extends java.nio.DoubleBuffer implements org.apache.harmony.nio.internal.DirectBuffer

----------------FIELDS----------------

static final boolean $assertionsDisabled

private final java.nio.ByteBuffer byteBuffer
----------------METHODS----------------

static void <clinit>()

 void <init>(
java.nio.ByteBuffer)

static java.nio.DoubleBuffer wrap(
java.nio.ByteBuffer)

public void addressValidityCheck()

public java.nio.DoubleBuffer asReadOnlyBuffer()

public java.nio.DoubleBuffer compact()

public java.nio.DoubleBuffer duplicate()

public void free()

public double get()

public double get(
int)

public org.apache.harmony.luni.platform.PlatformAddress getBaseAddress()

public int getByteCapacity()

public org.apache.harmony.luni.platform.PlatformAddress getEffectiveAddress()

public boolean isAddressValid()

public boolean isDirect()

public boolean isReadOnly()

public java.nio.ByteOrder order()

protected double[] protectedArray()

protected int protectedArrayOffset()

protected boolean protectedHasArray()

public java.nio.DoubleBuffer put(
double)

public java.nio.DoubleBuffer put(
int
double)

public java.nio.DoubleBuffer slice()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/nio/Buffer;Ljava/lang/Comparable<Ljava/nio/FloatBuffer;>; )
public abstract class java.nio.FloatBuffer extends java.nio.Buffer implements java.lang.Comparable

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
int)

public static java.nio.FloatBuffer allocate(
int)

public static java.nio.FloatBuffer wrap(
float[])

public static java.nio.FloatBuffer wrap(
float[]
int
int)

 java.lang.Object _array()

 int _arrayOffset()

public final float[] array()

public final int arrayOffset()

public abstract java.nio.FloatBuffer asReadOnlyBuffer()

public abstract java.nio.FloatBuffer compact()

public volatile int compareTo(
java.lang.Object)

public int compareTo(
java.nio.FloatBuffer)

public abstract java.nio.FloatBuffer duplicate()

public boolean equals(
java.lang.Object)

public abstract float get()

public abstract float get(
int)

public java.nio.FloatBuffer get(
float[])

public java.nio.FloatBuffer get(
float[]
int
int)

public final boolean hasArray()

public int hashCode()

public abstract boolean isDirect()

public abstract java.nio.ByteOrder order()

abstract float[] protectedArray()

abstract int protectedArrayOffset()

abstract boolean protectedHasArray()

public abstract java.nio.FloatBuffer put(
float)

public abstract java.nio.FloatBuffer put(
int
float)

public java.nio.FloatBuffer put(
java.nio.FloatBuffer)

public final java.nio.FloatBuffer put(
float[])

public java.nio.FloatBuffer put(
float[]
int
int)

public abstract java.nio.FloatBuffer slice()

public java.lang.String toString()

________________CLASS________________


abstract class java.nio.FloatArrayBuffer extends java.nio.FloatBuffer

----------------FIELDS----------------

protected final float[] backingArray

protected final int offset
----------------METHODS----------------

 void <init>(
int)

 void <init>(
int
float[]
int)

 void <init>(
float[])

public final float get()

public final float get(
int)

public final java.nio.FloatBuffer get(
float[]
int
int)

public final boolean isDirect()

public final java.nio.ByteOrder order()

________________CLASS________________


final class java.nio.FloatToByteBufferAdapter extends java.nio.FloatBuffer implements org.apache.harmony.nio.internal.DirectBuffer

----------------FIELDS----------------

static final boolean $assertionsDisabled

private final java.nio.ByteBuffer byteBuffer
----------------METHODS----------------

static void <clinit>()

 void <init>(
java.nio.ByteBuffer)

static java.nio.FloatBuffer wrap(
java.nio.ByteBuffer)

public void addressValidityCheck()

public java.nio.FloatBuffer asReadOnlyBuffer()

public java.nio.FloatBuffer compact()

public java.nio.FloatBuffer duplicate()

public void free()

public float get()

public float get(
int)

public org.apache.harmony.luni.platform.PlatformAddress getBaseAddress()

public int getByteCapacity()

public org.apache.harmony.luni.platform.PlatformAddress getEffectiveAddress()

public boolean isAddressValid()

public boolean isDirect()

public boolean isReadOnly()

public java.nio.ByteOrder order()

protected float[] protectedArray()

protected int protectedArrayOffset()

protected boolean protectedHasArray()

public java.nio.FloatBuffer put(
float)

public java.nio.FloatBuffer put(
int
float)

public java.nio.FloatBuffer slice()

________________CLASS________________


abstract class java.nio.HeapByteBuffer extends java.nio.BaseByteBuffer

----------------FIELDS----------------

protected final byte[] backingArray

protected final int offset
----------------METHODS----------------

 void <init>(
int)

 void <init>(
byte[])

 void <init>(
byte[]
int
int)

public final byte get()

public final byte get(
int)

public final java.nio.ByteBuffer get(
byte[]
int
int)

public final double getDouble()

public final double getDouble(
int)

public final float getFloat()

public final float getFloat(
int)

public final int getInt()

public final int getInt(
int)

public final long getLong()

public final long getLong(
int)

public final short getShort()

public final short getShort(
int)

public final boolean isDirect()

protected final int loadInt(
int)

protected final long loadLong(
int)

protected final short loadShort(
int)

protected final void store(
int
int)

protected final void store(
int
long)

protected final void store(
int
short)

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/nio/Buffer;Ljava/lang/Comparable<Ljava/nio/IntBuffer;>; )
public abstract class java.nio.IntBuffer extends java.nio.Buffer implements java.lang.Comparable

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
int)

public static java.nio.IntBuffer allocate(
int)

public static java.nio.IntBuffer wrap(
int[])

public static java.nio.IntBuffer wrap(
int[]
int
int)

 java.lang.Object _array()

 int _arrayOffset()

public final int[] array()

public final int arrayOffset()

public abstract java.nio.IntBuffer asReadOnlyBuffer()

public abstract java.nio.IntBuffer compact()

public volatile int compareTo(
java.lang.Object)

public int compareTo(
java.nio.IntBuffer)

public abstract java.nio.IntBuffer duplicate()

public boolean equals(
java.lang.Object)

public abstract int get()

public abstract int get(
int)

public java.nio.IntBuffer get(
int[])

public java.nio.IntBuffer get(
int[]
int
int)

public final boolean hasArray()

public int hashCode()

public abstract boolean isDirect()

public abstract java.nio.ByteOrder order()

abstract int[] protectedArray()

abstract int protectedArrayOffset()

abstract boolean protectedHasArray()

public abstract java.nio.IntBuffer put(
int)

public abstract java.nio.IntBuffer put(
int
int)

public java.nio.IntBuffer put(
java.nio.IntBuffer)

public final java.nio.IntBuffer put(
int[])

public java.nio.IntBuffer put(
int[]
int
int)

public abstract java.nio.IntBuffer slice()

public java.lang.String toString()

________________CLASS________________


abstract class java.nio.IntArrayBuffer extends java.nio.IntBuffer

----------------FIELDS----------------

protected final int[] backingArray

protected final int offset
----------------METHODS----------------

 void <init>(
int)

 void <init>(
int
int[]
int)

 void <init>(
int[])

public final int get()

public final int get(
int)

public final java.nio.IntBuffer get(
int[]
int
int)

public final boolean isDirect()

public final java.nio.ByteOrder order()

________________CLASS________________


final class java.nio.IntToByteBufferAdapter extends java.nio.IntBuffer implements org.apache.harmony.nio.internal.DirectBuffer

----------------FIELDS----------------

static final boolean $assertionsDisabled

private final java.nio.ByteBuffer byteBuffer
----------------METHODS----------------

static void <clinit>()

 void <init>(
java.nio.ByteBuffer)

static java.nio.IntBuffer wrap(
java.nio.ByteBuffer)

public void addressValidityCheck()

public java.nio.IntBuffer asReadOnlyBuffer()

public java.nio.IntBuffer compact()

public java.nio.IntBuffer duplicate()

public void free()

public int get()

public int get(
int)

public org.apache.harmony.luni.platform.PlatformAddress getBaseAddress()

public int getByteCapacity()

public org.apache.harmony.luni.platform.PlatformAddress getEffectiveAddress()

public boolean isAddressValid()

public boolean isDirect()

public boolean isReadOnly()

public java.nio.ByteOrder order()

protected int[] protectedArray()

protected int protectedArrayOffset()

protected boolean protectedHasArray()

public java.nio.IntBuffer put(
int)

public java.nio.IntBuffer put(
int
int)

public java.nio.IntBuffer put(
int[]
int
int)

public java.nio.IntBuffer slice()

________________CLASS________________


public class java.nio.InvalidMarkException extends java.lang.IllegalStateException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/nio/Buffer;Ljava/lang/Comparable<Ljava/nio/LongBuffer;>; )
public abstract class java.nio.LongBuffer extends java.nio.Buffer implements java.lang.Comparable

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
int)

public static java.nio.LongBuffer allocate(
int)

public static java.nio.LongBuffer wrap(
long[])

public static java.nio.LongBuffer wrap(
long[]
int
int)

 java.lang.Object _array()

 int _arrayOffset()

public final long[] array()

public final int arrayOffset()

public abstract java.nio.LongBuffer asReadOnlyBuffer()

public abstract java.nio.LongBuffer compact()

public volatile int compareTo(
java.lang.Object)

public int compareTo(
java.nio.LongBuffer)

public abstract java.nio.LongBuffer duplicate()

public boolean equals(
java.lang.Object)

public abstract long get()

public abstract long get(
int)

public java.nio.LongBuffer get(
long[])

public java.nio.LongBuffer get(
long[]
int
int)

public final boolean hasArray()

public int hashCode()

public abstract boolean isDirect()

public abstract java.nio.ByteOrder order()

abstract long[] protectedArray()

abstract int protectedArrayOffset()

abstract boolean protectedHasArray()

public abstract java.nio.LongBuffer put(
int
long)

public abstract java.nio.LongBuffer put(
long)

public java.nio.LongBuffer put(
java.nio.LongBuffer)

public final java.nio.LongBuffer put(
long[])

public java.nio.LongBuffer put(
long[]
int
int)

public abstract java.nio.LongBuffer slice()

public java.lang.String toString()

________________CLASS________________


abstract class java.nio.LongArrayBuffer extends java.nio.LongBuffer

----------------FIELDS----------------

protected final long[] backingArray

protected final int offset
----------------METHODS----------------

 void <init>(
int)

 void <init>(
int
long[]
int)

 void <init>(
long[])

public final long get()

public final long get(
int)

public final java.nio.LongBuffer get(
long[]
int
int)

public final boolean isDirect()

public final java.nio.ByteOrder order()

________________CLASS________________


final class java.nio.LongToByteBufferAdapter extends java.nio.LongBuffer implements org.apache.harmony.nio.internal.DirectBuffer

----------------FIELDS----------------

static final boolean $assertionsDisabled

private final java.nio.ByteBuffer byteBuffer
----------------METHODS----------------

static void <clinit>()

 void <init>(
java.nio.ByteBuffer)

static java.nio.LongBuffer wrap(
java.nio.ByteBuffer)

public void addressValidityCheck()

public java.nio.LongBuffer asReadOnlyBuffer()

public java.nio.LongBuffer compact()

public java.nio.LongBuffer duplicate()

public void free()

public long get()

public long get(
int)

public org.apache.harmony.luni.platform.PlatformAddress getBaseAddress()

public int getByteCapacity()

public org.apache.harmony.luni.platform.PlatformAddress getEffectiveAddress()

public boolean isAddressValid()

public boolean isDirect()

public boolean isReadOnly()

public java.nio.ByteOrder order()

protected long[] protectedArray()

protected int protectedArrayOffset()

protected boolean protectedHasArray()

public java.nio.LongBuffer put(
int
long)

public java.nio.LongBuffer put(
long)

public java.nio.LongBuffer slice()

________________CLASS________________


public abstract class java.nio.MappedByteBuffer extends java.nio.ByteBuffer

----------------FIELDS----------------

private int mapMode

final java.nio.DirectByteBuffer wrapped
----------------METHODS----------------

 void <init>(
java.nio.ByteBuffer)

 void <init>(
org.apache.harmony.luni.platform.PlatformAddress
int
int
int)

public final java.nio.MappedByteBuffer force()

public final boolean isLoaded()

public final java.nio.MappedByteBuffer load()

________________CLASS________________


 class java.nio.MappedByteBufferAdapter extends java.nio.MappedByteBuffer implements org.apache.harmony.nio.internal.DirectBuffer

----------------FIELDS----------------

private static final int CHAR_SIZE

private static final int DOUBLE_SIZE

private static final int FLOAT_SIZE

private static final int INTEGER_SIZE

private static final int LONG_SIZE

private static final int SHORT_SIZE
----------------METHODS----------------

public void <init>(
java.nio.ByteBuffer)

public void <init>(
org.apache.harmony.luni.platform.PlatformAddress
int
int
int)

public void addressValidityCheck()

public java.nio.CharBuffer asCharBuffer()

public java.nio.DoubleBuffer asDoubleBuffer()

public java.nio.FloatBuffer asFloatBuffer()

public java.nio.IntBuffer asIntBuffer()

public java.nio.LongBuffer asLongBuffer()

public java.nio.ByteBuffer asReadOnlyBuffer()

public java.nio.ShortBuffer asShortBuffer()

public java.nio.ByteBuffer compact()

public java.nio.ByteBuffer duplicate()

public void free()

public byte get()

public byte get(
int)

public org.apache.harmony.luni.platform.PlatformAddress getBaseAddress()

public int getByteCapacity()

public char getChar()

public char getChar(
int)

public double getDouble()

public double getDouble(
int)

public org.apache.harmony.luni.platform.PlatformAddress getEffectiveAddress()

public float getFloat()

public float getFloat(
int)

public int getInt()

public int getInt(
int)

public long getLong()

public long getLong(
int)

public short getShort()

public short getShort(
int)

public boolean isAddressValid()

public boolean isDirect()

public boolean isReadOnly()

 java.nio.ByteBuffer orderImpl(
java.nio.ByteOrder)

 byte[] protectedArray()

 int protectedArrayOffset()

 boolean protectedHasArray()

public java.nio.ByteBuffer put(
byte)

public java.nio.ByteBuffer put(
int
byte)

public java.nio.ByteBuffer put(
byte[]
int
int)

public java.nio.ByteBuffer putChar(
char)

public java.nio.ByteBuffer putChar(
int
char)

public java.nio.ByteBuffer putDouble(
double)

public java.nio.ByteBuffer putDouble(
int
double)

public java.nio.ByteBuffer putFloat(
float)

public java.nio.ByteBuffer putFloat(
int
float)

public java.nio.ByteBuffer putInt(
int)

public java.nio.ByteBuffer putInt(
int
int)

public java.nio.ByteBuffer putLong(
int
long)

public java.nio.ByteBuffer putLong(
long)

public java.nio.ByteBuffer putShort(
int
short)

public java.nio.ByteBuffer putShort(
short)

public java.nio.ByteBuffer slice()

________________CLASS________________


 class java.nio.NIOAccess extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

static java.lang.Object getBaseArray(
java.nio.Buffer)

static int getBaseArrayOffset(
java.nio.Buffer)

static long getBasePointer(
java.nio.Buffer)

static int getRemainingBytes(
java.nio.Buffer)

________________CLASS________________


public class java.nio.ReadOnlyBufferException extends java.lang.UnsupportedOperationException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

________________CLASS________________


final class java.nio.ReadOnlyCharArrayBuffer extends java.nio.CharArrayBuffer

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
int
char[]
int)

static java.nio.ReadOnlyCharArrayBuffer copy(
java.nio.CharArrayBuffer
int)

public java.nio.CharBuffer asReadOnlyBuffer()

public java.nio.CharBuffer compact()

public java.nio.CharBuffer duplicate()

public boolean isReadOnly()

protected char[] protectedArray()

protected int protectedArrayOffset()

protected boolean protectedHasArray()

public java.nio.CharBuffer put(
char)

public java.nio.CharBuffer put(
int
char)

public java.nio.CharBuffer put(
java.lang.String
int
int)

public final java.nio.CharBuffer put(
java.nio.CharBuffer)

public final java.nio.CharBuffer put(
char[]
int
int)

public java.nio.CharBuffer slice()

________________CLASS________________


final class java.nio.ReadOnlyDirectByteBuffer extends java.nio.DirectByteBuffer

----------------FIELDS----------------
----------------METHODS----------------

protected void <init>(
java.nio.DirectByteBuffer$SafeAddress
int
int)

protected void <init>(
org.apache.harmony.luni.platform.PlatformAddress
int
int)

static java.nio.ReadOnlyDirectByteBuffer copy(
java.nio.DirectByteBuffer
int)

public java.nio.ByteBuffer asReadOnlyBuffer()

public java.nio.ByteBuffer compact()

public java.nio.ByteBuffer duplicate()

public boolean isReadOnly()

public java.nio.ByteBuffer put(
byte)

public java.nio.ByteBuffer put(
int
byte)

public java.nio.ByteBuffer put(
java.nio.ByteBuffer)

public java.nio.ByteBuffer put(
byte[]
int
int)

public java.nio.ByteBuffer putDouble(
double)

public java.nio.ByteBuffer putDouble(
int
double)

public java.nio.ByteBuffer putFloat(
float)

public java.nio.ByteBuffer putFloat(
int
float)

public java.nio.ByteBuffer putInt(
int)

public java.nio.ByteBuffer putInt(
int
int)

public java.nio.ByteBuffer putLong(
int
long)

public java.nio.ByteBuffer putLong(
long)

public java.nio.ByteBuffer putShort(
int
short)

public java.nio.ByteBuffer putShort(
short)

public java.nio.ByteBuffer slice()

________________CLASS________________


final class java.nio.ReadOnlyDoubleArrayBuffer extends java.nio.DoubleArrayBuffer

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
int
double[]
int)

static java.nio.ReadOnlyDoubleArrayBuffer copy(
java.nio.DoubleArrayBuffer
int)

public java.nio.DoubleBuffer asReadOnlyBuffer()

public java.nio.DoubleBuffer compact()

public java.nio.DoubleBuffer duplicate()

public boolean isReadOnly()

protected double[] protectedArray()

protected int protectedArrayOffset()

protected boolean protectedHasArray()

public java.nio.DoubleBuffer put(
double)

public java.nio.DoubleBuffer put(
int
double)

public final java.nio.DoubleBuffer put(
java.nio.DoubleBuffer)

public final java.nio.DoubleBuffer put(
double[]
int
int)

public java.nio.DoubleBuffer slice()

________________CLASS________________


final class java.nio.ReadOnlyFloatArrayBuffer extends java.nio.FloatArrayBuffer

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
int
float[]
int)

static java.nio.ReadOnlyFloatArrayBuffer copy(
java.nio.FloatArrayBuffer
int)

public java.nio.FloatBuffer asReadOnlyBuffer()

public java.nio.FloatBuffer compact()

public java.nio.FloatBuffer duplicate()

public boolean isReadOnly()

protected float[] protectedArray()

protected int protectedArrayOffset()

protected boolean protectedHasArray()

public java.nio.FloatBuffer put(
float)

public java.nio.FloatBuffer put(
int
float)

public java.nio.FloatBuffer put(
java.nio.FloatBuffer)

public final java.nio.FloatBuffer put(
float[]
int
int)

public java.nio.FloatBuffer slice()

________________CLASS________________


final class java.nio.ReadOnlyHeapByteBuffer extends java.nio.HeapByteBuffer

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
byte[]
int
int)

static java.nio.ReadOnlyHeapByteBuffer copy(
java.nio.HeapByteBuffer
int)

public java.nio.ByteBuffer asReadOnlyBuffer()

public java.nio.ByteBuffer compact()

public java.nio.ByteBuffer duplicate()

public boolean isReadOnly()

protected byte[] protectedArray()

protected int protectedArrayOffset()

protected boolean protectedHasArray()

public java.nio.ByteBuffer put(
byte)

public java.nio.ByteBuffer put(
int
byte)

public java.nio.ByteBuffer put(
java.nio.ByteBuffer)

public java.nio.ByteBuffer put(
byte[]
int
int)

public java.nio.ByteBuffer putDouble(
double)

public java.nio.ByteBuffer putDouble(
int
double)

public java.nio.ByteBuffer putFloat(
float)

public java.nio.ByteBuffer putFloat(
int
float)

public java.nio.ByteBuffer putInt(
int)

public java.nio.ByteBuffer putInt(
int
int)

public java.nio.ByteBuffer putLong(
int
long)

public java.nio.ByteBuffer putLong(
long)

public java.nio.ByteBuffer putShort(
int
short)

public java.nio.ByteBuffer putShort(
short)

public java.nio.ByteBuffer slice()

________________CLASS________________


final class java.nio.ReadOnlyIntArrayBuffer extends java.nio.IntArrayBuffer

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
int
int[]
int)

static java.nio.ReadOnlyIntArrayBuffer copy(
java.nio.IntArrayBuffer
int)

public java.nio.IntBuffer asReadOnlyBuffer()

public java.nio.IntBuffer compact()

public java.nio.IntBuffer duplicate()

public boolean isReadOnly()

protected int[] protectedArray()

protected int protectedArrayOffset()

protected boolean protectedHasArray()

public java.nio.IntBuffer put(
int)

public java.nio.IntBuffer put(
int
int)

public java.nio.IntBuffer put(
java.nio.IntBuffer)

public final java.nio.IntBuffer put(
int[]
int
int)

public java.nio.IntBuffer slice()

________________CLASS________________


final class java.nio.ReadOnlyLongArrayBuffer extends java.nio.LongArrayBuffer

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
int
long[]
int)

static java.nio.ReadOnlyLongArrayBuffer copy(
java.nio.LongArrayBuffer
int)

public java.nio.LongBuffer asReadOnlyBuffer()

public java.nio.LongBuffer compact()

public java.nio.LongBuffer duplicate()

public boolean isReadOnly()

protected long[] protectedArray()

protected int protectedArrayOffset()

protected boolean protectedHasArray()

public java.nio.LongBuffer put(
int
long)

public java.nio.LongBuffer put(
long)

public java.nio.LongBuffer put(
java.nio.LongBuffer)

public final java.nio.LongBuffer put(
long[]
int
int)

public java.nio.LongBuffer slice()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/nio/Buffer;Ljava/lang/Comparable<Ljava/nio/ShortBuffer;>; )
public abstract class java.nio.ShortBuffer extends java.nio.Buffer implements java.lang.Comparable

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
int)

public static java.nio.ShortBuffer allocate(
int)

public static java.nio.ShortBuffer wrap(
short[])

public static java.nio.ShortBuffer wrap(
short[]
int
int)

 java.lang.Object _array()

 int _arrayOffset()

public final short[] array()

public final int arrayOffset()

public abstract java.nio.ShortBuffer asReadOnlyBuffer()

public abstract java.nio.ShortBuffer compact()

public volatile int compareTo(
java.lang.Object)

public int compareTo(
java.nio.ShortBuffer)

public abstract java.nio.ShortBuffer duplicate()

public boolean equals(
java.lang.Object)

public java.nio.ShortBuffer get(
short[])

public java.nio.ShortBuffer get(
short[]
int
int)

public abstract short get()

public abstract short get(
int)

public final boolean hasArray()

public int hashCode()

public abstract boolean isDirect()

public abstract java.nio.ByteOrder order()

abstract short[] protectedArray()

abstract int protectedArrayOffset()

abstract boolean protectedHasArray()

public abstract java.nio.ShortBuffer put(
int
short)

public java.nio.ShortBuffer put(
java.nio.ShortBuffer)

public abstract java.nio.ShortBuffer put(
short)

public final java.nio.ShortBuffer put(
short[])

public java.nio.ShortBuffer put(
short[]
int
int)

public abstract java.nio.ShortBuffer slice()

public java.lang.String toString()

________________CLASS________________


abstract class java.nio.ShortArrayBuffer extends java.nio.ShortBuffer

----------------FIELDS----------------

protected final short[] backingArray

protected final int offset
----------------METHODS----------------

 void <init>(
int)

 void <init>(
int
short[]
int)

 void <init>(
short[])

public final java.nio.ShortBuffer get(
short[]
int
int)

public final short get()

public final short get(
int)

public final boolean isDirect()

public final java.nio.ByteOrder order()

________________CLASS________________


final class java.nio.ReadOnlyShortArrayBuffer extends java.nio.ShortArrayBuffer

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
int
short[]
int)

static java.nio.ReadOnlyShortArrayBuffer copy(
java.nio.ShortArrayBuffer
int)

public java.nio.ShortBuffer asReadOnlyBuffer()

public java.nio.ShortBuffer compact()

public java.nio.ShortBuffer duplicate()

public boolean isReadOnly()

protected short[] protectedArray()

protected int protectedArrayOffset()

protected boolean protectedHasArray()

public java.nio.ShortBuffer put(
int
short)

public java.nio.ShortBuffer put(
java.nio.ShortBuffer)

public java.nio.ShortBuffer put(
short)

public final java.nio.ShortBuffer put(
short[]
int
int)

public java.nio.ShortBuffer slice()

________________CLASS________________


final class java.nio.ReadWriteCharArrayBuffer extends java.nio.CharArrayBuffer

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
int)

 void <init>(
int
char[]
int)

 void <init>(
char[])

static java.nio.ReadWriteCharArrayBuffer copy(
java.nio.CharArrayBuffer
int)

public java.nio.CharBuffer asReadOnlyBuffer()

public java.nio.CharBuffer compact()

public java.nio.CharBuffer duplicate()

public boolean isReadOnly()

protected char[] protectedArray()

protected int protectedArrayOffset()

protected boolean protectedHasArray()

public java.nio.CharBuffer put(
char)

public java.nio.CharBuffer put(
int
char)

public java.nio.CharBuffer put(
char[]
int
int)

public java.nio.CharBuffer slice()

________________CLASS________________


final class java.nio.ReadWriteDirectByteBuffer extends java.nio.DirectByteBuffer

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
int)

 void <init>(
int
int)

 void <init>(
java.nio.DirectByteBuffer$SafeAddress
int
int)

 void <init>(
org.apache.harmony.luni.platform.PlatformAddress
int
int)

static java.nio.ReadWriteDirectByteBuffer copy(
java.nio.DirectByteBuffer
int)

public java.nio.ByteBuffer asReadOnlyBuffer()

public java.nio.ByteBuffer compact()

public java.nio.ByteBuffer duplicate()

 int getAddress()

public boolean isReadOnly()

public java.nio.ByteBuffer put(
byte)

public java.nio.ByteBuffer put(
int
byte)

public java.nio.ByteBuffer put(
byte[]
int
int)

 java.nio.ByteBuffer put(
int[]
int
int)

 java.nio.ByteBuffer put(
short[]
int
int)

public java.nio.ByteBuffer putDouble(
double)

public java.nio.ByteBuffer putDouble(
int
double)

public java.nio.ByteBuffer putFloat(
float)

public java.nio.ByteBuffer putFloat(
int
float)

public java.nio.ByteBuffer putInt(
int)

public java.nio.ByteBuffer putInt(
int
int)

public java.nio.ByteBuffer putLong(
int
long)

public java.nio.ByteBuffer putLong(
long)

public java.nio.ByteBuffer putShort(
int
short)

public java.nio.ByteBuffer putShort(
short)

public java.nio.ByteBuffer slice()

________________CLASS________________


final class java.nio.ReadWriteDoubleArrayBuffer extends java.nio.DoubleArrayBuffer

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
int)

 void <init>(
int
double[]
int)

 void <init>(
double[])

static java.nio.ReadWriteDoubleArrayBuffer copy(
java.nio.DoubleArrayBuffer
int)

public java.nio.DoubleBuffer asReadOnlyBuffer()

public java.nio.DoubleBuffer compact()

public java.nio.DoubleBuffer duplicate()

public boolean isReadOnly()

protected double[] protectedArray()

protected int protectedArrayOffset()

protected boolean protectedHasArray()

public java.nio.DoubleBuffer put(
double)

public java.nio.DoubleBuffer put(
int
double)

public java.nio.DoubleBuffer put(
double[]
int
int)

public java.nio.DoubleBuffer slice()

________________CLASS________________


final class java.nio.ReadWriteFloatArrayBuffer extends java.nio.FloatArrayBuffer

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
int)

 void <init>(
int
float[]
int)

 void <init>(
float[])

static java.nio.ReadWriteFloatArrayBuffer copy(
java.nio.FloatArrayBuffer
int)

public java.nio.FloatBuffer asReadOnlyBuffer()

public java.nio.FloatBuffer compact()

public java.nio.FloatBuffer duplicate()

public boolean isReadOnly()

protected float[] protectedArray()

protected int protectedArrayOffset()

protected boolean protectedHasArray()

public java.nio.FloatBuffer put(
float)

public java.nio.FloatBuffer put(
int
float)

public java.nio.FloatBuffer put(
float[]
int
int)

public java.nio.FloatBuffer slice()

________________CLASS________________


final class java.nio.ReadWriteHeapByteBuffer extends java.nio.HeapByteBuffer

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
int)

 void <init>(
byte[])

 void <init>(
byte[]
int
int)

static java.nio.ReadWriteHeapByteBuffer copy(
java.nio.HeapByteBuffer
int)

public java.nio.ByteBuffer asReadOnlyBuffer()

public java.nio.ByteBuffer compact()

public java.nio.ByteBuffer duplicate()

public boolean isReadOnly()

protected byte[] protectedArray()

protected int protectedArrayOffset()

protected boolean protectedHasArray()

public java.nio.ByteBuffer put(
byte)

public java.nio.ByteBuffer put(
int
byte)

public java.nio.ByteBuffer put(
byte[]
int
int)

public java.nio.ByteBuffer putDouble(
double)

public java.nio.ByteBuffer putDouble(
int
double)

public java.nio.ByteBuffer putFloat(
float)

public java.nio.ByteBuffer putFloat(
int
float)

public java.nio.ByteBuffer putInt(
int)

public java.nio.ByteBuffer putInt(
int
int)

public java.nio.ByteBuffer putLong(
int
long)

public java.nio.ByteBuffer putLong(
long)

public java.nio.ByteBuffer putShort(
int
short)

public java.nio.ByteBuffer putShort(
short)

public java.nio.ByteBuffer slice()

________________CLASS________________


final class java.nio.ReadWriteIntArrayBuffer extends java.nio.IntArrayBuffer

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
int)

 void <init>(
int
int[]
int)

 void <init>(
int[])

static java.nio.ReadWriteIntArrayBuffer copy(
java.nio.IntArrayBuffer
int)

public java.nio.IntBuffer asReadOnlyBuffer()

public java.nio.IntBuffer compact()

public java.nio.IntBuffer duplicate()

public boolean isReadOnly()

protected int[] protectedArray()

protected int protectedArrayOffset()

protected boolean protectedHasArray()

public java.nio.IntBuffer put(
int)

public java.nio.IntBuffer put(
int
int)

public java.nio.IntBuffer put(
int[]
int
int)

public java.nio.IntBuffer slice()

________________CLASS________________


final class java.nio.ReadWriteLongArrayBuffer extends java.nio.LongArrayBuffer

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
int)

 void <init>(
int
long[]
int)

 void <init>(
long[])

static java.nio.ReadWriteLongArrayBuffer copy(
java.nio.LongArrayBuffer
int)

public java.nio.LongBuffer asReadOnlyBuffer()

public java.nio.LongBuffer compact()

public java.nio.LongBuffer duplicate()

public boolean isReadOnly()

protected long[] protectedArray()

protected int protectedArrayOffset()

protected boolean protectedHasArray()

public java.nio.LongBuffer put(
int
long)

public java.nio.LongBuffer put(
long)

public java.nio.LongBuffer put(
long[]
int
int)

public java.nio.LongBuffer slice()

________________CLASS________________


final class java.nio.ReadWriteShortArrayBuffer extends java.nio.ShortArrayBuffer

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
int)

 void <init>(
int
short[]
int)

 void <init>(
short[])

static java.nio.ReadWriteShortArrayBuffer copy(
java.nio.ShortArrayBuffer
int)

public java.nio.ShortBuffer asReadOnlyBuffer()

public java.nio.ShortBuffer compact()

public java.nio.ShortBuffer duplicate()

public boolean isReadOnly()

protected short[] protectedArray()

protected int protectedArrayOffset()

protected boolean protectedHasArray()

public java.nio.ShortBuffer put(
int
short)

public java.nio.ShortBuffer put(
short)

public java.nio.ShortBuffer put(
short[]
int
int)

public java.nio.ShortBuffer slice()

________________CLASS________________


final class java.nio.ShortToByteBufferAdapter extends java.nio.ShortBuffer implements org.apache.harmony.nio.internal.DirectBuffer

----------------FIELDS----------------

static final boolean $assertionsDisabled

private final java.nio.ByteBuffer byteBuffer
----------------METHODS----------------

static void <clinit>()

 void <init>(
java.nio.ByteBuffer)

static java.nio.ShortBuffer wrap(
java.nio.ByteBuffer)

public void addressValidityCheck()

public java.nio.ShortBuffer asReadOnlyBuffer()

public java.nio.ShortBuffer compact()

public java.nio.ShortBuffer duplicate()

public void free()

public short get()

public short get(
int)

public org.apache.harmony.luni.platform.PlatformAddress getBaseAddress()

public int getByteCapacity()

public org.apache.harmony.luni.platform.PlatformAddress getEffectiveAddress()

public boolean isAddressValid()

public boolean isDirect()

public boolean isReadOnly()

public java.nio.ByteOrder order()

protected short[] protectedArray()

protected int protectedArrayOffset()

protected boolean protectedHasArray()

public java.nio.ShortBuffer put(
int
short)

public java.nio.ShortBuffer put(
short)

public java.nio.ShortBuffer put(
short[]
int
int)

public java.nio.ShortBuffer slice()

________________CLASS________________


public class java.nio.channels.AlreadyConnectedException extends java.lang.IllegalStateException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

________________CLASS________________


public class java.nio.channels.ClosedChannelException extends java.io.IOException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

________________CLASS________________


public class java.nio.channels.AsynchronousCloseException extends java.nio.channels.ClosedChannelException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

________________CLASS________________


public abstract interface class java.nio.channels.Channel extends java.lang.Object implements java.io.Closeable

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void close()

public abstract boolean isOpen()

________________CLASS________________


public abstract interface class java.nio.channels.ReadableByteChannel extends java.lang.Object implements java.nio.channels.Channel

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int read(
java.nio.ByteBuffer)

________________CLASS________________


public abstract interface class java.nio.channels.WritableByteChannel extends java.lang.Object implements java.nio.channels.Channel

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int write(
java.nio.ByteBuffer)

________________CLASS________________


public abstract interface class java.nio.channels.ByteChannel extends java.lang.Object implements java.nio.channels.ReadableByteChannel, java.nio.channels.WritableByteChannel

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________


public class java.nio.channels.CancelledKeyException extends java.lang.IllegalStateException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =10 name =ByteChannelReader )
@dalvik.annotation.EnclosingClass (value =Ljava/nio/channels/Channels; )
 class java.nio.channels.Channels$ByteChannelReader extends java.io.Reader

----------------FIELDS----------------

private static final int BUFFER_SIZE

 java.nio.ByteBuffer bytes

 java.nio.CharBuffer chars

 java.nio.charset.CharsetDecoder decoder

private java.io.InputStream inputStream
----------------METHODS----------------

public void <init>(
java.io.InputStream
java.nio.charset.CharsetDecoder
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
char[]
int
int)

public boolean ready()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =10 name =ByteChannelWriter )
@dalvik.annotation.EnclosingClass (value =Ljava/nio/channels/Channels; )
 class java.nio.channels.Channels$ByteChannelWriter extends java.io.Writer

----------------FIELDS----------------

private static final int BUFFER_SIZE

private java.nio.ByteBuffer byteBuf

private java.nio.charset.CharsetEncoder encoder

private java.io.OutputStream outputStream
----------------METHODS----------------

public void <init>(
java.io.OutputStream
java.nio.charset.CharsetEncoder
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void flush()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
java.lang.String
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
char[]
int
int)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =10 name =ChannelInputStream )
@dalvik.annotation.EnclosingClass (value =Ljava/nio/channels/Channels; )
 class java.nio.channels.Channels$ChannelInputStream extends java.io.InputStream

----------------FIELDS----------------

protected java.nio.channels.ReadableByteChannel channel
----------------METHODS----------------

public void <init>(
java.nio.channels.ReadableByteChannel)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()

________________CLASS________________


public abstract interface class java.nio.channels.InterruptibleChannel extends java.lang.Object implements java.nio.channels.Channel

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void close()

________________CLASS________________


public abstract class java.nio.channels.spi.AbstractInterruptibleChannel extends java.lang.Object implements java.nio.channels.Channel, java.nio.channels.InterruptibleChannel

----------------FIELDS----------------

static java.lang.reflect.Method setInterruptAction

private volatile boolean closed

volatile boolean interrupted
----------------METHODS----------------

static void <clinit>()

protected void <init>()

protected final void begin()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final void close()
@dalvik.annotation.Throws (value =Ljava/nio/channels/AsynchronousCloseException; )
protected final void end(
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected abstract void implCloseChannel()

public final boolean isOpen()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =10 name =ReadableByteChannelImpl )
@dalvik.annotation.EnclosingClass (value =Ljava/nio/channels/Channels; )
 class java.nio.channels.Channels$ReadableByteChannelImpl extends java.nio.channels.spi.AbstractInterruptibleChannel implements java.nio.channels.ReadableByteChannel

----------------FIELDS----------------

private java.io.InputStream inputStream
----------------METHODS----------------

 void <init>(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void implCloseChannel()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
java.nio.ByteBuffer)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =10 name =ReadableByteChannelInputStream )
@dalvik.annotation.EnclosingClass (value =Ljava/nio/channels/Channels; )
 class java.nio.channels.Channels$ReadableByteChannelInputStream extends java.nio.channels.Channels$ChannelInputStream

----------------FIELDS----------------
----------------METHODS----------------

public void <init>(
java.nio.channels.ReadableByteChannel)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[]
int
int)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/nio/channels/Channels; )
@dalvik.annotation.InnerClass (accessFlags =10 name =ReaderInputStream )
 class java.nio.channels.Channels$ReaderInputStream extends java.nio.channels.Channels$ChannelInputStream

----------------FIELDS----------------
----------------METHODS----------------

public void <init>(
java.nio.channels.ReadableByteChannel)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[]
int
int)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =10 name =WritableByteChannelImpl )
@dalvik.annotation.EnclosingClass (value =Ljava/nio/channels/Channels; )
 class java.nio.channels.Channels$WritableByteChannelImpl extends java.nio.channels.spi.AbstractInterruptibleChannel implements java.nio.channels.WritableByteChannel

----------------FIELDS----------------

private java.io.OutputStream outputStream
----------------METHODS----------------

 void <init>(
java.io.OutputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void implCloseChannel()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int write(
java.nio.ByteBuffer)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =10 name =WritableByteChannelOutputStream )
@dalvik.annotation.EnclosingClass (value =Ljava/nio/channels/Channels; )
 class java.nio.channels.Channels$WritableByteChannelOutputStream extends java.io.OutputStream

----------------FIELDS----------------

private java.nio.channels.WritableByteChannel channel
----------------METHODS----------------

public void <init>(
java.nio.channels.WritableByteChannel)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
byte[]
int
int)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/nio/channels/Channels$ByteChannelWriter;Ljava/nio/channels/Channels$ByteChannelReader;Ljava/nio/channels/Channels$WritableByteChannelImpl;Ljava/nio/channels/Channels$ReadableByteChannelImpl;Ljava/nio/channels/Channels$WritableByteChannelOutputStream;Ljava/nio/channels/Channels$ReaderInputStream;Ljava/nio/channels/Channels$ReadableByteChannelInputStream;Ljava/nio/channels/Channels$ChannelInputStream; )
public final class java.nio.channels.Channels extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

private void <init>()

public static java.nio.channels.ReadableByteChannel newChannel(
java.io.InputStream)

public static java.nio.channels.WritableByteChannel newChannel(
java.io.OutputStream)

public static java.io.InputStream newInputStream(
java.nio.channels.ReadableByteChannel)

public static java.io.OutputStream newOutputStream(
java.nio.channels.WritableByteChannel)

public static java.io.Reader newReader(
java.nio.channels.ReadableByteChannel
java.lang.String)

public static java.io.Reader newReader(
java.nio.channels.ReadableByteChannel
java.nio.charset.CharsetDecoder
int)

public static java.io.Writer newWriter(
java.nio.channels.WritableByteChannel
java.lang.String)

public static java.io.Writer newWriter(
java.nio.channels.WritableByteChannel
java.nio.charset.CharsetEncoder
int)

static java.nio.ByteBuffer wrapByteBuffer(
byte[]
int
int)

________________CLASS________________


public class java.nio.channels.ClosedByInterruptException extends java.nio.channels.AsynchronousCloseException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

________________CLASS________________


public class java.nio.channels.ClosedSelectorException extends java.lang.IllegalStateException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

________________CLASS________________


public class java.nio.channels.ConnectionPendingException extends java.lang.IllegalStateException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

________________CLASS________________


public abstract class java.nio.channels.SelectableChannel extends java.nio.channels.spi.AbstractInterruptibleChannel implements java.nio.channels.Channel

----------------FIELDS----------------
----------------METHODS----------------

protected void <init>()

public abstract java.lang.Object blockingLock()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract java.nio.channels.SelectableChannel configureBlocking(
boolean)

public abstract boolean isBlocking()

public abstract boolean isRegistered()

public abstract java.nio.channels.SelectionKey keyFor(
java.nio.channels.Selector)

public abstract java.nio.channels.spi.SelectorProvider provider()
@dalvik.annotation.Throws (value =Ljava/nio/channels/ClosedChannelException; )
public final java.nio.channels.SelectionKey register(
java.nio.channels.Selector
int)
@dalvik.annotation.Throws (value =Ljava/nio/channels/ClosedChannelException; )
public abstract java.nio.channels.SelectionKey register(
java.nio.channels.Selector
int
java.lang.Object)

public abstract int validOps()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/nio/channels/spi/AbstractSelectableChannel$1;Ljava/nio/channels/spi/AbstractSelectableChannel$BlockingLock; )
public abstract class java.nio.channels.spi.AbstractSelectableChannel extends java.nio.channels.SelectableChannel

----------------FIELDS----------------

private final java.lang.Object blockingLock

 boolean isBlocking
@dalvik.annotation.Signature (value =Ljava/util/List<Ljava/nio/channels/SelectionKey;>; )
private java.util.List keyList

private final java.nio.channels.spi.SelectorProvider provider
----------------METHODS----------------

protected void <init>(
java.nio.channels.spi.SelectorProvider)

public final java.lang.Object blockingLock()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final java.nio.channels.SelectableChannel configureBlocking(
boolean)

 void deregister(
java.nio.channels.SelectionKey)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected final void implCloseChannel()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected abstract void implCloseSelectableChannel()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected abstract void implConfigureBlocking(
boolean)

public final boolean isBlocking()

public final boolean isRegistered()

public final java.nio.channels.SelectionKey keyFor(
java.nio.channels.Selector)

public final java.nio.channels.spi.SelectorProvider provider()
@dalvik.annotation.Throws (value =Ljava/nio/channels/ClosedChannelException; )
public final java.nio.channels.SelectionKey register(
java.nio.channels.Selector
int
java.lang.Object)

________________CLASS________________


public abstract interface class java.nio.channels.ScatteringByteChannel extends java.lang.Object implements java.nio.channels.ReadableByteChannel

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract long read(
java.nio.ByteBuffer[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract long read(
java.nio.ByteBuffer[]
int
int)

________________CLASS________________


public abstract interface class java.nio.channels.GatheringByteChannel extends java.lang.Object implements java.nio.channels.WritableByteChannel

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract long write(
java.nio.ByteBuffer[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract long write(
java.nio.ByteBuffer[]
int
int)

________________CLASS________________


public abstract class java.nio.channels.DatagramChannel extends java.nio.channels.spi.AbstractSelectableChannel implements java.nio.channels.ByteChannel, java.nio.channels.ScatteringByteChannel, java.nio.channels.GatheringByteChannel

----------------FIELDS----------------
----------------METHODS----------------

static void <clinit>()

protected void <init>(
java.nio.channels.spi.SelectorProvider)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static java.nio.channels.DatagramChannel open()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract java.nio.channels.DatagramChannel connect(
java.net.SocketAddress)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract java.nio.channels.DatagramChannel disconnect()

public abstract boolean isConnected()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int read(
java.nio.ByteBuffer)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final long read(
java.nio.ByteBuffer[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract long read(
java.nio.ByteBuffer[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract java.net.SocketAddress receive(
java.nio.ByteBuffer)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int send(
java.nio.ByteBuffer
java.net.SocketAddress)

public abstract java.net.DatagramSocket socket()

public final int validOps()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int write(
java.nio.ByteBuffer)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final long write(
java.nio.ByteBuffer[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract long write(
java.nio.ByteBuffer[]
int
int)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/nio/channels/FileChannel; )
@dalvik.annotation.InnerClass (accessFlags =9 name =MapMode )
public class java.nio.channels.FileChannel$MapMode extends java.lang.Object

----------------FIELDS----------------

public static final java.nio.channels.FileChannel$MapMode PRIVATE

public static final java.nio.channels.FileChannel$MapMode READ_ONLY

public static final java.nio.channels.FileChannel$MapMode READ_WRITE

private final java.lang.String displayName
----------------METHODS----------------

static void <clinit>()

private void <init>(
java.lang.String)

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/nio/channels/FileChannel$MapMode; )
public abstract class java.nio.channels.FileChannel extends java.nio.channels.spi.AbstractInterruptibleChannel implements java.nio.channels.GatheringByteChannel, java.nio.channels.ScatteringByteChannel, java.nio.channels.ByteChannel

----------------FIELDS----------------
----------------METHODS----------------

protected void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void force(
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final java.nio.channels.FileLock lock()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract java.nio.channels.FileLock lock(
long
long
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract java.nio.MappedByteBuffer map(
java.nio.channels.FileChannel$MapMode
long
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract long position()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract java.nio.channels.FileChannel position(
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int read(
java.nio.ByteBuffer)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int read(
java.nio.ByteBuffer
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final long read(
java.nio.ByteBuffer[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract long read(
java.nio.ByteBuffer[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract long size()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract long transferFrom(
java.nio.channels.ReadableByteChannel
long
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract long transferTo(
long
long
java.nio.channels.WritableByteChannel)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract java.nio.channels.FileChannel truncate(
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final java.nio.channels.FileLock tryLock()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract java.nio.channels.FileLock tryLock(
long
long
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int write(
java.nio.ByteBuffer)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int write(
java.nio.ByteBuffer
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final long write(
java.nio.ByteBuffer[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract long write(
java.nio.ByteBuffer[]
int
int)

________________CLASS________________


public abstract class java.nio.channels.FileLock extends java.lang.Object

----------------FIELDS----------------

private final java.nio.channels.FileChannel channel

private final long position

private final boolean shared

private final long size
----------------METHODS----------------

protected void <init>(
java.nio.channels.FileChannel
long
long
boolean)

public final java.nio.channels.FileChannel channel()

public final boolean isShared()

public abstract boolean isValid()

public final boolean overlaps(
long
long)

public final long position()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void release()

public final long size()

public final java.lang.String toString()

________________CLASS________________


public class java.nio.channels.FileLockInterruptionException extends java.io.IOException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

________________CLASS________________


public class java.nio.channels.IllegalBlockingModeException extends java.lang.IllegalStateException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

________________CLASS________________


public class java.nio.channels.IllegalSelectorException extends java.lang.IllegalArgumentException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

________________CLASS________________


public class java.nio.channels.NoConnectionPendingException extends java.lang.IllegalStateException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

________________CLASS________________


public class java.nio.channels.NonReadableChannelException extends java.lang.IllegalStateException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

________________CLASS________________


public class java.nio.channels.NonWritableChannelException extends java.lang.IllegalStateException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

________________CLASS________________


public class java.nio.channels.NotYetBoundException extends java.lang.IllegalStateException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

________________CLASS________________


public class java.nio.channels.NotYetConnectedException extends java.lang.IllegalStateException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

________________CLASS________________


public class java.nio.channels.OverlappingFileLockException extends java.lang.IllegalStateException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/nio/channels/Pipe; )
@dalvik.annotation.InnerClass (accessFlags =1033 name =SinkChannel )
public abstract class java.nio.channels.Pipe$SinkChannel extends java.nio.channels.spi.AbstractSelectableChannel implements java.nio.channels.WritableByteChannel, java.nio.channels.GatheringByteChannel

----------------FIELDS----------------
----------------METHODS----------------

protected void <init>(
java.nio.channels.spi.SelectorProvider)

public final int validOps()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/nio/channels/Pipe; )
@dalvik.annotation.InnerClass (accessFlags =1033 name =SourceChannel )
public abstract class java.nio.channels.Pipe$SourceChannel extends java.nio.channels.spi.AbstractSelectableChannel implements java.nio.channels.ReadableByteChannel, java.nio.channels.ScatteringByteChannel

----------------FIELDS----------------
----------------METHODS----------------

protected void <init>(
java.nio.channels.spi.SelectorProvider)

public final int validOps()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/nio/channels/Pipe$SourceChannel;Ljava/nio/channels/Pipe$SinkChannel; )
public abstract class java.nio.channels.Pipe extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

protected void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static java.nio.channels.Pipe open()

public abstract java.nio.channels.Pipe$SinkChannel sink()

public abstract java.nio.channels.Pipe$SourceChannel source()

________________CLASS________________


public abstract class java.nio.channels.SelectionKey extends java.lang.Object

----------------FIELDS----------------

public static final int OP_ACCEPT

public static final int OP_CONNECT

public static final int OP_READ

public static final int OP_WRITE

private volatile java.lang.Object attachment
----------------METHODS----------------

protected void <init>()

public final java.lang.Object attach(
java.lang.Object)

public final java.lang.Object attachment()

public abstract void cancel()

public abstract java.nio.channels.SelectableChannel channel()

public abstract int interestOps()

public abstract java.nio.channels.SelectionKey interestOps(
int)

public final boolean isAcceptable()

public final boolean isConnectable()

public final boolean isReadable()

public abstract boolean isValid()

public final boolean isWritable()

public abstract int readyOps()

public abstract java.nio.channels.Selector selector()

________________CLASS________________


public abstract class java.nio.channels.Selector extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

protected void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static java.nio.channels.Selector open()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void close()

public abstract boolean isOpen()
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/nio/channels/SelectionKey;>; )
public abstract java.util.Set keys()

public abstract java.nio.channels.spi.SelectorProvider provider()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int select()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int select(
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int selectNow()
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/nio/channels/SelectionKey;>; )
public abstract java.util.Set selectedKeys()

public abstract java.nio.channels.Selector wakeup()

________________CLASS________________


public abstract class java.nio.channels.ServerSocketChannel extends java.nio.channels.spi.AbstractSelectableChannel

----------------FIELDS----------------
----------------METHODS----------------

protected void <init>(
java.nio.channels.spi.SelectorProvider)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static java.nio.channels.ServerSocketChannel open()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract java.nio.channels.SocketChannel accept()

public abstract java.net.ServerSocket socket()

public final int validOps()

________________CLASS________________


public abstract class java.nio.channels.SocketChannel extends java.nio.channels.spi.AbstractSelectableChannel implements java.nio.channels.ByteChannel, java.nio.channels.ScatteringByteChannel, java.nio.channels.GatheringByteChannel

----------------FIELDS----------------
----------------METHODS----------------

static void <clinit>()

protected void <init>(
java.nio.channels.spi.SelectorProvider)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static java.nio.channels.SocketChannel open()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static java.nio.channels.SocketChannel open(
java.net.SocketAddress)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract boolean connect(
java.net.SocketAddress)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract boolean finishConnect()

public abstract boolean isConnected()

public abstract boolean isConnectionPending()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int read(
java.nio.ByteBuffer)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final long read(
java.nio.ByteBuffer[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract long read(
java.nio.ByteBuffer[]
int
int)

public abstract java.net.Socket socket()

public final int validOps()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int write(
java.nio.ByteBuffer)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final long write(
java.nio.ByteBuffer[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract long write(
java.nio.ByteBuffer[]
int
int)

________________CLASS________________


public class java.nio.channels.UnresolvedAddressException extends java.lang.IllegalArgumentException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

________________CLASS________________


public class java.nio.channels.UnsupportedAddressTypeException extends java.lang.IllegalArgumentException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedExceptionAction<Ljava/lang/reflect/Method;>; )
@dalvik.annotation.EnclosingClass (value =Ljava/nio/channels/spi/AbstractInterruptibleChannel; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class java.nio.channels.spi.AbstractInterruptibleChannel$1 extends java.lang.Object implements java.security.PrivilegedExceptionAction

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()
@dalvik.annotation.Throws (value =Ljava/lang/Exception; )
public volatile java.lang.Object run()
@dalvik.annotation.Throws (value =Ljava/lang/Exception; )
public java.lang.reflect.Method run()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
 class java.nio.channels.spi.AbstractInterruptibleChannel$2 extends java.lang.Object implements java.lang.Runnable

----------------FIELDS----------------

final java.nio.channels.spi.AbstractInterruptibleChannel this$0
----------------METHODS----------------

 void <init>(
java.nio.channels.spi.AbstractInterruptibleChannel)

public void run()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/nio/channels/spi/AbstractSelectableChannel; )
@dalvik.annotation.InnerClass (accessFlags =4104 name =null )
 class java.nio.channels.spi.AbstractSelectableChannel$1 extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =2 name =BlockingLock )
@dalvik.annotation.EnclosingClass (value =Ljava/nio/channels/spi/AbstractSelectableChannel; )
 class java.nio.channels.spi.AbstractSelectableChannel$BlockingLock extends java.lang.Object

----------------FIELDS----------------

final java.nio.channels.spi.AbstractSelectableChannel this$0
----------------METHODS----------------

private void <init>(
java.nio.channels.spi.AbstractSelectableChannel)

 void <init>(
java.nio.channels.spi.AbstractSelectableChannel
java.nio.channels.spi.AbstractSelectableChannel$1)

________________CLASS________________


public abstract class java.nio.channels.spi.AbstractSelectionKey extends java.nio.channels.SelectionKey

----------------FIELDS----------------

 boolean isValid
----------------METHODS----------------

protected void <init>()

public final void cancel()

public final boolean isValid()

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
 class java.nio.channels.spi.AbstractSelector$1 extends java.lang.Object implements java.lang.Runnable

----------------FIELDS----------------

final java.nio.channels.spi.AbstractSelector this$0
----------------METHODS----------------

 void <init>(
java.nio.channels.spi.AbstractSelector)

public void run()

________________CLASS________________


public abstract class java.nio.channels.spi.AbstractSelector extends java.nio.channels.Selector

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Set<Ljava/nio/channels/SelectionKey;>; )
private java.util.Set cancelledKeysSet

private volatile boolean isOpen

private java.nio.channels.spi.SelectorProvider provider
----------------METHODS----------------

protected void <init>(
java.nio.channels.spi.SelectorProvider)

protected final void begin()

 void cancel(
java.nio.channels.SelectionKey)
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/nio/channels/SelectionKey;>; )
protected final java.util.Set cancelledKeys()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final void close()

protected final void deregister(
java.nio.channels.spi.AbstractSelectionKey)

protected final void end()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected abstract void implCloseSelector()

public final boolean isOpen()

public final java.nio.channels.spi.SelectorProvider provider()

protected abstract java.nio.channels.SelectionKey register(
java.nio.channels.spi.AbstractSelectableChannel
int
java.lang.Object)

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/nio/channels/spi/SelectorProvider;>; )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class java.nio.channels.spi.SelectorProvider$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public volatile java.lang.Object run()

public java.nio.channels.spi.SelectorProvider run()

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/ClassLoader;>; )
final class java.nio.channels.spi.SelectorProvider$2 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public java.lang.ClassLoader run()

public volatile java.lang.Object run()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/nio/channels/spi/SelectorProvider;>; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
final class java.nio.channels.spi.SelectorProvider$3 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public volatile java.lang.Object run()

public java.nio.channels.spi.SelectorProvider run()

________________CLASS________________


public abstract class java.nio.channels.spi.SelectorProvider extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.String PROVIDER_IN_JAR_RESOURCE

private static final java.lang.String PROVIDER_IN_SYSTEM_PROPERTY

private static final java.lang.String SYMBOL_COMMENT

private static java.nio.channels.Channel inheritedChannel

private static java.nio.channels.spi.SelectorProvider provider
----------------METHODS----------------

static void <clinit>()

protected void <init>()

static java.nio.channels.spi.SelectorProvider loadProviderByJar()

static java.nio.channels.spi.SelectorProvider loadProviderByProperty()

public static java.nio.channels.spi.SelectorProvider provider()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.nio.channels.Channel inheritedChannel()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract java.nio.channels.DatagramChannel openDatagramChannel()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract java.nio.channels.Pipe openPipe()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract java.nio.channels.spi.AbstractSelector openSelector()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract java.nio.channels.ServerSocketChannel openServerSocketChannel()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract java.nio.channels.SocketChannel openSocketChannel()

________________CLASS________________


public class java.nio.charset.CharacterCodingException extends java.io.IOException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Lcom/ibm/icu4jni/charset/CharsetProviderICU;>; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Ljava/nio/charset/Charset; )
final class java.nio.charset.Charset$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public com.ibm.icu4jni.charset.CharsetProviderICU run()

public volatile java.lang.Object run()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/ClassLoader;>; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
final class java.nio.charset.Charset$2 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final java.lang.Thread val$t
----------------METHODS----------------

 void <init>(
java.lang.Thread)

public java.lang.ClassLoader run()

public volatile java.lang.Object run()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/ClassLoader;>; )
@dalvik.annotation.EnclosingMethod (value =null )
final class java.nio.charset.Charset$3 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public java.lang.ClassLoader run()

public volatile java.lang.Object run()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/String;>; )
@dalvik.annotation.EnclosingMethod (value =null )
final class java.nio.charset.Charset$4 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public volatile java.lang.Object run()

public java.lang.String run()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =IgnoreCaseComparator )
@dalvik.annotation.EnclosingClass (value =Ljava/nio/charset/Charset; )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Comparator<Ljava/lang/String;>; )
 class java.nio.charset.Charset$IgnoreCaseComparator extends java.lang.Object implements java.util.Comparator

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Comparator<Ljava/lang/String;>; )
private static java.util.Comparator c
----------------METHODS----------------

static void <clinit>()

private void <init>()
@dalvik.annotation.Signature (value =()Ljava/util/Comparator<Ljava/lang/String;>; )
public static java.util.Comparator getInstance()

public volatile int compare(
java.lang.Object
java.lang.Object)

public int compare(
java.lang.String
java.lang.String)

________________CLASS________________


public class java.nio.charset.CoderMalfunctionError extends java.lang.Error

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>(
java.lang.Exception)

________________CLASS________________


public class java.nio.charset.CoderResult extends java.lang.Object

----------------FIELDS----------------

public static final java.nio.charset.CoderResult OVERFLOW

private static final int TYPE_MALFORMED_INPUT

private static final int TYPE_OVERFLOW

private static final int TYPE_UNDERFLOW

private static final int TYPE_UNMAPPABLE_CHAR

public static final java.nio.charset.CoderResult UNDERFLOW
@dalvik.annotation.Signature (value =Ljava/util/WeakHashMap<Ljava/lang/Integer;Ljava/nio/charset/CoderResult;>; )
private static java.util.WeakHashMap _malformedErrors
@dalvik.annotation.Signature (value =Ljava/util/WeakHashMap<Ljava/lang/Integer;Ljava/nio/charset/CoderResult;>; )
private static java.util.WeakHashMap _unmappableErrors

private final int length

private final int type
----------------METHODS----------------

static void <clinit>()

private void <init>(
int
int)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public static java.nio.charset.CoderResult malformedForLength(
int)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public static java.nio.charset.CoderResult unmappableForLength(
int)

public boolean isError()

public boolean isMalformed()

public boolean isOverflow()

public boolean isUnderflow()

public boolean isUnmappable()
@dalvik.annotation.Throws (value =Ljava/lang/UnsupportedOperationException; )
public int length()
@dalvik.annotation.Throws (value =Ljava/nio/BufferUnderflowException;Ljava/nio/BufferOverflowException;Ljava/nio/charset/UnmappableCharacterException;Ljava/nio/charset/MalformedInputException;Ljava/nio/charset/CharacterCodingException; )
public void throwException()

public java.lang.String toString()

________________CLASS________________


public class java.nio.charset.CodingErrorAction extends java.lang.Object

----------------FIELDS----------------

public static final java.nio.charset.CodingErrorAction IGNORE

public static final java.nio.charset.CodingErrorAction REPLACE

public static final java.nio.charset.CodingErrorAction REPORT

private java.lang.String action
----------------METHODS----------------

static void <clinit>()

private void <init>(
java.lang.String)

public java.lang.String toString()

________________CLASS________________


public class java.nio.charset.IllegalCharsetNameException extends java.lang.IllegalArgumentException

----------------FIELDS----------------

private static final long serialVersionUID

private java.lang.String charsetName
----------------METHODS----------------

public void <init>(
java.lang.String)

public java.lang.String getCharsetName()

________________CLASS________________


public class java.nio.charset.MalformedInputException extends java.nio.charset.CharacterCodingException

----------------FIELDS----------------

private static final long serialVersionUID

private int inputLength
----------------METHODS----------------

public void <init>(
int)

public int getInputLength()

public java.lang.String getMessage()

________________CLASS________________


public class java.nio.charset.UnmappableCharacterException extends java.nio.charset.CharacterCodingException

----------------FIELDS----------------

private static final long serialVersionUID

private int inputLength
----------------METHODS----------------

public void <init>(
int)

public int getInputLength()

public java.lang.String getMessage()

________________CLASS________________


public class java.nio.charset.UnsupportedCharsetException extends java.lang.IllegalArgumentException

----------------FIELDS----------------

private static final long serialVersionUID

private java.lang.String charsetName
----------------METHODS----------------

public void <init>(
java.lang.String)

public java.lang.String getCharsetName()

________________CLASS________________


public final class java.security.AccessControlContext extends java.lang.Object

----------------FIELDS----------------

 java.security.DomainCombiner combiner

 java.security.ProtectionDomain[] context

private java.security.AccessControlContext inherited
----------------METHODS----------------

public void <init>(
java.security.AccessControlContext
java.security.DomainCombiner)

public void <init>(
java.security.ProtectionDomain[])

 void <init>(
java.security.ProtectionDomain[]
java.security.AccessControlContext)

 void <init>(
java.security.ProtectionDomain[]
java.security.DomainCombiner)
@dalvik.annotation.Throws (value =Ljava/security/AccessControlException; )
public void checkPermission(
java.security.Permission)

public boolean equals(
java.lang.Object)

public java.security.DomainCombiner getDomainCombiner()

public int hashCode()

________________CLASS________________


public class java.security.AccessControlException extends java.lang.SecurityException

----------------FIELDS----------------

private static final long serialVersionUID

private java.security.Permission perm
----------------METHODS----------------

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.security.Permission)

public java.security.Permission getPermission()

________________CLASS________________


public final class java.security.AccessController extends java.lang.Object

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/WeakHashMap<Ljava/lang/Thread;Ljava/util/ArrayList<Ljava/security/AccessControlContext;>;>; )
private static final java.util.WeakHashMap contexts
----------------METHODS----------------

static void <clinit>()

private void <init>()
@dalvik.annotation.Throws (value =Ljava/security/AccessControlException; )
public static void checkPermission(
java.security.Permission)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/security/PrivilegedAction<TT;>;)TT; )
public static java.lang.Object doPrivileged(
java.security.PrivilegedAction)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/security/PrivilegedAction<TT;>;Ljava/security/AccessControlContext;)TT; )
public static java.lang.Object doPrivileged(
java.security.PrivilegedAction
java.security.AccessControlContext)
@dalvik.annotation.Throws (value =Ljava/security/PrivilegedActionException; )
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/security/PrivilegedExceptionAction<TT;>;)TT; )
public static java.lang.Object doPrivileged(
java.security.PrivilegedExceptionAction)
@dalvik.annotation.Throws (value =Ljava/security/PrivilegedActionException; )
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/security/PrivilegedExceptionAction<TT;>;Ljava/security/AccessControlContext;)TT; )
public static java.lang.Object doPrivileged(
java.security.PrivilegedExceptionAction
java.security.AccessControlContext)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/security/PrivilegedAction<TT;>;Ljava/security/AccessControlContext;)TT; )
private static java.lang.Object doPrivilegedImpl(
java.security.PrivilegedAction
java.security.AccessControlContext)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/security/PrivilegedExceptionAction<TT;>;Ljava/security/AccessControlContext;)TT; )
@dalvik.annotation.Throws (value =Ljava/security/PrivilegedActionException; )
private static java.lang.Object doPrivilegedImpl(
java.security.PrivilegedExceptionAction
java.security.AccessControlContext)

public static java.security.AccessControlContext getContext()

private static native java.security.ProtectionDomain[] getStackDomains()

________________CLASS________________


public class java.security.AlgorithmParameterGenerator extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.String SERVICE

private static org.apache.harmony.security.fortress.Engine engine

private static java.security.SecureRandom randm

private final java.lang.String algorithm

private final java.security.Provider provider

private final java.security.AlgorithmParameterGeneratorSpi spiImpl
----------------METHODS----------------

static void <clinit>()

protected void <init>(
java.security.AlgorithmParameterGeneratorSpi
java.security.Provider
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public static java.security.AlgorithmParameterGenerator getInstance(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/NoSuchProviderException; )
public static java.security.AlgorithmParameterGenerator getInstance(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public static java.security.AlgorithmParameterGenerator getInstance(
java.lang.String
java.security.Provider)

public final java.security.AlgorithmParameters generateParameters()

public final java.lang.String getAlgorithm()

public final java.security.Provider getProvider()

public final void init(
int)

public final void init(
int
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/InvalidAlgorithmParameterException; )
public final void init(
java.security.spec.AlgorithmParameterSpec)
@dalvik.annotation.Throws (value =Ljava/security/InvalidAlgorithmParameterException; )
public final void init(
java.security.spec.AlgorithmParameterSpec
java.security.SecureRandom)

________________CLASS________________


public abstract class java.security.AlgorithmParameterGeneratorSpi extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

protected abstract java.security.AlgorithmParameters engineGenerateParameters()

protected abstract void engineInit(
int
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/InvalidAlgorithmParameterException; )
protected abstract void engineInit(
java.security.spec.AlgorithmParameterSpec
java.security.SecureRandom)

________________CLASS________________


public class java.security.AlgorithmParameters extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.String SEVICE

private static org.apache.harmony.security.fortress.Engine engine

private java.lang.String algorithm

private boolean initialized

private java.security.Provider provider

private java.security.AlgorithmParametersSpi spiImpl
----------------METHODS----------------

static void <clinit>()

protected void <init>(
java.security.AlgorithmParametersSpi
java.security.Provider
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public static java.security.AlgorithmParameters getInstance(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/NoSuchProviderException; )
public static java.security.AlgorithmParameters getInstance(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public static java.security.AlgorithmParameters getInstance(
java.lang.String
java.security.Provider)

public final java.lang.String getAlgorithm()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final byte[] getEncoded()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final byte[] getEncoded(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidParameterSpecException; )
@dalvik.annotation.Signature (value =<T::Ljava/security/spec/AlgorithmParameterSpec;>(Ljava/lang/Class<TT;>;)TT; )
public final java.security.spec.AlgorithmParameterSpec getParameterSpec(
java.lang.Class)

public final java.security.Provider getProvider()
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidParameterSpecException; )
public final void init(
java.security.spec.AlgorithmParameterSpec)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final void init(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final void init(
byte[]
java.lang.String)

public final java.lang.String toString()

________________CLASS________________


public abstract class java.security.AlgorithmParametersSpi extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected abstract byte[] engineGetEncoded()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected abstract byte[] engineGetEncoded(
java.lang.String)
@dalvik.annotation.Signature (value =<T::Ljava/security/spec/AlgorithmParameterSpec;>(Ljava/lang/Class<TT;>;)TT; )
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidParameterSpecException; )
protected abstract java.security.spec.AlgorithmParameterSpec engineGetParameterSpec(
java.lang.Class)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidParameterSpecException; )
protected abstract void engineInit(
java.security.spec.AlgorithmParameterSpec)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected abstract void engineInit(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected abstract void engineInit(
byte[]
java.lang.String)

protected abstract java.lang.String engineToString()

________________CLASS________________


public final class java.security.AllPermission extends java.security.Permission

----------------FIELDS----------------

private static final java.lang.String ALL_ACTIONS

private static final java.lang.String ALL_PERMISSIONS

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String
java.lang.String)

public boolean equals(
java.lang.Object)

public java.lang.String getActions()

public int hashCode()

public boolean implies(
java.security.Permission)

public java.security.PermissionCollection newPermissionCollection()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/security/AllPermissionCollection; )
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Enumeration<TE;>; )
@dalvik.annotation.InnerClass (accessFlags =24 name =SingletonEnumeration )
final class java.security.AllPermissionCollection$SingletonEnumeration extends java.lang.Object implements java.util.Enumeration

----------------FIELDS----------------
@dalvik.annotation.Signature (value =TE; )
private java.lang.Object element
----------------METHODS----------------
@dalvik.annotation.Signature (value =(TE;)V )
public void <init>(
java.lang.Object)

public boolean hasMoreElements()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object nextElement()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/security/AllPermissionCollection$SingletonEnumeration; )
final class java.security.AllPermissionCollection extends java.security.PermissionCollection

----------------FIELDS----------------

private static final java.io.ObjectStreamField[] serialPersistentFields

private static final long serialVersionUID

private transient java.security.Permission all
----------------METHODS----------------

static void <clinit>()

 void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

public void add(
java.security.Permission)
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<Ljava/security/Permission;>; )
public java.util.Enumeration elements()

public boolean implies(
java.security.Permission)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/security/Provider$Service; )
public abstract class java.security.Provider extends java.util.Properties

----------------FIELDS----------------

private static final long serialVersionUID
@dalvik.annotation.Signature (value =Lorg/apache/harmony/luni/util/TwoKeyHashMap<Ljava/lang/String;Ljava/lang/String;Ljava/security/Provider$Service;>; )
private transient org.apache.harmony.luni.util.TwoKeyHashMap aliasTable

private transient java.util.Properties changedProperties

private java.lang.String info

private transient java.lang.String lastAlgorithm

private transient java.lang.String lastServiceName

private transient java.security.Provider$Service lastServicesByType
@dalvik.annotation.Signature (value =Ljava/util/Set<Ljava/security/Provider$Service;>; )
private transient java.util.Set lastServicesSet

private transient java.lang.String lastType

private java.lang.String name
@dalvik.annotation.Signature (value =Lorg/apache/harmony/luni/util/TwoKeyHashMap<Ljava/lang/String;Ljava/lang/String;Ljava/security/Provider$Service;>; )
private transient org.apache.harmony.luni.util.TwoKeyHashMap propertyAliasTable
@dalvik.annotation.Signature (value =Lorg/apache/harmony/luni/util/TwoKeyHashMap<Ljava/lang/String;Ljava/lang/String;Ljava/security/Provider$Service;>; )
private transient org.apache.harmony.luni.util.TwoKeyHashMap propertyServiceTable

private transient int providerNumber

private transient java.security.Provider$Service returnedService
@dalvik.annotation.Signature (value =Lorg/apache/harmony/luni/util/TwoKeyHashMap<Ljava/lang/String;Ljava/lang/String;Ljava/security/Provider$Service;>; )
private transient org.apache.harmony.luni.util.TwoKeyHashMap serviceTable

private double version

private transient java.lang.String versionString
----------------METHODS----------------

protected void <init>(
java.lang.String
double
java.lang.String)

private boolean checkAttribute(
java.lang.String
java.lang.String
java.lang.String)

private java.lang.String getPropertyIgnoreCase(
java.lang.String)
@dalvik.annotation.Signature (value =(Ljava/util/Map<**>;)V )
private void myPutAll(
java.util.Map)

private void putProviderInfo()

private void removeFromPropertyServiceTable(
java.lang.Object)

private void serviceInfoFromProperties(
java.security.Provider$Service)

private void serviceInfoToProperties(
java.security.Provider$Service)

private void servicesChanged()

private void updatePropertyServiceTable()

public void clear()
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/util/Map$Entry<Ljava/lang/Object;Ljava/lang/Object;>;>; )
public java.util.Set entrySet()

public java.lang.String getInfo()

public java.lang.String getName()

 int getProviderNumber()

 java.security.Provider$Service getService(
java.lang.String)

public java.security.Provider$Service getService(
java.lang.String
java.lang.String)
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/security/Provider$Service;>; )
public java.util.Set getServices()

public double getVersion()

 boolean implementsAlg(
java.lang.String
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/lang/Object;>; )
public java.util.Set keySet()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void load(
java.io.InputStream)

public java.lang.Object put(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Map<**>;)V )
public void putAll(
java.util.Map)

protected void putService(
java.security.Provider$Service)

public java.lang.Object remove(
java.lang.Object)

protected void removeService(
java.security.Provider$Service)

 void setProviderNumber(
int)

public java.lang.String toString()
@dalvik.annotation.Signature (value =()Ljava/util/Collection<Ljava/lang/Object;>; )
public java.util.Collection values()

________________CLASS________________


public abstract class java.security.AuthProvider extends java.security.Provider

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

protected void <init>(
java.lang.String
double
java.lang.String)
@dalvik.annotation.Throws (value =Ljavax/security/auth/login/LoginException; )
public abstract void login(
javax.security.auth.Subject
javax.security.auth.callback.CallbackHandler)
@dalvik.annotation.Throws (value =Ljavax/security/auth/login/LoginException; )
public abstract void logout()

public abstract void setCallbackHandler(
javax.security.auth.callback.CallbackHandler)

________________CLASS________________


final class java.security.BasicPermissionCollection extends java.security.PermissionCollection

----------------FIELDS----------------

private static final java.io.ObjectStreamField[] serialPersistentFields

private static final long serialVersionUID

private transient boolean allEnabled
@dalvik.annotation.Signature (value =Ljava/util/Map<Ljava/lang/String;Ljava/security/Permission;>; )
private transient java.util.Map items
@dalvik.annotation.Signature (value =Ljava/lang/Class<+Ljava/security/Permission;>; )
private java.lang.Class permClass
----------------METHODS----------------

static void <clinit>()

 void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

public void add(
java.security.Permission)
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<Ljava/security/Permission;>; )
public java.util.Enumeration elements()

public boolean implies(
java.security.Permission)

________________CLASS________________


public abstract interface class java.security.Certificate extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/security/KeyException;Ljava/io/IOException; )
public abstract void decode(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/security/KeyException;Ljava/io/IOException; )
public abstract void encode(
java.io.OutputStream)

public abstract java.lang.String getFormat()

public abstract java.security.Principal getGuarantor()

public abstract java.security.Principal getPrincipal()

public abstract java.security.PublicKey getPublicKey()

public abstract java.lang.String toString(
boolean)

________________CLASS________________


public final class java.security.CodeSigner extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

private transient int hash

private java.security.cert.CertPath signerCertPath

private java.security.Timestamp timestamp
----------------METHODS----------------

public void <init>(
java.security.cert.CertPath
java.security.Timestamp)

public boolean equals(
java.lang.Object)

public java.security.cert.CertPath getSignerCertPath()

public java.security.Timestamp getTimestamp()

public int hashCode()

public java.lang.String toString()

________________CLASS________________


public class java.security.CodeSource extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

private transient java.security.cert.Certificate[] certs

private transient java.security.cert.CertificateFactory factory

private java.net.URL location

private transient java.security.CodeSigner[] signers

private transient java.net.SocketPermission sp
----------------METHODS----------------

public void <init>(
java.net.URL
java.security.CodeSigner[])

public void <init>(
java.net.URL
java.security.cert.Certificate[])

private java.security.cert.Certificate[] getCertificatesNoClone()
@dalvik.annotation.Signature (value =(Ljava/util/List<+Ljava/security/cert/Certificate;>;)Ljava/security/cert/CertPath; )
private java.security.cert.CertPath makeCertPath(
java.util.List)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

public boolean equals(
java.lang.Object)

public final java.security.cert.Certificate[] getCertificates()

public final java.security.CodeSigner[] getCodeSigners()

public final java.net.URL getLocation()

public int hashCode()

public boolean implies(
java.security.CodeSource)

public java.lang.String toString()

________________CLASS________________


public class java.security.GeneralSecurityException extends java.lang.Exception

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.Throwable)

public void <init>(
java.lang.Throwable)

________________CLASS________________


public class java.security.DigestException extends java.security.GeneralSecurityException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.Throwable)

public void <init>(
java.lang.Throwable)

________________CLASS________________


public class java.security.DigestInputStream extends java.io.FilterInputStream

----------------FIELDS----------------

protected java.security.MessageDigest digest

private boolean isOn
----------------METHODS----------------

public void <init>(
java.io.InputStream
java.security.MessageDigest)

public java.security.MessageDigest getMessageDigest()

public void on(
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[]
int
int)

public void setMessageDigest(
java.security.MessageDigest)

public java.lang.String toString()

________________CLASS________________


public class java.security.DigestOutputStream extends java.io.FilterOutputStream

----------------FIELDS----------------

protected java.security.MessageDigest digest

private boolean isOn
----------------METHODS----------------

public void <init>(
java.io.OutputStream
java.security.MessageDigest)

public java.security.MessageDigest getMessageDigest()

public void on(
boolean)

public void setMessageDigest(
java.security.MessageDigest)

public java.lang.String toString()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
byte[]
int
int)

________________CLASS________________


public abstract interface class java.security.DomainCombiner extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.security.ProtectionDomain[] combine(
java.security.ProtectionDomain[]
java.security.ProtectionDomain[])

________________CLASS________________


public class java.security.GuardedObject extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

private final java.security.Guard guard

private final java.lang.Object object
----------------METHODS----------------

public void <init>(
java.lang.Object
java.security.Guard)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)
@dalvik.annotation.Throws (value =Ljava/lang/SecurityException; )
public java.lang.Object getObject()

________________CLASS________________


public abstract interface class java.security.Principal extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract boolean equals(
java.lang.Object)

public abstract java.lang.String getName()

public abstract int hashCode()

public abstract java.lang.String toString()

________________CLASS________________


public abstract class java.security.Identity extends java.lang.Object implements java.security.Principal, java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID
@dalvik.annotation.Signature (value =Ljava/util/Vector<Ljava/security/Certificate;>; )
private java.util.Vector certificates

private java.lang.String info

private java.lang.String name

private java.security.PublicKey publicKey

private java.security.IdentityScope scope
----------------METHODS----------------

protected void <init>()

public void <init>(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/KeyManagementException; )
public void <init>(
java.lang.String
java.security.IdentityScope)

private static boolean checkKeysEqual(
java.security.PublicKey
java.security.PublicKey)
@dalvik.annotation.Throws (value =Ljava/security/KeyManagementException; )
public void addCertificate(
java.security.Certificate)

public java.security.Certificate[] certificates()

public final boolean equals(
java.lang.Object)

public java.lang.String getInfo()

public final java.lang.String getName()

public java.security.PublicKey getPublicKey()

public final java.security.IdentityScope getScope()

public int hashCode()

protected boolean identityEquals(
java.security.Identity)
@dalvik.annotation.Throws (value =Ljava/security/KeyManagementException; )
public void removeCertificate(
java.security.Certificate)

public void setInfo(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/KeyManagementException; )
public void setPublicKey(
java.security.PublicKey)

public java.lang.String toString()

public java.lang.String toString(
boolean)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/String;>; )
@dalvik.annotation.EnclosingMethod (value =null )
final class java.security.IdentityScope$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public volatile java.lang.Object run()

public java.lang.String run()

________________CLASS________________


public abstract class java.security.IdentityScope extends java.security.Identity

----------------FIELDS----------------

private static final long serialVersionUID

private static java.security.IdentityScope systemScope
----------------METHODS----------------

protected void <init>()

public void <init>(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/KeyManagementException; )
public void <init>(
java.lang.String
java.security.IdentityScope)

public static java.security.IdentityScope getSystemScope()

protected static void setSystemScope(
java.security.IdentityScope)
@dalvik.annotation.Throws (value =Ljava/security/KeyManagementException; )
public abstract void addIdentity(
java.security.Identity)

public abstract java.security.Identity getIdentity(
java.lang.String)

public java.security.Identity getIdentity(
java.security.Principal)

public abstract java.security.Identity getIdentity(
java.security.PublicKey)
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<Ljava/security/Identity;>; )
public abstract java.util.Enumeration identities()
@dalvik.annotation.Throws (value =Ljava/security/KeyManagementException; )
public abstract void removeIdentity(
java.security.Identity)

public abstract int size()

public java.lang.String toString()

________________CLASS________________


public class java.security.InvalidAlgorithmParameterException extends java.security.GeneralSecurityException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.Throwable)

public void <init>(
java.lang.Throwable)

________________CLASS________________


public class java.security.KeyException extends java.security.GeneralSecurityException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.Throwable)

public void <init>(
java.lang.Throwable)

________________CLASS________________


public class java.security.InvalidKeyException extends java.security.KeyException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.Throwable)

public void <init>(
java.lang.Throwable)

________________CLASS________________


public class java.security.InvalidParameterException extends java.lang.IllegalArgumentException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public abstract interface class java.security.Key extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------

public static final long serialVersionUID
----------------METHODS----------------

public abstract java.lang.String getAlgorithm()

public abstract byte[] getEncoded()

public abstract java.lang.String getFormat()

________________CLASS________________


public class java.security.KeyFactory extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.String SERVICE

private static org.apache.harmony.security.fortress.Engine engine

private java.lang.String algorithm

private java.security.Provider provider

private java.security.KeyFactorySpi spiImpl
----------------METHODS----------------

static void <clinit>()

protected void <init>(
java.security.KeyFactorySpi
java.security.Provider
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public static java.security.KeyFactory getInstance(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/NoSuchProviderException; )
public static java.security.KeyFactory getInstance(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public static java.security.KeyFactory getInstance(
java.lang.String
java.security.Provider)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidKeySpecException; )
public final java.security.PrivateKey generatePrivate(
java.security.spec.KeySpec)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidKeySpecException; )
public final java.security.PublicKey generatePublic(
java.security.spec.KeySpec)

public final java.lang.String getAlgorithm()
@dalvik.annotation.Signature (value =<T::Ljava/security/spec/KeySpec;>(Ljava/security/Key;Ljava/lang/Class<TT;>;)TT; )
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidKeySpecException; )
public final java.security.spec.KeySpec getKeySpec(
java.security.Key
java.lang.Class)

public final java.security.Provider getProvider()
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
public final java.security.Key translateKey(
java.security.Key)

________________CLASS________________


public abstract class java.security.KeyFactorySpi extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidKeySpecException; )
protected abstract java.security.PrivateKey engineGeneratePrivate(
java.security.spec.KeySpec)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidKeySpecException; )
protected abstract java.security.PublicKey engineGeneratePublic(
java.security.spec.KeySpec)
@dalvik.annotation.Signature (value =<T::Ljava/security/spec/KeySpec;>(Ljava/security/Key;Ljava/lang/Class<TT;>;)TT; )
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidKeySpecException; )
protected abstract java.security.spec.KeySpec engineGetKeySpec(
java.security.Key
java.lang.Class)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
protected abstract java.security.Key engineTranslateKey(
java.security.Key)

________________CLASS________________


public class java.security.KeyManagementException extends java.security.KeyException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.Throwable)

public void <init>(
java.lang.Throwable)

________________CLASS________________


public final class java.security.KeyPair extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

private final java.security.PrivateKey privateKey

private final java.security.PublicKey publicKey
----------------METHODS----------------

public void <init>(
java.security.PublicKey
java.security.PrivateKey)

public java.security.PrivateKey getPrivate()

public java.security.PublicKey getPublic()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/security/KeyPairGenerator; )
@dalvik.annotation.InnerClass (accessFlags =4104 name =null )
 class java.security.KeyPairGenerator$1 extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________


public abstract class java.security.KeyPairGeneratorSpi extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public abstract java.security.KeyPair generateKeyPair()

public abstract void initialize(
int
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/InvalidAlgorithmParameterException; )
public void initialize(
java.security.spec.AlgorithmParameterSpec
java.security.SecureRandom)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/security/KeyPairGenerator$1;Ljava/security/KeyPairGenerator$KeyPairGeneratorImpl; )
public abstract class java.security.KeyPairGenerator extends java.security.KeyPairGeneratorSpi

----------------FIELDS----------------

private static final java.lang.String SERVICE

private static org.apache.harmony.security.fortress.Engine engine

private static java.security.SecureRandom random

private java.lang.String algorithm

private java.security.Provider provider
----------------METHODS----------------

static void <clinit>()

protected void <init>(
java.lang.String)

static java.security.Provider access$102(
java.security.KeyPairGenerator
java.security.Provider)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public static java.security.KeyPairGenerator getInstance(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/NoSuchProviderException; )
public static java.security.KeyPairGenerator getInstance(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public static java.security.KeyPairGenerator getInstance(
java.lang.String
java.security.Provider)

public final java.security.KeyPair genKeyPair()

public java.security.KeyPair generateKeyPair()

public java.lang.String getAlgorithm()

public final java.security.Provider getProvider()

public void initialize(
int)

public void initialize(
int
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/InvalidAlgorithmParameterException; )
public void initialize(
java.security.spec.AlgorithmParameterSpec)
@dalvik.annotation.Throws (value =Ljava/security/InvalidAlgorithmParameterException; )
public void initialize(
java.security.spec.AlgorithmParameterSpec
java.security.SecureRandom)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/security/KeyPairGenerator; )
@dalvik.annotation.InnerClass (accessFlags =10 name =KeyPairGeneratorImpl )
 class java.security.KeyPairGenerator$KeyPairGeneratorImpl extends java.security.KeyPairGenerator

----------------FIELDS----------------

private java.security.KeyPairGeneratorSpi spiImpl
----------------METHODS----------------

private void <init>(
java.security.KeyPairGeneratorSpi
java.security.Provider
java.lang.String)

 void <init>(
java.security.KeyPairGeneratorSpi
java.security.Provider
java.lang.String
java.security.KeyPairGenerator$1)

public java.security.KeyPair generateKeyPair()

public void initialize(
int
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/InvalidAlgorithmParameterException; )
public void initialize(
java.security.spec.AlgorithmParameterSpec
java.security.SecureRandom)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =4104 name =null )
@dalvik.annotation.EnclosingClass (value =Ljava/security/KeyRep; )
 class java.security.KeyRep$1 extends java.lang.Object

----------------FIELDS----------------

static final int[] $SwitchMap$java$security$KeyRep$Type
----------------METHODS----------------

static void <clinit>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =16409 name =Type )
@dalvik.annotation.Signature (value =Ljava/lang/Enum<Ljava/security/KeyRep$Type;>; )
@dalvik.annotation.EnclosingClass (value =Ljava/security/KeyRep; )
public final class java.security.KeyRep$Type extends java.lang.Enum

----------------FIELDS----------------

private static final java.security.KeyRep$Type[] $VALUES

public static final java.security.KeyRep$Type PRIVATE

public static final java.security.KeyRep$Type PUBLIC

public static final java.security.KeyRep$Type SECRET
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Signature (value =()V )
private void <init>(
java.lang.String
int)

public static java.security.KeyRep$Type valueOf(
java.lang.String)

public static java.security.KeyRep$Type[] values()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/security/KeyRep$1;Ljava/security/KeyRep$Type; )
public class java.security.KeyRep extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

private final java.lang.String algorithm

private byte[] encoded

private final java.lang.String format

private final java.security.KeyRep$Type type
----------------METHODS----------------

public void <init>(
java.security.KeyRep$Type
java.lang.String
java.lang.String
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)
@dalvik.annotation.Throws (value =Ljava/io/ObjectStreamException; )
protected java.lang.Object readResolve()

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/String;>; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class java.security.KeyStore$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public volatile java.lang.Object run()

public java.lang.String run()

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedExceptionAction<Ljava/lang/Object;>; )
 class java.security.KeyStore$Builder$BuilderImpl$1 extends java.lang.Object implements java.security.PrivilegedExceptionAction

----------------FIELDS----------------

final java.security.KeyStore$Builder$BuilderImpl this$0

final java.security.KeyStore val$ks

final char[] val$passwd
----------------METHODS----------------

 void <init>(
java.security.KeyStore$Builder$BuilderImpl
java.security.KeyStore
char[])
@dalvik.annotation.Throws (value =Ljava/lang/Exception; )
public java.lang.Object run()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/security/KeyStore$Builder$TmpLSParameter;Ljava/security/KeyStore$Builder$BuilderImpl; )
@dalvik.annotation.EnclosingClass (value =Ljava/security/KeyStore; )
@dalvik.annotation.InnerClass (accessFlags =1033 name =Builder )
public abstract class java.security.KeyStore$Builder extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

protected void <init>()

public static java.security.KeyStore$Builder newInstance(
java.lang.String
java.security.Provider
java.io.File
java.security.KeyStore$ProtectionParameter)

public static java.security.KeyStore$Builder newInstance(
java.lang.String
java.security.Provider
java.security.KeyStore$ProtectionParameter)

public static java.security.KeyStore$Builder newInstance(
java.security.KeyStore
java.security.KeyStore$ProtectionParameter)
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException; )
public abstract java.security.KeyStore getKeyStore()
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException; )
public abstract java.security.KeyStore$ProtectionParameter getProtectionParameter(
java.lang.String)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/security/KeyStore$Builder; )
@dalvik.annotation.InnerClass (accessFlags =10 name =BuilderImpl )
 class java.security.KeyStore$Builder$BuilderImpl extends java.security.KeyStore$Builder

----------------FIELDS----------------

private final java.security.AccessControlContext accControlContext

private final java.io.File fileForLoad

private boolean isGetKeyStore

private java.security.KeyStore keyStore

private java.security.KeyStoreException lastException

private java.security.KeyStore$ProtectionParameter protParameter

private final java.security.Provider providerForKeyStore

private final java.lang.String typeForKeyStore
----------------METHODS----------------

 void <init>(
java.security.KeyStore
java.security.KeyStore$ProtectionParameter
java.io.File
java.lang.String
java.security.Provider
java.security.AccessControlContext)

static java.io.File access$200(
java.security.KeyStore$Builder$BuilderImpl)

static java.security.KeyStore$ProtectionParameter access$300(
java.security.KeyStore$Builder$BuilderImpl)
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException; )
public java.security.KeyStore getKeyStore()
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException; )
public java.security.KeyStore$ProtectionParameter getProtectionParameter(
java.lang.String)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =1545 name =LoadStoreParameter )
@dalvik.annotation.EnclosingClass (value =Ljava/security/KeyStore; )
public abstract interface class java.security.KeyStore$LoadStoreParameter extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.security.KeyStore$ProtectionParameter getProtectionParameter()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =10 name =TmpLSParameter )
@dalvik.annotation.EnclosingClass (value =Ljava/security/KeyStore$Builder; )
 class java.security.KeyStore$Builder$TmpLSParameter extends java.lang.Object implements java.security.KeyStore$LoadStoreParameter

----------------FIELDS----------------

private final java.security.KeyStore$ProtectionParameter protPar
----------------METHODS----------------

public void <init>(
java.security.KeyStore$ProtectionParameter)

public java.security.KeyStore$ProtectionParameter getProtectionParameter()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =1545 name =ProtectionParameter )
@dalvik.annotation.EnclosingClass (value =Ljava/security/KeyStore; )
public abstract interface class java.security.KeyStore$ProtectionParameter extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =CallbackHandlerProtection )
@dalvik.annotation.EnclosingClass (value =Ljava/security/KeyStore; )
public class java.security.KeyStore$CallbackHandlerProtection extends java.lang.Object implements java.security.KeyStore$ProtectionParameter

----------------FIELDS----------------

private final javax.security.auth.callback.CallbackHandler callbackHandler
----------------METHODS----------------

public void <init>(
javax.security.auth.callback.CallbackHandler)

public javax.security.auth.callback.CallbackHandler getCallbackHandler()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =1545 name =Entry )
@dalvik.annotation.EnclosingClass (value =Ljava/security/KeyStore; )
public abstract interface class java.security.KeyStore$Entry extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________


public abstract interface class javax.security.auth.Destroyable extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljavax/security/auth/DestroyFailedException; )
public abstract void destroy()

public abstract boolean isDestroyed()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =PasswordProtection )
@dalvik.annotation.EnclosingClass (value =Ljava/security/KeyStore; )
public class java.security.KeyStore$PasswordProtection extends java.lang.Object implements java.security.KeyStore$ProtectionParameter, javax.security.auth.Destroyable

----------------FIELDS----------------

private boolean isDestroyed

private char[] password
----------------METHODS----------------

public void <init>(
char[])
@dalvik.annotation.Throws (value =Ljavax/security/auth/DestroyFailedException; )
public void destroy()

public char[] getPassword()

public boolean isDestroyed()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/security/KeyStore; )
@dalvik.annotation.InnerClass (accessFlags =25 name =PrivateKeyEntry )
public final class java.security.KeyStore$PrivateKeyEntry extends java.lang.Object implements java.security.KeyStore$Entry

----------------FIELDS----------------

private java.security.cert.Certificate[] chain

private java.security.PrivateKey privateKey
----------------METHODS----------------

public void <init>(
java.security.PrivateKey
java.security.cert.Certificate[])

public java.security.cert.Certificate getCertificate()

public java.security.cert.Certificate[] getCertificateChain()

public java.security.PrivateKey getPrivateKey()

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/security/KeyStore; )
@dalvik.annotation.InnerClass (accessFlags =25 name =SecretKeyEntry )
public final class java.security.KeyStore$SecretKeyEntry extends java.lang.Object implements java.security.KeyStore$Entry

----------------FIELDS----------------

private final javax.crypto.SecretKey secretKey
----------------METHODS----------------

public void <init>(
javax.crypto.SecretKey)

public javax.crypto.SecretKey getSecretKey()

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =25 name =TrustedCertificateEntry )
@dalvik.annotation.EnclosingClass (value =Ljava/security/KeyStore; )
public final class java.security.KeyStore$TrustedCertificateEntry extends java.lang.Object implements java.security.KeyStore$Entry

----------------FIELDS----------------

private final java.security.cert.Certificate trustCertificate
----------------METHODS----------------

public void <init>(
java.security.cert.Certificate)

public java.security.cert.Certificate getTrustedCertificate()

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/security/KeyStore$TrustedCertificateEntry;Ljava/security/KeyStore$SecretKeyEntry;Ljava/security/KeyStore$PrivateKeyEntry;Ljava/security/KeyStore$ProtectionParameter;Ljava/security/KeyStore$PasswordProtection;Ljava/security/KeyStore$LoadStoreParameter;Ljava/security/KeyStore$Entry;Ljava/security/KeyStore$CallbackHandlerProtection;Ljava/security/KeyStore$Builder; )
public class java.security.KeyStore extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.String DEFAULT_KEYSTORE_TYPE

private static java.lang.String NOTINITKEYSTORE

private static final java.lang.String PROPERTYNAME

private static final java.lang.String SERVICE

private static org.apache.harmony.security.fortress.Engine engine

private final java.security.KeyStoreSpi implSpi

private boolean isInit

private final java.security.Provider provider

private final java.lang.String type
----------------METHODS----------------

static void <clinit>()

protected void <init>(
java.security.KeyStoreSpi
java.security.Provider
java.lang.String)

static boolean access$000(
java.security.KeyStore)

static java.lang.String access$100()

public static final java.lang.String getDefaultType()
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException; )
public static java.security.KeyStore getInstance(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException;Ljava/security/NoSuchProviderException; )
public static java.security.KeyStore getInstance(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException; )
public static java.security.KeyStore getInstance(
java.lang.String
java.security.Provider)
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException; )
private static void throwNotInitialized()
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException; )
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<Ljava/lang/String;>; )
public final java.util.Enumeration aliases()
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException; )
public final boolean containsAlias(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException; )
public final void deleteEntry(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException; )
@dalvik.annotation.Signature (value =(Ljava/lang/String;Ljava/lang/Class<+Ljava/security/KeyStore$Entry;>;)Z )
public final boolean entryInstanceOf(
java.lang.String
java.lang.Class)
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException; )
public final java.security.cert.Certificate getCertificate(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException; )
public final java.lang.String getCertificateAlias(
java.security.cert.Certificate)
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException; )
public final java.security.cert.Certificate[] getCertificateChain(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException; )
public final java.util.Date getCreationDate(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/UnrecoverableEntryException;Ljava/security/KeyStoreException; )
public final java.security.KeyStore$Entry getEntry(
java.lang.String
java.security.KeyStore$ProtectionParameter)
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException;Ljava/security/NoSuchAlgorithmException;Ljava/security/UnrecoverableKeyException; )
public final java.security.Key getKey(
java.lang.String
char[])

public final java.security.Provider getProvider()

public final java.lang.String getType()
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException; )
public final boolean isCertificateEntry(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException; )
public final boolean isKeyEntry(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/security/NoSuchAlgorithmException;Ljava/security/cert/CertificateException; )
public final void load(
java.io.InputStream
char[])
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/security/NoSuchAlgorithmException;Ljava/security/cert/CertificateException; )
public final void load(
java.security.KeyStore$LoadStoreParameter)
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException; )
public final void setCertificateEntry(
java.lang.String
java.security.cert.Certificate)
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException; )
public final void setEntry(
java.lang.String
java.security.KeyStore$Entry
java.security.KeyStore$ProtectionParameter)
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException; )
public final void setKeyEntry(
java.lang.String
java.security.Key
char[]
java.security.cert.Certificate[])
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException; )
public final void setKeyEntry(
java.lang.String
byte[]
java.security.cert.Certificate[])
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException; )
public final int size()
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException;Ljava/io/IOException;Ljava/security/NoSuchAlgorithmException;Ljava/security/cert/CertificateException; )
public final void store(
java.io.OutputStream
char[])
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException;Ljava/io/IOException;Ljava/security/NoSuchAlgorithmException;Ljava/security/cert/CertificateException; )
public final void store(
java.security.KeyStore$LoadStoreParameter)

________________CLASS________________


public class java.security.KeyStoreException extends java.security.GeneralSecurityException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.Throwable)

public void <init>(
java.lang.Throwable)

________________CLASS________________


public abstract class java.security.KeyStoreSpi extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/security/UnrecoverableEntryException; )
static char[] getPasswordFromCallBack(
java.security.KeyStore$ProtectionParameter)
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<Ljava/lang/String;>; )
public abstract java.util.Enumeration engineAliases()

public abstract boolean engineContainsAlias(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException; )
public abstract void engineDeleteEntry(
java.lang.String)
@dalvik.annotation.Signature (value =(Ljava/lang/String;Ljava/lang/Class<+Ljava/security/KeyStore$Entry;>;)Z )
public boolean engineEntryInstanceOf(
java.lang.String
java.lang.Class)

public abstract java.security.cert.Certificate engineGetCertificate(
java.lang.String)

public abstract java.lang.String engineGetCertificateAlias(
java.security.cert.Certificate)

public abstract java.security.cert.Certificate[] engineGetCertificateChain(
java.lang.String)

public abstract java.util.Date engineGetCreationDate(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException;Ljava/security/NoSuchAlgorithmException;Ljava/security/UnrecoverableEntryException; )
public java.security.KeyStore$Entry engineGetEntry(
java.lang.String
java.security.KeyStore$ProtectionParameter)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/UnrecoverableKeyException; )
public abstract java.security.Key engineGetKey(
java.lang.String
char[])

public abstract boolean engineIsCertificateEntry(
java.lang.String)

public abstract boolean engineIsKeyEntry(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/security/NoSuchAlgorithmException;Ljava/security/cert/CertificateException; )
public abstract void engineLoad(
java.io.InputStream
char[])
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/security/NoSuchAlgorithmException;Ljava/security/cert/CertificateException; )
public void engineLoad(
java.security.KeyStore$LoadStoreParameter)
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException; )
public abstract void engineSetCertificateEntry(
java.lang.String
java.security.cert.Certificate)
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException; )
public void engineSetEntry(
java.lang.String
java.security.KeyStore$Entry
java.security.KeyStore$ProtectionParameter)
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException; )
public abstract void engineSetKeyEntry(
java.lang.String
java.security.Key
char[]
java.security.cert.Certificate[])
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException; )
public abstract void engineSetKeyEntry(
java.lang.String
byte[]
java.security.cert.Certificate[])

public abstract int engineSize()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/security/NoSuchAlgorithmException;Ljava/security/cert/CertificateException; )
public abstract void engineStore(
java.io.OutputStream
char[])
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/security/NoSuchAlgorithmException;Ljava/security/cert/CertificateException; )
public void engineStore(
java.security.KeyStore$LoadStoreParameter)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/security/MessageDigest; )
@dalvik.annotation.InnerClass (accessFlags =4104 name =null )
 class java.security.MessageDigest$1 extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________


public abstract class java.security.MessageDigestSpi extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/lang/CloneNotSupportedException; )
public java.lang.Object clone()
@dalvik.annotation.Throws (value =Ljava/security/DigestException; )
protected int engineDigest(
byte[]
int
int)

protected abstract byte[] engineDigest()

protected int engineGetDigestLength()

protected abstract void engineReset()

protected abstract void engineUpdate(
byte)

protected void engineUpdate(
java.nio.ByteBuffer)

protected abstract void engineUpdate(
byte[]
int
int)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/security/MessageDigest$1;Ljava/security/MessageDigest$MessageDigestImpl; )
public abstract class java.security.MessageDigest extends java.security.MessageDigestSpi

----------------FIELDS----------------

private static final java.lang.String SERVICE

private static org.apache.harmony.security.fortress.Engine engine

private java.lang.String algorithm

private java.security.Provider provider
----------------METHODS----------------

static void <clinit>()

protected void <init>(
java.lang.String)

static java.security.Provider access$102(
java.security.MessageDigest
java.security.Provider)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public static java.security.MessageDigest getInstance(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/NoSuchProviderException; )
public static java.security.MessageDigest getInstance(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public static java.security.MessageDigest getInstance(
java.lang.String
java.security.Provider)

public static boolean isEqual(
byte[]
byte[])
@dalvik.annotation.Throws (value =Ljava/lang/CloneNotSupportedException; )
public java.lang.Object clone()
@dalvik.annotation.Throws (value =Ljava/security/DigestException; )
public int digest(
byte[]
int
int)

public byte[] digest()

public byte[] digest(
byte[])

public final java.lang.String getAlgorithm()

public final int getDigestLength()

public final java.security.Provider getProvider()

public void reset()

public java.lang.String toString()

public void update(
byte)

public final void update(
java.nio.ByteBuffer)

public void update(
byte[])

public void update(
byte[]
int
int)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =10 name =MessageDigestImpl )
@dalvik.annotation.EnclosingClass (value =Ljava/security/MessageDigest; )
 class java.security.MessageDigest$MessageDigestImpl extends java.security.MessageDigest

----------------FIELDS----------------

private java.security.MessageDigestSpi spiImpl
----------------METHODS----------------

private void <init>(
java.security.MessageDigestSpi
java.security.Provider
java.lang.String)

 void <init>(
java.security.MessageDigestSpi
java.security.Provider
java.lang.String
java.security.MessageDigest$1)
@dalvik.annotation.Throws (value =Ljava/lang/CloneNotSupportedException; )
public java.lang.Object clone()

protected byte[] engineDigest()

protected int engineGetDigestLength()

protected void engineReset()

protected void engineUpdate(
byte)

protected void engineUpdate(
byte[]
int
int)

________________CLASS________________


public class java.security.NoSuchAlgorithmException extends java.security.GeneralSecurityException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.Throwable)

public void <init>(
java.lang.Throwable)

________________CLASS________________


public class java.security.NoSuchProviderException extends java.security.GeneralSecurityException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =24 name =MetaEnumeration )
@dalvik.annotation.EnclosingClass (value =Ljava/security/Permissions; )
final class java.security.Permissions$MetaEnumeration extends java.lang.Object implements java.util.Enumeration

----------------FIELDS----------------

private java.util.Enumeration current

private java.util.Iterator pcIter
----------------METHODS----------------

public void <init>(
java.util.Iterator)

private java.util.Enumeration getNextEnumeration()

public boolean hasMoreElements()

public java.lang.Object nextElement()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/security/Permissions$MetaEnumeration; )
public final class java.security.Permissions extends java.security.PermissionCollection implements java.io.Serializable

----------------FIELDS----------------

private static final java.io.ObjectStreamField[] serialPersistentFields

private static final long serialVersionUID

private boolean allEnabled

private transient java.util.Map klasses
----------------METHODS----------------

static void <clinit>()

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

public void add(
java.security.Permission)
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<Ljava/security/Permission;>; )
public java.util.Enumeration elements()

public boolean implies(
java.security.Permission)

________________CLASS________________


final class java.security.PermissionsHash extends java.security.PermissionCollection

----------------FIELDS----------------

private static final long serialVersionUID

private final java.util.Hashtable perms
----------------METHODS----------------

 void <init>()

public void add(
java.security.Permission)

public java.util.Enumeration elements()

public boolean implies(
java.security.Permission)

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/security/Policy;>; )
final class java.security.Policy$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final java.lang.String val$defaultClass
----------------METHODS----------------

 void <init>(
java.lang.String)

public volatile java.lang.Object run()

public java.security.Policy run()

________________CLASS________________


public abstract class java.security.Policy extends java.lang.Object

----------------FIELDS----------------

private static final java.security.SecurityPermission GET_POLICY

private static final java.lang.String POLICY_PROVIDER

private static final java.security.SecurityPermission SET_POLICY

private static java.security.Policy activePolicy
----------------METHODS----------------

static void <clinit>()

public void <init>()

static java.security.Policy getAccessiblePolicy()

private static java.security.Policy getDefaultProvider()

public static java.security.Policy getPolicy()

static boolean isSet()

public static void setPolicy(
java.security.Policy)

public abstract java.security.PermissionCollection getPermissions(
java.security.CodeSource)

public java.security.PermissionCollection getPermissions(
java.security.ProtectionDomain)

public boolean implies(
java.security.ProtectionDomain
java.security.Permission)

public abstract void refresh()

________________CLASS________________


public abstract interface class java.security.PrivateKey extends java.lang.Object implements java.security.Key

----------------FIELDS----------------

public static final long serialVersionUID
----------------METHODS----------------

________________CLASS________________


public class java.security.PrivilegedActionException extends java.lang.Exception

----------------FIELDS----------------

private static final long serialVersionUID

private java.lang.Exception exception
----------------METHODS----------------

public void <init>(
java.lang.Exception)

public java.lang.Throwable getCause()

public java.lang.Exception getException()

public java.lang.String toString()

________________CLASS________________


public class java.security.ProtectionDomain extends java.lang.Object

----------------FIELDS----------------

private java.lang.ClassLoader classLoader

private java.security.CodeSource codeSource

private boolean dynamicPerms

private java.security.PermissionCollection permissions

private java.security.Principal[] principals
----------------METHODS----------------

public void <init>(
java.security.CodeSource
java.security.PermissionCollection)

public void <init>(
java.security.CodeSource
java.security.PermissionCollection
java.lang.ClassLoader
java.security.Principal[])

public final java.lang.ClassLoader getClassLoader()

public final java.security.CodeSource getCodeSource()

public final java.security.PermissionCollection getPermissions()

public final java.security.Principal[] getPrincipals()

public boolean implies(
java.security.Permission)

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/security/NoSuchAlgorithmException;>; )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
 class java.security.Provider$Service$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final java.security.Provider$Service this$0
----------------METHODS----------------

 void <init>(
java.security.Provider$Service)

public volatile java.lang.Object run()

public java.security.NoSuchAlgorithmException run()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/security/Provider; )
@dalvik.annotation.InnerClass (accessFlags =9 name =Service )
public class java.security.Provider$Service extends java.lang.Object

----------------FIELDS----------------

private java.lang.String algorithm
@dalvik.annotation.Signature (value =Ljava/util/List<Ljava/lang/String;>; )
private java.util.List aliases
@dalvik.annotation.Signature (value =Ljava/util/Map<Ljava/lang/String;Ljava/lang/String;>; )
private java.util.Map attributes

private java.lang.String className
@dalvik.annotation.Signature (value =Ljava/lang/Class<*>; )
private java.lang.Class implementation

private java.lang.String lastClassName

private java.security.Provider provider

private java.lang.String type
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/security/Provider;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/util/List<Ljava/lang/String;>;Ljava/util/Map<Ljava/lang/String;Ljava/lang/String;>;)V )
public void <init>(
java.security.Provider
java.lang.String
java.lang.String
java.lang.String
java.util.List
java.util.Map)

static java.lang.String access$000(
java.security.Provider$Service)

static java.lang.String access$100(
java.security.Provider$Service)

static java.util.List access$200(
java.security.Provider$Service)

static java.lang.String access$300(
java.security.Provider$Service)

static java.lang.String access$302(
java.security.Provider$Service
java.lang.String)

static java.util.Map access$400(
java.security.Provider$Service)

static java.security.Provider access$500(
java.security.Provider$Service)

static java.lang.Class access$602(
java.security.Provider$Service
java.lang.Class)

static java.lang.String access$702(
java.security.Provider$Service
java.lang.String)

 void addAlias(
java.lang.String)

public final java.lang.String getAlgorithm()
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<Ljava/lang/String;>; )
 java.util.Iterator getAliases()

public final java.lang.String getAttribute(
java.lang.String)

public final java.lang.String getClassName()

public final java.security.Provider getProvider()

public final java.lang.String getType()
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public java.lang.Object newInstance(
java.lang.Object)

 void putAttribute(
java.lang.String
java.lang.String)

public boolean supportsParameter(
java.lang.Object)

public java.lang.String toString()

________________CLASS________________


public class java.security.ProviderException extends java.lang.RuntimeException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.Throwable)

public void <init>(
java.lang.Throwable)

________________CLASS________________


public abstract interface class java.security.PublicKey extends java.lang.Object implements java.security.Key

----------------FIELDS----------------

public static final long serialVersionUID
----------------METHODS----------------

________________CLASS________________


public class java.util.Random extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------

static final long multiplier

private static final long serialVersionUID

 boolean haveNextNextGaussian

 double nextNextGaussian

 long seed
----------------METHODS----------------

public void <init>()

public void <init>(
long)

protected int next(
int)

public boolean nextBoolean()

public void nextBytes(
byte[])

public double nextDouble()

public float nextFloat()

public double nextGaussian()

public int nextInt()

public int nextInt(
int)

public long nextLong()

public void setSeed(
long)

________________CLASS________________


public class java.security.SecureRandom extends java.util.Random

----------------FIELDS----------------

private static final transient java.lang.String SERVICE

private static transient org.apache.harmony.security.fortress.Engine engine

private static transient java.security.SecureRandom internalSecureRandom

private static final long serialVersionUID

private java.lang.String algorithm

private long counter

private java.security.Provider provider

private byte[] randomBytes

private int randomBytesUsed

private java.security.SecureRandomSpi secureRandomSpi

private byte[] state
----------------METHODS----------------

static void <clinit>()

public void <init>()

protected void <init>(
java.security.SecureRandomSpi
java.security.Provider)

private void <init>(
java.security.SecureRandomSpi
java.security.Provider
java.lang.String)

public void <init>(
byte[])

private java.security.Provider$Service findService()
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public static java.security.SecureRandom getInstance(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/NoSuchProviderException; )
public static java.security.SecureRandom getInstance(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public static java.security.SecureRandom getInstance(
java.lang.String
java.security.Provider)

public static byte[] getSeed(
int)

public byte[] generateSeed(
int)

public java.lang.String getAlgorithm()

public final java.security.Provider getProvider()

protected final int next(
int)

public void nextBytes(
byte[])

public void setSeed(
long)

public void setSeed(
byte[])

________________CLASS________________


public abstract class java.security.SecureRandomSpi extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

protected abstract byte[] engineGenerateSeed(
int)

protected abstract void engineNextBytes(
byte[])

protected abstract void engineSetSeed(
byte[])

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/Void;>; )
@dalvik.annotation.EnclosingClass (value =Ljava/security/Security; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class java.security.Security$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public volatile java.lang.Object run()

public java.lang.Void run()

________________CLASS________________


public abstract interface class org.apache.harmony.security.fortress.SecurityAccess extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/security/Provider$Service;)Ljava/util/Iterator<Ljava/lang/String;>; )
public abstract java.util.Iterator getAliases(
java.security.Provider$Service)

public abstract java.security.Provider$Service getService(
java.security.Provider
java.lang.String)

public abstract void renumProviders()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/security/Security; )
@dalvik.annotation.InnerClass (accessFlags =10 name =SecurityDoor )
 class java.security.Security$SecurityDoor extends java.lang.Object implements org.apache.harmony.security.fortress.SecurityAccess

----------------FIELDS----------------
----------------METHODS----------------

private void <init>()

 void <init>(
java.security.Security$1)
@dalvik.annotation.Signature (value =(Ljava/security/Provider$Service;)Ljava/util/Iterator<Ljava/lang/String;>; )
public java.util.Iterator getAliases(
java.security.Provider$Service)

public java.security.Provider$Service getService(
java.security.Provider
java.lang.String)

public void renumProviders()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/security/Security$SecurityDoor; )
public final class java.security.Security extends java.lang.Object

----------------FIELDS----------------

private static java.util.Properties secprops
----------------METHODS----------------

static void <clinit>()

private void <init>()

static java.util.Properties access$000()

static void access$100()

static void access$300()

public static int addProvider(
java.security.Provider)

public static java.lang.String getAlgorithmProperty(
java.lang.String
java.lang.String)
@dalvik.annotation.Signature (value =(Ljava/lang/String;)Ljava/util/Set<Ljava/lang/String;>; )
public static java.util.Set getAlgorithms(
java.lang.String)

public static java.lang.String getProperty(
java.lang.String)

public static java.security.Provider getProvider(
java.lang.String)

public static java.security.Provider[] getProviders()

public static java.security.Provider[] getProviders(
java.lang.String)
@dalvik.annotation.Signature (value =(Ljava/util/Map<Ljava/lang/String;Ljava/lang/String;>;)[Ljava/security/Provider; )
public static java.security.Provider[] getProviders(
java.util.Map)

public static int insertProviderAt(
java.security.Provider
int)

private static void registerDefaultProviders()

public static void removeProvider(
java.lang.String)

private static void renumProviders()

public static void setProperty(
java.lang.String
java.lang.String)

________________CLASS________________


public final class java.security.SecurityPermission extends java.security.BasicPermission

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.String)

________________CLASS________________


public abstract class java.security.SignatureSpi extends java.lang.Object

----------------FIELDS----------------

protected java.security.SecureRandom appRandom
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/lang/CloneNotSupportedException; )
public java.lang.Object clone()
@dalvik.annotation.Throws (value =Ljava/security/InvalidParameterException; )
protected abstract java.lang.Object engineGetParameter(
java.lang.String)

protected java.security.AlgorithmParameters engineGetParameters()
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
protected abstract void engineInitSign(
java.security.PrivateKey)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
protected void engineInitSign(
java.security.PrivateKey
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
protected abstract void engineInitVerify(
java.security.PublicKey)
@dalvik.annotation.Throws (value =Ljava/security/InvalidParameterException; )
protected abstract void engineSetParameter(
java.lang.String
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/security/InvalidAlgorithmParameterException; )
protected void engineSetParameter(
java.security.spec.AlgorithmParameterSpec)
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
protected int engineSign(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
protected abstract byte[] engineSign()
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
protected abstract void engineUpdate(
byte)

protected void engineUpdate(
java.nio.ByteBuffer)
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
protected abstract void engineUpdate(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
protected abstract boolean engineVerify(
byte[])
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
protected boolean engineVerify(
byte[]
int
int)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/security/Signature$SignatureImpl; )
public abstract class java.security.Signature extends java.security.SignatureSpi

----------------FIELDS----------------

private static final java.lang.String SERVICE

protected static final int SIGN

protected static final int UNINITIALIZED

protected static final int VERIFY

private static org.apache.harmony.security.fortress.Engine engine

private java.lang.String algorithm

private java.security.Provider provider

protected int state
----------------METHODS----------------

static void <clinit>()

protected void <init>(
java.lang.String)

static java.security.Provider access$002(
java.security.Signature
java.security.Provider)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public static java.security.Signature getInstance(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/NoSuchProviderException; )
public static java.security.Signature getInstance(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public static java.security.Signature getInstance(
java.lang.String
java.security.Provider)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
private static java.security.Signature getSignatureInstance(
java.lang.String
java.security.Provider)

private java.lang.String stateToString(
int)
@dalvik.annotation.Throws (value =Ljava/lang/CloneNotSupportedException; )
public java.lang.Object clone()

public final java.lang.String getAlgorithm()
@dalvik.annotation.Throws (value =Ljava/security/InvalidParameterException; )
public final java.lang.Object getParameter(
java.lang.String)

public final java.security.AlgorithmParameters getParameters()

public final java.security.Provider getProvider()
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
public final void initSign(
java.security.PrivateKey)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
public final void initSign(
java.security.PrivateKey
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
public final void initVerify(
java.security.PublicKey)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
public final void initVerify(
java.security.cert.Certificate)
@dalvik.annotation.Throws (value =Ljava/security/InvalidParameterException; )
public final void setParameter(
java.lang.String
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/security/InvalidAlgorithmParameterException; )
public final void setParameter(
java.security.spec.AlgorithmParameterSpec)
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
public final int sign(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
public final byte[] sign()

public java.lang.String toString()
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
public final void update(
byte)
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
public final void update(
java.nio.ByteBuffer)
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
public final void update(
byte[])
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
public final void update(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
public final boolean verify(
byte[])
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
public final boolean verify(
byte[]
int
int)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/security/Signature; )
@dalvik.annotation.InnerClass (accessFlags =10 name =SignatureImpl )
 class java.security.Signature$SignatureImpl extends java.security.Signature

----------------FIELDS----------------

private java.security.SignatureSpi spiImpl
----------------METHODS----------------

public void <init>(
java.security.SignatureSpi
java.security.Provider
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/lang/CloneNotSupportedException; )
public java.lang.Object clone()
@dalvik.annotation.Throws (value =Ljava/security/InvalidParameterException; )
protected java.lang.Object engineGetParameter(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
protected void engineInitSign(
java.security.PrivateKey)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
protected void engineInitVerify(
java.security.PublicKey)
@dalvik.annotation.Throws (value =Ljava/security/InvalidParameterException; )
protected void engineSetParameter(
java.lang.String
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
protected byte[] engineSign()
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
protected void engineUpdate(
byte)
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
protected void engineUpdate(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
protected boolean engineVerify(
byte[])

________________CLASS________________


public class java.security.SignatureException extends java.security.GeneralSecurityException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.Throwable)

public void <init>(
java.lang.Throwable)

________________CLASS________________


public final class java.security.SignedObject extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

private byte[] content

private byte[] signature

private java.lang.String thealgorithm
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/security/InvalidKeyException;Ljava/security/SignatureException; )
public void <init>(
java.io.Serializable
java.security.PrivateKey
java.security.Signature)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)

public java.lang.String getAlgorithm()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
public java.lang.Object getObject()

public byte[] getSignature()
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljava/security/SignatureException; )
public boolean verify(
java.security.PublicKey
java.security.Signature)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedExceptionAction<Ljava/lang/Void;>; )
 class java.security.Signer$1 extends java.lang.Object implements java.security.PrivilegedExceptionAction

----------------FIELDS----------------

final java.security.Signer this$0

final java.security.PublicKey val$pk
----------------METHODS----------------

 void <init>(
java.security.Signer
java.security.PublicKey)
@dalvik.annotation.Throws (value =Ljava/lang/Exception; )
public volatile java.lang.Object run()
@dalvik.annotation.Throws (value =Ljava/security/KeyManagementException; )
public java.lang.Void run()

________________CLASS________________


public abstract class java.security.Signer extends java.security.Identity

----------------FIELDS----------------

private static final long serialVersionUID

private java.security.PrivateKey privateKey
----------------METHODS----------------

protected void <init>()

public void <init>(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/KeyManagementException; )
public void <init>(
java.lang.String
java.security.IdentityScope)

public java.security.PrivateKey getPrivateKey()
@dalvik.annotation.Throws (value =Ljava/security/InvalidParameterException;Ljava/security/KeyException; )
public final void setKeyPair(
java.security.KeyPair)

public java.lang.String toString()

________________CLASS________________


public final class java.security.Timestamp extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

private transient int hash

private java.security.cert.CertPath signerCertPath

private java.util.Date timestamp
----------------METHODS----------------

public void <init>(
java.util.Date
java.security.cert.CertPath)

public boolean equals(
java.lang.Object)

public java.security.cert.CertPath getSignerCertPath()

public java.util.Date getTimestamp()

public int hashCode()

public java.lang.String toString()

________________CLASS________________


public class java.security.UnrecoverableEntryException extends java.security.GeneralSecurityException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class java.security.UnrecoverableKeyException extends java.security.GeneralSecurityException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public final class java.security.UnresolvedPermission extends java.security.Permission implements java.io.Serializable

----------------FIELDS----------------

private static final java.io.ObjectStreamField[] serialPersistentFields

private static final long serialVersionUID

private transient int hash

private transient java.lang.String targetActions

private transient java.security.cert.Certificate[] targetCerts

private transient java.lang.String targetName
----------------METHODS----------------

static void <clinit>()

public void <init>(
java.lang.String
java.lang.String
java.lang.String
java.security.cert.Certificate[])

private final void checkType(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

public boolean equals(
java.lang.Object)

public java.lang.String getActions()

public java.lang.String getUnresolvedActions()

public java.security.cert.Certificate[] getUnresolvedCerts()

public java.lang.String getUnresolvedName()

public java.lang.String getUnresolvedType()

public int hashCode()

public boolean implies(
java.security.Permission)

public java.security.PermissionCollection newPermissionCollection()

 java.security.Permission resolve(
java.lang.Class)

public java.lang.String toString()

________________CLASS________________


final class java.security.UnresolvedPermissionCollection extends java.security.PermissionCollection

----------------FIELDS----------------

private static final java.io.ObjectStreamField[] serialPersistentFields

private static final long serialVersionUID

private transient java.util.Map klasses
----------------METHODS----------------

static void <clinit>()

 void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

public void add(
java.security.Permission)

public java.util.Enumeration elements()

 boolean hasUnresolved(
java.security.Permission)

public boolean implies(
java.security.Permission)

 java.security.PermissionCollection resolveCollection(
java.security.Permission
java.security.PermissionCollection)

________________CLASS________________


public abstract interface class java.security.acl.Owner extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/security/acl/NotOwnerException; )
public abstract boolean addOwner(
java.security.Principal
java.security.Principal)
@dalvik.annotation.Throws (value =Ljava/security/acl/NotOwnerException;Ljava/security/acl/LastOwnerException; )
public abstract boolean deleteOwner(
java.security.Principal
java.security.Principal)

public abstract boolean isOwner(
java.security.Principal)

________________CLASS________________


public abstract interface class java.security.acl.Acl extends java.lang.Object implements java.security.acl.Owner

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/security/acl/NotOwnerException; )
public abstract boolean addEntry(
java.security.Principal
java.security.acl.AclEntry)

public abstract boolean checkPermission(
java.security.Principal
java.security.acl.Permission)
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<Ljava/security/acl/AclEntry;>; )
public abstract java.util.Enumeration entries()

public abstract java.lang.String getName()
@dalvik.annotation.Signature (value =(Ljava/security/Principal;)Ljava/util/Enumeration<Ljava/security/acl/Permission;>; )
public abstract java.util.Enumeration getPermissions(
java.security.Principal)
@dalvik.annotation.Throws (value =Ljava/security/acl/NotOwnerException; )
public abstract boolean removeEntry(
java.security.Principal
java.security.acl.AclEntry)
@dalvik.annotation.Throws (value =Ljava/security/acl/NotOwnerException; )
public abstract void setName(
java.security.Principal
java.lang.String)

public abstract java.lang.String toString()

________________CLASS________________


public abstract interface class java.security.acl.AclEntry extends java.lang.Object implements java.lang.Cloneable

----------------FIELDS----------------
----------------METHODS----------------

public abstract boolean addPermission(
java.security.acl.Permission)

public abstract boolean checkPermission(
java.security.acl.Permission)

public abstract java.lang.Object clone()

public abstract java.security.Principal getPrincipal()

public abstract boolean isNegative()
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<Ljava/security/acl/Permission;>; )
public abstract java.util.Enumeration permissions()

public abstract boolean removePermission(
java.security.acl.Permission)

public abstract void setNegativePermissions()

public abstract boolean setPrincipal(
java.security.Principal)

public abstract java.lang.String toString()

________________CLASS________________


public class java.security.acl.AclNotFoundException extends java.lang.Exception

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

________________CLASS________________


public abstract interface class java.security.acl.Group extends java.lang.Object implements java.security.Principal

----------------FIELDS----------------
----------------METHODS----------------

public abstract boolean addMember(
java.security.Principal)

public abstract boolean isMember(
java.security.Principal)
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<+Ljava/security/Principal;>; )
public abstract java.util.Enumeration members()

public abstract boolean removeMember(
java.security.Principal)

________________CLASS________________


public class java.security.acl.LastOwnerException extends java.lang.Exception

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

________________CLASS________________


public class java.security.acl.NotOwnerException extends java.lang.Exception

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

________________CLASS________________


public abstract interface class java.security.acl.Permission extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract boolean equals(
java.lang.Object)

public abstract java.lang.String toString()

________________CLASS________________


public abstract class java.security.cert.CRL extends java.lang.Object

----------------FIELDS----------------

private final java.lang.String type
----------------METHODS----------------

protected void <init>(
java.lang.String)

public final java.lang.String getType()

public abstract boolean isRevoked(
java.security.cert.Certificate)

public abstract java.lang.String toString()

________________CLASS________________


public class java.security.cert.CRLException extends java.security.GeneralSecurityException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.Throwable)

public void <init>(
java.lang.Throwable)

________________CLASS________________


public abstract interface class java.security.cert.CRLSelector extends java.lang.Object implements java.lang.Cloneable

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.lang.Object clone()

public abstract boolean match(
java.security.cert.CRL)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/security/cert/CertPath; )
@dalvik.annotation.InnerClass (accessFlags =12 name =CertPathRep )
public class java.security.cert.CertPath$CertPathRep extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------

private static final java.io.ObjectStreamField[] serialPersistentFields

private static final long serialVersionUID

private final byte[] data

private final java.lang.String type
----------------METHODS----------------

static void <clinit>()

protected void <init>(
java.lang.String
byte[])
@dalvik.annotation.Throws (value =Ljava/io/ObjectStreamException; )
protected java.lang.Object readResolve()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/security/cert/CertPath$CertPathRep; )
public abstract class java.security.cert.CertPath extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

private final java.lang.String type
----------------METHODS----------------

protected void <init>(
java.lang.String)

public boolean equals(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/List<+Ljava/security/cert/Certificate;>; )
public abstract java.util.List getCertificates()
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateEncodingException; )
public abstract byte[] getEncoded()
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateEncodingException; )
public abstract byte[] getEncoded(
java.lang.String)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<Ljava/lang/String;>; )
public abstract java.util.Iterator getEncodings()

public java.lang.String getType()

public int hashCode()

public java.lang.String toString()
@dalvik.annotation.Throws (value =Ljava/io/ObjectStreamException; )
protected java.lang.Object writeReplace()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/String;>; )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class java.security.cert.CertPathBuilder$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public volatile java.lang.Object run()

public java.lang.String run()

________________CLASS________________


public class java.security.cert.CertPathBuilder extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.String DEFAULTPROPERTY

private static final java.lang.String PROPERTYNAME

private static final java.lang.String SERVICE

private static org.apache.harmony.security.fortress.Engine engine

private final java.lang.String algorithm

private final java.security.Provider provider

private java.security.cert.CertPathBuilderSpi spiImpl
----------------METHODS----------------

static void <clinit>()

protected void <init>(
java.security.cert.CertPathBuilderSpi
java.security.Provider
java.lang.String)

public static final java.lang.String getDefaultType()
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public static java.security.cert.CertPathBuilder getInstance(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/NoSuchProviderException; )
public static java.security.cert.CertPathBuilder getInstance(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public static java.security.cert.CertPathBuilder getInstance(
java.lang.String
java.security.Provider)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertPathBuilderException;Ljava/security/InvalidAlgorithmParameterException; )
public final java.security.cert.CertPathBuilderResult build(
java.security.cert.CertPathParameters)

public final java.lang.String getAlgorithm()

public final java.security.Provider getProvider()

________________CLASS________________


public class java.security.cert.CertPathBuilderException extends java.security.GeneralSecurityException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.Throwable)

public void <init>(
java.lang.Throwable)

________________CLASS________________


public abstract interface class java.security.cert.CertPathBuilderResult extends java.lang.Object implements java.lang.Cloneable

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.lang.Object clone()

public abstract java.security.cert.CertPath getCertPath()

________________CLASS________________


public abstract class java.security.cert.CertPathBuilderSpi extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/security/cert/CertPathBuilderException;Ljava/security/InvalidAlgorithmParameterException; )
public abstract java.security.cert.CertPathBuilderResult engineBuild(
java.security.cert.CertPathParameters)

________________CLASS________________


public abstract interface class java.security.cert.CertPathParameters extends java.lang.Object implements java.lang.Cloneable

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.lang.Object clone()

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/String;>; )
final class java.security.cert.CertPathValidator$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public volatile java.lang.Object run()

public java.lang.String run()

________________CLASS________________


public class java.security.cert.CertPathValidator extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.String DEFAULTPROPERTY

private static final java.lang.String PROPERTYNAME

private static final java.lang.String SERVICE

private static org.apache.harmony.security.fortress.Engine engine

private final java.lang.String algorithm

private final java.security.Provider provider

private final java.security.cert.CertPathValidatorSpi spiImpl
----------------METHODS----------------

static void <clinit>()

protected void <init>(
java.security.cert.CertPathValidatorSpi
java.security.Provider
java.lang.String)

public static final java.lang.String getDefaultType()
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public static java.security.cert.CertPathValidator getInstance(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/NoSuchProviderException; )
public static java.security.cert.CertPathValidator getInstance(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public static java.security.cert.CertPathValidator getInstance(
java.lang.String
java.security.Provider)

public final java.lang.String getAlgorithm()

public final java.security.Provider getProvider()
@dalvik.annotation.Throws (value =Ljava/security/cert/CertPathValidatorException;Ljava/security/InvalidAlgorithmParameterException; )
public final java.security.cert.CertPathValidatorResult validate(
java.security.cert.CertPath
java.security.cert.CertPathParameters)

________________CLASS________________


public class java.security.cert.CertPathValidatorException extends java.security.GeneralSecurityException

----------------FIELDS----------------

private static final long serialVersionUID

private java.security.cert.CertPath certPath

private int index
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.Throwable)

public void <init>(
java.lang.String
java.lang.Throwable
java.security.cert.CertPath
int)

public void <init>(
java.lang.Throwable)

public java.security.cert.CertPath getCertPath()

public int getIndex()

________________CLASS________________


public abstract interface class java.security.cert.CertPathValidatorResult extends java.lang.Object implements java.lang.Cloneable

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.lang.Object clone()

________________CLASS________________


public abstract class java.security.cert.CertPathValidatorSpi extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/security/cert/CertPathValidatorException;Ljava/security/InvalidAlgorithmParameterException; )
public abstract java.security.cert.CertPathValidatorResult engineValidate(
java.security.cert.CertPath
java.security.cert.CertPathParameters)

________________CLASS________________


public abstract interface class java.security.cert.CertSelector extends java.lang.Object implements java.lang.Cloneable

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.lang.Object clone()

public abstract boolean match(
java.security.cert.Certificate)

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/String;>; )
final class java.security.cert.CertStore$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public volatile java.lang.Object run()

public java.lang.String run()

________________CLASS________________


public class java.security.cert.CertStore extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.String DEFAULTPROPERTY

private static final java.lang.String PROPERTYNAME

private static final java.lang.String SERVICE

private static org.apache.harmony.security.fortress.Engine engine

private final java.security.cert.CertStoreParameters certStoreParams

private final java.security.Provider provider

private final java.security.cert.CertStoreSpi spiImpl

private final java.lang.String type
----------------METHODS----------------

static void <clinit>()

protected void <init>(
java.security.cert.CertStoreSpi
java.security.Provider
java.lang.String
java.security.cert.CertStoreParameters)

public static final java.lang.String getDefaultType()
@dalvik.annotation.Throws (value =Ljava/security/InvalidAlgorithmParameterException;Ljava/security/NoSuchAlgorithmException; )
public static java.security.cert.CertStore getInstance(
java.lang.String
java.security.cert.CertStoreParameters)
@dalvik.annotation.Throws (value =Ljava/security/InvalidAlgorithmParameterException;Ljava/security/NoSuchAlgorithmException;Ljava/security/NoSuchProviderException; )
public static java.security.cert.CertStore getInstance(
java.lang.String
java.security.cert.CertStoreParameters
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/InvalidAlgorithmParameterException; )
public static java.security.cert.CertStore getInstance(
java.lang.String
java.security.cert.CertStoreParameters
java.security.Provider)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertStoreException; )
@dalvik.annotation.Signature (value =(Ljava/security/cert/CRLSelector;)Ljava/util/Collection<+Ljava/security/cert/CRL;>; )
public final java.util.Collection getCRLs(
java.security.cert.CRLSelector)

public final java.security.cert.CertStoreParameters getCertStoreParameters()
@dalvik.annotation.Signature (value =(Ljava/security/cert/CertSelector;)Ljava/util/Collection<+Ljava/security/cert/Certificate;>; )
@dalvik.annotation.Throws (value =Ljava/security/cert/CertStoreException; )
public final java.util.Collection getCertificates(
java.security.cert.CertSelector)

public final java.security.Provider getProvider()

public final java.lang.String getType()

________________CLASS________________


public class java.security.cert.CertStoreException extends java.security.GeneralSecurityException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.Throwable)

public void <init>(
java.lang.Throwable)

________________CLASS________________


public abstract interface class java.security.cert.CertStoreParameters extends java.lang.Object implements java.lang.Cloneable

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.lang.Object clone()

________________CLASS________________


public abstract class java.security.cert.CertStoreSpi extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/security/InvalidAlgorithmParameterException; )
public void <init>(
java.security.cert.CertStoreParameters)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertStoreException; )
@dalvik.annotation.Signature (value =(Ljava/security/cert/CRLSelector;)Ljava/util/Collection<+Ljava/security/cert/CRL;>; )
public abstract java.util.Collection engineGetCRLs(
java.security.cert.CRLSelector)
@dalvik.annotation.Signature (value =(Ljava/security/cert/CertSelector;)Ljava/util/Collection<+Ljava/security/cert/Certificate;>; )
@dalvik.annotation.Throws (value =Ljava/security/cert/CertStoreException; )
public abstract java.util.Collection engineGetCertificates(
java.security.cert.CertSelector)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =12 name =CertificateRep )
@dalvik.annotation.EnclosingClass (value =Ljava/security/cert/Certificate; )
public class java.security.cert.Certificate$CertificateRep extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------

private static final java.io.ObjectStreamField[] serialPersistentFields

private static final long serialVersionUID

private final byte[] data

private final java.lang.String type
----------------METHODS----------------

static void <clinit>()

protected void <init>(
java.lang.String
byte[])
@dalvik.annotation.Throws (value =Ljava/io/ObjectStreamException; )
protected java.lang.Object readResolve()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/security/cert/Certificate$CertificateRep; )
public abstract class java.security.cert.Certificate extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

private final java.lang.String type
----------------METHODS----------------

protected void <init>(
java.lang.String)

public boolean equals(
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateEncodingException; )
public abstract byte[] getEncoded()

public abstract java.security.PublicKey getPublicKey()

public final java.lang.String getType()

public int hashCode()

public abstract java.lang.String toString()
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException;Ljava/security/NoSuchAlgorithmException;Ljava/security/InvalidKeyException;Ljava/security/NoSuchProviderException;Ljava/security/SignatureException; )
public abstract void verify(
java.security.PublicKey)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException;Ljava/security/NoSuchAlgorithmException;Ljava/security/InvalidKeyException;Ljava/security/NoSuchProviderException;Ljava/security/SignatureException; )
public abstract void verify(
java.security.PublicKey
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/ObjectStreamException; )
protected java.lang.Object writeReplace()

________________CLASS________________


public class java.security.cert.CertificateException extends java.security.GeneralSecurityException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.Throwable)

public void <init>(
java.lang.Throwable)

________________CLASS________________


public class java.security.cert.CertificateEncodingException extends java.security.cert.CertificateException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.Throwable)

public void <init>(
java.lang.Throwable)

________________CLASS________________


public class java.security.cert.CertificateExpiredException extends java.security.cert.CertificateException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class java.security.cert.CertificateFactory extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.String SERVICE

private static org.apache.harmony.security.fortress.Engine engine

private final java.security.Provider provider

private final java.security.cert.CertificateFactorySpi spiImpl

private final java.lang.String type
----------------METHODS----------------

static void <clinit>()

protected void <init>(
java.security.cert.CertificateFactorySpi
java.security.Provider
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException; )
public static final java.security.cert.CertificateFactory getInstance(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException;Ljava/security/NoSuchProviderException; )
public static final java.security.cert.CertificateFactory getInstance(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException; )
public static final java.security.cert.CertificateFactory getInstance(
java.lang.String
java.security.Provider)
@dalvik.annotation.Throws (value =Ljava/security/cert/CRLException; )
public final java.security.cert.CRL generateCRL(
java.io.InputStream)
@dalvik.annotation.Signature (value =(Ljava/io/InputStream;)Ljava/util/Collection<+Ljava/security/cert/CRL;>; )
@dalvik.annotation.Throws (value =Ljava/security/cert/CRLException; )
public final java.util.Collection generateCRLs(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException; )
public final java.security.cert.CertPath generateCertPath(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException; )
public final java.security.cert.CertPath generateCertPath(
java.io.InputStream
java.lang.String)
@dalvik.annotation.Signature (value =(Ljava/util/List<+Ljava/security/cert/Certificate;>;)Ljava/security/cert/CertPath; )
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException; )
public final java.security.cert.CertPath generateCertPath(
java.util.List)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException; )
public final java.security.cert.Certificate generateCertificate(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException; )
@dalvik.annotation.Signature (value =(Ljava/io/InputStream;)Ljava/util/Collection<+Ljava/security/cert/Certificate;>; )
public final java.util.Collection generateCertificates(
java.io.InputStream)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<Ljava/lang/String;>; )
public final java.util.Iterator getCertPathEncodings()

public final java.security.Provider getProvider()

public final java.lang.String getType()

________________CLASS________________


public abstract class java.security.cert.CertificateFactorySpi extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/security/cert/CRLException; )
public abstract java.security.cert.CRL engineGenerateCRL(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/security/cert/CRLException; )
@dalvik.annotation.Signature (value =(Ljava/io/InputStream;)Ljava/util/Collection<+Ljava/security/cert/CRL;>; )
public abstract java.util.Collection engineGenerateCRLs(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException; )
public java.security.cert.CertPath engineGenerateCertPath(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException; )
public java.security.cert.CertPath engineGenerateCertPath(
java.io.InputStream
java.lang.String)
@dalvik.annotation.Signature (value =(Ljava/util/List<+Ljava/security/cert/Certificate;>;)Ljava/security/cert/CertPath; )
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException; )
public java.security.cert.CertPath engineGenerateCertPath(
java.util.List)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException; )
public abstract java.security.cert.Certificate engineGenerateCertificate(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException; )
@dalvik.annotation.Signature (value =(Ljava/io/InputStream;)Ljava/util/Collection<+Ljava/security/cert/Certificate;>; )
public abstract java.util.Collection engineGenerateCertificates(
java.io.InputStream)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<Ljava/lang/String;>; )
public java.util.Iterator engineGetCertPathEncodings()

________________CLASS________________


public class java.security.cert.CertificateNotYetValidException extends java.security.cert.CertificateException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class java.security.cert.CertificateParsingException extends java.security.cert.CertificateException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.Throwable)

public void <init>(
java.lang.Throwable)

________________CLASS________________


public class java.security.cert.CollectionCertStoreParameters extends java.lang.Object implements java.security.cert.CertStoreParameters

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Collection<*>; )
private static final java.util.Collection defaultCollection
@dalvik.annotation.Signature (value =Ljava/util/Collection<*>; )
private final java.util.Collection collection
----------------METHODS----------------

static void <clinit>()

public void <init>()
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)V )
public void <init>(
java.util.Collection)

public java.lang.Object clone()
@dalvik.annotation.Signature (value =()Ljava/util/Collection<*>; )
public java.util.Collection getCollection()

public java.lang.String toString()

________________CLASS________________


public class java.security.cert.LDAPCertStoreParameters extends java.lang.Object implements java.security.cert.CertStoreParameters

----------------FIELDS----------------

private static final int DEFAULT_LDAP_PORT

private static final java.lang.String DEFAULT_LDAP_SERVER_NAME

private final int port

private final java.lang.String serverName
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
int)

public java.lang.Object clone()

public int getPort()

public java.lang.String getServerName()

public java.lang.String toString()

________________CLASS________________


public class java.security.cert.PKIXParameters extends java.lang.Object implements java.security.cert.CertPathParameters

----------------FIELDS----------------

private boolean anyPolicyInhibited
@dalvik.annotation.Signature (value =Ljava/util/List<Ljava/security/cert/PKIXCertPathChecker;>; )
private java.util.List certPathCheckers
@dalvik.annotation.Signature (value =Ljava/util/List<Ljava/security/cert/CertStore;>; )
private java.util.List certStores

private java.util.Date date

private boolean explicitPolicyRequired
@dalvik.annotation.Signature (value =Ljava/util/Set<Ljava/lang/String;>; )
private java.util.Set initialPolicies

private boolean policyMappingInhibited

private boolean policyQualifiersRejected

private boolean revocationEnabled

private java.lang.String sigProvider

private java.security.cert.CertSelector targetCertConstraints
@dalvik.annotation.Signature (value =Ljava/util/Set<Ljava/security/cert/TrustAnchor;>; )
private java.util.Set trustAnchors
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException;Ljava/security/InvalidAlgorithmParameterException; )
public void <init>(
java.security.KeyStore)
@dalvik.annotation.Throws (value =Ljava/security/InvalidAlgorithmParameterException; )
@dalvik.annotation.Signature (value =(Ljava/util/Set<Ljava/security/cert/TrustAnchor;>;)V )
public void <init>(
java.util.Set)
@dalvik.annotation.Throws (value =Ljava/security/InvalidAlgorithmParameterException; )
private void checkTrustAnchors(
java.util.Set)

public void addCertPathChecker(
java.security.cert.PKIXCertPathChecker)

public void addCertStore(
java.security.cert.CertStore)

public java.lang.Object clone()
@dalvik.annotation.Signature (value =()Ljava/util/List<Ljava/security/cert/PKIXCertPathChecker;>; )
public java.util.List getCertPathCheckers()
@dalvik.annotation.Signature (value =()Ljava/util/List<Ljava/security/cert/CertStore;>; )
public java.util.List getCertStores()

public java.util.Date getDate()
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/lang/String;>; )
public java.util.Set getInitialPolicies()

public boolean getPolicyQualifiersRejected()

public java.lang.String getSigProvider()

public java.security.cert.CertSelector getTargetCertConstraints()
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/security/cert/TrustAnchor;>; )
public java.util.Set getTrustAnchors()

public boolean isAnyPolicyInhibited()

public boolean isExplicitPolicyRequired()

public boolean isPolicyMappingInhibited()

public boolean isRevocationEnabled()

public void setAnyPolicyInhibited(
boolean)
@dalvik.annotation.Signature (value =(Ljava/util/List<Ljava/security/cert/PKIXCertPathChecker;>;)V )
public void setCertPathCheckers(
java.util.List)
@dalvik.annotation.Signature (value =(Ljava/util/List<Ljava/security/cert/CertStore;>;)V )
public void setCertStores(
java.util.List)

public void setDate(
java.util.Date)

public void setExplicitPolicyRequired(
boolean)
@dalvik.annotation.Signature (value =(Ljava/util/Set<Ljava/lang/String;>;)V )
public void setInitialPolicies(
java.util.Set)

public void setPolicyMappingInhibited(
boolean)

public void setPolicyQualifiersRejected(
boolean)

public void setRevocationEnabled(
boolean)

public void setSigProvider(
java.lang.String)

public void setTargetCertConstraints(
java.security.cert.CertSelector)
@dalvik.annotation.Signature (value =(Ljava/util/Set<Ljava/security/cert/TrustAnchor;>;)V )
@dalvik.annotation.Throws (value =Ljava/security/InvalidAlgorithmParameterException; )
public void setTrustAnchors(
java.util.Set)

public java.lang.String toString()

________________CLASS________________


public class java.security.cert.PKIXBuilderParameters extends java.security.cert.PKIXParameters

----------------FIELDS----------------

private int maxPathLength
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException;Ljava/security/InvalidAlgorithmParameterException; )
public void <init>(
java.security.KeyStore
java.security.cert.CertSelector)
@dalvik.annotation.Throws (value =Ljava/security/InvalidAlgorithmParameterException; )
@dalvik.annotation.Signature (value =(Ljava/util/Set<Ljava/security/cert/TrustAnchor;>;Ljava/security/cert/CertSelector;)V )
public void <init>(
java.util.Set
java.security.cert.CertSelector)

public int getMaxPathLength()

public void setMaxPathLength(
int)

public java.lang.String toString()

________________CLASS________________


public class java.security.cert.PKIXCertPathValidatorResult extends java.lang.Object implements java.security.cert.CertPathValidatorResult

----------------FIELDS----------------

private final java.security.cert.PolicyNode policyTree

private final java.security.PublicKey subjectPublicKey

private final java.security.cert.TrustAnchor trustAnchor
----------------METHODS----------------

public void <init>(
java.security.cert.TrustAnchor
java.security.cert.PolicyNode
java.security.PublicKey)

public java.lang.Object clone()

public java.security.cert.PolicyNode getPolicyTree()

public java.security.PublicKey getPublicKey()

public java.security.cert.TrustAnchor getTrustAnchor()

public java.lang.String toString()

________________CLASS________________


public class java.security.cert.PKIXCertPathBuilderResult extends java.security.cert.PKIXCertPathValidatorResult implements java.security.cert.CertPathBuilderResult

----------------FIELDS----------------

private final java.security.cert.CertPath certPath
----------------METHODS----------------

public void <init>(
java.security.cert.CertPath
java.security.cert.TrustAnchor
java.security.cert.PolicyNode
java.security.PublicKey)

public java.security.cert.CertPath getCertPath()

public java.lang.String toString()

________________CLASS________________


public abstract class java.security.cert.PKIXCertPathChecker extends java.lang.Object implements java.lang.Cloneable

----------------FIELDS----------------
----------------METHODS----------------

protected void <init>()
@dalvik.annotation.Throws (value =Ljava/security/cert/CertPathValidatorException; )
@dalvik.annotation.Signature (value =(Ljava/security/cert/Certificate;Ljava/util/Collection<Ljava/lang/String;>;)V )
public abstract void check(
java.security.cert.Certificate
java.util.Collection)

public java.lang.Object clone()
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/lang/String;>; )
public abstract java.util.Set getSupportedExtensions()
@dalvik.annotation.Throws (value =Ljava/security/cert/CertPathValidatorException; )
public abstract void init(
boolean)

public abstract boolean isForwardCheckingSupported()

________________CLASS________________


public abstract interface class java.security.cert.PolicyNode extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<+Ljava/security/cert/PolicyNode;>; )
public abstract java.util.Iterator getChildren()

public abstract int getDepth()
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/lang/String;>; )
public abstract java.util.Set getExpectedPolicies()

public abstract java.security.cert.PolicyNode getParent()
@dalvik.annotation.Signature (value =()Ljava/util/Set<+Ljava/security/cert/PolicyQualifierInfo;>; )
public abstract java.util.Set getPolicyQualifiers()

public abstract java.lang.String getValidPolicy()

public abstract boolean isCritical()

________________CLASS________________


public class java.security.cert.PolicyQualifierInfo extends java.lang.Object

----------------FIELDS----------------

private final byte[] encoded

private final byte[] policyQualifier

private final java.lang.String policyQualifierId
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
byte[])

public final byte[] getEncoded()

public final byte[] getPolicyQualifier()

public final java.lang.String getPolicyQualifierId()

public java.lang.String toString()

________________CLASS________________


public class java.security.cert.TrustAnchor extends java.lang.Object

----------------FIELDS----------------

private final java.lang.String caName

private final javax.security.auth.x500.X500Principal caPrincipal

private final java.security.PublicKey caPublicKey

private final byte[] nameConstraints

private final java.security.cert.X509Certificate trustedCert
----------------METHODS----------------

public void <init>(
java.lang.String
java.security.PublicKey
byte[])

public void <init>(
java.security.cert.X509Certificate
byte[])

public void <init>(
javax.security.auth.x500.X500Principal
java.security.PublicKey
byte[])

private void processNameConstraints()

public final javax.security.auth.x500.X500Principal getCA()

public final java.lang.String getCAName()

public final java.security.PublicKey getCAPublicKey()

public final byte[] getNameConstraints()

public final java.security.cert.X509Certificate getTrustedCert()

public java.lang.String toString()

________________CLASS________________


public abstract interface class java.security.cert.X509Extension extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/lang/String;>; )
public abstract java.util.Set getCriticalExtensionOIDs()

public abstract byte[] getExtensionValue(
java.lang.String)
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/lang/String;>; )
public abstract java.util.Set getNonCriticalExtensionOIDs()

public abstract boolean hasUnsupportedCriticalExtension()

________________CLASS________________


public abstract class java.security.cert.X509CRL extends java.security.cert.CRL implements java.security.cert.X509Extension

----------------FIELDS----------------
----------------METHODS----------------

protected void <init>()

public boolean equals(
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/security/cert/CRLException; )
public abstract byte[] getEncoded()

public abstract java.security.Principal getIssuerDN()

public javax.security.auth.x500.X500Principal getIssuerX500Principal()

public abstract java.util.Date getNextUpdate()

public abstract java.security.cert.X509CRLEntry getRevokedCertificate(
java.math.BigInteger)

public java.security.cert.X509CRLEntry getRevokedCertificate(
java.security.cert.X509Certificate)
@dalvik.annotation.Signature (value =()Ljava/util/Set<+Ljava/security/cert/X509CRLEntry;>; )
public abstract java.util.Set getRevokedCertificates()

public abstract java.lang.String getSigAlgName()

public abstract java.lang.String getSigAlgOID()

public abstract byte[] getSigAlgParams()

public abstract byte[] getSignature()
@dalvik.annotation.Throws (value =Ljava/security/cert/CRLException; )
public abstract byte[] getTBSCertList()

public abstract java.util.Date getThisUpdate()

public abstract int getVersion()

public int hashCode()
@dalvik.annotation.Throws (value =Ljava/security/cert/CRLException;Ljava/security/NoSuchAlgorithmException;Ljava/security/InvalidKeyException;Ljava/security/NoSuchProviderException;Ljava/security/SignatureException; )
public abstract void verify(
java.security.PublicKey)
@dalvik.annotation.Throws (value =Ljava/security/cert/CRLException;Ljava/security/NoSuchAlgorithmException;Ljava/security/InvalidKeyException;Ljava/security/NoSuchProviderException;Ljava/security/SignatureException; )
public abstract void verify(
java.security.PublicKey
java.lang.String)

________________CLASS________________


public abstract class java.security.cert.X509CRLEntry extends java.lang.Object implements java.security.cert.X509Extension

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public boolean equals(
java.lang.Object)

public javax.security.auth.x500.X500Principal getCertificateIssuer()
@dalvik.annotation.Throws (value =Ljava/security/cert/CRLException; )
public abstract byte[] getEncoded()

public abstract java.util.Date getRevocationDate()

public abstract java.math.BigInteger getSerialNumber()

public abstract boolean hasExtensions()

public int hashCode()

public abstract java.lang.String toString()

________________CLASS________________


public class java.security.cert.X509CRLSelector extends java.lang.Object implements java.security.cert.CRLSelector

----------------FIELDS----------------

private java.security.cert.X509Certificate certificateChecking

private long dateAndTime
@dalvik.annotation.Signature (value =Ljava/util/ArrayList<Ljava/lang/String;>; )
private java.util.ArrayList issuerNames
@dalvik.annotation.Signature (value =Ljava/util/ArrayList<Ljavax/security/auth/x500/X500Principal;>; )
private java.util.ArrayList issuerPrincipals

private java.math.BigInteger maxCRL

private java.math.BigInteger minCRL
----------------METHODS----------------

public void <init>()

public void addIssuer(
javax.security.auth.x500.X500Principal)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void addIssuerName(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void addIssuerName(
byte[])

public java.lang.Object clone()

public java.security.cert.X509Certificate getCertificateChecking()

public java.util.Date getDateAndTime()
@dalvik.annotation.Signature (value =()Ljava/util/Collection<Ljava/lang/Object;>; )
public java.util.Collection getIssuerNames()
@dalvik.annotation.Signature (value =()Ljava/util/Collection<Ljavax/security/auth/x500/X500Principal;>; )
public java.util.Collection getIssuers()

public java.math.BigInteger getMaxCRL()

public java.math.BigInteger getMinCRL()

public boolean match(
java.security.cert.CRL)

public void setCertificateChecking(
java.security.cert.X509Certificate)

public void setDateAndTime(
java.util.Date)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)V )
public void setIssuerNames(
java.util.Collection)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<Ljavax/security/auth/x500/X500Principal;>;)V )
public void setIssuers(
java.util.Collection)

public void setMaxCRLNumber(
java.math.BigInteger)

public void setMinCRLNumber(
java.math.BigInteger)

public java.lang.String toString()

________________CLASS________________


public class java.security.cert.X509CertSelector extends java.lang.Object implements java.security.cert.CertSelector

----------------FIELDS----------------

private byte[] authorityKeyIdentifier

private java.security.cert.X509Certificate certificateEquals

private java.util.Date certificateValid

private java.util.Set extendedKeyUsage

private javax.security.auth.x500.X500Principal issuer

private byte[] issuerBytes

private java.lang.String issuerName

private boolean[] keyUsage

private boolean matchAllNames

private org.apache.harmony.security.x509.NameConstraints nameConstraints

private int pathLen

private java.util.ArrayList pathToNames

private java.util.Set policies

private java.util.Date privateKeyValid

private java.math.BigInteger serialNumber

private javax.security.auth.x500.X500Principal subject

private java.util.List[] subjectAltNames

private byte[] subjectKeyIdentifier

private byte[] subjectPublicKey

private java.lang.String subjectPublicKeyAlgID

private java.security.PublicKey subjectPublicKeyImpl
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void checkOID(
java.lang.String)

private java.lang.String getBytesAsString(
byte[])

private byte[] getExtensionValue(
java.security.cert.X509Certificate
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void addPathToName(
int
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void addPathToName(
int
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void addSubjectAlternativeName(
int
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void addSubjectAlternativeName(
int
byte[])

public java.lang.Object clone()

public byte[] getAuthorityKeyIdentifier()

public int getBasicConstraints()

public java.security.cert.X509Certificate getCertificate()

public java.util.Date getCertificateValid()
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/lang/String;>; )
public java.util.Set getExtendedKeyUsage()

public javax.security.auth.x500.X500Principal getIssuer()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public byte[] getIssuerAsBytes()

public java.lang.String getIssuerAsString()

public boolean[] getKeyUsage()

public boolean getMatchAllSubjectAltNames()

public byte[] getNameConstraints()
@dalvik.annotation.Signature (value =()Ljava/util/Collection<Ljava/util/List<*>;>; )
public java.util.Collection getPathToNames()
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/lang/String;>; )
public java.util.Set getPolicy()

public java.util.Date getPrivateKeyValid()

public java.math.BigInteger getSerialNumber()

public javax.security.auth.x500.X500Principal getSubject()
@dalvik.annotation.Signature (value =()Ljava/util/Collection<Ljava/util/List<*>;>; )
public java.util.Collection getSubjectAlternativeNames()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public byte[] getSubjectAsBytes()

public java.lang.String getSubjectAsString()

public byte[] getSubjectKeyIdentifier()

public java.security.PublicKey getSubjectPublicKey()

public java.lang.String getSubjectPublicKeyAlgID()

public boolean match(
java.security.cert.Certificate)

public void setAuthorityKeyIdentifier(
byte[])

public void setBasicConstraints(
int)

public void setCertificate(
java.security.cert.X509Certificate)

public void setCertificateValid(
java.util.Date)
@dalvik.annotation.Signature (value =(Ljava/util/Set<Ljava/lang/String;>;)V )
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void setExtendedKeyUsage(
java.util.Set)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void setIssuer(
java.lang.String)

public void setIssuer(
javax.security.auth.x500.X500Principal)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void setIssuer(
byte[])

public void setKeyUsage(
boolean[])

public void setMatchAllSubjectAltNames(
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void setNameConstraints(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
@dalvik.annotation.Signature (value =(Ljava/util/Collection<Ljava/util/List<*>;>;)V )
public void setPathToNames(
java.util.Collection)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
@dalvik.annotation.Signature (value =(Ljava/util/Set<Ljava/lang/String;>;)V )
public void setPolicy(
java.util.Set)

public void setPrivateKeyValid(
java.util.Date)

public void setSerialNumber(
java.math.BigInteger)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void setSubject(
java.lang.String)

public void setSubject(
javax.security.auth.x500.X500Principal)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void setSubject(
byte[])
@dalvik.annotation.Signature (value =(Ljava/util/Collection<Ljava/util/List<*>;>;)V )
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void setSubjectAlternativeNames(
java.util.Collection)

public void setSubjectKeyIdentifier(
byte[])

public void setSubjectPublicKey(
java.security.PublicKey)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void setSubjectPublicKey(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void setSubjectPublicKeyAlgID(
java.lang.String)

public java.lang.String toString()

________________CLASS________________


public abstract class java.security.cert.X509Certificate extends java.security.cert.Certificate implements java.security.cert.X509Extension

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

protected void <init>()
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateExpiredException;Ljava/security/cert/CertificateNotYetValidException; )
public abstract void checkValidity()
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateExpiredException;Ljava/security/cert/CertificateNotYetValidException; )
public abstract void checkValidity(
java.util.Date)

public abstract int getBasicConstraints()
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateParsingException; )
@dalvik.annotation.Signature (value =()Ljava/util/List<Ljava/lang/String;>; )
public java.util.List getExtendedKeyUsage()
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateParsingException; )
@dalvik.annotation.Signature (value =()Ljava/util/Collection<Ljava/util/List<*>;>; )
public java.util.Collection getIssuerAlternativeNames()

public abstract java.security.Principal getIssuerDN()

public abstract boolean[] getIssuerUniqueID()

public javax.security.auth.x500.X500Principal getIssuerX500Principal()

public abstract boolean[] getKeyUsage()

public abstract java.util.Date getNotAfter()

public abstract java.util.Date getNotBefore()

public abstract java.math.BigInteger getSerialNumber()

public abstract java.lang.String getSigAlgName()

public abstract java.lang.String getSigAlgOID()

public abstract byte[] getSigAlgParams()

public abstract byte[] getSignature()
@dalvik.annotation.Signature (value =()Ljava/util/Collection<Ljava/util/List<*>;>; )
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateParsingException; )
public java.util.Collection getSubjectAlternativeNames()

public abstract java.security.Principal getSubjectDN()

public abstract boolean[] getSubjectUniqueID()

public javax.security.auth.x500.X500Principal getSubjectX500Principal()
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateEncodingException; )
public abstract byte[] getTBSCertificate()

public abstract int getVersion()

________________CLASS________________


public abstract interface class java.security.interfaces.DSAKey extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.security.interfaces.DSAParams getParams()

________________CLASS________________


public abstract interface class java.security.interfaces.DSAKeyPairGenerator extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/security/InvalidParameterException; )
public abstract void initialize(
int
boolean
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/InvalidParameterException; )
public abstract void initialize(
java.security.interfaces.DSAParams
java.security.SecureRandom)

________________CLASS________________


public abstract interface class java.security.interfaces.DSAParams extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.math.BigInteger getG()

public abstract java.math.BigInteger getP()

public abstract java.math.BigInteger getQ()

________________CLASS________________


public abstract interface class java.security.interfaces.DSAPrivateKey extends java.lang.Object implements java.security.interfaces.DSAKey, java.security.PrivateKey

----------------FIELDS----------------

public static final long serialVersionUID
----------------METHODS----------------

public abstract java.math.BigInteger getX()

________________CLASS________________


public abstract interface class java.security.interfaces.DSAPublicKey extends java.lang.Object implements java.security.interfaces.DSAKey, java.security.PublicKey

----------------FIELDS----------------

public static final long serialVersionUID
----------------METHODS----------------

public abstract java.math.BigInteger getY()

________________CLASS________________


public abstract interface class java.security.interfaces.ECKey extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.security.spec.ECParameterSpec getParams()

________________CLASS________________


public abstract interface class java.security.interfaces.ECPrivateKey extends java.lang.Object implements java.security.PrivateKey, java.security.interfaces.ECKey

----------------FIELDS----------------

public static final long serialVersionUID
----------------METHODS----------------

public abstract java.math.BigInteger getS()

________________CLASS________________


public abstract interface class java.security.interfaces.ECPublicKey extends java.lang.Object implements java.security.PublicKey, java.security.interfaces.ECKey

----------------FIELDS----------------

public static final long serialVersionUID
----------------METHODS----------------

public abstract java.security.spec.ECPoint getW()

________________CLASS________________


public abstract interface class java.security.interfaces.RSAKey extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.math.BigInteger getModulus()

________________CLASS________________


public abstract interface class java.security.interfaces.RSAPrivateKey extends java.lang.Object implements java.security.PrivateKey, java.security.interfaces.RSAKey

----------------FIELDS----------------

public static final long serialVersionUID
----------------METHODS----------------

public abstract java.math.BigInteger getPrivateExponent()

________________CLASS________________


public abstract interface class java.security.interfaces.RSAMultiPrimePrivateCrtKey extends java.lang.Object implements java.security.interfaces.RSAPrivateKey

----------------FIELDS----------------

public static final long serialVersionUID
----------------METHODS----------------

public abstract java.math.BigInteger getCrtCoefficient()

public abstract java.security.spec.RSAOtherPrimeInfo[] getOtherPrimeInfo()

public abstract java.math.BigInteger getPrimeExponentP()

public abstract java.math.BigInteger getPrimeExponentQ()

public abstract java.math.BigInteger getPrimeP()

public abstract java.math.BigInteger getPrimeQ()

public abstract java.math.BigInteger getPublicExponent()

________________CLASS________________


public abstract interface class java.security.interfaces.RSAPrivateCrtKey extends java.lang.Object implements java.security.interfaces.RSAPrivateKey

----------------FIELDS----------------

public static final long serialVersionUID
----------------METHODS----------------

public abstract java.math.BigInteger getCrtCoefficient()

public abstract java.math.BigInteger getPrimeExponentP()

public abstract java.math.BigInteger getPrimeExponentQ()

public abstract java.math.BigInteger getPrimeP()

public abstract java.math.BigInteger getPrimeQ()

public abstract java.math.BigInteger getPublicExponent()

________________CLASS________________


public abstract interface class java.security.interfaces.RSAPublicKey extends java.lang.Object implements java.security.PublicKey, java.security.interfaces.RSAKey

----------------FIELDS----------------

public static final long serialVersionUID
----------------METHODS----------------

public abstract java.math.BigInteger getPublicExponent()

________________CLASS________________


public abstract interface class java.security.spec.AlgorithmParameterSpec extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________


public class java.security.spec.DSAParameterSpec extends java.lang.Object implements java.security.spec.AlgorithmParameterSpec, java.security.interfaces.DSAParams

----------------FIELDS----------------

private final java.math.BigInteger g

private final java.math.BigInteger p

private final java.math.BigInteger q
----------------METHODS----------------

public void <init>(
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger)

public java.math.BigInteger getG()

public java.math.BigInteger getP()

public java.math.BigInteger getQ()

________________CLASS________________


public abstract interface class java.security.spec.KeySpec extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________


public class java.security.spec.DSAPrivateKeySpec extends java.lang.Object implements java.security.spec.KeySpec

----------------FIELDS----------------

private final java.math.BigInteger g

private final java.math.BigInteger p

private final java.math.BigInteger q

private final java.math.BigInteger x
----------------METHODS----------------

public void <init>(
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger)

public java.math.BigInteger getG()

public java.math.BigInteger getP()

public java.math.BigInteger getQ()

public java.math.BigInteger getX()

________________CLASS________________


public class java.security.spec.DSAPublicKeySpec extends java.lang.Object implements java.security.spec.KeySpec

----------------FIELDS----------------

private final java.math.BigInteger g

private final java.math.BigInteger p

private final java.math.BigInteger q

private final java.math.BigInteger y
----------------METHODS----------------

public void <init>(
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger)

public java.math.BigInteger getG()

public java.math.BigInteger getP()

public java.math.BigInteger getQ()

public java.math.BigInteger getY()

________________CLASS________________


public abstract interface class java.security.spec.ECField extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract int getFieldSize()

________________CLASS________________


public class java.security.spec.ECFieldF2m extends java.lang.Object implements java.security.spec.ECField

----------------FIELDS----------------

private static final int PPB_LEN

private static final int PPB_MID_LEN

private static final int TPB_LEN

private static final int TPB_MID_LEN

private final int[] ks

private final int m

private final java.math.BigInteger rp
----------------METHODS----------------

public void <init>(
int)

public void <init>(
int
java.math.BigInteger)

public void <init>(
int
int[])

public boolean equals(
java.lang.Object)

public int getFieldSize()

public int getM()

public int[] getMidTermsOfReductionPolynomial()

public java.math.BigInteger getReductionPolynomial()

public int hashCode()

________________CLASS________________


public class java.security.spec.ECFieldFp extends java.lang.Object implements java.security.spec.ECField

----------------FIELDS----------------

private final java.math.BigInteger p
----------------METHODS----------------

public void <init>(
java.math.BigInteger)

public boolean equals(
java.lang.Object)

public int getFieldSize()

public java.math.BigInteger getP()

public int hashCode()

________________CLASS________________


public class java.security.spec.ECGenParameterSpec extends java.lang.Object implements java.security.spec.AlgorithmParameterSpec

----------------FIELDS----------------

private final java.lang.String name
----------------METHODS----------------

public void <init>(
java.lang.String)

public java.lang.String getName()

________________CLASS________________


public class java.security.spec.ECParameterSpec extends java.lang.Object implements java.security.spec.AlgorithmParameterSpec

----------------FIELDS----------------

private final int cofactor

private final java.security.spec.EllipticCurve curve

private final java.security.spec.ECPoint generator

private final java.math.BigInteger order
----------------METHODS----------------

public void <init>(
java.security.spec.EllipticCurve
java.security.spec.ECPoint
java.math.BigInteger
int)

public int getCofactor()

public java.security.spec.EllipticCurve getCurve()

public java.security.spec.ECPoint getGenerator()

public java.math.BigInteger getOrder()

________________CLASS________________


public class java.security.spec.ECPoint extends java.lang.Object

----------------FIELDS----------------

public static final java.security.spec.ECPoint POINT_INFINITY

private final java.math.BigInteger affineX

private final java.math.BigInteger affineY
----------------METHODS----------------

static void <clinit>()

private void <init>()

public void <init>(
java.math.BigInteger
java.math.BigInteger)

public boolean equals(
java.lang.Object)

public java.math.BigInteger getAffineX()

public java.math.BigInteger getAffineY()

public int hashCode()

________________CLASS________________


public class java.security.spec.ECPrivateKeySpec extends java.lang.Object implements java.security.spec.KeySpec

----------------FIELDS----------------

private final java.security.spec.ECParameterSpec params

private final java.math.BigInteger s
----------------METHODS----------------

public void <init>(
java.math.BigInteger
java.security.spec.ECParameterSpec)

public java.security.spec.ECParameterSpec getParams()

public java.math.BigInteger getS()

________________CLASS________________


public class java.security.spec.ECPublicKeySpec extends java.lang.Object implements java.security.spec.KeySpec

----------------FIELDS----------------

private final java.security.spec.ECParameterSpec params

private final java.security.spec.ECPoint w
----------------METHODS----------------

public void <init>(
java.security.spec.ECPoint
java.security.spec.ECParameterSpec)

public java.security.spec.ECParameterSpec getParams()

public java.security.spec.ECPoint getW()

________________CLASS________________


public class java.security.spec.EllipticCurve extends java.lang.Object

----------------FIELDS----------------

private final java.math.BigInteger a

private final java.math.BigInteger b

private final java.security.spec.ECField field

private volatile int hash

private final byte[] seed
----------------METHODS----------------

public void <init>(
java.security.spec.ECField
java.math.BigInteger
java.math.BigInteger)

public void <init>(
java.security.spec.ECField
java.math.BigInteger
java.math.BigInteger
byte[])

public boolean equals(
java.lang.Object)

public java.math.BigInteger getA()

public java.math.BigInteger getB()

public java.security.spec.ECField getField()

public byte[] getSeed()

public int hashCode()

________________CLASS________________


public abstract class java.security.spec.EncodedKeySpec extends java.lang.Object implements java.security.spec.KeySpec

----------------FIELDS----------------

private final byte[] encodedKey
----------------METHODS----------------

public void <init>(
byte[])

public byte[] getEncoded()

public abstract java.lang.String getFormat()

________________CLASS________________


public class java.security.spec.InvalidKeySpecException extends java.security.GeneralSecurityException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.Throwable)

public void <init>(
java.lang.Throwable)

________________CLASS________________


public class java.security.spec.InvalidParameterSpecException extends java.security.GeneralSecurityException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class java.security.spec.MGF1ParameterSpec extends java.lang.Object implements java.security.spec.AlgorithmParameterSpec

----------------FIELDS----------------

public static final java.security.spec.MGF1ParameterSpec SHA1

public static final java.security.spec.MGF1ParameterSpec SHA256

public static final java.security.spec.MGF1ParameterSpec SHA384

public static final java.security.spec.MGF1ParameterSpec SHA512

private final java.lang.String mdName
----------------METHODS----------------

static void <clinit>()

public void <init>(
java.lang.String)

public java.lang.String getDigestAlgorithm()

________________CLASS________________


public class java.security.spec.PKCS8EncodedKeySpec extends java.security.spec.EncodedKeySpec

----------------FIELDS----------------
----------------METHODS----------------

public void <init>(
byte[])

public byte[] getEncoded()

public final java.lang.String getFormat()

________________CLASS________________


public class java.security.spec.PSSParameterSpec extends java.lang.Object implements java.security.spec.AlgorithmParameterSpec

----------------FIELDS----------------

public static final java.security.spec.PSSParameterSpec DEFAULT

private final java.lang.String mdName

private final java.lang.String mgfName

private final java.security.spec.AlgorithmParameterSpec mgfSpec

private final int saltLen

private final int trailerField
----------------METHODS----------------

static void <clinit>()

public void <init>(
int)

public void <init>(
java.lang.String
java.lang.String
java.security.spec.AlgorithmParameterSpec
int
int)

public java.lang.String getDigestAlgorithm()

public java.lang.String getMGFAlgorithm()

public java.security.spec.AlgorithmParameterSpec getMGFParameters()

public int getSaltLength()

public int getTrailerField()

________________CLASS________________


public class java.security.spec.RSAKeyGenParameterSpec extends java.lang.Object implements java.security.spec.AlgorithmParameterSpec

----------------FIELDS----------------

public static final java.math.BigInteger F0

public static final java.math.BigInteger F4

private final int keysize

private final java.math.BigInteger publicExponent
----------------METHODS----------------

static void <clinit>()

public void <init>(
int
java.math.BigInteger)

public int getKeysize()

public java.math.BigInteger getPublicExponent()

________________CLASS________________


public class java.security.spec.RSAPrivateKeySpec extends java.lang.Object implements java.security.spec.KeySpec

----------------FIELDS----------------

private final java.math.BigInteger modulus

private final java.math.BigInteger privateExponent
----------------METHODS----------------

public void <init>(
java.math.BigInteger
java.math.BigInteger)

public java.math.BigInteger getModulus()

public java.math.BigInteger getPrivateExponent()

________________CLASS________________


public class java.security.spec.RSAMultiPrimePrivateCrtKeySpec extends java.security.spec.RSAPrivateKeySpec

----------------FIELDS----------------

private final java.math.BigInteger crtCoefficient

private final java.security.spec.RSAOtherPrimeInfo[] otherPrimeInfo

private final java.math.BigInteger primeExponentP

private final java.math.BigInteger primeExponentQ

private final java.math.BigInteger primeP

private final java.math.BigInteger primeQ

private final java.math.BigInteger publicExponent
----------------METHODS----------------

public void <init>(
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger
java.security.spec.RSAOtherPrimeInfo[])

public java.math.BigInteger getCrtCoefficient()

public java.security.spec.RSAOtherPrimeInfo[] getOtherPrimeInfo()

public java.math.BigInteger getPrimeExponentP()

public java.math.BigInteger getPrimeExponentQ()

public java.math.BigInteger getPrimeP()

public java.math.BigInteger getPrimeQ()

public java.math.BigInteger getPublicExponent()

________________CLASS________________


public class java.security.spec.RSAOtherPrimeInfo extends java.lang.Object

----------------FIELDS----------------

private final java.math.BigInteger crtCoefficient

private final java.math.BigInteger prime

private final java.math.BigInteger primeExponent
----------------METHODS----------------

public void <init>(
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger)

public final java.math.BigInteger getCrtCoefficient()

public final java.math.BigInteger getExponent()

public final java.math.BigInteger getPrime()

________________CLASS________________


public class java.security.spec.RSAPrivateCrtKeySpec extends java.security.spec.RSAPrivateKeySpec

----------------FIELDS----------------

private final java.math.BigInteger crtCoefficient

private final java.math.BigInteger primeExponentP

private final java.math.BigInteger primeExponentQ

private final java.math.BigInteger primeP

private final java.math.BigInteger primeQ

private final java.math.BigInteger publicExponent
----------------METHODS----------------

public void <init>(
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger)

public java.math.BigInteger getCrtCoefficient()

public java.math.BigInteger getPrimeExponentP()

public java.math.BigInteger getPrimeExponentQ()

public java.math.BigInteger getPrimeP()

public java.math.BigInteger getPrimeQ()

public java.math.BigInteger getPublicExponent()

________________CLASS________________


public class java.security.spec.RSAPublicKeySpec extends java.lang.Object implements java.security.spec.KeySpec

----------------FIELDS----------------

private final java.math.BigInteger modulus

private final java.math.BigInteger publicExponent
----------------METHODS----------------

public void <init>(
java.math.BigInteger
java.math.BigInteger)

public java.math.BigInteger getModulus()

public java.math.BigInteger getPublicExponent()

________________CLASS________________


public class java.security.spec.X509EncodedKeySpec extends java.security.spec.EncodedKeySpec

----------------FIELDS----------------
----------------METHODS----------------

public void <init>(
byte[])

public byte[] getEncoded()

public final java.lang.String getFormat()

________________CLASS________________


public abstract interface class java.sql.Array extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.Object getArray()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.Object getArray(
long
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
@dalvik.annotation.Signature (value =(JILjava/util/Map<Ljava/lang/String;Ljava/lang/Class<*>;>;)Ljava/lang/Object; )
public abstract java.lang.Object getArray(
long
int
java.util.Map)
@dalvik.annotation.Signature (value =(Ljava/util/Map<Ljava/lang/String;Ljava/lang/Class<*>;>;)Ljava/lang/Object; )
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.Object getArray(
java.util.Map)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getBaseType()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String getBaseTypeName()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.ResultSet getResultSet()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.ResultSet getResultSet(
long
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
@dalvik.annotation.Signature (value =(JILjava/util/Map<Ljava/lang/String;Ljava/lang/Class<*>;>;)Ljava/sql/ResultSet; )
public abstract java.sql.ResultSet getResultSet(
long
int
java.util.Map)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
@dalvik.annotation.Signature (value =(Ljava/util/Map<Ljava/lang/String;Ljava/lang/Class<*>;>;)Ljava/sql/ResultSet; )
public abstract java.sql.ResultSet getResultSet(
java.util.Map)

________________CLASS________________


public class java.sql.SQLException extends java.lang.Exception implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

private java.lang.String SQLState

private java.sql.SQLException next

private int vendorCode
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.String)

public void <init>(
java.lang.String
java.lang.String
int)

public int getErrorCode()

public java.sql.SQLException getNextException()

public java.lang.String getSQLState()

public void setNextException(
java.sql.SQLException)

________________CLASS________________


public class java.sql.BatchUpdateException extends java.sql.SQLException implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

private int[] updateCounts
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String
java.lang.String
int
int[])

public void <init>(
java.lang.String
java.lang.String
int[])

public void <init>(
java.lang.String
int[])

public void <init>(
int[])

public int[] getUpdateCounts()

________________CLASS________________


public abstract interface class java.sql.Blob extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.io.InputStream getBinaryStream()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract byte[] getBytes(
long
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract long length()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract long position(
java.sql.Blob
long)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract long position(
byte[]
long)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.io.OutputStream setBinaryStream(
long)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int setBytes(
long
byte[])
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int setBytes(
long
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void truncate(
long)

________________CLASS________________


public abstract interface class java.sql.CallableStatement extends java.lang.Object implements java.sql.PreparedStatement

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Array getArray(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Array getArray(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.math.BigDecimal getBigDecimal(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
@java.lang.Deprecated
public abstract java.math.BigDecimal getBigDecimal(
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.math.BigDecimal getBigDecimal(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Blob getBlob(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Blob getBlob(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean getBoolean(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean getBoolean(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract byte getByte(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract byte getByte(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract byte[] getBytes(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract byte[] getBytes(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Clob getClob(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Clob getClob(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Date getDate(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Date getDate(
int
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Date getDate(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Date getDate(
java.lang.String
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract double getDouble(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract double getDouble(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract float getFloat(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract float getFloat(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getInt(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getInt(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract long getLong(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract long getLong(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.Object getObject(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
@dalvik.annotation.Signature (value =(ILjava/util/Map<Ljava/lang/String;Ljava/lang/Class<*>;>;)Ljava/lang/Object; )
public abstract java.lang.Object getObject(
int
java.util.Map)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.Object getObject(
java.lang.String)
@dalvik.annotation.Signature (value =(Ljava/lang/String;Ljava/util/Map<Ljava/lang/String;Ljava/lang/Class<*>;>;)Ljava/lang/Object; )
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.Object getObject(
java.lang.String
java.util.Map)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Ref getRef(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Ref getRef(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract short getShort(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract short getShort(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String getString(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String getString(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Time getTime(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Time getTime(
int
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Time getTime(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Time getTime(
java.lang.String
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Timestamp getTimestamp(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Timestamp getTimestamp(
int
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Timestamp getTimestamp(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Timestamp getTimestamp(
java.lang.String
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.net.URL getURL(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.net.URL getURL(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void registerOutParameter(
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void registerOutParameter(
int
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void registerOutParameter(
int
int
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void registerOutParameter(
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void registerOutParameter(
java.lang.String
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void registerOutParameter(
java.lang.String
int
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setAsciiStream(
java.lang.String
java.io.InputStream
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setBigDecimal(
java.lang.String
java.math.BigDecimal)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setBinaryStream(
java.lang.String
java.io.InputStream
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setBoolean(
java.lang.String
boolean)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setByte(
java.lang.String
byte)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setBytes(
java.lang.String
byte[])
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setCharacterStream(
java.lang.String
java.io.Reader
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setDate(
java.lang.String
java.sql.Date)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setDate(
java.lang.String
java.sql.Date
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setDouble(
java.lang.String
double)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setFloat(
java.lang.String
float)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setInt(
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setLong(
java.lang.String
long)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setNull(
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setNull(
java.lang.String
int
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setObject(
java.lang.String
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setObject(
java.lang.String
java.lang.Object
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setObject(
java.lang.String
java.lang.Object
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setShort(
java.lang.String
short)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setString(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setTime(
java.lang.String
java.sql.Time)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setTime(
java.lang.String
java.sql.Time
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setTimestamp(
java.lang.String
java.sql.Timestamp)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setTimestamp(
java.lang.String
java.sql.Timestamp
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setURL(
java.lang.String
java.net.URL)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean wasNull()

________________CLASS________________


public abstract interface class java.sql.Clob extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.io.InputStream getAsciiStream()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.io.Reader getCharacterStream()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String getSubString(
long
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract long length()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract long position(
java.lang.String
long)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract long position(
java.sql.Clob
long)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.io.OutputStream setAsciiStream(
long)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.io.Writer setCharacterStream(
long)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int setString(
long
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int setString(
long
java.lang.String
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void truncate(
long)

________________CLASS________________


public class java.sql.SQLWarning extends java.sql.SQLException implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.String)

public void <init>(
java.lang.String
java.lang.String
int)

public java.sql.SQLWarning getNextWarning()

public void setNextWarning(
java.sql.SQLWarning)

________________CLASS________________


public class java.sql.DataTruncation extends java.sql.SQLWarning implements java.io.Serializable

----------------FIELDS----------------

private static final int THE_ERROR_CODE

private static final java.lang.String THE_REASON

private static final java.lang.String THE_SQLSTATE

private static final long serialVersionUID

private int dataSize

private int index

private boolean parameter

private boolean read

private int transferSize
----------------METHODS----------------

public void <init>(
int
boolean
boolean
int
int)

public int getDataSize()

public int getIndex()

public boolean getParameter()

public boolean getRead()

public int getTransferSize()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/io/Serializable;Ljava/lang/Cloneable;Ljava/lang/Comparable<Ljava/util/Date;>; )
public class java.util.Date extends java.lang.Object implements java.io.Serializable, java.lang.Cloneable, java.lang.Comparable

----------------FIELDS----------------

private static int creationYear

private static final long serialVersionUID

private transient long milliseconds
----------------METHODS----------------

static void <clinit>()

public void <init>()
@java.lang.Deprecated
public void <init>(
int
int
int)
@java.lang.Deprecated
public void <init>(
int
int
int
int
int)
@java.lang.Deprecated
public void <init>(
int
int
int
int
int
int)

public void <init>(
long)
@java.lang.Deprecated
public void <init>(
java.lang.String)
@java.lang.Deprecated
public static long UTC(
int
int
int
int
int
int)

private static int parse(
java.lang.String
java.lang.String[])
@java.lang.Deprecated
public static long parse(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

private static int zone(
java.lang.String)

public boolean after(
java.util.Date)

public boolean before(
java.util.Date)

public java.lang.Object clone()

public volatile int compareTo(
java.lang.Object)

public int compareTo(
java.util.Date)

public boolean equals(
java.lang.Object)
@java.lang.Deprecated
public int getDate()
@java.lang.Deprecated
public int getDay()
@java.lang.Deprecated
public int getHours()
@java.lang.Deprecated
public int getMinutes()
@java.lang.Deprecated
public int getMonth()
@java.lang.Deprecated
public int getSeconds()

public long getTime()
@java.lang.Deprecated
public int getTimezoneOffset()
@java.lang.Deprecated
public int getYear()

public int hashCode()
@java.lang.Deprecated
public void setDate(
int)
@java.lang.Deprecated
public void setHours(
int)
@java.lang.Deprecated
public void setMinutes(
int)
@java.lang.Deprecated
public void setMonth(
int)
@java.lang.Deprecated
public void setSeconds(
int)

public void setTime(
long)
@java.lang.Deprecated
public void setYear(
int)
@java.lang.Deprecated
public java.lang.String toGMTString()
@java.lang.Deprecated
public java.lang.String toLocaleString()

public java.lang.String toString()

________________CLASS________________


public class java.sql.Date extends java.util.Date

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------
@java.lang.Deprecated
public void <init>(
int
int
int)

public void <init>(
long)

private static long normalizeTime(
long)

public static java.sql.Date valueOf(
java.lang.String)
@java.lang.Deprecated
public int getHours()
@java.lang.Deprecated
public int getMinutes()
@java.lang.Deprecated
public int getSeconds()
@java.lang.Deprecated
public void setHours(
int)
@java.lang.Deprecated
public void setMinutes(
int)
@java.lang.Deprecated
public void setSeconds(
int)

public void setTime(
long)

public java.lang.String toString()

________________CLASS________________


public class java.sql.DriverManager extends java.lang.Object

----------------FIELDS----------------

private static final java.sql.SQLPermission logPermission

private static int loginTimeout
@dalvik.annotation.Signature (value =Ljava/util/Set<Ljava/sql/Driver;>; )
private static final java.util.Set theDriverSet

private static java.io.PrintStream thePrintStream

private static java.io.PrintWriter thePrintWriter
----------------METHODS----------------

static void <clinit>()

private void <init>()

private static void checkLogSecurity()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public static void deregisterDriver(
java.sql.Driver)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public static java.sql.Connection getConnection(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public static java.sql.Connection getConnection(
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public static java.sql.Connection getConnection(
java.lang.String
java.util.Properties)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public static java.sql.Driver getDriver(
java.lang.String)
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<Ljava/sql/Driver;>; )
public static java.util.Enumeration getDrivers()
@java.lang.Deprecated
public static java.io.PrintStream getLogStream()

public static java.io.PrintWriter getLogWriter()

public static int getLoginTimeout()

private static boolean isClassFromClassLoader(
java.lang.Object
java.lang.ClassLoader)

private static void loadInitialDrivers()

public static void println(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public static void registerDriver(
java.sql.Driver)
@java.lang.Deprecated
public static void setLogStream(
java.io.PrintStream)

public static void setLogWriter(
java.io.PrintWriter)

public static void setLoginTimeout(
int)

________________CLASS________________


public class java.sql.DriverPropertyInfo extends java.lang.Object

----------------FIELDS----------------

public java.lang.String[] choices

public java.lang.String description

public java.lang.String name

public boolean required

public java.lang.String value
----------------METHODS----------------

public void <init>(
java.lang.String
java.lang.String)

________________CLASS________________


public abstract interface class java.sql.ParameterMetaData extends java.lang.Object

----------------FIELDS----------------

public static final int parameterModeIn

public static final int parameterModeInOut

public static final int parameterModeOut

public static final int parameterModeUnknown

public static final int parameterNoNulls

public static final int parameterNullable

public static final int parameterNullableUnknown
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String getParameterClassName(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getParameterCount()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getParameterMode(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getParameterType(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String getParameterTypeName(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getPrecision(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getScale(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int isNullable(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean isSigned(
int)

________________CLASS________________


public abstract interface class java.sql.Ref extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String getBaseTypeName()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.Object getObject()
@dalvik.annotation.Signature (value =(Ljava/util/Map<Ljava/lang/String;Ljava/lang/Class<*>;>;)Ljava/lang/Object; )
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.Object getObject(
java.util.Map)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setObject(
java.lang.Object)

________________CLASS________________


public abstract interface class java.sql.SQLData extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String getSQLTypeName()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void readSQL(
java.sql.SQLInput
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void writeSQL(
java.sql.SQLOutput)

________________CLASS________________


public abstract interface class java.sql.SQLInput extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Array readArray()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.io.InputStream readAsciiStream()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.math.BigDecimal readBigDecimal()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.io.InputStream readBinaryStream()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Blob readBlob()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean readBoolean()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract byte readByte()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract byte[] readBytes()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.io.Reader readCharacterStream()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Clob readClob()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Date readDate()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract double readDouble()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract float readFloat()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int readInt()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract long readLong()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.Object readObject()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Ref readRef()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract short readShort()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String readString()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Time readTime()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Timestamp readTimestamp()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.net.URL readURL()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean wasNull()

________________CLASS________________


public abstract interface class java.sql.SQLOutput extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void writeArray(
java.sql.Array)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void writeAsciiStream(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void writeBigDecimal(
java.math.BigDecimal)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void writeBinaryStream(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void writeBlob(
java.sql.Blob)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void writeBoolean(
boolean)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void writeByte(
byte)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void writeBytes(
byte[])
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void writeCharacterStream(
java.io.Reader)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void writeClob(
java.sql.Clob)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void writeDate(
java.sql.Date)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void writeDouble(
double)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void writeFloat(
float)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void writeInt(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void writeLong(
long)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void writeObject(
java.sql.SQLData)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void writeRef(
java.sql.Ref)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void writeShort(
short)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void writeString(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void writeStruct(
java.sql.Struct)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void writeTime(
java.sql.Time)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void writeTimestamp(
java.sql.Timestamp)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void writeURL(
java.net.URL)

________________CLASS________________


public final class java.sql.SQLPermission extends java.security.BasicPermission implements java.security.Guard, java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.String)

________________CLASS________________


public abstract interface class java.sql.Savepoint extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getSavepointId()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String getSavepointName()

________________CLASS________________


public abstract interface class java.sql.Struct extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.Object[] getAttributes()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
@dalvik.annotation.Signature (value =(Ljava/util/Map<Ljava/lang/String;Ljava/lang/Class<*>;>;)[Ljava/lang/Object; )
public abstract java.lang.Object[] getAttributes(
java.util.Map)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String getSQLTypeName()

________________CLASS________________


public class java.sql.Time extends java.util.Date

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------
@java.lang.Deprecated
public void <init>(
int
int
int)

public void <init>(
long)

public static java.sql.Time valueOf(
java.lang.String)
@java.lang.Deprecated
public int getDate()
@java.lang.Deprecated
public int getDay()
@java.lang.Deprecated
public int getMonth()
@java.lang.Deprecated
public int getYear()
@java.lang.Deprecated
public void setDate(
int)
@java.lang.Deprecated
public void setMonth(
int)

public void setTime(
long)
@java.lang.Deprecated
public void setYear(
int)

public java.lang.String toString()

________________CLASS________________


public class java.sql.Timestamp extends java.util.Date

----------------FIELDS----------------

private static final long serialVersionUID

private int nanos
----------------METHODS----------------
@java.lang.Deprecated
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public void <init>(
int
int
int
int
int
int
int)

public void <init>(
long)

private java.lang.String format(
int
int)

private java.lang.String stripTrailingZeros(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public static java.sql.Timestamp valueOf(
java.lang.String)

public boolean after(
java.sql.Timestamp)

public boolean before(
java.sql.Timestamp)

public volatile int compareTo(
java.lang.Object)

public int compareTo(
java.sql.Timestamp)
@dalvik.annotation.Throws (value =Ljava/lang/ClassCastException; )
public int compareTo(
java.util.Date)

public boolean equals(
java.lang.Object)

public boolean equals(
java.sql.Timestamp)

public int getNanos()

public long getTime()
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public void setNanos(
int)

public void setTime(
long)

public java.lang.String toString()

________________CLASS________________


public class java.sql.Types extends java.lang.Object

----------------FIELDS----------------

public static final int ARRAY

public static final int BIGINT

public static final int BINARY

public static final int BIT

public static final int BLOB

public static final int BOOLEAN

public static final int CHAR

public static final int CLOB

public static final int DATALINK

public static final int DATE

public static final int DECIMAL

public static final int DISTINCT

public static final int DOUBLE

public static final int FLOAT

public static final int INTEGER

public static final int JAVA_OBJECT

public static final int LONGVARBINARY

public static final int LONGVARCHAR

public static final int NULL

public static final int NUMERIC

public static final int OTHER

public static final int REAL

public static final int REF

public static final int SMALLINT

public static final int STRUCT

public static final int TIME

public static final int TIMESTAMP

public static final int TINYINT

public static final int VARBINARY

public static final int VARCHAR
----------------METHODS----------------

private void <init>()

________________CLASS________________


public class java.text.Annotation extends java.lang.Object

----------------FIELDS----------------

private java.lang.Object value
----------------METHODS----------------

public void <init>(
java.lang.Object)

public java.lang.Object getValue()

public java.lang.String toString()

________________CLASS________________


public abstract interface class java.text.CharacterIterator extends java.lang.Object implements java.lang.Cloneable

----------------FIELDS----------------

public static final char DONE
----------------METHODS----------------

public abstract java.lang.Object clone()

public abstract char current()

public abstract char first()

public abstract int getBeginIndex()

public abstract int getEndIndex()

public abstract int getIndex()

public abstract char last()

public abstract char next()

public abstract char previous()

public abstract char setIndex(
int)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/text/AttributedCharacterIterator$Attribute; )
public abstract interface class java.text.AttributedCharacterIterator extends java.lang.Object implements java.text.CharacterIterator

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/text/AttributedCharacterIterator$Attribute;>; )
public abstract java.util.Set getAllAttributeKeys()

public abstract java.lang.Object getAttribute(
java.text.AttributedCharacterIterator$Attribute)
@dalvik.annotation.Signature (value =()Ljava/util/Map<Ljava/text/AttributedCharacterIterator$Attribute;Ljava/lang/Object;>; )
public abstract java.util.Map getAttributes()

public abstract int getRunLimit()

public abstract int getRunLimit(
java.text.AttributedCharacterIterator$Attribute)
@dalvik.annotation.Signature (value =(Ljava/util/Set<+Ljava/text/AttributedCharacterIterator$Attribute;>;)I )
public abstract int getRunLimit(
java.util.Set)

public abstract int getRunStart()

public abstract int getRunStart(
java.text.AttributedCharacterIterator$Attribute)
@dalvik.annotation.Signature (value =(Ljava/util/Set<+Ljava/text/AttributedCharacterIterator$Attribute;>;)I )
public abstract int getRunStart(
java.util.Set)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =AttributedIterator )
@dalvik.annotation.EnclosingClass (value =Ljava/text/AttributedString; )
 class java.text.AttributedString$AttributedIterator extends java.lang.Object implements java.text.AttributedCharacterIterator

----------------FIELDS----------------

private java.text.AttributedString attrString
@dalvik.annotation.Signature (value =Ljava/util/HashSet<Ljava/text/AttributedCharacterIterator$Attribute;>; )
private java.util.HashSet attributesAllowed

private int begin

private int end

private int offset
----------------METHODS----------------

 void <init>(
java.text.AttributedString)

 void <init>(
java.text.AttributedString
java.text.AttributedCharacterIterator$Attribute[]
int
int)
@dalvik.annotation.Signature (value =(Ljava/util/List<Ljava/text/AttributedString$Range;>;)Ljava/lang/Object; )
private java.lang.Object currentValue(
java.util.List)

private boolean inRange(
java.text.AttributedString$Range)
@dalvik.annotation.Signature (value =(Ljava/util/List<Ljava/text/AttributedString$Range;>;)Z )
private boolean inRange(
java.util.List)
@dalvik.annotation.Signature (value =(Ljava/util/List<Ljava/text/AttributedString$Range;>;)I )
private int runLimit(
java.util.List)
@dalvik.annotation.Signature (value =(Ljava/util/List<Ljava/text/AttributedString$Range;>;)I )
private int runStart(
java.util.List)

public java.lang.Object clone()

public char current()

public char first()
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/text/AttributedCharacterIterator$Attribute;>; )
public java.util.Set getAllAttributeKeys()

public java.lang.Object getAttribute(
java.text.AttributedCharacterIterator$Attribute)
@dalvik.annotation.Signature (value =()Ljava/util/Map<Ljava/text/AttributedCharacterIterator$Attribute;Ljava/lang/Object;>; )
public java.util.Map getAttributes()

public int getBeginIndex()

public int getEndIndex()

public int getIndex()

public int getRunLimit()

public int getRunLimit(
java.text.AttributedCharacterIterator$Attribute)
@dalvik.annotation.Signature (value =(Ljava/util/Set<+Ljava/text/AttributedCharacterIterator$Attribute;>;)I )
public int getRunLimit(
java.util.Set)

public int getRunStart()

public int getRunStart(
java.text.AttributedCharacterIterator$Attribute)
@dalvik.annotation.Signature (value =(Ljava/util/Set<+Ljava/text/AttributedCharacterIterator$Attribute;>;)I )
public int getRunStart(
java.util.Set)

public char last()

public char next()

public char previous()

public char setIndex(
int)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =Range )
@dalvik.annotation.EnclosingClass (value =Ljava/text/AttributedString; )
 class java.text.AttributedString$Range extends java.lang.Object

----------------FIELDS----------------

 int end

 int start

 java.lang.Object value
----------------METHODS----------------

 void <init>(
int
int
java.lang.Object)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/text/AttributedString$AttributedIterator;Ljava/text/AttributedString$Range; )
public class java.text.AttributedString extends java.lang.Object

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Map<Ljava/text/AttributedCharacterIterator$Attribute;Ljava/util/List<Ljava/text/AttributedString$Range;>;>; )
 java.util.Map attributeMap

 java.lang.String text
----------------METHODS----------------

public void <init>(
java.lang.String)
@dalvik.annotation.Signature (value =(Ljava/lang/String;Ljava/util/Map<+Ljava/text/AttributedCharacterIterator$Attribute;*>;)V )
public void <init>(
java.lang.String
java.util.Map)

public void <init>(
java.text.AttributedCharacterIterator)

public void <init>(
java.text.AttributedCharacterIterator
int
int)
@dalvik.annotation.Signature (value =(Ljava/text/AttributedCharacterIterator;IILjava/util/Set<Ljava/text/AttributedCharacterIterator$Attribute;>;)V )
private void <init>(
java.text.AttributedCharacterIterator
int
int
java.util.Set)

public void <init>(
java.text.AttributedCharacterIterator
int
int
java.text.AttributedCharacterIterator$Attribute[])

public void addAttribute(
java.text.AttributedCharacterIterator$Attribute
java.lang.Object)

public void addAttribute(
java.text.AttributedCharacterIterator$Attribute
java.lang.Object
int
int)
@dalvik.annotation.Signature (value =(Ljava/util/Map<+Ljava/text/AttributedCharacterIterator$Attribute;*>;II)V )
public void addAttributes(
java.util.Map
int
int)

public java.text.AttributedCharacterIterator getIterator()

public java.text.AttributedCharacterIterator getIterator(
java.text.AttributedCharacterIterator$Attribute[])

public java.text.AttributedCharacterIterator getIterator(
java.text.AttributedCharacterIterator$Attribute[]
int
int)

________________CLASS________________


public final class java.text.Bidi extends java.lang.Object

----------------FIELDS----------------

public static final int DIRECTION_DEFAULT_LEFT_TO_RIGHT

public static final int DIRECTION_DEFAULT_RIGHT_TO_LEFT

public static final int DIRECTION_LEFT_TO_RIGHT

public static final int DIRECTION_RIGHT_TO_LEFT

private int baseLevel

private int direction

private int length

private byte[] offsetLevel

private org.apache.harmony.text.BidiRun[] runs

private boolean unidirectional
----------------METHODS----------------

private void <init>(
long)

public void <init>(
java.lang.String
int)

public void <init>(
java.text.AttributedCharacterIterator)

public void <init>(
char[]
int
byte[]
int
int
int)

private static long createUBiDi(
char[]
int
byte[]
int
int
int)

private void readBidiInfo(
long)

public static void reorderVisually(
byte[]
int
java.lang.Object[]
int
int)

public static boolean requiresBidi(
char[]
int
int)

public boolean baseIsLeftToRight()

public java.text.Bidi createLineBidi(
int
int)

public int getBaseLevel()

public int getLength()

public int getLevelAt(
int)

public int getRunCount()

public int getRunLevel(
int)

public int getRunLimit(
int)

public int getRunStart(
int)

public boolean isLeftToRight()

public boolean isMixed()

public boolean isRightToLeft()

public java.lang.String toString()

________________CLASS________________


public abstract class java.text.BreakIterator extends java.lang.Object implements java.lang.Cloneable

----------------FIELDS----------------

public static final int DONE

private static final int INT_LENGTH

private static final int LONG_LENGTH

private static final int SHORT_LENGTH

 com.ibm.icu4jni.text.BreakIterator wrapped
----------------METHODS----------------

protected void <init>()

 void <init>(
com.ibm.icu4jni.text.BreakIterator)

public static java.util.Locale[] getAvailableLocales()

public static java.text.BreakIterator getCharacterInstance()

public static java.text.BreakIterator getCharacterInstance(
java.util.Locale)

protected static int getInt(
byte[]
int)

public static java.text.BreakIterator getLineInstance()

public static java.text.BreakIterator getLineInstance(
java.util.Locale)

protected static long getLong(
byte[]
int)

public static java.text.BreakIterator getSentenceInstance()

public static java.text.BreakIterator getSentenceInstance(
java.util.Locale)

protected static short getShort(
byte[]
int)

public static java.text.BreakIterator getWordInstance()

public static java.text.BreakIterator getWordInstance(
java.util.Locale)

public java.lang.Object clone()

public abstract int current()

public abstract int first()

public abstract int following(
int)

public abstract java.text.CharacterIterator getText()

public boolean isBoundary(
int)

public abstract int last()

public abstract int next()

public abstract int next(
int)

public int preceding(
int)

public abstract int previous()

public void setText(
java.lang.String)

public abstract void setText(
java.text.CharacterIterator)

________________CLASS________________


public class java.text.ChoiceFormat extends java.text.NumberFormat

----------------FIELDS----------------

private static final long serialVersionUID

private java.lang.String[] choiceFormats

private double[] choiceLimits
----------------METHODS----------------

public void <init>(
java.lang.String)

public void <init>(
double[]
java.lang.String[])

public static final double nextDouble(
double)

public static double nextDouble(
double
boolean)

public static final double previousDouble(
double)

private int skipWhitespace(
java.lang.String
int)

public void applyPattern(
java.lang.String)

public java.lang.Object clone()

public boolean equals(
java.lang.Object)

public java.lang.StringBuffer format(
double
java.lang.StringBuffer
java.text.FieldPosition)

public java.lang.StringBuffer format(
long
java.lang.StringBuffer
java.text.FieldPosition)

public java.lang.Object[] getFormats()

public double[] getLimits()

public int hashCode()

public java.lang.Number parse(
java.lang.String
java.text.ParsePosition)

public void setChoices(
double[]
java.lang.String[])

public java.lang.String toPattern()

________________CLASS________________


public final class java.text.CollationElementIterator extends java.lang.Object

----------------FIELDS----------------

public static final int NULLORDER

private com.ibm.icu4jni.text.CollationElementIterator icuIterator
----------------METHODS----------------

 void <init>(
com.ibm.icu4jni.text.CollationElementIterator)

public static final int primaryOrder(
int)

public static final short secondaryOrder(
int)

public static final short tertiaryOrder(
int)

public int getMaxExpansion(
int)

public int getOffset()

public int next()

public int previous()

public void reset()

public void setOffset(
int)

public void setText(
java.lang.String)

public void setText(
java.text.CharacterIterator)

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/lang/Comparable<Ljava/text/CollationKey;>; )
public final class java.text.CollationKey extends java.lang.Object implements java.lang.Comparable

----------------FIELDS----------------

private com.ibm.icu4jni.text.CollationKey icuKey

private java.lang.String source
----------------METHODS----------------

 void <init>(
java.lang.String
com.ibm.icu4jni.text.CollationKey)

public volatile int compareTo(
java.lang.Object)

public int compareTo(
java.text.CollationKey)

public boolean equals(
java.lang.Object)

public java.lang.String getSourceString()

public int hashCode()

public byte[] toByteArray()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Comparator<Ljava/lang/Object;>;Ljava/lang/Cloneable; )
public abstract class java.text.Collator extends java.lang.Object implements java.util.Comparator, java.lang.Cloneable

----------------FIELDS----------------

private static int CACHE_SIZE

public static final int CANONICAL_DECOMPOSITION

static final int EQUAL

public static final int FULL_DECOMPOSITION

static final int GREATER

public static final int IDENTICAL

static final int LESS

public static final int NO_DECOMPOSITION

public static final int PRIMARY

public static final int SECONDARY

public static final int TERTIARY
@dalvik.annotation.Signature (value =Ljava/util/Vector<Ljava/text/Collator;>; )
private static java.util.Vector cache

 com.ibm.icu4jni.text.Collator icuColl
----------------METHODS----------------

static void <clinit>()

protected void <init>()

 void <init>(
com.ibm.icu4jni.text.Collator)

private int decompositionMode_ICU_Java(
int)

private int decompositionMode_Java_ICU(
int)

public static java.util.Locale[] getAvailableLocales()

public static java.text.Collator getInstance()

public static java.text.Collator getInstance(
java.util.Locale)

private int strength_ICU_Java(
int)

private int strength_Java_ICU(
int)

public java.lang.Object clone()

public int compare(
java.lang.Object
java.lang.Object)

public abstract int compare(
java.lang.String
java.lang.String)

public boolean equals(
java.lang.Object)

public boolean equals(
java.lang.String
java.lang.String)

public abstract java.text.CollationKey getCollationKey(
java.lang.String)

public int getDecomposition()

public int getStrength()

public abstract int hashCode()

public void setDecomposition(
int)

public void setStrength(
int)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =Field )
@dalvik.annotation.EnclosingClass (value =Ljava/text/Format; )
public class java.text.Format$Field extends java.text.AttributedCharacterIterator$Attribute

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

protected void <init>(
java.lang.String)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/text/DateFormat; )
@dalvik.annotation.InnerClass (accessFlags =9 name =Field )
public class java.text.DateFormat$Field extends java.text.Format$Field

----------------FIELDS----------------

public static final java.text.DateFormat$Field AM_PM

public static final java.text.DateFormat$Field DAY_OF_MONTH

public static final java.text.DateFormat$Field DAY_OF_WEEK

public static final java.text.DateFormat$Field DAY_OF_WEEK_IN_MONTH

public static final java.text.DateFormat$Field DAY_OF_YEAR

public static final java.text.DateFormat$Field ERA

public static final java.text.DateFormat$Field HOUR0

public static final java.text.DateFormat$Field HOUR1

public static final java.text.DateFormat$Field HOUR_OF_DAY0

public static final java.text.DateFormat$Field HOUR_OF_DAY1

public static final java.text.DateFormat$Field MILLISECOND

public static final java.text.DateFormat$Field MINUTE

public static final java.text.DateFormat$Field MONTH

public static final java.text.DateFormat$Field SECOND

public static final java.text.DateFormat$Field TIME_ZONE

public static final java.text.DateFormat$Field WEEK_OF_MONTH

public static final java.text.DateFormat$Field WEEK_OF_YEAR

public static final java.text.DateFormat$Field YEAR

private static final long serialVersionUID
@dalvik.annotation.Signature (value =Ljava/util/Hashtable<Ljava/lang/Integer;Ljava/text/DateFormat$Field;>; )
private static java.util.Hashtable table

private int calendarField
----------------METHODS----------------

static void <clinit>()

protected void <init>(
java.lang.String
int)

public static java.text.DateFormat$Field ofCalendarField(
int)

public int getCalendarField()
@dalvik.annotation.Throws (value =Ljava/io/InvalidObjectException; )
protected java.lang.Object readResolve()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/text/DateFormat$Field; )
public abstract class java.text.DateFormat extends java.text.Format

----------------FIELDS----------------

public static final int AM_PM_FIELD

public static final int DATE_FIELD

public static final int DAY_OF_WEEK_FIELD

public static final int DAY_OF_WEEK_IN_MONTH_FIELD

public static final int DAY_OF_YEAR_FIELD

public static final int DEFAULT

public static final int ERA_FIELD

public static final int FULL

public static final int HOUR0_FIELD

public static final int HOUR1_FIELD

public static final int HOUR_OF_DAY0_FIELD

public static final int HOUR_OF_DAY1_FIELD

public static final int LONG

public static final int MEDIUM

public static final int MILLISECOND_FIELD

public static final int MINUTE_FIELD

public static final int MONTH_FIELD

public static final int SECOND_FIELD

public static final int SHORT

public static final int TIMEZONE_FIELD

public static final int WEEK_OF_MONTH_FIELD

public static final int WEEK_OF_YEAR_FIELD

public static final int YEAR_FIELD

private static final long serialVersionUID

protected java.util.Calendar calendar

protected java.text.NumberFormat numberFormat
----------------METHODS----------------

protected void <init>()

private static void checkDateStyle(
int)

private static void checkTimeStyle(
int)

public static java.util.Locale[] getAvailableLocales()

public static final java.text.DateFormat getDateInstance()

public static final java.text.DateFormat getDateInstance(
int)

public static final java.text.DateFormat getDateInstance(
int
java.util.Locale)

public static final java.text.DateFormat getDateTimeInstance()

public static final java.text.DateFormat getDateTimeInstance(
int
int)

public static final java.text.DateFormat getDateTimeInstance(
int
int
java.util.Locale)

public static final java.text.DateFormat getInstance()

static java.lang.String getStyleName(
int)

public static final java.text.DateFormat getTimeInstance()

public static final java.text.DateFormat getTimeInstance(
int)

public static final java.text.DateFormat getTimeInstance(
int
java.util.Locale)

public java.lang.Object clone()

public boolean equals(
java.lang.Object)

public final java.lang.String format(
java.util.Date)

public final java.lang.StringBuffer format(
java.lang.Object
java.lang.StringBuffer
java.text.FieldPosition)

public abstract java.lang.StringBuffer format(
java.util.Date
java.lang.StringBuffer
java.text.FieldPosition)

public java.util.Calendar getCalendar()

public java.text.NumberFormat getNumberFormat()

public java.util.TimeZone getTimeZone()

public int hashCode()

public boolean isLenient()
@dalvik.annotation.Throws (value =Ljava/text/ParseException; )
public java.util.Date parse(
java.lang.String)

public abstract java.util.Date parse(
java.lang.String
java.text.ParsePosition)

public java.lang.Object parseObject(
java.lang.String
java.text.ParsePosition)

public void setCalendar(
java.util.Calendar)

public void setLenient(
boolean)

public void setNumberFormat(
java.text.NumberFormat)

public void setTimeZone(
java.util.TimeZone)

________________CLASS________________


public class java.text.DateFormatSymbols extends java.lang.Object implements java.io.Serializable, java.lang.Cloneable

----------------FIELDS----------------

private static final long serialVersionUID

 java.lang.String[] ampms

 java.lang.String[] eras

private java.lang.String localPatternChars

final transient java.util.Locale locale

 java.lang.String[] months

 java.lang.String[] shortMonths

 java.lang.String[] shortWeekdays

 java.lang.String[] weekdays

 java.lang.String[][] zoneStrings
----------------METHODS----------------

public void <init>()

public void <init>(
java.util.Locale)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

public java.lang.Object clone()

public boolean equals(
java.lang.Object)

public java.lang.String[] getAmPmStrings()

public java.lang.String[] getEras()

public java.lang.String getLocalPatternChars()

public java.lang.String[] getMonths()

public java.lang.String[] getShortMonths()

public java.lang.String[] getShortWeekdays()

public java.lang.String[] getWeekdays()

public java.lang.String[][] getZoneStrings()

public int hashCode()

 java.lang.String[][] internalZoneStrings()

public void setAmPmStrings(
java.lang.String[])

public void setEras(
java.lang.String[])

public void setLocalPatternChars(
java.lang.String)

public void setMonths(
java.lang.String[])

public void setShortMonths(
java.lang.String[])

public void setShortWeekdays(
java.lang.String[])

public void setWeekdays(
java.lang.String[])

public void setZoneStrings(
java.lang.String[][])

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/reflect/Field;>; )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
 class java.text.DecimalFormat$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final java.text.DecimalFormat this$0

final java.lang.String val$fieldName

final java.lang.Object val$target

final java.lang.Object val$value
----------------METHODS----------------

 void <init>(
java.text.DecimalFormat
java.lang.Object
java.lang.String
java.lang.Object)

public volatile java.lang.Object run()

public java.lang.reflect.Field run()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/Object;>; )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
 class java.text.DecimalFormat$2 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final java.text.DecimalFormat this$0

final java.lang.String val$fieldName

final java.lang.Object val$target
----------------METHODS----------------

 void <init>(
java.text.DecimalFormat
java.lang.Object
java.lang.String)

public java.lang.Object run()

________________CLASS________________


public class java.text.DecimalFormat extends java.text.NumberFormat

----------------FIELDS----------------

private static final int CURRENT_SERIAL_VERTION

private static final java.lang.Double NEGATIVE_ZERO_DOUBLE

private static final java.io.ObjectStreamField[] serialPersistentFields

private static final long serialVersionUID

private transient com.ibm.icu4jni.text.DecimalFormat dform

private transient com.ibm.icu4jni.text.DecimalFormatSymbols icuSymbols

private transient boolean parseBigDecimal

private transient int serialVersionOnStream

private transient java.text.DecimalFormatSymbols symbols
----------------METHODS----------------

static void <clinit>()

public void <init>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.text.DecimalFormatSymbols)

private void copySymbols(
com.ibm.icu4jni.text.DecimalFormatSymbols
java.text.DecimalFormatSymbols)

private java.lang.Object getInternalField(
java.lang.String
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)

private void setInternalField(
java.lang.String
java.lang.Object
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void writeObject(
java.io.ObjectOutputStream)

public void applyLocalizedPattern(
java.lang.String)

public void applyPattern(
java.lang.String)

public java.lang.Object clone()

public boolean equals(
java.lang.Object)

public java.lang.StringBuffer format(
double
java.lang.StringBuffer
java.text.FieldPosition)

public java.lang.StringBuffer format(
long
java.lang.StringBuffer
java.text.FieldPosition)

public final java.lang.StringBuffer format(
java.lang.Object
java.lang.StringBuffer
java.text.FieldPosition)

public java.text.AttributedCharacterIterator formatToCharacterIterator(
java.lang.Object)

public java.util.Currency getCurrency()

public java.text.DecimalFormatSymbols getDecimalFormatSymbols()

public int getGroupingSize()

public int getMultiplier()

public java.lang.String getNegativePrefix()

public java.lang.String getNegativeSuffix()

public java.lang.String getPositivePrefix()

public java.lang.String getPositiveSuffix()

public int hashCode()

public boolean isDecimalSeparatorAlwaysShown()

public boolean isGroupingUsed()

public boolean isParseBigDecimal()

public boolean isParseIntegerOnly()

public java.lang.Number parse(
java.lang.String
java.text.ParsePosition)

public void setCurrency(
java.util.Currency)

public void setDecimalFormatSymbols(
java.text.DecimalFormatSymbols)

public void setDecimalSeparatorAlwaysShown(
boolean)

public void setGroupingSize(
int)

public void setGroupingUsed(
boolean)

public void setMaximumFractionDigits(
int)

public void setMaximumIntegerDigits(
int)

public void setMinimumFractionDigits(
int)

public void setMinimumIntegerDigits(
int)

public void setMultiplier(
int)

public void setNegativePrefix(
java.lang.String)

public void setNegativeSuffix(
java.lang.String)

public void setParseBigDecimal(
boolean)

public void setParseIntegerOnly(
boolean)

public void setPositivePrefix(
java.lang.String)

public void setPositiveSuffix(
java.lang.String)

public java.lang.String toLocalizedPattern()

public java.lang.String toPattern()

________________CLASS________________


public final class java.text.DecimalFormatSymbols extends java.lang.Object implements java.lang.Cloneable, java.io.Serializable

----------------FIELDS----------------

private static final java.io.ObjectStreamField[] serialPersistentFields

private static final long serialVersionUID

private final int DecimalSeparator

private final int Digit

private final int Exponent

private final int GroupingSeparator

private final int MinusSign

private final int MonetaryDecimalSeparator

private java.lang.String NaN

private final int PatternSeparator

private final int PerMill

private final int Percent

private final int ZeroDigit

private transient java.util.Currency currency

private java.lang.String currencySymbol

private java.lang.String infinity

private java.lang.String intlCurrencySymbol

private transient java.util.Locale locale

transient char[] patternChars
----------------METHODS----------------

static void <clinit>()

public void <init>()

public void <init>(
java.util.Locale)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

public java.lang.Object clone()

public boolean equals(
java.lang.Object)

public java.util.Currency getCurrency()

public java.lang.String getCurrencySymbol()

public char getDecimalSeparator()

public char getDigit()

 char getExponential()

public char getGroupingSeparator()

public java.lang.String getInfinity()

public java.lang.String getInternationalCurrencySymbol()

 java.lang.String getLocalPatternChars()

public char getMinusSign()

public char getMonetaryDecimalSeparator()

public java.lang.String getNaN()

public char getPatternSeparator()

public char getPerMill()

public char getPercent()

public char getZeroDigit()

public int hashCode()

public void setCurrency(
java.util.Currency)

public void setCurrencySymbol(
java.lang.String)

public void setDecimalSeparator(
char)

public void setDigit(
char)

 void setExponential(
char)

public void setGroupingSeparator(
char)

public void setInfinity(
java.lang.String)

public void setInternationalCurrencySymbol(
java.lang.String)

public void setMinusSign(
char)

public void setMonetaryDecimalSeparator(
char)

public void setNaN(
java.lang.String)

public void setPatternSeparator(
char)

public void setPerMill(
char)

public void setPercent(
char)

public void setZeroDigit(
char)

________________CLASS________________


public class java.text.FieldPosition extends java.lang.Object

----------------FIELDS----------------

private int beginIndex

private int endIndex

private java.text.Format$Field myAttribute

private int myField
----------------METHODS----------------

public void <init>(
int)

public void <init>(
java.text.Format$Field)

public void <init>(
java.text.Format$Field
int)

 void clear()

public boolean equals(
java.lang.Object)

public int getBeginIndex()

public int getEndIndex()

public int getField()

public java.text.Format$Field getFieldAttribute()

public int hashCode()

public void setBeginIndex(
int)

public void setEndIndex(
int)

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/util/ResourceBundle;>; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
final class java.text.Format$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final java.util.Locale val$locale
----------------METHODS----------------

 void <init>(
java.util.Locale)

public volatile java.lang.Object run()

public java.util.ResourceBundle run()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =Field )
@dalvik.annotation.EnclosingClass (value =Ljava/text/MessageFormat; )
public class java.text.MessageFormat$Field extends java.text.Format$Field

----------------FIELDS----------------

public static final java.text.MessageFormat$Field ARGUMENT

private static final long serialVersionUID
----------------METHODS----------------

static void <clinit>()

protected void <init>(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/InvalidObjectException; )
protected java.lang.Object readResolve()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/text/MessageFormat; )
@dalvik.annotation.InnerClass (accessFlags =10 name =FieldContainer )
 class java.text.MessageFormat$FieldContainer extends java.lang.Object

----------------FIELDS----------------

 java.text.AttributedCharacterIterator$Attribute attribute

 int end

 int start

 java.lang.Object value
----------------METHODS----------------

public void <init>(
int
int
java.text.AttributedCharacterIterator$Attribute
java.lang.Object)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/text/MessageFormat$Field;Ljava/text/MessageFormat$FieldContainer; )
public class java.text.MessageFormat extends java.text.Format

----------------FIELDS----------------

private static final java.io.ObjectStreamField[] serialPersistentFields

private static final long serialVersionUID

private int[] argumentNumbers

private java.text.Format[] formats

private java.util.Locale locale

private transient int maxArgumentIndex

private int maxOffset

private transient java.lang.String[] strings
----------------METHODS----------------

static void <clinit>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.util.Locale)

private void appendQuoted(
java.lang.StringBuffer
java.lang.String)

private java.lang.String decodeDecimalFormat(
java.lang.StringBuffer
java.text.Format)

private java.lang.String decodeSimpleDateFormat(
java.lang.StringBuffer
java.text.Format)

public static transient java.lang.String format(
java.lang.String
java.lang.Object[])
@dalvik.annotation.Signature (value =([Ljava/lang/Object;Ljava/lang/StringBuffer;Ljava/text/FieldPosition;Ljava/util/Vector<Ljava/text/MessageFormat$FieldContainer;>;)Ljava/lang/StringBuffer; )
private java.lang.StringBuffer formatImpl(
java.lang.Object[]
java.lang.StringBuffer
java.text.FieldPosition
java.util.Vector)
@dalvik.annotation.Signature (value =(IIILjava/text/FieldPosition;Ljava/util/Vector<Ljava/text/MessageFormat$FieldContainer;>;)V )
private void handleArgumentField(
int
int
int
java.text.FieldPosition
java.util.Vector)
@dalvik.annotation.Signature (value =(Ljava/text/Format;Ljava/lang/Object;ILjava/util/Vector<Ljava/text/MessageFormat$FieldContainer;>;)V )
private void handleformat(
java.text.Format
java.lang.Object
int
java.util.Vector)

private int match(
java.lang.String
java.text.ParsePosition
boolean
java.lang.String[])

private java.text.Format parseVariable(
java.lang.String
java.text.ParsePosition)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

public void applyPattern(
java.lang.String)

public java.lang.Object clone()

public boolean equals(
java.lang.Object)

public final java.lang.StringBuffer format(
java.lang.Object
java.lang.StringBuffer
java.text.FieldPosition)

public final java.lang.StringBuffer format(
java.lang.Object[]
java.lang.StringBuffer
java.text.FieldPosition)

public java.text.AttributedCharacterIterator formatToCharacterIterator(
java.lang.Object)

public java.text.Format[] getFormats()

public java.text.Format[] getFormatsByArgumentIndex()

public java.util.Locale getLocale()

public int hashCode()
@dalvik.annotation.Throws (value =Ljava/text/ParseException; )
public java.lang.Object[] parse(
java.lang.String)

public java.lang.Object[] parse(
java.lang.String
java.text.ParsePosition)

public java.lang.Object parseObject(
java.lang.String
java.text.ParsePosition)

public void setFormat(
int
java.text.Format)

public void setFormatByArgumentIndex(
int
java.text.Format)

public void setFormats(
java.text.Format[])

public void setFormatsByArgumentIndex(
java.text.Format[])

public void setLocale(
java.util.Locale)

public java.lang.String toPattern()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =Field )
@dalvik.annotation.EnclosingClass (value =Ljava/text/NumberFormat; )
public class java.text.NumberFormat$Field extends java.text.Format$Field

----------------FIELDS----------------

public static final java.text.NumberFormat$Field CURRENCY

public static final java.text.NumberFormat$Field DECIMAL_SEPARATOR

public static final java.text.NumberFormat$Field EXPONENT

public static final java.text.NumberFormat$Field EXPONENT_SIGN

public static final java.text.NumberFormat$Field EXPONENT_SYMBOL

public static final java.text.NumberFormat$Field FRACTION

public static final java.text.NumberFormat$Field GROUPING_SEPARATOR

public static final java.text.NumberFormat$Field INTEGER

public static final java.text.NumberFormat$Field PERCENT

public static final java.text.NumberFormat$Field PERMILLE

public static final java.text.NumberFormat$Field SIGN

private static final long serialVersionUID
----------------METHODS----------------

static void <clinit>()

protected void <init>(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/InvalidObjectException; )
protected java.lang.Object readResolve()

________________CLASS________________


public class java.text.ParseException extends java.lang.Exception

----------------FIELDS----------------

private static final long serialVersionUID

private int errorOffset
----------------METHODS----------------

public void <init>(
java.lang.String
int)

public int getErrorOffset()

________________CLASS________________


public class java.text.ParsePosition extends java.lang.Object

----------------FIELDS----------------

private int currentPosition

private int errorIndex
----------------METHODS----------------

public void <init>(
int)

public boolean equals(
java.lang.Object)

public int getErrorIndex()

public int getIndex()

public int hashCode()

public void setErrorIndex(
int)

public void setIndex(
int)

public java.lang.String toString()

________________CLASS________________


 class java.text.RuleBasedBreakIterator extends java.text.BreakIterator

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
com.ibm.icu4jni.text.BreakIterator)

private void validateOffset(
int)

public java.lang.Object clone()

public int current()

public boolean equals(
java.lang.Object)

public int first()

public int following(
int)

public java.text.CharacterIterator getText()

public int hashCode()

public boolean isBoundary(
int)

public int last()

public int next()

public int next(
int)

public int preceding(
int)

public int previous()

public void setText(
java.text.CharacterIterator)

public java.lang.String toString()

________________CLASS________________


public class java.text.RuleBasedCollator extends java.text.Collator

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
com.ibm.icu4jni.text.Collator)
@dalvik.annotation.Throws (value =Ljava/text/ParseException; )
public void <init>(
java.lang.String)

public java.lang.Object clone()

public int compare(
java.lang.String
java.lang.String)

public boolean equals(
java.lang.Object)

public java.text.CollationElementIterator getCollationElementIterator(
java.lang.String)

public java.text.CollationElementIterator getCollationElementIterator(
java.text.CharacterIterator)

public java.text.CollationKey getCollationKey(
java.lang.String)

public java.lang.String getRules()

public int hashCode()

________________CLASS________________


public class java.text.SimpleDateFormat extends java.text.DateFormat

----------------FIELDS----------------

private static final java.lang.String patternChars

private static final java.io.ObjectStreamField[] serialPersistentFields

private static final long serialVersionUID

private transient int creationYear

private java.util.Date defaultCenturyStart

private java.text.DateFormatSymbols formatData

private java.lang.String pattern
----------------METHODS----------------

static void <clinit>()

public void <init>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.text.DateFormatSymbols)

public void <init>(
java.lang.String
java.util.Locale)

private void <init>(
java.util.Locale)
@dalvik.annotation.Signature (value =(Ljava/lang/StringBuffer;Ljava/text/FieldPosition;Ljava/util/Vector<Ljava/text/FieldPosition;>;CI)V )
private void append(
java.lang.StringBuffer
java.text.FieldPosition
java.util.Vector
char
int)

private void appendNumber(
java.lang.StringBuffer
int
int)

private void appendTimeZone(
java.lang.StringBuffer
int
boolean)

private static java.lang.String defaultPattern()

private java.util.Date error(
java.text.ParsePosition
int
java.util.TimeZone)
@dalvik.annotation.Signature (value =(Ljava/util/Date;Ljava/lang/StringBuffer;Ljava/text/FieldPosition;Ljava/util/Vector<Ljava/text/FieldPosition;>;)Ljava/lang/StringBuffer; )
private java.lang.StringBuffer formatImpl(
java.util.Date
java.lang.StringBuffer
java.text.FieldPosition
java.util.Vector)

private java.text.AttributedCharacterIterator formatToCharacterIteratorImpl(
java.util.Date)

private int parse(
java.lang.String
int
char
int)

private int parseNumber(
int
java.lang.String
int
int
int)

private java.lang.Number parseNumber(
int
java.lang.String
java.text.ParsePosition)

private int parseText(
java.lang.String
int
java.lang.String[]
int)

private int parseTimeZone(
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)

private void validateFormat(
char)

private void validatePattern(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

public void applyLocalizedPattern(
java.lang.String)

public void applyPattern(
java.lang.String)

public java.lang.Object clone()

public boolean equals(
java.lang.Object)

public java.lang.StringBuffer format(
java.util.Date
java.lang.StringBuffer
java.text.FieldPosition)

public java.text.AttributedCharacterIterator formatToCharacterIterator(
java.lang.Object)

public java.util.Date get2DigitYearStart()

public java.text.DateFormatSymbols getDateFormatSymbols()

public int hashCode()

public java.util.Date parse(
java.lang.String
java.text.ParsePosition)

public void set2DigitYearStart(
java.util.Date)

public void setDateFormatSymbols(
java.text.DateFormatSymbols)

public java.lang.String toLocalizedPattern()

public java.lang.String toPattern()

________________CLASS________________


public final class java.text.StringCharacterIterator extends java.lang.Object implements java.text.CharacterIterator

----------------FIELDS----------------

 int end

 int offset

 int start

 java.lang.String string
----------------METHODS----------------

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
int)

public void <init>(
java.lang.String
int
int
int)

public java.lang.Object clone()

public char current()

public boolean equals(
java.lang.Object)

public char first()

public int getBeginIndex()

public int getEndIndex()

public int getIndex()

public int hashCode()

public char last()

public char next()

public char previous()

public char setIndex(
int)

public void setText(
java.lang.String)

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/lang/Object;Ljava/lang/Iterable<TE;>; )
public abstract interface class java.util.Collection extends java.lang.Object implements java.lang.Iterable

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =(TE;)Z )
public abstract boolean add(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<+TE;>;)Z )
public abstract boolean addAll(
java.util.Collection)

public abstract void clear()

public abstract boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public abstract boolean containsAll(
java.util.Collection)

public abstract boolean equals(
java.lang.Object)

public abstract int hashCode()

public abstract boolean isEmpty()
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TE;>; )
public abstract java.util.Iterator iterator()

public abstract boolean remove(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public abstract boolean removeAll(
java.util.Collection)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public abstract boolean retainAll(
java.util.Collection)

public abstract int size()

public abstract java.lang.Object[] toArray()
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>([TT;)[TT; )
public abstract java.lang.Object[] toArray(
java.lang.Object[])

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Collection<TE;>; )
public abstract class java.util.AbstractCollection extends java.lang.Object implements java.util.Collection

----------------FIELDS----------------
----------------METHODS----------------

protected void <init>()
@dalvik.annotation.Signature (value =(TE;)Z )
public boolean add(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<+TE;>;)Z )
public boolean addAll(
java.util.Collection)

public void clear()

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public boolean containsAll(
java.util.Collection)

public boolean isEmpty()
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TE;>; )
public abstract java.util.Iterator iterator()

public boolean remove(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public boolean removeAll(
java.util.Collection)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public boolean retainAll(
java.util.Collection)

public abstract int size()

public java.lang.Object[] toArray()
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>([TT;)[TT; )
public java.lang.Object[] toArray(
java.lang.Object[])

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =2 name =SimpleListIterator )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Iterator<TE;>; )
@dalvik.annotation.EnclosingClass (value =Ljava/util/AbstractList; )
 class java.util.AbstractList$SimpleListIterator extends java.lang.Object implements java.util.Iterator

----------------FIELDS----------------

 int expectedModCount

 int lastPosition

 int pos

final java.util.AbstractList this$0
----------------METHODS----------------

 void <init>(
java.util.AbstractList)

public boolean hasNext()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object next()

public void remove()

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Iterator<TE;>; )
public abstract interface class java.util.ListIterator extends java.lang.Object implements java.util.Iterator

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =(TE;)V )
public abstract void add(
java.lang.Object)

public abstract boolean hasNext()

public abstract boolean hasPrevious()
@dalvik.annotation.Signature (value =()TE; )
public abstract java.lang.Object next()

public abstract int nextIndex()
@dalvik.annotation.Signature (value =()TE; )
public abstract java.lang.Object previous()

public abstract int previousIndex()

public abstract void remove()
@dalvik.annotation.Signature (value =(TE;)V )
public abstract void set(
java.lang.Object)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/AbstractList; )
@dalvik.annotation.InnerClass (accessFlags =18 name =FullListIterator )
@dalvik.annotation.Signature (value =Ljava/util/AbstractList<TE;>.SimpleListIterator;Ljava/util/ListIterator<TE;>; )
final class java.util.AbstractList$FullListIterator extends java.util.AbstractList$SimpleListIterator implements java.util.ListIterator

----------------FIELDS----------------

final java.util.AbstractList this$0
----------------METHODS----------------

 void <init>(
java.util.AbstractList
int)
@dalvik.annotation.Signature (value =(TE;)V )
public void add(
java.lang.Object)

public boolean hasPrevious()

public int nextIndex()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object previous()

public int previousIndex()
@dalvik.annotation.Signature (value =(TE;)V )
public void set(
java.lang.Object)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/AbstractList$SubAbstractList; )
@dalvik.annotation.InnerClass (accessFlags =26 name =SubAbstractListIterator )
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/ListIterator<TE;>; )
final class java.util.AbstractList$SubAbstractList$SubAbstractListIterator extends java.lang.Object implements java.util.ListIterator

----------------FIELDS----------------

private int end
@dalvik.annotation.Signature (value =Ljava/util/ListIterator<TE;>; )
private final java.util.ListIterator iterator

private int start
@dalvik.annotation.Signature (value =Ljava/util/AbstractList$SubAbstractList<TE;>; )
private final java.util.AbstractList$SubAbstractList subList
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/ListIterator<TE;>;Ljava/util/AbstractList$SubAbstractList<TE;>;II)V )
 void <init>(
java.util.ListIterator
java.util.AbstractList$SubAbstractList
int
int)
@dalvik.annotation.Signature (value =(TE;)V )
public void add(
java.lang.Object)

public boolean hasNext()

public boolean hasPrevious()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object next()

public int nextIndex()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object previous()

public int previousIndex()

public void remove()
@dalvik.annotation.Signature (value =(TE;)V )
public void set(
java.lang.Object)

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Collection<TE;>; )
public abstract interface class java.util.List extends java.lang.Object implements java.util.Collection

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =(ITE;)V )
public abstract void add(
int
java.lang.Object)
@dalvik.annotation.Signature (value =(TE;)Z )
public abstract boolean add(
java.lang.Object)
@dalvik.annotation.Signature (value =(ILjava/util/Collection<+TE;>;)Z )
public abstract boolean addAll(
int
java.util.Collection)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<+TE;>;)Z )
public abstract boolean addAll(
java.util.Collection)

public abstract void clear()

public abstract boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public abstract boolean containsAll(
java.util.Collection)

public abstract boolean equals(
java.lang.Object)
@dalvik.annotation.Signature (value =(I)TE; )
public abstract java.lang.Object get(
int)

public abstract int hashCode()

public abstract int indexOf(
java.lang.Object)

public abstract boolean isEmpty()
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TE;>; )
public abstract java.util.Iterator iterator()

public abstract int lastIndexOf(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/ListIterator<TE;>; )
public abstract java.util.ListIterator listIterator()
@dalvik.annotation.Signature (value =(I)Ljava/util/ListIterator<TE;>; )
public abstract java.util.ListIterator listIterator(
int)
@dalvik.annotation.Signature (value =(I)TE; )
public abstract java.lang.Object remove(
int)

public abstract boolean remove(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public abstract boolean removeAll(
java.util.Collection)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public abstract boolean retainAll(
java.util.Collection)
@dalvik.annotation.Signature (value =(ITE;)TE; )
public abstract java.lang.Object set(
int
java.lang.Object)

public abstract int size()
@dalvik.annotation.Signature (value =(II)Ljava/util/List<TE;>; )
public abstract java.util.List subList(
int
int)

public abstract java.lang.Object[] toArray()
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>([TT;)[TT; )
public abstract java.lang.Object[] toArray(
java.lang.Object[])

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/AbstractList$SubAbstractList;Ljava/util/AbstractList$SubAbstractListRandomAccess;Ljava/util/AbstractList$FullListIterator;Ljava/util/AbstractList$SimpleListIterator; )
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/util/AbstractCollection<TE;>;Ljava/util/List<TE;>; )
public abstract class java.util.AbstractList extends java.util.AbstractCollection implements java.util.List

----------------FIELDS----------------

protected transient int modCount
----------------METHODS----------------

protected void <init>()
@dalvik.annotation.Signature (value =(ITE;)V )
public void add(
int
java.lang.Object)
@dalvik.annotation.Signature (value =(TE;)Z )
public boolean add(
java.lang.Object)
@dalvik.annotation.Signature (value =(ILjava/util/Collection<+TE;>;)Z )
public boolean addAll(
int
java.util.Collection)

public void clear()

public boolean equals(
java.lang.Object)
@dalvik.annotation.Signature (value =(I)TE; )
public abstract java.lang.Object get(
int)

public int hashCode()

public int indexOf(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TE;>; )
public java.util.Iterator iterator()

public int lastIndexOf(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/ListIterator<TE;>; )
public java.util.ListIterator listIterator()
@dalvik.annotation.Signature (value =(I)Ljava/util/ListIterator<TE;>; )
public java.util.ListIterator listIterator(
int)
@dalvik.annotation.Signature (value =(I)TE; )
public java.lang.Object remove(
int)

protected void removeRange(
int
int)
@dalvik.annotation.Signature (value =(ITE;)TE; )
public java.lang.Object set(
int
java.lang.Object)
@dalvik.annotation.Signature (value =(II)Ljava/util/List<TE;>; )
public java.util.List subList(
int
int)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/AbstractList$SubAbstractList$SubAbstractListIterator; )
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/util/AbstractList<TE;>; )
@dalvik.annotation.InnerClass (accessFlags =10 name =SubAbstractList )
@dalvik.annotation.EnclosingClass (value =Ljava/util/AbstractList; )
 class java.util.AbstractList$SubAbstractList extends java.util.AbstractList

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/AbstractList<TE;>; )
private final java.util.AbstractList fullList

private int offset

private int size
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/AbstractList<TE;>;II)V )
 void <init>(
java.util.AbstractList
int
int)
@dalvik.annotation.Signature (value =(ITE;)V )
public void add(
int
java.lang.Object)
@dalvik.annotation.Signature (value =(ILjava/util/Collection<+TE;>;)Z )
public boolean addAll(
int
java.util.Collection)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<+TE;>;)Z )
public boolean addAll(
java.util.Collection)
@dalvik.annotation.Signature (value =(I)TE; )
public java.lang.Object get(
int)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TE;>; )
public java.util.Iterator iterator()
@dalvik.annotation.Signature (value =(I)Ljava/util/ListIterator<TE;>; )
public java.util.ListIterator listIterator(
int)
@dalvik.annotation.Signature (value =(I)TE; )
public java.lang.Object remove(
int)

protected void removeRange(
int
int)
@dalvik.annotation.Signature (value =(ITE;)TE; )
public java.lang.Object set(
int
java.lang.Object)

public int size()

 void sizeChanged(
boolean)

________________CLASS________________


public abstract interface class java.util.RandomAccess extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =26 name =SubAbstractListRandomAccess )
@dalvik.annotation.EnclosingClass (value =Ljava/util/AbstractList; )
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/util/AbstractList$SubAbstractList<TE;>;Ljava/util/RandomAccess; )
final class java.util.AbstractList$SubAbstractListRandomAccess extends java.util.AbstractList$SubAbstractList implements java.util.RandomAccess

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/AbstractList<TE;>;II)V )
 void <init>(
java.util.AbstractList
int
int)

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Iterator<TK;>; )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
 class java.util.AbstractMap$1$1 extends java.lang.Object implements java.util.Iterator

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Iterator<Ljava/util/Map$Entry<TK;TV;>;>; )
 java.util.Iterator setIterator

final java.util.AbstractMap$1 this$1
----------------METHODS----------------

 void <init>(
java.util.AbstractMap$1)

public boolean hasNext()
@dalvik.annotation.Signature (value =()TK; )
public java.lang.Object next()

public void remove()

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Collection<TE;>; )
public abstract interface class java.util.Set extends java.lang.Object implements java.util.Collection

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =(TE;)Z )
public abstract boolean add(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<+TE;>;)Z )
public abstract boolean addAll(
java.util.Collection)

public abstract void clear()

public abstract boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public abstract boolean containsAll(
java.util.Collection)

public abstract boolean equals(
java.lang.Object)

public abstract int hashCode()

public abstract boolean isEmpty()
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TE;>; )
public abstract java.util.Iterator iterator()

public abstract boolean remove(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public abstract boolean removeAll(
java.util.Collection)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public abstract boolean retainAll(
java.util.Collection)

public abstract int size()

public abstract java.lang.Object[] toArray()
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>([TT;)[TT; )
public abstract java.lang.Object[] toArray(
java.lang.Object[])

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/util/AbstractCollection<TE;>;Ljava/util/Set<TE;>; )
public abstract class java.util.AbstractSet extends java.util.AbstractCollection implements java.util.Set

----------------FIELDS----------------
----------------METHODS----------------

protected void <init>()

public boolean equals(
java.lang.Object)

public int hashCode()
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public boolean removeAll(
java.util.Collection)

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/util/AbstractSet<TK;>; )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
 class java.util.AbstractMap$1 extends java.util.AbstractSet

----------------FIELDS----------------

final java.util.AbstractMap this$0
----------------METHODS----------------

 void <init>(
java.util.AbstractMap)

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TK;>; )
public java.util.Iterator iterator()

public int size()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Iterator<TV;>; )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
 class java.util.AbstractMap$2$1 extends java.lang.Object implements java.util.Iterator

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Iterator<Ljava/util/Map$Entry<TK;TV;>;>; )
 java.util.Iterator setIterator

final java.util.AbstractMap$2 this$1
----------------METHODS----------------

 void <init>(
java.util.AbstractMap$2)

public boolean hasNext()
@dalvik.annotation.Signature (value =()TV; )
public java.lang.Object next()

public void remove()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.Signature (value =Ljava/util/AbstractCollection<TV;>; )
 class java.util.AbstractMap$2 extends java.util.AbstractCollection

----------------FIELDS----------------

final java.util.AbstractMap this$0
----------------METHODS----------------

 void <init>(
java.util.AbstractMap)

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TV;>; )
public java.util.Iterator iterator()

public int size()

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Collection<TE;>; )
public abstract interface class java.util.Queue extends java.lang.Object implements java.util.Collection

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =()TE; )
public abstract java.lang.Object element()
@dalvik.annotation.Signature (value =(TE;)Z )
public abstract boolean offer(
java.lang.Object)
@dalvik.annotation.Signature (value =()TE; )
public abstract java.lang.Object peek()
@dalvik.annotation.Signature (value =()TE; )
public abstract java.lang.Object poll()
@dalvik.annotation.Signature (value =()TE; )
public abstract java.lang.Object remove()

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/util/AbstractCollection<TE;>;Ljava/util/Queue<TE;>; )
public abstract class java.util.AbstractQueue extends java.util.AbstractCollection implements java.util.Queue

----------------FIELDS----------------
----------------METHODS----------------

protected void <init>()
@dalvik.annotation.Signature (value =(TE;)Z )
public boolean add(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<+TE;>;)Z )
public boolean addAll(
java.util.Collection)

public void clear()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object element()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object remove()

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/util/AbstractList<TE;>; )
public abstract class java.util.AbstractSequentialList extends java.util.AbstractList

----------------FIELDS----------------
----------------METHODS----------------

protected void <init>()
@dalvik.annotation.Signature (value =(ITE;)V )
public void add(
int
java.lang.Object)
@dalvik.annotation.Signature (value =(ILjava/util/Collection<+TE;>;)Z )
public boolean addAll(
int
java.util.Collection)
@dalvik.annotation.Signature (value =(I)TE; )
public java.lang.Object get(
int)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TE;>; )
public java.util.Iterator iterator()
@dalvik.annotation.Signature (value =(I)Ljava/util/ListIterator<TE;>; )
public abstract java.util.ListIterator listIterator(
int)
@dalvik.annotation.Signature (value =(I)TE; )
public java.lang.Object remove(
int)
@dalvik.annotation.Signature (value =(ITE;)TE; )
public java.lang.Object set(
int
java.lang.Object)

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/util/AbstractList<TE;>;Ljava/util/List<TE;>;Ljava/lang/Cloneable;Ljava/io/Serializable;Ljava/util/RandomAccess; )
public class java.util.ArrayList extends java.util.AbstractList implements java.util.List, java.lang.Cloneable, java.io.Serializable, java.util.RandomAccess

----------------FIELDS----------------

private static final java.lang.Object[] emptyArray

private static final java.io.ObjectStreamField[] serialPersistentFields

private static final long serialVersionUID
@dalvik.annotation.Signature (value =[TE; )
private transient java.lang.Object[] array

private transient int firstIndex

private transient int lastIndex
----------------METHODS----------------

static void <clinit>()

public void <init>()

public void <init>(
int)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<+TE;>;)V )
public void <init>(
java.util.Collection)

private void growAtEnd(
int)

private void growAtFront(
int)

private void growForInsert(
int
int)
@dalvik.annotation.Signature (value =(I)[TE; )
private java.lang.Object[] newElementArray(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)
@dalvik.annotation.Signature (value =(ITE;)V )
public void add(
int
java.lang.Object)
@dalvik.annotation.Signature (value =(TE;)Z )
public boolean add(
java.lang.Object)
@dalvik.annotation.Signature (value =(ILjava/util/Collection<+TE;>;)Z )
public boolean addAll(
int
java.util.Collection)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<+TE;>;)Z )
public boolean addAll(
java.util.Collection)

public void clear()

public java.lang.Object clone()

public boolean contains(
java.lang.Object)

public void ensureCapacity(
int)
@dalvik.annotation.Signature (value =(I)TE; )
public java.lang.Object get(
int)

public int indexOf(
java.lang.Object)

public boolean isEmpty()

public int lastIndexOf(
java.lang.Object)
@dalvik.annotation.Signature (value =(I)TE; )
public java.lang.Object remove(
int)

public boolean remove(
java.lang.Object)

protected void removeRange(
int
int)
@dalvik.annotation.Signature (value =(ITE;)TE; )
public java.lang.Object set(
int
java.lang.Object)

public int size()

public java.lang.Object[] toArray()
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>([TT;)[TT; )
public java.lang.Object[] toArray(
java.lang.Object[])

public void trimToSize()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/Arrays; )
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/util/AbstractList<TE;>;Ljava/util/List<TE;>;Ljava/io/Serializable;Ljava/util/RandomAccess; )
@dalvik.annotation.InnerClass (accessFlags =10 name =ArrayList )
 class java.util.Arrays$ArrayList extends java.util.AbstractList implements java.util.List, java.io.Serializable, java.util.RandomAccess

----------------FIELDS----------------

private static final long serialVersionUID
@dalvik.annotation.Signature (value =[TE; )
private final java.lang.Object[] a
----------------METHODS----------------
@dalvik.annotation.Signature (value =([TE;)V )
 void <init>(
java.lang.Object[])

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =(I)TE; )
public java.lang.Object get(
int)

public int indexOf(
java.lang.Object)

public int lastIndexOf(
java.lang.Object)
@dalvik.annotation.Signature (value =(ITE;)TE; )
public java.lang.Object set(
int
java.lang.Object)

public int size()

public java.lang.Object[] toArray()
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>([TT;)[TT; )
public java.lang.Object[] toArray(
java.lang.Object[])

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/Arrays$ArrayList; )
public class java.util.Arrays extends java.lang.Object

----------------FIELDS----------------

static final boolean $assertionsDisabled

private static final int SIMPLE_LENGTH
----------------METHODS----------------

static void <clinit>()

private void <init>()
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>([TT;)Ljava/util/List<TT;>; )
public static transient java.util.List asList(
java.lang.Object[])

public static int binarySearch(
byte[]
byte)

public static int binarySearch(
char[]
char)

public static int binarySearch(
double[]
double)

public static int binarySearch(
float[]
float)

public static int binarySearch(
int[]
int)

public static int binarySearch(
long[]
long)

public static int binarySearch(
java.lang.Object[]
java.lang.Object)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>([TT;TT;Ljava/util/Comparator<-TT;>;)I )
public static int binarySearch(
java.lang.Object[]
java.lang.Object
java.util.Comparator)

public static int binarySearch(
short[]
short)

private static int charAt(
java.lang.String
int)

private static void checkBounds(
int
int
int)

private static void copySwap(
java.lang.Object[]
int
java.lang.Object[]
int
int)

public static boolean deepEquals(
java.lang.Object[]
java.lang.Object[])

private static boolean deepEqualsElements(
java.lang.Object
java.lang.Object)

public static int deepHashCode(
java.lang.Object[])

private static int deepHashCodeElement(
java.lang.Object)

public static java.lang.String deepToString(
java.lang.Object[])

private static java.lang.String deepToStringImpl(
java.lang.Object[]
java.lang.Object[]
java.lang.StringBuilder)

private static boolean deepToStringImplContains(
java.lang.Object[]
java.lang.Object)

public static boolean equals(
byte[]
byte[])

public static boolean equals(
char[]
char[])

public static boolean equals(
double[]
double[])

public static boolean equals(
float[]
float[])

public static boolean equals(
int[]
int[])

public static boolean equals(
long[]
long[])

public static boolean equals(
java.lang.Object[]
java.lang.Object[])

public static boolean equals(
short[]
short[])

public static boolean equals(
boolean[]
boolean[])

public static void fill(
byte[]
byte)

public static void fill(
byte[]
int
int
byte)

public static void fill(
char[]
char)

public static void fill(
char[]
int
int
char)

public static void fill(
double[]
double)

public static void fill(
double[]
int
int
double)

public static void fill(
float[]
float)

public static void fill(
float[]
int
int
float)

public static void fill(
int[]
int)

public static void fill(
int[]
int
int
int)

public static void fill(
long[]
int
int
long)

public static void fill(
long[]
long)

public static void fill(
java.lang.Object[]
int
int
java.lang.Object)

public static void fill(
java.lang.Object[]
java.lang.Object)

public static void fill(
short[]
int
int
short)

public static void fill(
short[]
short)

public static void fill(
boolean[]
int
int
boolean)

public static void fill(
boolean[]
boolean)

private static int find(
java.lang.Object[]
java.lang.Comparable
int
int
int)

private static int find(
java.lang.Object[]
java.lang.Object
int
int
int
java.util.Comparator)

public static int hashCode(
byte[])

public static int hashCode(
char[])

public static int hashCode(
double[])

public static int hashCode(
float[])

public static int hashCode(
int[])

public static int hashCode(
long[])

public static int hashCode(
java.lang.Object[])

public static int hashCode(
short[])

public static int hashCode(
boolean[])

private static boolean lessThan(
double
double)

private static boolean lessThan(
float
float)

private static int med3(
byte[]
int
int
int)

private static int med3(
char[]
int
int
int)

private static int med3(
double[]
int
int
int)

private static int med3(
float[]
int
int
int)

private static int med3(
int[]
int
int
int)

private static int med3(
long[]
int
int
int)

private static int med3(
short[]
int
int
int)

private static int medChar(
int
int
int
java.lang.String[]
int)

private static void mergeSort(
java.lang.Object[]
java.lang.Object[]
int
int)

private static void mergeSort(
java.lang.Object[]
java.lang.Object[]
int
int
java.util.Comparator)

private static void sort(
int
int
byte[])

private static void sort(
int
int
char[])

private static void sort(
int
int
double[])

private static void sort(
int
int
float[])

private static void sort(
int
int
int[])

private static void sort(
int
int
long[])

private static void sort(
int
int
java.lang.Object[])
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(II[TT;Ljava/util/Comparator<-TT;>;)V )
private static void sort(
int
int
java.lang.Object[]
java.util.Comparator)

private static void sort(
int
int
short[])

public static void sort(
byte[])

public static void sort(
byte[]
int
int)

public static void sort(
char[])

public static void sort(
char[]
int
int)

public static void sort(
double[])

public static void sort(
double[]
int
int)

public static void sort(
float[])

public static void sort(
float[]
int
int)

public static void sort(
int[])

public static void sort(
int[]
int
int)

public static void sort(
long[])

public static void sort(
long[]
int
int)

public static void sort(
java.lang.Object[])

public static void sort(
java.lang.Object[]
int
int)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>([TT;IILjava/util/Comparator<-TT;>;)V )
public static void sort(
java.lang.Object[]
int
int
java.util.Comparator)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>([TT;Ljava/util/Comparator<-TT;>;)V )
public static void sort(
java.lang.Object[]
java.util.Comparator)

public static void sort(
short[])

public static void sort(
short[]
int
int)

private static void stableStringSort(
java.lang.String[]
int
int)

private static void stableStringSort(
java.lang.String[]
java.lang.String[]
java.lang.String[]
int
int
int)

private static void swap(
int
int
java.lang.Object[])

public static java.lang.String toString(
byte[])

public static java.lang.String toString(
char[])

public static java.lang.String toString(
double[])

public static java.lang.String toString(
float[])

public static java.lang.String toString(
int[])

public static java.lang.String toString(
long[])

public static java.lang.String toString(
java.lang.Object[])

public static java.lang.String toString(
short[])

public static java.lang.String toString(
boolean[])

________________CLASS________________


public class java.util.BitSet extends java.lang.Object implements java.io.Serializable, java.lang.Cloneable

----------------FIELDS----------------

private static final int ELM_SIZE

private static final long serialVersionUID

private long[] bits
----------------METHODS----------------

public void <init>()

public void <init>(
int)

private void <init>(
long[])

private void growBits(
int)

public void and(
java.util.BitSet)

public void andNot(
java.util.BitSet)

public int cardinality()

public void clear()

public void clear(
int)

public void clear(
int
int)

public java.lang.Object clone()

public boolean equals(
java.lang.Object)

public void flip(
int)

public void flip(
int
int)

public java.util.BitSet get(
int
int)

public boolean get(
int)

public int hashCode()

public boolean intersects(
java.util.BitSet)

public boolean isEmpty()

public int length()

public int nextClearBit(
int)

public int nextSetBit(
int)

public void or(
java.util.BitSet)

public void set(
int)

public void set(
int
int)

public void set(
int
int
boolean)

public void set(
int
boolean)

public int size()

public java.lang.String toString()

public void xor(
java.util.BitSet)

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/io/Serializable;Ljava/lang/Cloneable;Ljava/lang/Comparable<Ljava/util/Calendar;>; )
public abstract class java.util.Calendar extends java.lang.Object implements java.io.Serializable, java.lang.Cloneable, java.lang.Comparable

----------------FIELDS----------------

public static final int AM

public static final int AM_PM

public static final int APRIL

public static final int AUGUST

public static final int DATE

public static final int DAY_OF_MONTH

public static final int DAY_OF_WEEK

public static final int DAY_OF_WEEK_IN_MONTH

public static final int DAY_OF_YEAR

public static final int DECEMBER

public static final int DST_OFFSET

public static final int ERA

public static final int FEBRUARY

public static final int FIELD_COUNT

public static final int FRIDAY

public static final int HOUR

public static final int HOUR_OF_DAY

public static final int JANUARY

public static final int JULY

public static final int JUNE

public static final int MARCH

public static final int MAY

public static final int MILLISECOND

public static final int MINUTE

public static final int MONDAY

public static final int MONTH

public static final int NOVEMBER

public static final int OCTOBER

public static final int PM

public static final int SATURDAY

public static final int SECOND

public static final int SEPTEMBER

public static final int SUNDAY

public static final int THURSDAY

public static final int TUESDAY

public static final int UNDECIMBER

public static final int WEDNESDAY

public static final int WEEK_OF_MONTH

public static final int WEEK_OF_YEAR

public static final int YEAR

public static final int ZONE_OFFSET

private static java.lang.String[] fieldNames

private static final java.io.ObjectStreamField[] serialPersistentFields

private static final long serialVersionUID

protected boolean areFieldsSet

protected int[] fields

private int firstDayOfWeek

protected boolean[] isSet

protected boolean isTimeSet

transient int lastDateFieldSet

transient int lastTimeFieldSet

private boolean lenient

private int minimalDaysInFirstWeek

protected long time

private java.util.TimeZone zone
----------------METHODS----------------

static void <clinit>()

protected void <init>()

 void <init>(
java.util.TimeZone)

protected void <init>(
java.util.TimeZone
java.util.Locale)

public static java.util.Locale[] getAvailableLocales()

public static java.util.Calendar getInstance()

public static java.util.Calendar getInstance(
java.util.Locale)

public static java.util.Calendar getInstance(
java.util.TimeZone)

public static java.util.Calendar getInstance(
java.util.TimeZone
java.util.Locale)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

public abstract void add(
int
int)

public boolean after(
java.lang.Object)

public boolean before(
java.lang.Object)

public final void clear()

public final void clear(
int)

public java.lang.Object clone()

public volatile int compareTo(
java.lang.Object)

public int compareTo(
java.util.Calendar)

protected void complete()

protected abstract void computeFields()

protected abstract void computeTime()

public boolean equals(
java.lang.Object)

public int get(
int)

public int getActualMaximum(
int)

public int getActualMinimum(
int)

public int getFirstDayOfWeek()

public abstract int getGreatestMinimum(
int)

public abstract int getLeastMaximum(
int)

public abstract int getMaximum(
int)

public int getMinimalDaysInFirstWeek()

public abstract int getMinimum(
int)

public final java.util.Date getTime()

public long getTimeInMillis()

public java.util.TimeZone getTimeZone()

public int hashCode()

protected final int internalGet(
int)

public boolean isLenient()

public final boolean isSet(
int)

public void roll(
int
int)

public abstract void roll(
int
boolean)

public void set(
int
int)

public final void set(
int
int
int)

public final void set(
int
int
int
int
int)

public final void set(
int
int
int
int
int
int)

public void setFirstDayOfWeek(
int)

public void setLenient(
boolean)

public void setMinimalDaysInFirstWeek(
int)

public final void setTime(
java.util.Date)

public void setTimeInMillis(
long)

public void setTimeZone(
java.util.TimeZone)

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Enumeration<TT;>; )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class java.util.Collections$1 extends java.lang.Object implements java.util.Enumeration

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Iterator<TT;>; )
 java.util.Iterator it

final java.util.Collection val$c
----------------METHODS----------------

 void <init>(
java.util.Collection)

public boolean hasMoreElements()
@dalvik.annotation.Signature (value =()TT; )
public java.lang.Object nextElement()

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Collection<TE;>;Ljava/io/Serializable; )
@dalvik.annotation.InnerClass (accessFlags =10 name =CheckedCollection )
@dalvik.annotation.EnclosingClass (value =Ljava/util/Collections; )
 class java.util.Collections$CheckedCollection extends java.lang.Object implements java.util.Collection, java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID
@dalvik.annotation.Signature (value =Ljava/util/Collection<TE;>; )
 java.util.Collection c
@dalvik.annotation.Signature (value =Ljava/lang/Class<TE;>; )
 java.lang.Class type
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/Collection<TE;>;Ljava/lang/Class<TE;>;)V )
public void <init>(
java.util.Collection
java.lang.Class)
@dalvik.annotation.Signature (value =(TE;)Z )
public boolean add(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<+TE;>;)Z )
public boolean addAll(
java.util.Collection)

public void clear()

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public boolean containsAll(
java.util.Collection)

public boolean isEmpty()
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TE;>; )
public java.util.Iterator iterator()

public boolean remove(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public boolean removeAll(
java.util.Collection)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public boolean retainAll(
java.util.Collection)

public int size()

public java.lang.Object[] toArray()
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>([TT;)[TT; )
public java.lang.Object[] toArray(
java.lang.Object[])

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/Collections; )
@dalvik.annotation.InnerClass (accessFlags =10 name =CheckedList )
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/util/Collections$CheckedCollection<TE;>;Ljava/util/List<TE;>; )
 class java.util.Collections$CheckedList extends java.util.Collections$CheckedCollection implements java.util.List

----------------FIELDS----------------

private static final long serialVersionUID
@dalvik.annotation.Signature (value =Ljava/util/List<TE;>; )
 java.util.List l
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/List<TE;>;Ljava/lang/Class<TE;>;)V )
public void <init>(
java.util.List
java.lang.Class)
@dalvik.annotation.Signature (value =(ITE;)V )
public void add(
int
java.lang.Object)
@dalvik.annotation.Signature (value =(ILjava/util/Collection<+TE;>;)Z )
public boolean addAll(
int
java.util.Collection)

public boolean equals(
java.lang.Object)
@dalvik.annotation.Signature (value =(I)TE; )
public java.lang.Object get(
int)

public int hashCode()

public int indexOf(
java.lang.Object)

public int lastIndexOf(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/ListIterator<TE;>; )
public java.util.ListIterator listIterator()
@dalvik.annotation.Signature (value =(I)Ljava/util/ListIterator<TE;>; )
public java.util.ListIterator listIterator(
int)
@dalvik.annotation.Signature (value =(I)TE; )
public java.lang.Object remove(
int)
@dalvik.annotation.Signature (value =(ITE;)TE; )
public java.lang.Object set(
int
java.lang.Object)
@dalvik.annotation.Signature (value =(II)Ljava/util/List<TE;>; )
public java.util.List subList(
int
int)

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/ListIterator<TE;>; )
@dalvik.annotation.EnclosingClass (value =Ljava/util/Collections; )
@dalvik.annotation.InnerClass (accessFlags =10 name =CheckedListIterator )
 class java.util.Collections$CheckedListIterator extends java.lang.Object implements java.util.ListIterator

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/ListIterator<TE;>; )
private java.util.ListIterator i
@dalvik.annotation.Signature (value =Ljava/lang/Class<TE;>; )
private java.lang.Class type
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/ListIterator<TE;>;Ljava/lang/Class<TE;>;)V )
public void <init>(
java.util.ListIterator
java.lang.Class)
@dalvik.annotation.Signature (value =(TE;)V )
public void add(
java.lang.Object)

public boolean hasNext()

public boolean hasPrevious()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object next()

public int nextIndex()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object previous()

public int previousIndex()

public void remove()
@dalvik.annotation.Signature (value =(TE;)V )
public void set(
java.lang.Object)

________________CLASS________________

@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/lang/Object; )
@dalvik.annotation.EnclosingClass (value =Ljava/util/Map; )
@dalvik.annotation.InnerClass (accessFlags =1545 name =Entry )
public abstract interface class java.util.Map$Entry extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract boolean equals(
java.lang.Object)
@dalvik.annotation.Signature (value =()TK; )
public abstract java.lang.Object getKey()
@dalvik.annotation.Signature (value =()TV; )
public abstract java.lang.Object getValue()

public abstract int hashCode()
@dalvik.annotation.Signature (value =(TV;)TV; )
public abstract java.lang.Object setValue(
java.lang.Object)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/Collections$CheckedMap; )
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Map$Entry<TK;TV;>; )
@dalvik.annotation.InnerClass (accessFlags =10 name =CheckedEntry )
 class java.util.Collections$CheckedMap$CheckedEntry extends java.lang.Object implements java.util.Map$Entry

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Map$Entry<TK;TV;>; )
 java.util.Map$Entry e
@dalvik.annotation.Signature (value =Ljava/lang/Class<TV;>; )
 java.lang.Class valueType
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/Map$Entry<TK;TV;>;Ljava/lang/Class<TV;>;)V )
public void <init>(
java.util.Map$Entry
java.lang.Class)

public boolean equals(
java.lang.Object)
@dalvik.annotation.Signature (value =()TK; )
public java.lang.Object getKey()
@dalvik.annotation.Signature (value =()TV; )
public java.lang.Object getValue()

public int hashCode()
@dalvik.annotation.Signature (value =(TV;)TV; )
public java.lang.Object setValue(
java.lang.Object)

________________CLASS________________

@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Iterator<Ljava/util/Map$Entry<TK;TV;>;>; )
@dalvik.annotation.EnclosingClass (value =Ljava/util/Collections$CheckedMap$CheckedEntrySet; )
@dalvik.annotation.InnerClass (accessFlags =10 name =CheckedEntryIterator )
 class java.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntryIterator extends java.lang.Object implements java.util.Iterator

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Iterator<Ljava/util/Map$Entry<TK;TV;>;>; )
 java.util.Iterator i
@dalvik.annotation.Signature (value =Ljava/lang/Class<TV;>; )
 java.lang.Class valueType
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/Iterator<Ljava/util/Map$Entry<TK;TV;>;>;Ljava/lang/Class<TV;>;)V )
public void <init>(
java.util.Iterator
java.lang.Class)

public boolean hasNext()

public volatile java.lang.Object next()
@dalvik.annotation.Signature (value =()Ljava/util/Map$Entry<TK;TV;>; )
public java.util.Map$Entry next()

public void remove()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =10 name =CheckedEntrySet )
@dalvik.annotation.EnclosingClass (value =Ljava/util/Collections$CheckedMap; )
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Set<Ljava/util/Map$Entry<TK;TV;>;>; )
@dalvik.annotation.MemberClasses (value =Ljava/util/Collections$CheckedMap$CheckedEntrySet$CheckedEntryIterator; )
 class java.util.Collections$CheckedMap$CheckedEntrySet extends java.lang.Object implements java.util.Set

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Set<Ljava/util/Map$Entry<TK;TV;>;>; )
 java.util.Set s
@dalvik.annotation.Signature (value =Ljava/lang/Class<TV;>; )
 java.lang.Class valueType
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/Set<Ljava/util/Map$Entry<TK;TV;>;>;Ljava/lang/Class<TV;>;)V )
public void <init>(
java.util.Set
java.lang.Class)

public volatile boolean add(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Map$Entry<TK;TV;>;)Z )
public boolean add(
java.util.Map$Entry)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<+Ljava/util/Map$Entry<TK;TV;>;>;)Z )
public boolean addAll(
java.util.Collection)

public void clear()

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public boolean containsAll(
java.util.Collection)

public boolean equals(
java.lang.Object)

public int hashCode()

public boolean isEmpty()
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<Ljava/util/Map$Entry<TK;TV;>;>; )
public java.util.Iterator iterator()

public boolean remove(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public boolean removeAll(
java.util.Collection)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public boolean retainAll(
java.util.Collection)

public int size()

public java.lang.Object[] toArray()
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>([TT;)[TT; )
public java.lang.Object[] toArray(
java.lang.Object[])

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =10 name =CheckedMap )
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Map<TK;TV;>;Ljava/io/Serializable; )
@dalvik.annotation.EnclosingClass (value =Ljava/util/Collections; )
@dalvik.annotation.MemberClasses (value =Ljava/util/Collections$CheckedMap$CheckedEntrySet;Ljava/util/Collections$CheckedMap$CheckedEntry; )
 class java.util.Collections$CheckedMap extends java.lang.Object implements java.util.Map, java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID
@dalvik.annotation.Signature (value =Ljava/lang/Class<TK;>; )
 java.lang.Class keyType
@dalvik.annotation.Signature (value =Ljava/util/Map<TK;TV;>; )
 java.util.Map m
@dalvik.annotation.Signature (value =Ljava/lang/Class<TV;>; )
 java.lang.Class valueType
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/Map<TK;TV;>;Ljava/lang/Class<TK;>;Ljava/lang/Class<TV;>;)V )
private void <init>(
java.util.Map
java.lang.Class
java.lang.Class)

 void <init>(
java.util.Map
java.lang.Class
java.lang.Class
java.util.Collections$1)

public void clear()

public boolean containsKey(
java.lang.Object)

public boolean containsValue(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/util/Map$Entry<TK;TV;>;>; )
public java.util.Set entrySet()

public boolean equals(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;)TV; )
public java.lang.Object get(
java.lang.Object)

public int hashCode()

public boolean isEmpty()
@dalvik.annotation.Signature (value =()Ljava/util/Set<TK;>; )
public java.util.Set keySet()
@dalvik.annotation.Signature (value =(TK;TV;)TV; )
public java.lang.Object put(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Map<+TK;+TV;>;)V )
public void putAll(
java.util.Map)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;)TV; )
public java.lang.Object remove(
java.lang.Object)

public int size()

public java.lang.String toString()
@dalvik.annotation.Signature (value =()Ljava/util/Collection<TV;>; )
public java.util.Collection values()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/Collections; )
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/util/Collections$CheckedList<TE;>;Ljava/util/RandomAccess; )
@dalvik.annotation.InnerClass (accessFlags =10 name =CheckedRandomAccessList )
 class java.util.Collections$CheckedRandomAccessList extends java.util.Collections$CheckedList implements java.util.RandomAccess

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/List<TE;>;Ljava/lang/Class<TE;>;)V )
public void <init>(
java.util.List
java.lang.Class)

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/util/Collections$CheckedCollection<TE;>;Ljava/util/Set<TE;>; )
@dalvik.annotation.InnerClass (accessFlags =10 name =CheckedSet )
@dalvik.annotation.EnclosingClass (value =Ljava/util/Collections; )
 class java.util.Collections$CheckedSet extends java.util.Collections$CheckedCollection implements java.util.Set

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/Set<TE;>;Ljava/lang/Class<TE;>;)V )
public void <init>(
java.util.Set
java.lang.Class)

public boolean equals(
java.lang.Object)

public int hashCode()

________________CLASS________________

@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Map<TK;TV;>; )
public abstract interface class java.util.SortedMap extends java.lang.Object implements java.util.Map

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =()Ljava/util/Comparator<-TK;>; )
public abstract java.util.Comparator comparator()
@dalvik.annotation.Signature (value =()TK; )
public abstract java.lang.Object firstKey()
@dalvik.annotation.Signature (value =(TK;)Ljava/util/SortedMap<TK;TV;>; )
public abstract java.util.SortedMap headMap(
java.lang.Object)
@dalvik.annotation.Signature (value =()TK; )
public abstract java.lang.Object lastKey()
@dalvik.annotation.Signature (value =(TK;TK;)Ljava/util/SortedMap<TK;TV;>; )
public abstract java.util.SortedMap subMap(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(TK;)Ljava/util/SortedMap<TK;TV;>; )
public abstract java.util.SortedMap tailMap(
java.lang.Object)

________________CLASS________________

@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/util/Collections$CheckedMap<TK;TV;>;Ljava/util/SortedMap<TK;TV;>; )
@dalvik.annotation.EnclosingClass (value =Ljava/util/Collections; )
@dalvik.annotation.InnerClass (accessFlags =10 name =CheckedSortedMap )
 class java.util.Collections$CheckedSortedMap extends java.util.Collections$CheckedMap implements java.util.SortedMap

----------------FIELDS----------------

private static final long serialVersionUID
@dalvik.annotation.Signature (value =Ljava/util/SortedMap<TK;TV;>; )
 java.util.SortedMap sm
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/SortedMap<TK;TV;>;Ljava/lang/Class<TK;>;Ljava/lang/Class<TV;>;)V )
 void <init>(
java.util.SortedMap
java.lang.Class
java.lang.Class)
@dalvik.annotation.Signature (value =()Ljava/util/Comparator<-TK;>; )
public java.util.Comparator comparator()
@dalvik.annotation.Signature (value =()TK; )
public java.lang.Object firstKey()
@dalvik.annotation.Signature (value =(TK;)Ljava/util/SortedMap<TK;TV;>; )
public java.util.SortedMap headMap(
java.lang.Object)
@dalvik.annotation.Signature (value =()TK; )
public java.lang.Object lastKey()
@dalvik.annotation.Signature (value =(TK;TK;)Ljava/util/SortedMap<TK;TV;>; )
public java.util.SortedMap subMap(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(TK;)Ljava/util/SortedMap<TK;TV;>; )
public java.util.SortedMap tailMap(
java.lang.Object)

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Set<TE;>; )
public abstract interface class java.util.SortedSet extends java.lang.Object implements java.util.Set

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =()Ljava/util/Comparator<-TE;>; )
public abstract java.util.Comparator comparator()
@dalvik.annotation.Signature (value =()TE; )
public abstract java.lang.Object first()
@dalvik.annotation.Signature (value =(TE;)Ljava/util/SortedSet<TE;>; )
public abstract java.util.SortedSet headSet(
java.lang.Object)
@dalvik.annotation.Signature (value =()TE; )
public abstract java.lang.Object last()
@dalvik.annotation.Signature (value =(TE;TE;)Ljava/util/SortedSet<TE;>; )
public abstract java.util.SortedSet subSet(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(TE;)Ljava/util/SortedSet<TE;>; )
public abstract java.util.SortedSet tailSet(
java.lang.Object)

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/util/Collections$CheckedSet<TE;>;Ljava/util/SortedSet<TE;>; )
@dalvik.annotation.InnerClass (accessFlags =10 name =CheckedSortedSet )
@dalvik.annotation.EnclosingClass (value =Ljava/util/Collections; )
 class java.util.Collections$CheckedSortedSet extends java.util.Collections$CheckedSet implements java.util.SortedSet

----------------FIELDS----------------

private static final long serialVersionUID
@dalvik.annotation.Signature (value =Ljava/util/SortedSet<TE;>; )
private java.util.SortedSet ss
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/SortedSet<TE;>;Ljava/lang/Class<TE;>;)V )
public void <init>(
java.util.SortedSet
java.lang.Class)
@dalvik.annotation.Signature (value =()Ljava/util/Comparator<-TE;>; )
public java.util.Comparator comparator()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object first()
@dalvik.annotation.Signature (value =(TE;)Ljava/util/SortedSet<TE;>; )
public java.util.SortedSet headSet(
java.lang.Object)
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object last()
@dalvik.annotation.Signature (value =(TE;TE;)Ljava/util/SortedSet<TE;>; )
public java.util.SortedSet subSet(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(TE;)Ljava/util/SortedSet<TE;>; )
public java.util.SortedSet tailSet(
java.lang.Object)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =26 name =CopiesList )
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/util/AbstractList<TE;>;Ljava/io/Serializable; )
@dalvik.annotation.EnclosingClass (value =Ljava/util/Collections; )
final class java.util.Collections$CopiesList extends java.util.AbstractList implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID
@dalvik.annotation.Signature (value =TE; )
private final java.lang.Object element

private final int n
----------------METHODS----------------
@dalvik.annotation.Signature (value =(ITE;)V )
 void <init>(
int
java.lang.Object)

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =(I)TE; )
public java.lang.Object get(
int)

public int size()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/Collections; )
@dalvik.annotation.InnerClass (accessFlags =26 name =EmptyList )
final class java.util.Collections$EmptyList extends java.util.AbstractList implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

private void <init>()

 void <init>(
java.util.Collections$1)

private java.lang.Object readResolve()

public boolean contains(
java.lang.Object)

public java.lang.Object get(
int)

public int size()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/Collections; )
@dalvik.annotation.InnerClass (accessFlags =26 name =EmptyMap )
final class java.util.Collections$EmptyMap extends java.util.AbstractMap implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

private void <init>()

 void <init>(
java.util.Collections$1)

private java.lang.Object readResolve()

public boolean containsKey(
java.lang.Object)

public boolean containsValue(
java.lang.Object)

public java.util.Set entrySet()

public java.lang.Object get(
java.lang.Object)

public java.util.Set keySet()

public java.util.Collection values()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
 class java.util.Collections$EmptySet$1 extends java.lang.Object implements java.util.Iterator

----------------FIELDS----------------

final java.util.Collections$EmptySet this$0
----------------METHODS----------------

 void <init>(
java.util.Collections$EmptySet)

public boolean hasNext()

public java.lang.Object next()

public void remove()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/Collections; )
@dalvik.annotation.InnerClass (accessFlags =26 name =EmptySet )
final class java.util.Collections$EmptySet extends java.util.AbstractSet implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

private void <init>()

 void <init>(
java.util.Collections$1)

private java.lang.Object readResolve()

public boolean contains(
java.lang.Object)

public java.util.Iterator iterator()

public int size()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/Collections; )
@dalvik.annotation.InnerClass (accessFlags =26 name =ReverseComparator )
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Comparator<TT;>;Ljava/io/Serializable; )
final class java.util.Collections$ReverseComparator extends java.lang.Object implements java.util.Comparator, java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

private void <init>()

 void <init>(
java.util.Collections$1)
@dalvik.annotation.Signature (value =(TT;TT;)I )
public int compare(
java.lang.Object
java.lang.Object)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =26 name =ReverseComparatorWithComparator )
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Comparator<TT;>;Ljava/io/Serializable; )
@dalvik.annotation.EnclosingClass (value =Ljava/util/Collections; )
final class java.util.Collections$ReverseComparatorWithComparator extends java.lang.Object implements java.util.Comparator, java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID
@dalvik.annotation.Signature (value =Ljava/util/Comparator<TT;>; )
private final java.util.Comparator comparator
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/Comparator<TT;>;)V )
 void <init>(
java.util.Comparator)
@dalvik.annotation.Signature (value =(TT;TT;)I )
public int compare(
java.lang.Object
java.lang.Object)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/Collections; )
@dalvik.annotation.InnerClass (accessFlags =26 name =SingletonList )
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/util/AbstractList<TE;>;Ljava/io/Serializable; )
final class java.util.Collections$SingletonList extends java.util.AbstractList implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID
@dalvik.annotation.Signature (value =TE; )
final java.lang.Object element
----------------METHODS----------------
@dalvik.annotation.Signature (value =(TE;)V )
 void <init>(
java.lang.Object)

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =(I)TE; )
public java.lang.Object get(
int)

public int size()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Map$Entry<TK;TV;>; )
@dalvik.annotation.EnclosingMethod (value =null )
 class java.util.Collections$SingletonMap$1$1$1 extends java.lang.Object implements java.util.Map$Entry

----------------FIELDS----------------

final java.util.Collections$SingletonMap$1$1 this$2
----------------METHODS----------------

 void <init>(
java.util.Collections$SingletonMap$1$1)

public boolean equals(
java.lang.Object)
@dalvik.annotation.Signature (value =()TK; )
public java.lang.Object getKey()
@dalvik.annotation.Signature (value =()TV; )
public java.lang.Object getValue()

public int hashCode()
@dalvik.annotation.Signature (value =(TV;)TV; )
public java.lang.Object setValue(
java.lang.Object)

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Iterator<Ljava/util/Map$Entry<TK;TV;>;>; )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
 class java.util.Collections$SingletonMap$1$1 extends java.lang.Object implements java.util.Iterator

----------------FIELDS----------------

 boolean hasNext

final java.util.Collections$SingletonMap$1 this$1
----------------METHODS----------------

 void <init>(
java.util.Collections$SingletonMap$1)

public boolean hasNext()

public volatile java.lang.Object next()
@dalvik.annotation.Signature (value =()Ljava/util/Map$Entry<TK;TV;>; )
public java.util.Map$Entry next()

public void remove()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.Signature (value =Ljava/util/AbstractSet<Ljava/util/Map$Entry<TK;TV;>;>; )
 class java.util.Collections$SingletonMap$1 extends java.util.AbstractSet

----------------FIELDS----------------

final java.util.Collections$SingletonMap this$0
----------------METHODS----------------

 void <init>(
java.util.Collections$SingletonMap)

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<Ljava/util/Map$Entry<TK;TV;>;>; )
public java.util.Iterator iterator()

public int size()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/Collections; )
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/util/AbstractMap<TK;TV;>;Ljava/io/Serializable; )
@dalvik.annotation.InnerClass (accessFlags =26 name =SingletonMap )
final class java.util.Collections$SingletonMap extends java.util.AbstractMap implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID
@dalvik.annotation.Signature (value =TK; )
final java.lang.Object k
@dalvik.annotation.Signature (value =TV; )
final java.lang.Object v
----------------METHODS----------------
@dalvik.annotation.Signature (value =(TK;TV;)V )
 void <init>(
java.lang.Object
java.lang.Object)

public boolean containsKey(
java.lang.Object)

public boolean containsValue(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/util/Map$Entry<TK;TV;>;>; )
public java.util.Set entrySet()
@dalvik.annotation.Signature (value =(Ljava/lang/Object;)TV; )
public java.lang.Object get(
java.lang.Object)

public int size()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Iterator<TE;>; )
 class java.util.Collections$SingletonSet$1 extends java.lang.Object implements java.util.Iterator

----------------FIELDS----------------

 boolean hasNext

final java.util.Collections$SingletonSet this$0
----------------METHODS----------------

 void <init>(
java.util.Collections$SingletonSet)

public boolean hasNext()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object next()

public void remove()

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/util/AbstractSet<TE;>;Ljava/io/Serializable; )
@dalvik.annotation.InnerClass (accessFlags =26 name =SingletonSet )
@dalvik.annotation.EnclosingClass (value =Ljava/util/Collections; )
final class java.util.Collections$SingletonSet extends java.util.AbstractSet implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID
@dalvik.annotation.Signature (value =TE; )
final java.lang.Object element
----------------METHODS----------------
@dalvik.annotation.Signature (value =(TE;)V )
 void <init>(
java.lang.Object)

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TE;>; )
public java.util.Iterator iterator()

public int size()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/Collections; )
@dalvik.annotation.InnerClass (accessFlags =8 name =SynchronizedCollection )
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Collection<TE;>;Ljava/io/Serializable; )
 class java.util.Collections$SynchronizedCollection extends java.lang.Object implements java.util.Collection, java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID
@dalvik.annotation.Signature (value =Ljava/util/Collection<TE;>; )
final java.util.Collection c

final java.lang.Object mutex
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/Collection<TE;>;)V )
 void <init>(
java.util.Collection)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<TE;>;Ljava/lang/Object;)V )
 void <init>(
java.util.Collection
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)
@dalvik.annotation.Signature (value =(TE;)Z )
public boolean add(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<+TE;>;)Z )
public boolean addAll(
java.util.Collection)

public void clear()

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public boolean containsAll(
java.util.Collection)

public boolean isEmpty()
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TE;>; )
public java.util.Iterator iterator()

public boolean remove(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public boolean removeAll(
java.util.Collection)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public boolean retainAll(
java.util.Collection)

public int size()

public java.lang.Object[] toArray()
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>([TT;)[TT; )
public java.lang.Object[] toArray(
java.lang.Object[])

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =SynchronizedList )
@dalvik.annotation.EnclosingClass (value =Ljava/util/Collections; )
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/util/Collections$SynchronizedCollection<TE;>;Ljava/util/List<TE;>; )
 class java.util.Collections$SynchronizedList extends java.util.Collections$SynchronizedCollection implements java.util.List

----------------FIELDS----------------

private static final long serialVersionUID
@dalvik.annotation.Signature (value =Ljava/util/List<TE;>; )
final java.util.List list
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/List<TE;>;)V )
 void <init>(
java.util.List)
@dalvik.annotation.Signature (value =(Ljava/util/List<TE;>;Ljava/lang/Object;)V )
 void <init>(
java.util.List
java.lang.Object)

private java.lang.Object readResolve()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)
@dalvik.annotation.Signature (value =(ITE;)V )
public void add(
int
java.lang.Object)
@dalvik.annotation.Signature (value =(ILjava/util/Collection<+TE;>;)Z )
public boolean addAll(
int
java.util.Collection)

public boolean equals(
java.lang.Object)
@dalvik.annotation.Signature (value =(I)TE; )
public java.lang.Object get(
int)

public int hashCode()

public int indexOf(
java.lang.Object)

public int lastIndexOf(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/ListIterator<TE;>; )
public java.util.ListIterator listIterator()
@dalvik.annotation.Signature (value =(I)Ljava/util/ListIterator<TE;>; )
public java.util.ListIterator listIterator(
int)
@dalvik.annotation.Signature (value =(I)TE; )
public java.lang.Object remove(
int)
@dalvik.annotation.Signature (value =(ITE;)TE; )
public java.lang.Object set(
int
java.lang.Object)
@dalvik.annotation.Signature (value =(II)Ljava/util/List<TE;>; )
public java.util.List subList(
int
int)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/Collections; )
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Map<TK;TV;>;Ljava/io/Serializable; )
@dalvik.annotation.InnerClass (accessFlags =8 name =SynchronizedMap )
 class java.util.Collections$SynchronizedMap extends java.lang.Object implements java.util.Map, java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID
@dalvik.annotation.Signature (value =Ljava/util/Map<TK;TV;>; )
private final java.util.Map m

final java.lang.Object mutex
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/Map<TK;TV;>;)V )
 void <init>(
java.util.Map)
@dalvik.annotation.Signature (value =(Ljava/util/Map<TK;TV;>;Ljava/lang/Object;)V )
 void <init>(
java.util.Map
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

public void clear()

public boolean containsKey(
java.lang.Object)

public boolean containsValue(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/util/Map$Entry<TK;TV;>;>; )
public java.util.Set entrySet()

public boolean equals(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;)TV; )
public java.lang.Object get(
java.lang.Object)

public int hashCode()

public boolean isEmpty()
@dalvik.annotation.Signature (value =()Ljava/util/Set<TK;>; )
public java.util.Set keySet()
@dalvik.annotation.Signature (value =(TK;TV;)TV; )
public java.lang.Object put(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Map<+TK;+TV;>;)V )
public void putAll(
java.util.Map)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;)TV; )
public java.lang.Object remove(
java.lang.Object)

public int size()

public java.lang.String toString()
@dalvik.annotation.Signature (value =()Ljava/util/Collection<TV;>; )
public java.util.Collection values()

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/util/Collections$SynchronizedList<TE;>;Ljava/util/RandomAccess; )
@dalvik.annotation.EnclosingClass (value =Ljava/util/Collections; )
@dalvik.annotation.InnerClass (accessFlags =8 name =SynchronizedRandomAccessList )
 class java.util.Collections$SynchronizedRandomAccessList extends java.util.Collections$SynchronizedList implements java.util.RandomAccess

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/List<TE;>;)V )
 void <init>(
java.util.List)
@dalvik.annotation.Signature (value =(Ljava/util/List<TE;>;Ljava/lang/Object;)V )
 void <init>(
java.util.List
java.lang.Object)

private java.lang.Object writeReplace()
@dalvik.annotation.Signature (value =(II)Ljava/util/List<TE;>; )
public java.util.List subList(
int
int)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/Collections; )
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/util/Collections$SynchronizedCollection<TE;>;Ljava/util/Set<TE;>; )
@dalvik.annotation.InnerClass (accessFlags =8 name =SynchronizedSet )
 class java.util.Collections$SynchronizedSet extends java.util.Collections$SynchronizedCollection implements java.util.Set

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/Set<TE;>;)V )
 void <init>(
java.util.Set)
@dalvik.annotation.Signature (value =(Ljava/util/Set<TE;>;Ljava/lang/Object;)V )
 void <init>(
java.util.Set
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

public boolean equals(
java.lang.Object)

public int hashCode()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =SynchronizedSortedMap )
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/util/Collections$SynchronizedMap<TK;TV;>;Ljava/util/SortedMap<TK;TV;>; )
@dalvik.annotation.EnclosingClass (value =Ljava/util/Collections; )
 class java.util.Collections$SynchronizedSortedMap extends java.util.Collections$SynchronizedMap implements java.util.SortedMap

----------------FIELDS----------------

private static final long serialVersionUID
@dalvik.annotation.Signature (value =Ljava/util/SortedMap<TK;TV;>; )
private final java.util.SortedMap sm
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/SortedMap<TK;TV;>;)V )
 void <init>(
java.util.SortedMap)
@dalvik.annotation.Signature (value =(Ljava/util/SortedMap<TK;TV;>;Ljava/lang/Object;)V )
 void <init>(
java.util.SortedMap
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)
@dalvik.annotation.Signature (value =()Ljava/util/Comparator<-TK;>; )
public java.util.Comparator comparator()
@dalvik.annotation.Signature (value =()TK; )
public java.lang.Object firstKey()
@dalvik.annotation.Signature (value =(TK;)Ljava/util/SortedMap<TK;TV;>; )
public java.util.SortedMap headMap(
java.lang.Object)
@dalvik.annotation.Signature (value =()TK; )
public java.lang.Object lastKey()
@dalvik.annotation.Signature (value =(TK;TK;)Ljava/util/SortedMap<TK;TV;>; )
public java.util.SortedMap subMap(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(TK;)Ljava/util/SortedMap<TK;TV;>; )
public java.util.SortedMap tailMap(
java.lang.Object)

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/util/Collections$SynchronizedSet<TE;>;Ljava/util/SortedSet<TE;>; )
@dalvik.annotation.InnerClass (accessFlags =8 name =SynchronizedSortedSet )
@dalvik.annotation.EnclosingClass (value =Ljava/util/Collections; )
 class java.util.Collections$SynchronizedSortedSet extends java.util.Collections$SynchronizedSet implements java.util.SortedSet

----------------FIELDS----------------

private static final long serialVersionUID
@dalvik.annotation.Signature (value =Ljava/util/SortedSet<TE;>; )
private final java.util.SortedSet ss
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/SortedSet<TE;>;)V )
 void <init>(
java.util.SortedSet)
@dalvik.annotation.Signature (value =(Ljava/util/SortedSet<TE;>;Ljava/lang/Object;)V )
 void <init>(
java.util.SortedSet
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)
@dalvik.annotation.Signature (value =()Ljava/util/Comparator<-TE;>; )
public java.util.Comparator comparator()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object first()
@dalvik.annotation.Signature (value =(TE;)Ljava/util/SortedSet<TE;>; )
public java.util.SortedSet headSet(
java.lang.Object)
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object last()
@dalvik.annotation.Signature (value =(TE;TE;)Ljava/util/SortedSet<TE;>; )
public java.util.SortedSet subSet(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(TE;)Ljava/util/SortedSet<TE;>; )
public java.util.SortedSet tailSet(
java.lang.Object)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Iterator<TE;>; )
 class java.util.Collections$UnmodifiableCollection$1 extends java.lang.Object implements java.util.Iterator

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Iterator<TE;>; )
 java.util.Iterator iterator

final java.util.Collections$UnmodifiableCollection this$0
----------------METHODS----------------

 void <init>(
java.util.Collections$UnmodifiableCollection)

public boolean hasNext()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object next()

public void remove()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/Collections; )
@dalvik.annotation.InnerClass (accessFlags =10 name =UnmodifiableCollection )
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Collection<TE;>;Ljava/io/Serializable; )
 class java.util.Collections$UnmodifiableCollection extends java.lang.Object implements java.util.Collection, java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID
@dalvik.annotation.Signature (value =Ljava/util/Collection<TE;>; )
final java.util.Collection c
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/Collection<TE;>;)V )
 void <init>(
java.util.Collection)
@dalvik.annotation.Signature (value =(TE;)Z )
public boolean add(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<+TE;>;)Z )
public boolean addAll(
java.util.Collection)

public void clear()

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public boolean containsAll(
java.util.Collection)

public boolean isEmpty()
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TE;>; )
public java.util.Iterator iterator()

public boolean remove(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public boolean removeAll(
java.util.Collection)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public boolean retainAll(
java.util.Collection)

public int size()

public java.lang.Object[] toArray()
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>([TT;)[TT; )
public java.lang.Object[] toArray(
java.lang.Object[])

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/ListIterator<TE;>; )
 class java.util.Collections$UnmodifiableList$1 extends java.lang.Object implements java.util.ListIterator

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/ListIterator<TE;>; )
 java.util.ListIterator iterator

final java.util.Collections$UnmodifiableList this$0

final int val$location
----------------METHODS----------------

 void <init>(
java.util.Collections$UnmodifiableList
int)
@dalvik.annotation.Signature (value =(TE;)V )
public void add(
java.lang.Object)

public boolean hasNext()

public boolean hasPrevious()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object next()

public int nextIndex()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object previous()

public int previousIndex()

public void remove()
@dalvik.annotation.Signature (value =(TE;)V )
public void set(
java.lang.Object)

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/util/Collections$UnmodifiableCollection<TE;>;Ljava/util/List<TE;>; )
@dalvik.annotation.InnerClass (accessFlags =10 name =UnmodifiableList )
@dalvik.annotation.EnclosingClass (value =Ljava/util/Collections; )
 class java.util.Collections$UnmodifiableList extends java.util.Collections$UnmodifiableCollection implements java.util.List

----------------FIELDS----------------

private static final long serialVersionUID
@dalvik.annotation.Signature (value =Ljava/util/List<TE;>; )
final java.util.List list
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/List<TE;>;)V )
 void <init>(
java.util.List)

private java.lang.Object readResolve()
@dalvik.annotation.Signature (value =(ITE;)V )
public void add(
int
java.lang.Object)
@dalvik.annotation.Signature (value =(ILjava/util/Collection<+TE;>;)Z )
public boolean addAll(
int
java.util.Collection)

public boolean equals(
java.lang.Object)
@dalvik.annotation.Signature (value =(I)TE; )
public java.lang.Object get(
int)

public int hashCode()

public int indexOf(
java.lang.Object)

public int lastIndexOf(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/ListIterator<TE;>; )
public java.util.ListIterator listIterator()
@dalvik.annotation.Signature (value =(I)Ljava/util/ListIterator<TE;>; )
public java.util.ListIterator listIterator(
int)
@dalvik.annotation.Signature (value =(I)TE; )
public java.lang.Object remove(
int)
@dalvik.annotation.Signature (value =(ITE;)TE; )
public java.lang.Object set(
int
java.lang.Object)
@dalvik.annotation.Signature (value =(II)Ljava/util/List<TE;>; )
public java.util.List subList(
int
int)

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Iterator<Ljava/util/Map$Entry<TK;TV;>;>; )
 class java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1 extends java.lang.Object implements java.util.Iterator

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Iterator<Ljava/util/Map$Entry<TK;TV;>;>; )
 java.util.Iterator iterator

final java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet this$0
----------------METHODS----------------

 void <init>(
java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet)

public boolean hasNext()

public volatile java.lang.Object next()
@dalvik.annotation.Signature (value =()Ljava/util/Map$Entry<TK;TV;>; )
public java.util.Map$Entry next()

public void remove()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =10 name =UnmodifiableMapEntry )
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Map$Entry<TK;TV;>; )
@dalvik.annotation.EnclosingClass (value =Ljava/util/Collections$UnmodifiableMap$UnmodifiableEntrySet; )
 class java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableMapEntry extends java.lang.Object implements java.util.Map$Entry

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Map$Entry<TK;TV;>; )
 java.util.Map$Entry mapEntry
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/Map$Entry<TK;TV;>;)V )
 void <init>(
java.util.Map$Entry)

public boolean equals(
java.lang.Object)
@dalvik.annotation.Signature (value =()TK; )
public java.lang.Object getKey()
@dalvik.annotation.Signature (value =()TV; )
public java.lang.Object getValue()

public int hashCode()
@dalvik.annotation.Signature (value =(TV;)TV; )
public java.lang.Object setValue(
java.lang.Object)

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/util/Collections$UnmodifiableCollection<TE;>;Ljava/util/Set<TE;>; )
@dalvik.annotation.EnclosingClass (value =Ljava/util/Collections; )
@dalvik.annotation.InnerClass (accessFlags =10 name =UnmodifiableSet )
 class java.util.Collections$UnmodifiableSet extends java.util.Collections$UnmodifiableCollection implements java.util.Set

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/Set<TE;>;)V )
 void <init>(
java.util.Set)

public boolean equals(
java.lang.Object)

public int hashCode()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/Collections$UnmodifiableMap; )
@dalvik.annotation.InnerClass (accessFlags =10 name =UnmodifiableEntrySet )
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/util/Collections$UnmodifiableSet<Ljava/util/Map$Entry<TK;TV;>;>; )
@dalvik.annotation.MemberClasses (value =Ljava/util/Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableMapEntry; )
 class java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet extends java.util.Collections$UnmodifiableSet

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/Set<Ljava/util/Map$Entry<TK;TV;>;>;)V )
 void <init>(
java.util.Set)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<Ljava/util/Map$Entry<TK;TV;>;>; )
public java.util.Iterator iterator()

public java.lang.Object[] toArray()
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>([TT;)[TT; )
public java.lang.Object[] toArray(
java.lang.Object[])

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =10 name =UnmodifiableMap )
@dalvik.annotation.MemberClasses (value =Ljava/util/Collections$UnmodifiableMap$UnmodifiableEntrySet; )
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Map<TK;TV;>;Ljava/io/Serializable; )
@dalvik.annotation.EnclosingClass (value =Ljava/util/Collections; )
 class java.util.Collections$UnmodifiableMap extends java.lang.Object implements java.util.Map, java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID
@dalvik.annotation.Signature (value =Ljava/util/Map<TK;TV;>; )
private final java.util.Map m
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/Map<TK;TV;>;)V )
 void <init>(
java.util.Map)

public void clear()

public boolean containsKey(
java.lang.Object)

public boolean containsValue(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/util/Map$Entry<TK;TV;>;>; )
public java.util.Set entrySet()

public boolean equals(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;)TV; )
public java.lang.Object get(
java.lang.Object)

public int hashCode()

public boolean isEmpty()
@dalvik.annotation.Signature (value =()Ljava/util/Set<TK;>; )
public java.util.Set keySet()
@dalvik.annotation.Signature (value =(TK;TV;)TV; )
public java.lang.Object put(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Map<+TK;+TV;>;)V )
public void putAll(
java.util.Map)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;)TV; )
public java.lang.Object remove(
java.lang.Object)

public int size()

public java.lang.String toString()
@dalvik.annotation.Signature (value =()Ljava/util/Collection<TV;>; )
public java.util.Collection values()

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/util/Collections$UnmodifiableList<TE;>;Ljava/util/RandomAccess; )
@dalvik.annotation.InnerClass (accessFlags =10 name =UnmodifiableRandomAccessList )
@dalvik.annotation.EnclosingClass (value =Ljava/util/Collections; )
 class java.util.Collections$UnmodifiableRandomAccessList extends java.util.Collections$UnmodifiableList implements java.util.RandomAccess

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/List<TE;>;)V )
 void <init>(
java.util.List)

private java.lang.Object writeReplace()
@dalvik.annotation.Signature (value =(II)Ljava/util/List<TE;>; )
public java.util.List subList(
int
int)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/Collections; )
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/util/Collections$UnmodifiableMap<TK;TV;>;Ljava/util/SortedMap<TK;TV;>; )
@dalvik.annotation.InnerClass (accessFlags =10 name =UnmodifiableSortedMap )
 class java.util.Collections$UnmodifiableSortedMap extends java.util.Collections$UnmodifiableMap implements java.util.SortedMap

----------------FIELDS----------------

private static final long serialVersionUID
@dalvik.annotation.Signature (value =Ljava/util/SortedMap<TK;TV;>; )
private final java.util.SortedMap sm
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/SortedMap<TK;TV;>;)V )
 void <init>(
java.util.SortedMap)
@dalvik.annotation.Signature (value =()Ljava/util/Comparator<-TK;>; )
public java.util.Comparator comparator()
@dalvik.annotation.Signature (value =()TK; )
public java.lang.Object firstKey()
@dalvik.annotation.Signature (value =(TK;)Ljava/util/SortedMap<TK;TV;>; )
public java.util.SortedMap headMap(
java.lang.Object)
@dalvik.annotation.Signature (value =()TK; )
public java.lang.Object lastKey()
@dalvik.annotation.Signature (value =(TK;TK;)Ljava/util/SortedMap<TK;TV;>; )
public java.util.SortedMap subMap(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(TK;)Ljava/util/SortedMap<TK;TV;>; )
public java.util.SortedMap tailMap(
java.lang.Object)

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/util/Collections$UnmodifiableSet<TE;>;Ljava/util/SortedSet<TE;>; )
@dalvik.annotation.InnerClass (accessFlags =10 name =UnmodifiableSortedSet )
@dalvik.annotation.EnclosingClass (value =Ljava/util/Collections; )
 class java.util.Collections$UnmodifiableSortedSet extends java.util.Collections$UnmodifiableSet implements java.util.SortedSet

----------------FIELDS----------------

private static final long serialVersionUID
@dalvik.annotation.Signature (value =Ljava/util/SortedSet<TE;>; )
private final java.util.SortedSet ss
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/SortedSet<TE;>;)V )
 void <init>(
java.util.SortedSet)
@dalvik.annotation.Signature (value =()Ljava/util/Comparator<-TE;>; )
public java.util.Comparator comparator()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object first()
@dalvik.annotation.Signature (value =(TE;)Ljava/util/SortedSet<TE;>; )
public java.util.SortedSet headSet(
java.lang.Object)
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object last()
@dalvik.annotation.Signature (value =(TE;TE;)Ljava/util/SortedSet<TE;>; )
public java.util.SortedSet subSet(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(TE;)Ljava/util/SortedSet<TE;>; )
public java.util.SortedSet tailSet(
java.lang.Object)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/Collections$CheckedSortedMap;Ljava/util/Collections$CheckedSortedSet;Ljava/util/Collections$CheckedMap;Ljava/util/Collections$CheckedSet;Ljava/util/Collections$CheckedRandomAccessList;Ljava/util/Collections$CheckedList;Ljava/util/Collections$CheckedListIterator;Ljava/util/Collections$CheckedCollection;Ljava/util/Collections$UnmodifiableSortedSet;Ljava/util/Collections$UnmodifiableSortedMap;Ljava/util/Collections$UnmodifiableSet;Ljava/util/Collections$UnmodifiableMap;Ljava/util/Collections$UnmodifiableList;Ljava/util/Collections$UnmodifiableRandomAccessList;Ljava/util/Collections$UnmodifiableCollection;Ljava/util/Collections$SynchronizedSortedSet;Ljava/util/Collections$SynchronizedSortedMap;Ljava/util/Collections$SynchronizedSet;Ljava/util/Collections$SynchronizedMap;Ljava/util/Collections$SynchronizedList;Ljava/util/Collections$SynchronizedRandomAccessList;Ljava/util/Collections$SynchronizedCollection;Ljava/util/Collections$SingletonMap;Ljava/util/Collections$SingletonList;Ljava/util/Collections$SingletonSet;Ljava/util/Collections$ReverseComparatorWithComparator;Ljava/util/Collections$ReverseComparator;Ljava/util/Collections$EmptyMap;Ljava/util/Collections$EmptySet;Ljava/util/Collections$EmptyList;Ljava/util/Collections$CopiesList; )
public class java.util.Collections extends java.lang.Object

----------------FIELDS----------------

public static final java.util.List EMPTY_LIST

public static final java.util.Map EMPTY_MAP

public static final java.util.Set EMPTY_SET
----------------METHODS----------------

static void <clinit>()

private void <init>()
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/util/Collection<-TT;>;[TT;)Z )
public static transient boolean addAll(
java.util.Collection
java.lang.Object[])
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/util/List<+Ljava/lang/Comparable<-TT;>;>;TT;)I )
public static int binarySearch(
java.util.List
java.lang.Object)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/util/List<+TT;>;TT;Ljava/util/Comparator<-TT;>;)I )
public static int binarySearch(
java.util.List
java.lang.Object
java.util.Comparator)
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>(TE;Ljava/lang/Class<TE;>;)TE; )
static java.lang.Object checkType(
java.lang.Object
java.lang.Class)
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>(Ljava/util/Collection<TE;>;Ljava/lang/Class<TE;>;)Ljava/util/Collection<TE;>; )
public static java.util.Collection checkedCollection(
java.util.Collection
java.lang.Class)
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>(Ljava/util/List<TE;>;Ljava/lang/Class<TE;>;)Ljava/util/List<TE;>; )
public static java.util.List checkedList(
java.util.List
java.lang.Class)
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>(Ljava/util/Map<TK;TV;>;Ljava/lang/Class<TK;>;Ljava/lang/Class<TV;>;)Ljava/util/Map<TK;TV;>; )
public static java.util.Map checkedMap(
java.util.Map
java.lang.Class
java.lang.Class)
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>(Ljava/util/Set<TE;>;Ljava/lang/Class<TE;>;)Ljava/util/Set<TE;>; )
public static java.util.Set checkedSet(
java.util.Set
java.lang.Class)
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>(Ljava/util/SortedMap<TK;TV;>;Ljava/lang/Class<TK;>;Ljava/lang/Class<TV;>;)Ljava/util/SortedMap<TK;TV;>; )
public static java.util.SortedMap checkedSortedMap(
java.util.SortedMap
java.lang.Class
java.lang.Class)
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>(Ljava/util/SortedSet<TE;>;Ljava/lang/Class<TE;>;)Ljava/util/SortedSet<TE;>; )
public static java.util.SortedSet checkedSortedSet(
java.util.SortedSet
java.lang.Class)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/util/List<-TT;>;Ljava/util/List<+TT;>;)V )
public static void copy(
java.util.List
java.util.List)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;Ljava/util/Collection<*>;)Z )
public static boolean disjoint(
java.util.Collection
java.util.Collection)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>()Ljava/util/List<TT;>; )
public static final java.util.List emptyList()
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>()Ljava/util/Map<TK;TV;>; )
public static final java.util.Map emptyMap()
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>()Ljava/util/Set<TT;>; )
public static final java.util.Set emptySet()
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/util/Collection<TT;>;)Ljava/util/Enumeration<TT;>; )
public static java.util.Enumeration enumeration(
java.util.Collection)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/util/List<-TT;>;TT;)V )
public static void fill(
java.util.List
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;Ljava/lang/Object;)I )
public static int frequency(
java.util.Collection
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/List<*>;Ljava/util/List<*>;)I )
public static int indexOfSubList(
java.util.List
java.util.List)
@dalvik.annotation.Signature (value =(Ljava/util/List<*>;Ljava/util/List<*>;)I )
public static int lastIndexOfSubList(
java.util.List
java.util.List)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/util/Enumeration<TT;>;)Ljava/util/ArrayList<TT;>; )
public static java.util.ArrayList list(
java.util.Enumeration)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;:Ljava/lang/Comparable<-TT;>;>(Ljava/util/Collection<+TT;>;)TT; )
public static java.lang.Object max(
java.util.Collection)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/util/Collection<+TT;>;Ljava/util/Comparator<-TT;>;)TT; )
public static java.lang.Object max(
java.util.Collection
java.util.Comparator)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;:Ljava/lang/Comparable<-TT;>;>(Ljava/util/Collection<+TT;>;)TT; )
public static java.lang.Object min(
java.util.Collection)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/util/Collection<+TT;>;Ljava/util/Comparator<-TT;>;)TT; )
public static java.lang.Object min(
java.util.Collection
java.util.Comparator)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(ITT;)Ljava/util/List<TT;>; )
public static java.util.List nCopies(
int
java.lang.Object)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/util/List<TT;>;TT;TT;)Z )
public static boolean replaceAll(
java.util.List
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/List<*>;)V )
public static void reverse(
java.util.List)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>()Ljava/util/Comparator<TT;>; )
public static java.util.Comparator reverseOrder()
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/util/Comparator<TT;>;)Ljava/util/Comparator<TT;>; )
public static java.util.Comparator reverseOrder(
java.util.Comparator)
@dalvik.annotation.Signature (value =(Ljava/util/List<*>;I)V )
public static void rotate(
java.util.List
int)
@dalvik.annotation.Signature (value =(Ljava/util/List<*>;)V )
public static void shuffle(
java.util.List)
@dalvik.annotation.Signature (value =(Ljava/util/List<*>;Ljava/util/Random;)V )
public static void shuffle(
java.util.List
java.util.Random)
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>(TE;)Ljava/util/Set<TE;>; )
public static java.util.Set singleton(
java.lang.Object)
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>(TE;)Ljava/util/List<TE;>; )
public static java.util.List singletonList(
java.lang.Object)
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>(TK;TV;)Ljava/util/Map<TK;TV;>; )
public static java.util.Map singletonMap(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =<T::Ljava/lang/Comparable<-TT;>;>(Ljava/util/List<TT;>;)V )
public static void sort(
java.util.List)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/util/List<TT;>;Ljava/util/Comparator<-TT;>;)V )
public static void sort(
java.util.List
java.util.Comparator)
@dalvik.annotation.Signature (value =(Ljava/util/List<*>;II)V )
public static void swap(
java.util.List
int
int)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/util/Collection<TT;>;)Ljava/util/Collection<TT;>; )
public static java.util.Collection synchronizedCollection(
java.util.Collection)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/util/List<TT;>;)Ljava/util/List<TT;>; )
public static java.util.List synchronizedList(
java.util.List)
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>(Ljava/util/Map<TK;TV;>;)Ljava/util/Map<TK;TV;>; )
public static java.util.Map synchronizedMap(
java.util.Map)
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>(Ljava/util/Set<TE;>;)Ljava/util/Set<TE;>; )
public static java.util.Set synchronizedSet(
java.util.Set)
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>(Ljava/util/SortedMap<TK;TV;>;)Ljava/util/SortedMap<TK;TV;>; )
public static java.util.SortedMap synchronizedSortedMap(
java.util.SortedMap)
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>(Ljava/util/SortedSet<TE;>;)Ljava/util/SortedSet<TE;>; )
public static java.util.SortedSet synchronizedSortedSet(
java.util.SortedSet)
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>(Ljava/util/Collection<+TE;>;)Ljava/util/Collection<TE;>; )
public static java.util.Collection unmodifiableCollection(
java.util.Collection)
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>(Ljava/util/List<+TE;>;)Ljava/util/List<TE;>; )
public static java.util.List unmodifiableList(
java.util.List)
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>(Ljava/util/Map<+TK;+TV;>;)Ljava/util/Map<TK;TV;>; )
public static java.util.Map unmodifiableMap(
java.util.Map)
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>(Ljava/util/Set<+TE;>;)Ljava/util/Set<TE;>; )
public static java.util.Set unmodifiableSet(
java.util.Set)
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>(Ljava/util/SortedMap<TK;+TV;>;)Ljava/util/SortedMap<TK;TV;>; )
public static java.util.SortedMap unmodifiableSortedMap(
java.util.SortedMap)
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>(Ljava/util/SortedSet<TE;>;)Ljava/util/SortedSet<TE;>; )
public static java.util.SortedSet unmodifiableSortedSet(
java.util.SortedSet)

________________CLASS________________


public class java.util.ConcurrentModificationException extends java.lang.RuntimeException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public final class java.util.Currency extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Hashtable<Ljava/lang/String;Ljava/util/Currency;>; )
private static java.util.Hashtable codesToCurrencies

private static java.lang.String currencyVars

private static final long serialVersionUID

private java.lang.String currencyCode

private transient int defaultFractionDigits
----------------METHODS----------------

static void <clinit>()

private void <init>(
java.lang.String)

public static java.util.Currency getInstance(
java.lang.String)

public static java.util.Currency getInstance(
java.util.Locale)

private java.lang.Object readResolve()

public java.lang.String getCurrencyCode()

public int getDefaultFractionDigits()

public java.lang.String getSymbol()

public java.lang.String getSymbol(
java.util.Locale)

public java.lang.String toString()

________________CLASS________________


public class java.util.IllegalFormatException extends java.lang.IllegalArgumentException implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

 void <init>()

________________CLASS________________


public class java.util.DuplicateFormatFlagsException extends java.util.IllegalFormatException

----------------FIELDS----------------

private static final long serialVersionUID

private java.lang.String flags
----------------METHODS----------------

public void <init>(
java.lang.String)

public java.lang.String getFlags()

public java.lang.String getMessage()

________________CLASS________________


public class java.util.EmptyStackException extends java.lang.RuntimeException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/MapEntry$Type; )
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Map$Entry<TK;TV;>;Ljava/lang/Cloneable; )
 class java.util.MapEntry extends java.lang.Object implements java.util.Map$Entry, java.lang.Cloneable

----------------FIELDS----------------
@dalvik.annotation.Signature (value =TK; )
 java.lang.Object key
@dalvik.annotation.Signature (value =TV; )
 java.lang.Object value
----------------METHODS----------------
@dalvik.annotation.Signature (value =(TK;)V )
 void <init>(
java.lang.Object)
@dalvik.annotation.Signature (value =(TK;TV;)V )
 void <init>(
java.lang.Object
java.lang.Object)

public java.lang.Object clone()

public boolean equals(
java.lang.Object)
@dalvik.annotation.Signature (value =()TK; )
public java.lang.Object getKey()
@dalvik.annotation.Signature (value =()TV; )
public java.lang.Object getValue()

public int hashCode()
@dalvik.annotation.Signature (value =(TV;)TV; )
public java.lang.Object setValue(
java.lang.Object)

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/EnumMap; )
@dalvik.annotation.Signature (value =<KT:Ljava/lang/Enum<TKT;>;VT:Ljava/lang/Object;>Ljava/util/MapEntry<TKT;TVT;>; )
@dalvik.annotation.InnerClass (accessFlags =10 name =Entry )
 class java.util.EnumMap$Entry extends java.util.MapEntry

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/EnumMap<TKT;TVT;>; )
private final java.util.EnumMap enumMap

private final int ordinal
----------------METHODS----------------
@dalvik.annotation.Signature (value =(TKT;TVT;Ljava/util/EnumMap<TKT;TVT;>;)V )
 void <init>(
java.lang.Enum
java.lang.Object
java.util.EnumMap)

private void checkEntryStatus()

public boolean equals(
java.lang.Object)
@dalvik.annotation.Signature (value =()TKT; )
public java.lang.Enum getKey()

public volatile java.lang.Object getKey()
@dalvik.annotation.Signature (value =()TVT; )
public java.lang.Object getValue()

public int hashCode()
@dalvik.annotation.Signature (value =(TVT;)TVT; )
public java.lang.Object setValue(
java.lang.Object)

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;KT:Ljava/lang/Enum<TKT;>;VT:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Iterator<TE;>; )
@dalvik.annotation.EnclosingClass (value =Ljava/util/EnumMap; )
@dalvik.annotation.InnerClass (accessFlags =10 name =EnumMapIterator )
 class java.util.EnumMap$EnumMapIterator extends java.lang.Object implements java.util.Iterator

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/EnumMap<TKT;TVT;>; )
final java.util.EnumMap enumMap

 int position

 int prePosition
@dalvik.annotation.Signature (value =Ljava/util/MapEntry$Type<TE;TKT;TVT;>; )
final java.util.MapEntry$Type type
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/MapEntry$Type<TE;TKT;TVT;>;Ljava/util/EnumMap<TKT;TVT;>;)V )
 void <init>(
java.util.MapEntry$Type
java.util.EnumMap)

private void checkStatus()

public boolean hasNext()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object next()

public void remove()

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/EnumMap; )
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;KT:Ljava/lang/Enum<TKT;>;VT:Ljava/lang/Object;>Ljava/util/EnumMap$EnumMapIterator<TE;TKT;TVT;>; )
@dalvik.annotation.InnerClass (accessFlags =10 name =EnumMapEntryIterator )
 class java.util.EnumMap$EnumMapEntryIterator extends java.util.EnumMap$EnumMapIterator

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/MapEntry$Type<TE;TKT;TVT;>;Ljava/util/EnumMap<TKT;TVT;>;)V )
 void <init>(
java.util.MapEntry$Type
java.util.EnumMap)
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object next()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =1544 name =Type )
@dalvik.annotation.Signature (value =<RT:Ljava/lang/Object;KT:Ljava/lang/Object;VT:Ljava/lang/Object;>Ljava/lang/Object; )
@dalvik.annotation.EnclosingClass (value =Ljava/util/MapEntry; )
abstract interface class java.util.MapEntry$Type extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/MapEntry<TKT;TVT;>;)TRT; )
public abstract java.lang.Object get(
java.util.MapEntry)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/MapEntry$Type<Ljava/util/Map$Entry<TKT;TVT;>;TKT;TVT;>; )
@dalvik.annotation.EnclosingMethod (value =null )
 class java.util.EnumMap$EnumMapEntrySet$1 extends java.lang.Object implements java.util.MapEntry$Type

----------------FIELDS----------------

final java.util.EnumMap$EnumMapEntrySet this$0
----------------METHODS----------------

 void <init>(
java.util.EnumMap$EnumMapEntrySet)

public volatile java.lang.Object get(
java.util.MapEntry)
@dalvik.annotation.Signature (value =(Ljava/util/MapEntry<TKT;TVT;>;)Ljava/util/Map$Entry<TKT;TVT;>; )
public java.util.Map$Entry get(
java.util.MapEntry)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/EnumMap; )
@dalvik.annotation.InnerClass (accessFlags =10 name =EnumMapEntrySet )
@dalvik.annotation.Signature (value =<KT:Ljava/lang/Enum<TKT;>;VT:Ljava/lang/Object;>Ljava/util/AbstractSet<Ljava/util/Map$Entry<TKT;TVT;>;>; )
 class java.util.EnumMap$EnumMapEntrySet extends java.util.AbstractSet

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/EnumMap<TKT;TVT;>; )
private final java.util.EnumMap enumMap
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/EnumMap<TKT;TVT;>;)V )
 void <init>(
java.util.EnumMap)

public void clear()

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<Ljava/util/Map$Entry<TKT;TVT;>;>; )
public java.util.Iterator iterator()

public boolean remove(
java.lang.Object)

public int size()

public java.lang.Object[] toArray()

public java.lang.Object[] toArray(
java.lang.Object[])

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/MapEntry$Type<TKT;TKT;TVT;>; )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
 class java.util.EnumMap$EnumMapKeySet$1 extends java.lang.Object implements java.util.MapEntry$Type

----------------FIELDS----------------

final java.util.EnumMap$EnumMapKeySet this$0
----------------METHODS----------------

 void <init>(
java.util.EnumMap$EnumMapKeySet)
@dalvik.annotation.Signature (value =(Ljava/util/MapEntry<TKT;TVT;>;)TKT; )
public java.lang.Enum get(
java.util.MapEntry)

public volatile java.lang.Object get(
java.util.MapEntry)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/EnumMap; )
@dalvik.annotation.Signature (value =<KT:Ljava/lang/Enum<TKT;>;VT:Ljava/lang/Object;>Ljava/util/AbstractSet<TKT;>; )
@dalvik.annotation.InnerClass (accessFlags =10 name =EnumMapKeySet )
 class java.util.EnumMap$EnumMapKeySet extends java.util.AbstractSet

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/EnumMap<TKT;TVT;>; )
private final java.util.EnumMap enumMap
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/EnumMap<TKT;TVT;>;)V )
 void <init>(
java.util.EnumMap)

public void clear()

public boolean contains(
java.lang.Object)

public java.util.Iterator iterator()

public boolean remove(
java.lang.Object)

public int size()

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/MapEntry$Type<TVT;TKT;TVT;>; )
 class java.util.EnumMap$EnumMapValueCollection$1 extends java.lang.Object implements java.util.MapEntry$Type

----------------FIELDS----------------

final java.util.EnumMap$EnumMapValueCollection this$0
----------------METHODS----------------

 void <init>(
java.util.EnumMap$EnumMapValueCollection)
@dalvik.annotation.Signature (value =(Ljava/util/MapEntry<TKT;TVT;>;)TVT; )
public java.lang.Object get(
java.util.MapEntry)

________________CLASS________________

@dalvik.annotation.Signature (value =<KT:Ljava/lang/Enum<TKT;>;VT:Ljava/lang/Object;>Ljava/util/AbstractCollection<TVT;>; )
@dalvik.annotation.EnclosingClass (value =Ljava/util/EnumMap; )
@dalvik.annotation.InnerClass (accessFlags =10 name =EnumMapValueCollection )
 class java.util.EnumMap$EnumMapValueCollection extends java.util.AbstractCollection

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/EnumMap<TKT;TVT;>; )
private final java.util.EnumMap enumMap
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/EnumMap<TKT;TVT;>;)V )
 void <init>(
java.util.EnumMap)

public void clear()

public boolean contains(
java.lang.Object)

public java.util.Iterator iterator()

public boolean remove(
java.lang.Object)

public int size()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/EnumMap$EnumMapEntrySet;Ljava/util/EnumMap$EnumMapEntryIterator;Ljava/util/EnumMap$EnumMapValueCollection;Ljava/util/EnumMap$EnumMapKeySet;Ljava/util/EnumMap$EnumMapIterator;Ljava/util/EnumMap$Entry; )
@dalvik.annotation.Signature (value =<K:Ljava/lang/Enum<TK;>;V:Ljava/lang/Object;>Ljava/util/AbstractMap<TK;TV;>;Ljava/util/Map<TK;TV;>;Ljava/io/Serializable;Ljava/lang/Cloneable; )
public class java.util.EnumMap extends java.util.AbstractMap implements java.util.Map, java.io.Serializable, java.lang.Cloneable

----------------FIELDS----------------

private static final long serialVersionUID
@dalvik.annotation.Signature (value =Ljava/util/EnumMap$EnumMapEntrySet<TK;TV;>; )
private transient java.util.EnumMap$EnumMapEntrySet entrySet

transient int enumSize

transient boolean[] hasMapping
@dalvik.annotation.Signature (value =Ljava/lang/Class<TK;>; )
private java.lang.Class keyType

transient java.lang.Enum[] keys

private transient int mappingsCount

transient java.lang.Object[] values
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/lang/Class<TK;>;)V )
public void <init>(
java.lang.Class)
@dalvik.annotation.Signature (value =(Ljava/util/EnumMap<TK;+TV;>;)V )
public void <init>(
java.util.EnumMap)
@dalvik.annotation.Signature (value =(Ljava/util/Map<TK;+TV;>;)V )
public void <init>(
java.util.Map)
@dalvik.annotation.Signature (value =(Ljava/lang/Class<TK;>;)V )
private void initialization(
java.lang.Class)

private void initialization(
java.util.EnumMap)

private boolean isValidKeyType(
java.lang.Object)

private void putAllImpl(
java.util.Map)
@dalvik.annotation.Signature (value =(TK;TV;)TV; )
private java.lang.Object putImpl(
java.lang.Enum
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

public void clear()
@dalvik.annotation.Throws (value =Ljava/lang/CloneNotSupportedException; )
public volatile java.lang.Object clone()
@dalvik.annotation.Signature (value =()Ljava/util/EnumMap<TK;TV;>; )
public java.util.EnumMap clone()

public boolean containsKey(
java.lang.Object)

public boolean containsValue(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/util/Map$Entry<TK;TV;>;>; )
public java.util.Set entrySet()

public boolean equals(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;)TV; )
public java.lang.Object get(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Set<TK;>; )
public java.util.Set keySet()
@dalvik.annotation.Signature (value =(TK;TV;)TV; )
public java.lang.Object put(
java.lang.Enum
java.lang.Object)

public volatile java.lang.Object put(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Map<+TK;+TV;>;)V )
public void putAll(
java.util.Map)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;)TV; )
public java.lang.Object remove(
java.lang.Object)

public int size()
@dalvik.annotation.Signature (value =()Ljava/util/Collection<TV;>; )
public java.util.Collection values()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =4104 name =null )
@dalvik.annotation.EnclosingClass (value =Ljava/util/EnumSet; )
 class java.util.EnumSet$1 extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/EnumSet; )
@dalvik.annotation.Signature (value =<E:Ljava/lang/Enum<TE;>;>Ljava/lang/Object;Ljava/io/Serializable; )
@dalvik.annotation.InnerClass (accessFlags =10 name =SerializationProxy )
 class java.util.EnumSet$SerializationProxy extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID
@dalvik.annotation.Signature (value =Ljava/lang/Class<TE;>; )
private java.lang.Class elementType
@dalvik.annotation.Signature (value =[TE; )
private java.lang.Enum[] elements
----------------METHODS----------------

private void <init>()

 void <init>(
java.util.EnumSet$1)

static java.lang.Enum[] access$102(
java.util.EnumSet$SerializationProxy
java.lang.Enum[])

static java.lang.Class access$202(
java.util.EnumSet$SerializationProxy
java.lang.Class)

private java.lang.Object readResolve()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/EnumSet$1;Ljava/util/EnumSet$SerializationProxy; )
@dalvik.annotation.Signature (value =<E:Ljava/lang/Enum<TE;>;>Ljava/util/AbstractSet<TE;>;Ljava/lang/Cloneable;Ljava/io/Serializable; )
public abstract class java.util.EnumSet extends java.util.AbstractSet implements java.lang.Cloneable, java.io.Serializable

----------------FIELDS----------------

static org.apache.harmony.kernel.vm.LangAccess LANG_BOOTSTRAP

private static final long serialVersionUID
@dalvik.annotation.Signature (value =Ljava/lang/Class<TE;>; )
final java.lang.Class elementClass
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Signature (value =(Ljava/lang/Class<TE;>;)V )
 void <init>(
java.lang.Class)
@dalvik.annotation.Signature (value =<E:Ljava/lang/Enum<TE;>;>(Ljava/lang/Class<TE;>;)Ljava/util/EnumSet<TE;>; )
public static java.util.EnumSet allOf(
java.lang.Class)
@dalvik.annotation.Signature (value =<E:Ljava/lang/Enum<TE;>;>(Ljava/util/EnumSet<TE;>;)Ljava/util/EnumSet<TE;>; )
public static java.util.EnumSet complementOf(
java.util.EnumSet)
@dalvik.annotation.Signature (value =<E:Ljava/lang/Enum<TE;>;>(Ljava/util/Collection<TE;>;)Ljava/util/EnumSet<TE;>; )
public static java.util.EnumSet copyOf(
java.util.Collection)
@dalvik.annotation.Signature (value =<E:Ljava/lang/Enum<TE;>;>(Ljava/util/EnumSet<TE;>;)Ljava/util/EnumSet<TE;>; )
public static java.util.EnumSet copyOf(
java.util.EnumSet)
@dalvik.annotation.Signature (value =<E:Ljava/lang/Enum<TE;>;>(Ljava/lang/Class<TE;>;)Ljava/util/EnumSet<TE;>; )
public static java.util.EnumSet noneOf(
java.lang.Class)
@dalvik.annotation.Signature (value =<E:Ljava/lang/Enum<TE;>;>(TE;)Ljava/util/EnumSet<TE;>; )
public static java.util.EnumSet of(
java.lang.Enum)
@dalvik.annotation.Signature (value =<E:Ljava/lang/Enum<TE;>;>(TE;TE;)Ljava/util/EnumSet<TE;>; )
public static java.util.EnumSet of(
java.lang.Enum
java.lang.Enum)
@dalvik.annotation.Signature (value =<E:Ljava/lang/Enum<TE;>;>(TE;TE;TE;)Ljava/util/EnumSet<TE;>; )
public static java.util.EnumSet of(
java.lang.Enum
java.lang.Enum
java.lang.Enum)
@dalvik.annotation.Signature (value =<E:Ljava/lang/Enum<TE;>;>(TE;TE;TE;TE;)Ljava/util/EnumSet<TE;>; )
public static java.util.EnumSet of(
java.lang.Enum
java.lang.Enum
java.lang.Enum
java.lang.Enum)
@dalvik.annotation.Signature (value =<E:Ljava/lang/Enum<TE;>;>(TE;TE;TE;TE;TE;)Ljava/util/EnumSet<TE;>; )
public static java.util.EnumSet of(
java.lang.Enum
java.lang.Enum
java.lang.Enum
java.lang.Enum
java.lang.Enum)
@dalvik.annotation.Signature (value =<E:Ljava/lang/Enum<TE;>;>(TE;[TE;)Ljava/util/EnumSet<TE;>; )
public static transient java.util.EnumSet of(
java.lang.Enum
java.lang.Enum[])
@dalvik.annotation.Signature (value =<E:Ljava/lang/Enum<TE;>;>(TE;TE;)Ljava/util/EnumSet<TE;>; )
public static java.util.EnumSet range(
java.lang.Enum
java.lang.Enum)
@dalvik.annotation.Throws (value =Ljava/lang/CloneNotSupportedException; )
public volatile java.lang.Object clone()
@dalvik.annotation.Signature (value =()Ljava/util/EnumSet<TE;>; )
public java.util.EnumSet clone()

abstract void complement()

 boolean isValidType(
java.lang.Class)
@dalvik.annotation.Signature (value =(TE;TE;)V )
abstract void setRange(
java.lang.Enum
java.lang.Enum)

 java.lang.Object writeReplace()

________________CLASS________________


public abstract interface class java.util.EventListener extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________


public abstract class java.util.EventListenerProxy extends java.lang.Object implements java.util.EventListener

----------------FIELDS----------------

private final java.util.EventListener listener
----------------METHODS----------------

public void <init>(
java.util.EventListener)

public java.util.EventListener getListener()

________________CLASS________________


public class java.util.EventObject extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

protected transient java.lang.Object source
----------------METHODS----------------

public void <init>(
java.lang.Object)

public java.lang.Object getSource()

public java.lang.String toString()

________________CLASS________________


public class java.util.FormatFlagsConversionMismatchException extends java.util.IllegalFormatException implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

private char c

private java.lang.String f
----------------METHODS----------------

public void <init>(
java.lang.String
char)

public char getConversion()

public java.lang.String getFlags()

public java.lang.String getMessage()

________________CLASS________________


public abstract interface class java.util.Formattable extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/util/IllegalFormatException; )
public abstract void formatTo(
java.util.Formatter
int
int
int)

________________CLASS________________


public class java.util.FormattableFlags extends java.lang.Object

----------------FIELDS----------------

public static final int ALTERNATE

public static final int LEFT_JUSTIFY

public static final int UPPERCASE
----------------METHODS----------------

private void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =4104 name =null )
@dalvik.annotation.EnclosingClass (value =Ljava/util/Formatter; )
 class java.util.Formatter$1 extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/Formatter; )
@dalvik.annotation.Signature (value =Ljava/lang/Enum<Ljava/util/Formatter$BigDecimalLayoutForm;>; )
@dalvik.annotation.InnerClass (accessFlags =16409 name =BigDecimalLayoutForm )
public final class java.util.Formatter$BigDecimalLayoutForm extends java.lang.Enum

----------------FIELDS----------------

private static final java.util.Formatter$BigDecimalLayoutForm[] $VALUES

public static final java.util.Formatter$BigDecimalLayoutForm DECIMAL_FLOAT

public static final java.util.Formatter$BigDecimalLayoutForm SCIENTIFIC
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Signature (value =()V )
private void <init>(
java.lang.String
int)

public static java.util.Formatter$BigDecimalLayoutForm valueOf(
java.lang.String)

public static java.util.Formatter$BigDecimalLayoutForm[] values()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =10 name =DateTimeUtil )
@dalvik.annotation.EnclosingClass (value =Ljava/util/Formatter; )
 class java.util.Formatter$DateTimeUtil extends java.lang.Object

----------------FIELDS----------------

private java.util.Calendar calendar

private java.text.DateFormatSymbols dateFormatSymbols

private java.util.Locale locale

private java.lang.StringBuilder result
----------------METHODS----------------

 void <init>(
java.util.Locale)

private java.text.DateFormatSymbols getDateFormatSymbols()

private static java.lang.String paddingZeros(
long
int)

private void transform_A()

private void transform_B()

private void transform_C()

private void transform_D()

private void transform_F()

private void transform_H()

private void transform_I()

private void transform_L()

private void transform_M()

private void transform_N()

private void transform_Q()

private void transform_R()

private void transform_S()

private void transform_T()

private void transform_Y()

private void transform_Z()

private void transform_a()

private void transform_b()

private void transform_c()

private void transform_d()

private void transform_e()

private void transform_j()

private void transform_k()

private void transform_l()

private void transform_m()

private void transform_p(
boolean)

private void transform_r()

private void transform_s()

private void transform_y()

private void transform_z()

 void transform(
java.util.Formatter$FormatToken
java.util.Calendar
java.lang.StringBuilder)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =10 name =FloatUtil )
@dalvik.annotation.EnclosingClass (value =Ljava/util/Formatter; )
 class java.util.Formatter$FloatUtil extends java.lang.Object

----------------FIELDS----------------

private java.lang.Object argument

private java.text.DecimalFormat decimalFormat

private java.util.Formatter$FormatToken formatToken

private char minusSign

private java.lang.StringBuilder result
----------------METHODS----------------

 void <init>(
java.lang.StringBuilder
java.util.Formatter$FormatToken
java.text.DecimalFormat
java.lang.Object)

 char getAddSign()

 char getMinusSign()

 void transform(
java.util.Formatter$FormatToken
java.lang.StringBuilder)

 void transform_a()

 void transform_e()

 void transform_f()

 void transform_g()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =10 name =FormatToken )
@dalvik.annotation.EnclosingClass (value =Ljava/util/Formatter; )
 class java.util.Formatter$FormatToken extends java.lang.Object

----------------FIELDS----------------

static final int DEFAULT_PRECISION

static final int FLAGS_UNSET

private static final int FLAGT_TYPE_COUNT

static final int FLAG_ADD

static final int FLAG_COMMA

static final int FLAG_MINUS

static final int FLAG_PARENTHESIS

static final int FLAG_SHARP

static final int FLAG_SPACE

static final int FLAG_ZERO

static final int LAST_ARGUMENT_INDEX

static final int UNSET

private int argIndex

private char conversionType

private char dateSuffix

private int flags

private int formatStringStartIndex

private java.lang.String plainText

private int precision

private java.lang.StringBuilder strFlags

private int width
----------------METHODS----------------

private void <init>()

 void <init>(
java.util.Formatter$1)

 int getArgIndex()

 char getConversionType()

 char getDateSuffix()

 int getFlags()

 int getFormatStringStartIndex()

 java.lang.String getPlainText()

 int getPrecision()

 java.lang.String getStrFlags()

 int getWidth()

 boolean isFlagSet(
int)

 boolean isPrecisionSet()

 boolean isWidthSet()

 boolean requireArgument()

 void setArgIndex(
int)

 void setConversionType(
char)

 void setDateSuffix(
char)

 boolean setFlag(
char)

 void setFlags(
int)

 void setFormatStringStartIndex(
int)

 void setPlainText(
java.lang.String)

 void setPrecision(
int)

 void setWidth(
int)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/Formatter; )
@dalvik.annotation.InnerClass (accessFlags =10 name =ParserStateMachine )
 class java.util.Formatter$ParserStateMachine extends java.lang.Object

----------------FIELDS----------------

private static final int CONVERSION_TYPE_STATE

private static final int ENTRY_STATE

private static final char EOS

private static final int EXIT_STATE

private static final int FLAGS_STATE

private static final int PRECISION_STATE

private static final int START_CONVERSION_STATE

private static final int SUFFIX_STATE

private static final int WIDTH_STATE

private char currentChar

private java.nio.CharBuffer format

private int state

private java.util.Formatter$FormatToken token
----------------METHODS----------------

 void <init>(
java.nio.CharBuffer)

private java.lang.String getFormatString()

private char getNextFormatChar()

private int parseInt(
java.nio.CharBuffer)

private void process_CONVERSION_TYPE_STATE()

private void process_ENTRY_STATE()

private void process_EXIT_STATE()

private void process_FlAGS_STATE()

private void process_PRECISION_STATE()

private void process_START_CONVERSION_STATE()

private void process_SUFFIX_STATE()

private void process_WIDTH_STATE()

 java.util.Formatter$FormatToken getNextFormatToken()

 void reset()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/String;>; )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
 class java.util.Formatter$Transformer$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final java.util.Formatter$Transformer this$0
----------------METHODS----------------

 void <init>(
java.util.Formatter$Transformer)

public volatile java.lang.Object run()

public java.lang.String run()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =10 name =Transformer )
@dalvik.annotation.EnclosingClass (value =Ljava/util/Formatter; )
 class java.util.Formatter$Transformer extends java.lang.Object

----------------FIELDS----------------

private static java.lang.String lineSeparator

private java.lang.Object arg

private java.util.Formatter$DateTimeUtil dateTimeUtil

private java.text.DecimalFormatSymbols decimalFormatSymbols

private java.util.Formatter$FormatToken formatToken

private java.util.Formatter formatter

private java.util.Locale locale

private java.text.NumberFormat numberFormat
----------------METHODS----------------

 void <init>(
java.util.Formatter
java.util.Locale)

static java.util.Locale access$000(
java.util.Formatter$Transformer)

private java.text.DecimalFormatSymbols getDecimalFormatSymbols()

private java.text.NumberFormat getNumberFormat()

private java.lang.String padding(
java.lang.StringBuilder
int)

private java.lang.String transformFromBigInteger()

private java.lang.String transformFromBoolean()

private java.lang.String transformFromCharacter()

private java.lang.String transformFromDateTime()

private java.lang.String transformFromFloat()

private java.lang.String transformFromHashCode()

private java.lang.String transformFromInteger()

private java.lang.String transformFromNull()

private java.lang.String transformFromPercent()

private java.lang.String transformFromSpecialNumber()

private java.lang.String transformFromString()

private java.lang.String transfromFromLineSeparator()

private java.lang.StringBuilder wrapParentheses(
java.lang.StringBuilder)

 java.lang.String transform(
java.util.Formatter$FormatToken
java.lang.Object)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/Formatter$1;Ljava/util/Formatter$ParserStateMachine;Ljava/util/Formatter$DateTimeUtil;Ljava/util/Formatter$FloatUtil;Ljava/util/Formatter$Transformer;Ljava/util/Formatter$FormatToken;Ljava/util/Formatter$BigDecimalLayoutForm; )
public final class java.util.Formatter extends java.lang.Object implements java.io.Closeable, java.io.Flushable

----------------FIELDS----------------

private boolean closed

private java.io.IOException lastIOException

private java.util.Locale locale

private java.lang.Appendable out

private java.util.Formatter$Transformer transformer
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/FileNotFoundException; )
public void <init>(
java.io.File)
@dalvik.annotation.Throws (value =Ljava/io/FileNotFoundException;Ljava/io/UnsupportedEncodingException; )
public void <init>(
java.io.File
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/FileNotFoundException;Ljava/io/UnsupportedEncodingException; )
public void <init>(
java.io.File
java.lang.String
java.util.Locale)

public void <init>(
java.io.OutputStream)
@dalvik.annotation.Throws (value =Ljava/io/UnsupportedEncodingException; )
public void <init>(
java.io.OutputStream
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/UnsupportedEncodingException; )
public void <init>(
java.io.OutputStream
java.lang.String
java.util.Locale)

public void <init>(
java.io.PrintStream)

public void <init>(
java.lang.Appendable)

public void <init>(
java.lang.Appendable
java.util.Locale)
@dalvik.annotation.Throws (value =Ljava/io/FileNotFoundException; )
public void <init>(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/FileNotFoundException;Ljava/io/UnsupportedEncodingException; )
public void <init>(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/FileNotFoundException;Ljava/io/UnsupportedEncodingException; )
public void <init>(
java.lang.String
java.lang.String
java.util.Locale)

public void <init>(
java.util.Locale)

private void checkClosed()

private static void closeOutputStream(
java.io.OutputStream)

private java.lang.Object getArgument(
java.lang.Object[]
int
java.util.Formatter$FormatToken
java.lang.Object
boolean)

public void close()

public void flush()

public transient java.util.Formatter format(
java.lang.String
java.lang.Object[])

public transient java.util.Formatter format(
java.util.Locale
java.lang.String
java.lang.Object[])

public java.io.IOException ioException()

public java.util.Locale locale()

public java.lang.Appendable out()

public java.lang.String toString()

________________CLASS________________


public class java.util.FormatterClosedException extends java.lang.IllegalStateException implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

________________CLASS________________


public class java.util.GregorianCalendar extends java.util.Calendar

----------------FIELDS----------------

public static final int AD

public static final int BC

static byte[] DaysInMonth

private static int[] DaysInYear

private static final long defaultGregorianCutover

private static int[] leastMaximums

private static int[] maximums

private static int[] minimums

private static final long serialVersionUID

private int[] cachedFields

private transient int changeYear

private int currentYearSkew

private long gregorianCutover

private boolean isCached

private transient int julianSkew

private long lastMidnightMillis

private int lastYearSkew

private long nextMidnightMillis
----------------METHODS----------------

static void <clinit>()

public void <init>()

public void <init>(
int
int
int)

public void <init>(
int
int
int
int
int)

public void <init>(
int
int
int
int
int
int)

 void <init>(
long)

public void <init>(
java.util.Locale)

public void <init>(
java.util.TimeZone)

public void <init>(
java.util.TimeZone
java.util.Locale)

 void <init>(
boolean)

private final void cachedFieldsCheckAndGet(
long
long
long
int
int)

private int computeYearAndDay(
long
long)

private long daysFromBaseYear(
int)

private int daysInMonth()

private int daysInMonth(
boolean
int)

private int daysInYear(
int)

private int daysInYear(
boolean
int)

private final void fullFieldsCalc(
long
int
int)

private int julianError()

private int mod(
int
int)

private int mod7(
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

public void add(
int
int)

public java.lang.Object clone()

protected void computeFields()

protected void computeTime()

public boolean equals(
java.lang.Object)

public int getActualMaximum(
int)

public int getActualMinimum(
int)

public int getGreatestMinimum(
int)

public final java.util.Date getGregorianChange()

public int getLeastMaximum(
int)

public int getMaximum(
int)

public int getMinimum(
int)

 int getOffset(
long)

public int hashCode()

public boolean isLeapYear(
int)

public void roll(
int
int)

public void roll(
int
boolean)

public void setFirstDayOfWeek(
int)

public void setGregorianChange(
java.util.Date)

public void setMinimalDaysInFirstWeek(
int)

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/MapEntry$Type<TK;TK;TV;>; )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
 class java.util.HashMap$1$1 extends java.lang.Object implements java.util.MapEntry$Type

----------------FIELDS----------------

final java.util.HashMap$1 this$1
----------------METHODS----------------

 void <init>(
java.util.HashMap$1)
@dalvik.annotation.Signature (value =(Ljava/util/MapEntry<TK;TV;>;)TK; )
public java.lang.Object get(
java.util.MapEntry)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.Signature (value =Ljava/util/AbstractSet<TK;>; )
@dalvik.annotation.EnclosingMethod (value =null )
 class java.util.HashMap$1 extends java.util.AbstractSet

----------------FIELDS----------------

final java.util.HashMap this$0
----------------METHODS----------------

 void <init>(
java.util.HashMap)

public void clear()

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TK;>; )
public java.util.Iterator iterator()

public boolean remove(
java.lang.Object)

public int size()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/MapEntry$Type<TV;TK;TV;>; )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
 class java.util.HashMap$2$1 extends java.lang.Object implements java.util.MapEntry$Type

----------------FIELDS----------------

final java.util.HashMap$2 this$1
----------------METHODS----------------

 void <init>(
java.util.HashMap$2)
@dalvik.annotation.Signature (value =(Ljava/util/MapEntry<TK;TV;>;)TV; )
public java.lang.Object get(
java.util.MapEntry)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.Signature (value =Ljava/util/AbstractCollection<TV;>; )
@dalvik.annotation.EnclosingMethod (value =null )
 class java.util.HashMap$2 extends java.util.AbstractCollection

----------------FIELDS----------------

final java.util.HashMap this$0
----------------METHODS----------------

 void <init>(
java.util.HashMap)

public void clear()

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TV;>; )
public java.util.Iterator iterator()

public int size()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/HashMap; )
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/util/MapEntry<TK;TV;>; )
@dalvik.annotation.InnerClass (accessFlags =8 name =Entry )
 class java.util.HashMap$Entry extends java.util.MapEntry

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/HashMap$Entry<TK;TV;>; )
 java.util.HashMap$Entry next

final int origKeyHash
----------------METHODS----------------
@dalvik.annotation.Signature (value =(TK;I)V )
 void <init>(
java.lang.Object
int)
@dalvik.annotation.Signature (value =(TK;TV;)V )
 void <init>(
java.lang.Object
java.lang.Object)

public java.lang.Object clone()

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/MapEntry$Type<Ljava/util/Map$Entry<TKT;TVT;>;TKT;TVT;>; )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
 class java.util.HashMap$HashMapEntrySet$1 extends java.lang.Object implements java.util.MapEntry$Type

----------------FIELDS----------------

final java.util.HashMap$HashMapEntrySet this$0
----------------METHODS----------------

 void <init>(
java.util.HashMap$HashMapEntrySet)

public volatile java.lang.Object get(
java.util.MapEntry)
@dalvik.annotation.Signature (value =(Ljava/util/MapEntry<TKT;TVT;>;)Ljava/util/Map$Entry<TKT;TVT;>; )
public java.util.Map$Entry get(
java.util.MapEntry)

________________CLASS________________

@dalvik.annotation.Signature (value =<KT:Ljava/lang/Object;VT:Ljava/lang/Object;>Ljava/util/AbstractSet<Ljava/util/Map$Entry<TKT;TVT;>;>; )
@dalvik.annotation.InnerClass (accessFlags =8 name =HashMapEntrySet )
@dalvik.annotation.EnclosingClass (value =Ljava/util/HashMap; )
 class java.util.HashMap$HashMapEntrySet extends java.util.AbstractSet

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/HashMap<TKT;TVT;>; )
private final java.util.HashMap associatedMap
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/HashMap<TKT;TVT;>;)V )
public void <init>(
java.util.HashMap)

public void clear()

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/HashMap<TKT;TVT;>; )
 java.util.HashMap hashMap()
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<Ljava/util/Map$Entry<TKT;TVT;>;>; )
public java.util.Iterator iterator()

public boolean remove(
java.lang.Object)

public int size()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =HashMapIterator )
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;KT:Ljava/lang/Object;VT:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Iterator<TE;>; )
@dalvik.annotation.EnclosingClass (value =Ljava/util/HashMap; )
 class java.util.HashMap$HashMapIterator extends java.lang.Object implements java.util.Iterator

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/HashMap<TKT;TVT;>; )
final java.util.HashMap associatedMap

 boolean canRemove
@dalvik.annotation.Signature (value =Ljava/util/HashMap$Entry<TKT;TVT;>; )
 java.util.HashMap$Entry entry

 int expectedModCount
@dalvik.annotation.Signature (value =Ljava/util/HashMap$Entry<TKT;TVT;>; )
 java.util.HashMap$Entry lastEntry

private int position
@dalvik.annotation.Signature (value =Ljava/util/MapEntry$Type<TE;TKT;TVT;>; )
final java.util.MapEntry$Type type
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/MapEntry$Type<TE;TKT;TVT;>;Ljava/util/HashMap<TKT;TVT;>;)V )
 void <init>(
java.util.MapEntry$Type
java.util.HashMap)
@dalvik.annotation.Throws (value =Ljava/util/ConcurrentModificationException; )
 void checkConcurrentMod()

public boolean hasNext()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object next()

public void remove()

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/util/AbstractSet<TE;>;Ljava/util/Set<TE;>;Ljava/lang/Cloneable;Ljava/io/Serializable; )
public class java.util.HashSet extends java.util.AbstractSet implements java.util.Set, java.lang.Cloneable, java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID
@dalvik.annotation.Signature (value =Ljava/util/HashMap<TE;Ljava/util/HashSet<TE;>;>; )
transient java.util.HashMap backingMap
----------------METHODS----------------

public void <init>()

public void <init>(
int)

public void <init>(
int
float)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<+TE;>;)V )
public void <init>(
java.util.Collection)
@dalvik.annotation.Signature (value =(Ljava/util/HashMap<TE;Ljava/util/HashSet<TE;>;>;)V )
 void <init>(
java.util.HashMap)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)
@dalvik.annotation.Signature (value =(TE;)Z )
public boolean add(
java.lang.Object)

public void clear()

public java.lang.Object clone()

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =(IF)Ljava/util/HashMap<TE;Ljava/util/HashSet<TE;>;>; )
 java.util.HashMap createBackingMap(
int
float)

public boolean isEmpty()
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TE;>; )
public java.util.Iterator iterator()

public boolean remove(
java.lang.Object)

public int size()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Enumeration<Ljava/lang/Object;>; )
@dalvik.annotation.EnclosingClass (value =Ljava/util/Hashtable; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class java.util.Hashtable$1 extends java.lang.Object implements java.util.Enumeration

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public boolean hasMoreElements()

public java.lang.Object nextElement()

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/MapEntry$Type<Ljava/util/Map$Entry<TK;TV;>;TK;TV;>; )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
 class java.util.Hashtable$2$1 extends java.lang.Object implements java.util.MapEntry$Type

----------------FIELDS----------------

final java.util.Hashtable$2 this$1
----------------METHODS----------------

 void <init>(
java.util.Hashtable$2)

public volatile java.lang.Object get(
java.util.MapEntry)
@dalvik.annotation.Signature (value =(Ljava/util/MapEntry<TK;TV;>;)Ljava/util/Map$Entry<TK;TV;>; )
public java.util.Map$Entry get(
java.util.MapEntry)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.Signature (value =Ljava/util/AbstractSet<Ljava/util/Map$Entry<TK;TV;>;>; )
@dalvik.annotation.EnclosingMethod (value =null )
 class java.util.Hashtable$2 extends java.util.AbstractSet

----------------FIELDS----------------

final java.util.Hashtable this$0
----------------METHODS----------------

 void <init>(
java.util.Hashtable)

public void clear()

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<Ljava/util/Map$Entry<TK;TV;>;>; )
public java.util.Iterator iterator()

public boolean remove(
java.lang.Object)

public int size()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/MapEntry$Type<TK;TK;TV;>; )
@dalvik.annotation.EnclosingMethod (value =null )
 class java.util.Hashtable$3$1 extends java.lang.Object implements java.util.MapEntry$Type

----------------FIELDS----------------

final java.util.Hashtable$3 this$1
----------------METHODS----------------

 void <init>(
java.util.Hashtable$3)
@dalvik.annotation.Signature (value =(Ljava/util/MapEntry<TK;TV;>;)TK; )
public java.lang.Object get(
java.util.MapEntry)

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.Signature (value =Ljava/util/AbstractSet<TK;>; )
 class java.util.Hashtable$3 extends java.util.AbstractSet

----------------FIELDS----------------

final java.util.Hashtable this$0
----------------METHODS----------------

 void <init>(
java.util.Hashtable)

public void clear()

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TK;>; )
public java.util.Iterator iterator()

public boolean remove(
java.lang.Object)

public int size()

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/MapEntry$Type<TV;TK;TV;>; )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
 class java.util.Hashtable$4$1 extends java.lang.Object implements java.util.MapEntry$Type

----------------FIELDS----------------

final java.util.Hashtable$4 this$1
----------------METHODS----------------

 void <init>(
java.util.Hashtable$4)
@dalvik.annotation.Signature (value =(Ljava/util/MapEntry<TK;TV;>;)TV; )
public java.lang.Object get(
java.util.MapEntry)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.Signature (value =Ljava/util/AbstractCollection<TV;>; )
 class java.util.Hashtable$4 extends java.util.AbstractCollection

----------------FIELDS----------------

final java.util.Hashtable this$0
----------------METHODS----------------

 void <init>(
java.util.Hashtable)

public void clear()

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TV;>; )
public java.util.Iterator iterator()

public int size()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =10 name =Entry )
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/util/MapEntry<TK;TV;>; )
@dalvik.annotation.EnclosingClass (value =Ljava/util/Hashtable; )
 class java.util.Hashtable$Entry extends java.util.MapEntry

----------------FIELDS----------------

final int hashcode
@dalvik.annotation.Signature (value =Ljava/util/Hashtable$Entry<TK;TV;>; )
 java.util.Hashtable$Entry next
----------------METHODS----------------
@dalvik.annotation.Signature (value =(TK;TV;)V )
 void <init>(
java.lang.Object
java.lang.Object)

public java.lang.Object clone()

public boolean equalsKey(
java.lang.Object
int)

public int getKeyHash()
@dalvik.annotation.Signature (value =(TV;)TV; )
public java.lang.Object setValue(
java.lang.Object)

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/Hashtable; )
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Enumeration<TE;>; )
@dalvik.annotation.InnerClass (accessFlags =18 name =HashEnumerator )
final class java.util.Hashtable$HashEnumerator extends java.lang.Object implements java.util.Enumeration

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Hashtable$Entry<TK;TV;>; )
 java.util.Hashtable$Entry entry

 boolean key

 int start

final java.util.Hashtable this$0
----------------METHODS----------------

 void <init>(
java.util.Hashtable
boolean)

public boolean hasMoreElements()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object nextElement()

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Iterator<TE;>; )
@dalvik.annotation.EnclosingClass (value =Ljava/util/Hashtable; )
@dalvik.annotation.InnerClass (accessFlags =18 name =HashIterator )
final class java.util.Hashtable$HashIterator extends java.lang.Object implements java.util.Iterator

----------------FIELDS----------------

private boolean canRemove

private int expectedModCount
@dalvik.annotation.Signature (value =Ljava/util/Hashtable$Entry<TK;TV;>; )
private java.util.Hashtable$Entry lastEntry

private int lastPosition

private int position

final java.util.Hashtable this$0
@dalvik.annotation.Signature (value =Ljava/util/MapEntry$Type<TE;TK;TV;>; )
private final java.util.MapEntry$Type type
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/MapEntry$Type<TE;TK;TV;>;)V )
 void <init>(
java.util.Hashtable
java.util.MapEntry$Type)

public boolean hasNext()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object next()

public void remove()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =4104 name =null )
@dalvik.annotation.EnclosingClass (value =Ljava/util/HugeEnumSet; )
 class java.util.HugeEnumSet$1 extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Iterator<TE;>; )
@dalvik.annotation.EnclosingClass (value =Ljava/util/HugeEnumSet; )
@dalvik.annotation.InnerClass (accessFlags =2 name =HugeEnumSetIterator )
 class java.util.HugeEnumSet$HugeEnumSetIterator extends java.lang.Object implements java.util.Iterator

----------------FIELDS----------------

private int bitsPosition

 boolean canProcess

private long currentElementMask

final java.util.HugeEnumSet this$0

private long[] unProcessedBits
----------------METHODS----------------

private void <init>(
java.util.HugeEnumSet)

 void <init>(
java.util.HugeEnumSet
java.util.HugeEnumSet$1)

private void findNextNoneZeroPosition(
int)

public boolean hasNext()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Enum next()

public volatile java.lang.Object next()

public void remove()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/HugeEnumSet$1;Ljava/util/HugeEnumSet$HugeEnumSetIterator; )
@dalvik.annotation.Signature (value =<E:Ljava/lang/Enum<TE;>;>Ljava/util/EnumSet<TE;>; )
final class java.util.HugeEnumSet extends java.util.EnumSet

----------------FIELDS----------------

private static final int BIT_IN_LONG

private long[] bits

private int bitsIndex

private int elementInBits
@dalvik.annotation.Signature (value =[TE; )
private final java.lang.Enum[] enums

private long oldBits

private int size
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/lang/Class<TE;>;[TE;)V )
 void <init>(
java.lang.Class
java.lang.Enum[])

static long[] access$000(
java.util.HugeEnumSet)

static java.lang.Enum[] access$100(
java.util.HugeEnumSet)

static int access$210(
java.util.HugeEnumSet)
@dalvik.annotation.Signature (value =(TE;)V )
private void calculateElementIndex(
java.lang.Enum)
@dalvik.annotation.Signature (value =(TE;)Z )
public boolean add(
java.lang.Enum)

public volatile boolean add(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<+TE;>;)Z )
public boolean addAll(
java.util.Collection)

public void clear()
@dalvik.annotation.Throws (value =Ljava/lang/CloneNotSupportedException; )
public volatile java.lang.Object clone()

public volatile java.util.EnumSet clone()
@dalvik.annotation.Signature (value =()Ljava/util/HugeEnumSet<TE;>; )
public java.util.HugeEnumSet clone()

protected void complement()

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public boolean containsAll(
java.util.Collection)

public boolean equals(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TE;>; )
public java.util.Iterator iterator()

public boolean remove(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public boolean removeAll(
java.util.Collection)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public boolean retainAll(
java.util.Collection)
@dalvik.annotation.Signature (value =(TE;TE;)V )
 void setRange(
java.lang.Enum
java.lang.Enum)

public int size()

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/MapEntry$Type<TK;TK;TV;>; )
 class java.util.IdentityHashMap$1$1 extends java.lang.Object implements java.util.MapEntry$Type

----------------FIELDS----------------

final java.util.IdentityHashMap$1 this$1
----------------METHODS----------------

 void <init>(
java.util.IdentityHashMap$1)
@dalvik.annotation.Signature (value =(Ljava/util/MapEntry<TK;TV;>;)TK; )
public java.lang.Object get(
java.util.MapEntry)

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.Signature (value =Ljava/util/AbstractSet<TK;>; )
 class java.util.IdentityHashMap$1 extends java.util.AbstractSet

----------------FIELDS----------------

final java.util.IdentityHashMap this$0
----------------METHODS----------------

 void <init>(
java.util.IdentityHashMap)

public void clear()

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TK;>; )
public java.util.Iterator iterator()

public boolean remove(
java.lang.Object)

public int size()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/MapEntry$Type<TV;TK;TV;>; )
@dalvik.annotation.EnclosingMethod (value =null )
 class java.util.IdentityHashMap$2$1 extends java.lang.Object implements java.util.MapEntry$Type

----------------FIELDS----------------

final java.util.IdentityHashMap$2 this$1
----------------METHODS----------------

 void <init>(
java.util.IdentityHashMap$2)
@dalvik.annotation.Signature (value =(Ljava/util/MapEntry<TK;TV;>;)TV; )
public java.lang.Object get(
java.util.MapEntry)

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/util/AbstractCollection<TV;>; )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
 class java.util.IdentityHashMap$2 extends java.util.AbstractCollection

----------------FIELDS----------------

final java.util.IdentityHashMap this$0
----------------METHODS----------------

 void <init>(
java.util.IdentityHashMap)

public void clear()

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TV;>; )
public java.util.Iterator iterator()

public boolean remove(
java.lang.Object)

public int size()

________________CLASS________________

@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/util/MapEntry<TK;TV;>; )
@dalvik.annotation.EnclosingClass (value =Ljava/util/IdentityHashMap; )
@dalvik.annotation.InnerClass (accessFlags =8 name =IdentityHashMapEntry )
 class java.util.IdentityHashMap$IdentityHashMapEntry extends java.util.MapEntry

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =(TK;TV;)V )
 void <init>(
java.lang.Object
java.lang.Object)

public java.lang.Object clone()

public boolean equals(
java.lang.Object)

public int hashCode()

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/MapEntry$Type<Ljava/util/Map$Entry<TKT;TVT;>;TKT;TVT;>; )
 class java.util.IdentityHashMap$IdentityHashMapEntrySet$1 extends java.lang.Object implements java.util.MapEntry$Type

----------------FIELDS----------------

final java.util.IdentityHashMap$IdentityHashMapEntrySet this$0
----------------METHODS----------------

 void <init>(
java.util.IdentityHashMap$IdentityHashMapEntrySet)

public volatile java.lang.Object get(
java.util.MapEntry)
@dalvik.annotation.Signature (value =(Ljava/util/MapEntry<TKT;TVT;>;)Ljava/util/Map$Entry<TKT;TVT;>; )
public java.util.Map$Entry get(
java.util.MapEntry)

________________CLASS________________

@dalvik.annotation.Signature (value =<KT:Ljava/lang/Object;VT:Ljava/lang/Object;>Ljava/util/AbstractSet<Ljava/util/Map$Entry<TKT;TVT;>;>; )
@dalvik.annotation.InnerClass (accessFlags =8 name =IdentityHashMapEntrySet )
@dalvik.annotation.EnclosingClass (value =Ljava/util/IdentityHashMap; )
 class java.util.IdentityHashMap$IdentityHashMapEntrySet extends java.util.AbstractSet

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/IdentityHashMap<TKT;TVT;>; )
private final java.util.IdentityHashMap associatedMap
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/IdentityHashMap<TKT;TVT;>;)V )
public void <init>(
java.util.IdentityHashMap)

public void clear()

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/IdentityHashMap<TKT;TVT;>; )
 java.util.IdentityHashMap hashMap()
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<Ljava/util/Map$Entry<TKT;TVT;>;>; )
public java.util.Iterator iterator()

public boolean remove(
java.lang.Object)

public int size()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/IdentityHashMap; )
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;KT:Ljava/lang/Object;VT:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Iterator<TE;>; )
@dalvik.annotation.InnerClass (accessFlags =8 name =IdentityHashMapIterator )
 class java.util.IdentityHashMap$IdentityHashMapIterator extends java.lang.Object implements java.util.Iterator

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/IdentityHashMap<TKT;TVT;>; )
final java.util.IdentityHashMap associatedMap

 boolean canRemove

 int expectedModCount

private int lastPosition

private int position
@dalvik.annotation.Signature (value =Ljava/util/MapEntry$Type<TE;TKT;TVT;>; )
final java.util.MapEntry$Type type
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/MapEntry$Type<TE;TKT;TVT;>;Ljava/util/IdentityHashMap<TKT;TVT;>;)V )
 void <init>(
java.util.MapEntry$Type
java.util.IdentityHashMap)
@dalvik.annotation.Throws (value =Ljava/util/ConcurrentModificationException; )
 void checkConcurrentMod()

public boolean hasNext()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object next()

public void remove()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/IdentityHashMap$IdentityHashMapEntrySet;Ljava/util/IdentityHashMap$IdentityHashMapIterator;Ljava/util/IdentityHashMap$IdentityHashMapEntry; )
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/util/AbstractMap<TK;TV;>;Ljava/util/Map<TK;TV;>;Ljava/io/Serializable;Ljava/lang/Cloneable; )
public class java.util.IdentityHashMap extends java.util.AbstractMap implements java.util.Map, java.io.Serializable, java.lang.Cloneable

----------------FIELDS----------------

private static final int DEFAULT_MAX_SIZE

private static final java.lang.Object NULL_OBJECT

private static final int loadFactor

private static final long serialVersionUID

transient java.lang.Object[] elementData

transient int modCount

 int size

transient int threshold
----------------METHODS----------------

static void <clinit>()

public void <init>()

public void <init>(
int)
@dalvik.annotation.Signature (value =(Ljava/util/Map<+TK;+TV;>;)V )
public void <init>(
java.util.Map)

static java.util.IdentityHashMap$IdentityHashMapEntry access$000(
java.util.IdentityHashMap
int)

static java.util.IdentityHashMap$IdentityHashMapEntry access$100(
java.util.IdentityHashMap
java.lang.Object)

private int computeElementArraySize()

private void computeMaxSize()

private int findIndex(
java.lang.Object
java.lang.Object[])
@dalvik.annotation.Signature (value =(I)Ljava/util/IdentityHashMap$IdentityHashMapEntry<TK;TV;>; )
private java.util.IdentityHashMap$IdentityHashMapEntry getEntry(
int)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;)Ljava/util/IdentityHashMap$IdentityHashMapEntry<TK;TV;>; )
private java.util.IdentityHashMap$IdentityHashMapEntry getEntry(
java.lang.Object)

private int getModuloHash(
java.lang.Object
int)

private int getThreshold(
int)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;)TV; )
private java.lang.Object massageValue(
java.lang.Object)

private java.lang.Object[] newElementArray(
int)
@dalvik.annotation.Signature (value =(Ljava/util/Map<+TK;+TV;>;)V )
private void putAllImpl(
java.util.Map)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)

private void rehash()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

public void clear()

public java.lang.Object clone()

public boolean containsKey(
java.lang.Object)

public boolean containsValue(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/util/Map$Entry<TK;TV;>;>; )
public java.util.Set entrySet()

public boolean equals(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;)TV; )
public java.lang.Object get(
java.lang.Object)

public boolean isEmpty()
@dalvik.annotation.Signature (value =()Ljava/util/Set<TK;>; )
public java.util.Set keySet()
@dalvik.annotation.Signature (value =(TK;TV;)TV; )
public java.lang.Object put(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Map<+TK;+TV;>;)V )
public void putAll(
java.util.Map)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;)TV; )
public java.lang.Object remove(
java.lang.Object)

public int size()
@dalvik.annotation.Signature (value =()Ljava/util/Collection<TV;>; )
public java.util.Collection values()

________________CLASS________________


public class java.util.IllegalFormatCodePointException extends java.util.IllegalFormatException implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

private int c
----------------METHODS----------------

public void <init>(
int)

public int getCodePoint()

public java.lang.String getMessage()

________________CLASS________________


public class java.util.IllegalFormatConversionException extends java.util.IllegalFormatException implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID
@dalvik.annotation.Signature (value =Ljava/lang/Class<*>; )
private java.lang.Class arg

private char c
----------------METHODS----------------
@dalvik.annotation.Signature (value =(CLjava/lang/Class<*>;)V )
public void <init>(
char
java.lang.Class)
@dalvik.annotation.Signature (value =()Ljava/lang/Class<*>; )
public java.lang.Class getArgumentClass()

public char getConversion()

public java.lang.String getMessage()

________________CLASS________________


public class java.util.IllegalFormatFlagsException extends java.util.IllegalFormatException implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

private java.lang.String flags
----------------METHODS----------------

public void <init>(
java.lang.String)

public java.lang.String getFlags()

public java.lang.String getMessage()

________________CLASS________________


public class java.util.IllegalFormatPrecisionException extends java.util.IllegalFormatException

----------------FIELDS----------------

private static final long serialVersionUID

private int p
----------------METHODS----------------

public void <init>(
int)

public java.lang.String getMessage()

public int getPrecision()

________________CLASS________________


public class java.util.IllegalFormatWidthException extends java.util.IllegalFormatException

----------------FIELDS----------------

private static final long serialVersionUID

private int w
----------------METHODS----------------

public void <init>(
int)

public java.lang.String getMessage()

public int getWidth()

________________CLASS________________


public class java.util.NoSuchElementException extends java.lang.RuntimeException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class java.util.InputMismatchException extends java.util.NoSuchElementException implements java.io.Serializable

----------------FIELDS----------------

static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class java.util.InvalidPropertiesFormatException extends java.io.IOException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>(
java.lang.String)

public void <init>(
java.lang.Throwable)
@dalvik.annotation.Throws (value =Ljava/io/NotSerializableException; )
private void readObject(
java.io.ObjectInputStream)
@dalvik.annotation.Throws (value =Ljava/io/NotSerializableException; )
private void writeObject(
java.io.ObjectOutputStream)

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/MapEntry$Type<TK;TK;TV;>; )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
 class java.util.LinkedHashMap$1$1 extends java.lang.Object implements java.util.MapEntry$Type

----------------FIELDS----------------

final java.util.LinkedHashMap$1 this$1
----------------METHODS----------------

 void <init>(
java.util.LinkedHashMap$1)
@dalvik.annotation.Signature (value =(Ljava/util/MapEntry<TK;TV;>;)TK; )
public java.lang.Object get(
java.util.MapEntry)

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.Signature (value =Ljava/util/AbstractSet<TK;>; )
 class java.util.LinkedHashMap$1 extends java.util.AbstractSet

----------------FIELDS----------------

final java.util.LinkedHashMap this$0
----------------METHODS----------------

 void <init>(
java.util.LinkedHashMap)

public void clear()

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TK;>; )
public java.util.Iterator iterator()

public boolean remove(
java.lang.Object)

public int size()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/MapEntry$Type<TV;TK;TV;>; )
 class java.util.LinkedHashMap$2$1 extends java.lang.Object implements java.util.MapEntry$Type

----------------FIELDS----------------

final java.util.LinkedHashMap$2 this$1
----------------METHODS----------------

 void <init>(
java.util.LinkedHashMap$2)
@dalvik.annotation.Signature (value =(Ljava/util/MapEntry<TK;TV;>;)TV; )
public java.lang.Object get(
java.util.MapEntry)

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/util/AbstractCollection<TV;>; )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
 class java.util.LinkedHashMap$2 extends java.util.AbstractCollection

----------------FIELDS----------------

final java.util.LinkedHashMap this$0
----------------METHODS----------------

 void <init>(
java.util.LinkedHashMap)

public void clear()

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TV;>; )
public java.util.Iterator iterator()

public int size()

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;KT:Ljava/lang/Object;VT:Ljava/lang/Object;>Ljava/util/HashMap$HashMapIterator<TE;TKT;TVT;>; )
@dalvik.annotation.InnerClass (accessFlags =24 name =LinkedHashIterator )
@dalvik.annotation.EnclosingClass (value =Ljava/util/LinkedHashMap; )
final class java.util.LinkedHashMap$LinkedHashIterator extends java.util.HashMap$HashMapIterator

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/MapEntry$Type<TE;TKT;TVT;>;Ljava/util/LinkedHashMap<TKT;TVT;>;)V )
 void <init>(
java.util.MapEntry$Type
java.util.LinkedHashMap)

public boolean hasNext()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object next()

public void remove()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =24 name =LinkedHashMapEntry )
@dalvik.annotation.EnclosingClass (value =Ljava/util/LinkedHashMap; )
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/util/HashMap$Entry<TK;TV;>; )
final class java.util.LinkedHashMap$LinkedHashMapEntry extends java.util.HashMap$Entry

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/LinkedHashMap$LinkedHashMapEntry<TK;TV;>; )
 java.util.LinkedHashMap$LinkedHashMapEntry chainBackward
@dalvik.annotation.Signature (value =Ljava/util/LinkedHashMap$LinkedHashMapEntry<TK;TV;>; )
 java.util.LinkedHashMap$LinkedHashMapEntry chainForward
----------------METHODS----------------
@dalvik.annotation.Signature (value =(TK;I)V )
 void <init>(
java.lang.Object
int)
@dalvik.annotation.Signature (value =(TK;TV;)V )
 void <init>(
java.lang.Object
java.lang.Object)

public java.lang.Object clone()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/MapEntry$Type<Ljava/util/Map$Entry<TKT;TVT;>;TKT;TVT;>; )
 class java.util.LinkedHashMap$LinkedHashMapEntrySet$1 extends java.lang.Object implements java.util.MapEntry$Type

----------------FIELDS----------------

final java.util.LinkedHashMap$LinkedHashMapEntrySet this$0
----------------METHODS----------------

 void <init>(
java.util.LinkedHashMap$LinkedHashMapEntrySet)

public volatile java.lang.Object get(
java.util.MapEntry)
@dalvik.annotation.Signature (value =(Ljava/util/MapEntry<TKT;TVT;>;)Ljava/util/Map$Entry<TKT;TVT;>; )
public java.util.Map$Entry get(
java.util.MapEntry)

________________CLASS________________

@dalvik.annotation.Signature (value =<KT:Ljava/lang/Object;VT:Ljava/lang/Object;>Ljava/util/HashMap$HashMapEntrySet<TKT;TVT;>; )
@dalvik.annotation.InnerClass (accessFlags =24 name =LinkedHashMapEntrySet )
@dalvik.annotation.EnclosingClass (value =Ljava/util/LinkedHashMap; )
final class java.util.LinkedHashMap$LinkedHashMapEntrySet extends java.util.HashMap$HashMapEntrySet

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/LinkedHashMap<TKT;TVT;>;)V )
public void <init>(
java.util.LinkedHashMap)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<Ljava/util/Map$Entry<TKT;TVT;>;>; )
public java.util.Iterator iterator()

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/util/HashSet<TE;>;Ljava/util/Set<TE;>;Ljava/lang/Cloneable;Ljava/io/Serializable; )
public class java.util.LinkedHashSet extends java.util.HashSet implements java.util.Set, java.lang.Cloneable, java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
int)

public void <init>(
int
float)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<+TE;>;)V )
public void <init>(
java.util.Collection)
@dalvik.annotation.Signature (value =(IF)Ljava/util/HashMap<TE;Ljava/util/HashSet<TE;>;>; )
 java.util.HashMap createBackingMap(
int
float)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =26 name =Link )
@dalvik.annotation.Signature (value =<ET:Ljava/lang/Object;>Ljava/lang/Object; )
@dalvik.annotation.EnclosingClass (value =Ljava/util/LinkedList; )
final class java.util.LinkedList$Link extends java.lang.Object

----------------FIELDS----------------
@dalvik.annotation.Signature (value =TET; )
 java.lang.Object data
@dalvik.annotation.Signature (value =Ljava/util/LinkedList$Link<TET;>; )
 java.util.LinkedList$Link next
@dalvik.annotation.Signature (value =Ljava/util/LinkedList$Link<TET;>; )
 java.util.LinkedList$Link previous
----------------METHODS----------------
@dalvik.annotation.Signature (value =(TET;Ljava/util/LinkedList$Link<TET;>;Ljava/util/LinkedList$Link<TET;>;)V )
 void <init>(
java.lang.Object
java.util.LinkedList$Link
java.util.LinkedList$Link)

________________CLASS________________

@dalvik.annotation.Signature (value =<ET:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/ListIterator<TET;>; )
@dalvik.annotation.InnerClass (accessFlags =26 name =LinkIterator )
@dalvik.annotation.EnclosingClass (value =Ljava/util/LinkedList; )
final class java.util.LinkedList$LinkIterator extends java.lang.Object implements java.util.ListIterator

----------------FIELDS----------------

 int expectedModCount
@dalvik.annotation.Signature (value =Ljava/util/LinkedList$Link<TET;>; )
 java.util.LinkedList$Link lastLink
@dalvik.annotation.Signature (value =Ljava/util/LinkedList$Link<TET;>; )
 java.util.LinkedList$Link link
@dalvik.annotation.Signature (value =Ljava/util/LinkedList<TET;>; )
final java.util.LinkedList list

 int pos
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/LinkedList<TET;>;I)V )
 void <init>(
java.util.LinkedList
int)
@dalvik.annotation.Signature (value =(TET;)V )
public void add(
java.lang.Object)

public boolean hasNext()

public boolean hasPrevious()
@dalvik.annotation.Signature (value =()TET; )
public java.lang.Object next()

public int nextIndex()
@dalvik.annotation.Signature (value =()TET; )
public java.lang.Object previous()

public int previousIndex()

public void remove()
@dalvik.annotation.Signature (value =(TET;)V )
public void set(
java.lang.Object)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/LinkedList$LinkIterator;Ljava/util/LinkedList$Link; )
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/util/AbstractSequentialList<TE;>;Ljava/util/List<TE;>;Ljava/util/Queue<TE;>;Ljava/lang/Cloneable;Ljava/io/Serializable; )
public class java.util.LinkedList extends java.util.AbstractSequentialList implements java.util.List, java.util.Queue, java.lang.Cloneable, java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

transient int size
@dalvik.annotation.Signature (value =Ljava/util/LinkedList$Link<TE;>; )
transient java.util.LinkedList$Link voidLink
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Signature (value =(Ljava/util/Collection<+TE;>;)V )
public void <init>(
java.util.Collection)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)
@dalvik.annotation.Signature (value =(ITE;)V )
public void add(
int
java.lang.Object)
@dalvik.annotation.Signature (value =(TE;)Z )
public boolean add(
java.lang.Object)
@dalvik.annotation.Signature (value =(ILjava/util/Collection<+TE;>;)Z )
public boolean addAll(
int
java.util.Collection)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<+TE;>;)Z )
public boolean addAll(
java.util.Collection)
@dalvik.annotation.Signature (value =(TE;)V )
public void addFirst(
java.lang.Object)
@dalvik.annotation.Signature (value =(TE;)V )
public void addLast(
java.lang.Object)

public void clear()

public java.lang.Object clone()

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object element()
@dalvik.annotation.Signature (value =(I)TE; )
public java.lang.Object get(
int)
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object getFirst()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object getLast()

public int indexOf(
java.lang.Object)

public int lastIndexOf(
java.lang.Object)
@dalvik.annotation.Signature (value =(I)Ljava/util/ListIterator<TE;>; )
public java.util.ListIterator listIterator(
int)
@dalvik.annotation.Signature (value =(TE;)Z )
public boolean offer(
java.lang.Object)
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object peek()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object poll()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object remove()
@dalvik.annotation.Signature (value =(I)TE; )
public java.lang.Object remove(
int)

public boolean remove(
java.lang.Object)
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object removeFirst()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object removeLast()
@dalvik.annotation.Signature (value =(ITE;)TE; )
public java.lang.Object set(
int
java.lang.Object)

public int size()

public java.lang.Object[] toArray()
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>([TT;)[TT; )
public java.lang.Object[] toArray(
java.lang.Object[])

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Enumeration<Ljava/lang/String;>; )
@dalvik.annotation.EnclosingMethod (value =null )
 class java.util.ListResourceBundle$1 extends java.lang.Object implements java.util.Enumeration

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Enumeration<Ljava/lang/String;>; )
 java.util.Enumeration local

 java.lang.String nextElement
@dalvik.annotation.Signature (value =Ljava/util/Enumeration<Ljava/lang/String;>; )
 java.util.Enumeration pEnum

final java.util.ListResourceBundle this$0
----------------METHODS----------------

 void <init>(
java.util.ListResourceBundle)

private boolean findNext()

public boolean hasMoreElements()

public volatile java.lang.Object nextElement()

public java.lang.String nextElement()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/util/ResourceBundle;>; )
final class java.util.Locale$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final java.lang.String val$clName

final java.util.Locale val$locale
----------------METHODS----------------

 void <init>(
java.lang.String
java.util.Locale)

public volatile java.lang.Object run()

public java.util.ResourceBundle run()

________________CLASS________________


public final class java.util.Locale extends java.lang.Object implements java.lang.Cloneable, java.io.Serializable

----------------FIELDS----------------

public static final java.util.Locale CANADA

public static final java.util.Locale CANADA_FRENCH

public static final java.util.Locale CHINA

public static final java.util.Locale CHINESE

public static final java.util.Locale ENGLISH

public static final java.util.Locale FRANCE

public static final java.util.Locale FRENCH

public static final java.util.Locale GERMAN

public static final java.util.Locale GERMANY

public static final java.util.Locale ITALIAN

public static final java.util.Locale ITALY

public static final java.util.Locale JAPAN

public static final java.util.Locale JAPANESE

public static final java.util.Locale KOREA

public static final java.util.Locale KOREAN

public static final java.util.Locale PRC

public static final java.util.Locale SIMPLIFIED_CHINESE

public static final java.util.Locale TAIWAN

public static final java.util.Locale TRADITIONAL_CHINESE

public static final java.util.Locale UK

public static final java.util.Locale US

private static java.util.Locale[] availableLocales

private static java.util.Locale defaultLocale

private static final java.io.ObjectStreamField[] serialPersistentFields

private static final long serialVersionUID

private static final java.util.PropertyPermission setLocalePermission

private transient java.lang.String countryCode

private transient java.lang.String languageCode

private transient java.lang.String variantCode
----------------METHODS----------------

static void <clinit>()

private void <init>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.String)

public void <init>(
java.lang.String
java.lang.String
java.lang.String)

static java.util.Locale[] find()

public static java.util.Locale[] getAvailableLocales()

static java.util.ResourceBundle getBundle(
java.lang.String
java.util.Locale)

public static java.util.Locale getDefault()

public static java.lang.String[] getISOCountries()

public static java.lang.String[] getISOLanguages()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)

public static void setDefault(
java.util.Locale)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

public java.lang.Object clone()

public boolean equals(
java.lang.Object)

public java.lang.String getCountry()

public final java.lang.String getDisplayCountry()

public java.lang.String getDisplayCountry(
java.util.Locale)

public final java.lang.String getDisplayLanguage()

public java.lang.String getDisplayLanguage(
java.util.Locale)

public final java.lang.String getDisplayName()

public java.lang.String getDisplayName(
java.util.Locale)

public final java.lang.String getDisplayVariant()

public java.lang.String getDisplayVariant(
java.util.Locale)
@dalvik.annotation.Throws (value =Ljava/util/MissingResourceException; )
public java.lang.String getISO3Country()
@dalvik.annotation.Throws (value =Ljava/util/MissingResourceException; )
public java.lang.String getISO3Language()

public java.lang.String getLanguage()

public java.lang.String getVariant()

public int hashCode()

public final java.lang.String toString()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/MiniEnumSet; )
@dalvik.annotation.InnerClass (accessFlags =4104 name =null )
 class java.util.MiniEnumSet$1 extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =2 name =MiniEnumSetIterator )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Iterator<TE;>; )
@dalvik.annotation.EnclosingClass (value =Ljava/util/MiniEnumSet; )
 class java.util.MiniEnumSet$MiniEnumSetIterator extends java.lang.Object implements java.util.Iterator

----------------FIELDS----------------

private boolean canProcess

private long currentElementMask

final java.util.MiniEnumSet this$0

private long unProcessedBits
----------------METHODS----------------

private void <init>(
java.util.MiniEnumSet)

 void <init>(
java.util.MiniEnumSet
java.util.MiniEnumSet$1)

public boolean hasNext()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Enum next()

public volatile java.lang.Object next()

public void remove()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/MiniEnumSet$1;Ljava/util/MiniEnumSet$MiniEnumSetIterator; )
@dalvik.annotation.Signature (value =<E:Ljava/lang/Enum<TE;>;>Ljava/util/EnumSet<TE;>; )
final class java.util.MiniEnumSet extends java.util.EnumSet

----------------FIELDS----------------

private static final int MAX_ELEMENTS

private long bits
@dalvik.annotation.Signature (value =[TE; )
private final java.lang.Enum[] enums

private int size
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/lang/Class<TE;>;[TE;)V )
 void <init>(
java.lang.Class
java.lang.Enum[])

static long access$000(
java.util.MiniEnumSet)

static long access$074(
java.util.MiniEnumSet
long)

static java.lang.Enum[] access$100(
java.util.MiniEnumSet)

static int access$202(
java.util.MiniEnumSet
int)
@dalvik.annotation.Signature (value =(TE;)Z )
public boolean add(
java.lang.Enum)

public volatile boolean add(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<+TE;>;)Z )
public boolean addAll(
java.util.Collection)

public void clear()

 void complement()

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public boolean containsAll(
java.util.Collection)

public boolean equals(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TE;>; )
public java.util.Iterator iterator()

public boolean remove(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public boolean removeAll(
java.util.Collection)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public boolean retainAll(
java.util.Collection)
@dalvik.annotation.Signature (value =(TE;TE;)V )
 void setRange(
java.lang.Enum
java.lang.Enum)

public int size()

________________CLASS________________


public class java.util.MissingFormatArgumentException extends java.util.IllegalFormatException

----------------FIELDS----------------

private static final long serialVersionUID

private java.lang.String s
----------------METHODS----------------

public void <init>(
java.lang.String)

public java.lang.String getFormatSpecifier()

public java.lang.String getMessage()

________________CLASS________________


public class java.util.MissingFormatWidthException extends java.util.IllegalFormatException

----------------FIELDS----------------

private static final long serialVersionUID

private java.lang.String s
----------------METHODS----------------

public void <init>(
java.lang.String)

public java.lang.String getFormatSpecifier()

public java.lang.String getMessage()

________________CLASS________________


public class java.util.MissingResourceException extends java.lang.RuntimeException

----------------FIELDS----------------

private static final long serialVersionUID

 java.lang.String className

 java.lang.String key
----------------METHODS----------------

public void <init>(
java.lang.String
java.lang.String
java.lang.String)

public java.lang.String getClassName()

public java.lang.String getKey()

________________CLASS________________


public class java.util.Observable extends java.lang.Object

----------------FIELDS----------------

 boolean changed
@dalvik.annotation.Signature (value =Ljava/util/Vector<Ljava/util/Observer;>; )
 java.util.Vector observers
----------------METHODS----------------

public void <init>()

public void addObserver(
java.util.Observer)

protected void clearChanged()

public int countObservers()

public void deleteObserver(
java.util.Observer)

public void deleteObservers()

public boolean hasChanged()

public void notifyObservers()

public void notifyObservers(
java.lang.Object)

protected void setChanged()

________________CLASS________________


public abstract interface class java.util.Observer extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract void update(
java.util.Observable
java.lang.Object)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =4104 name =null )
@dalvik.annotation.EnclosingClass (value =Ljava/util/PriorityQueue; )
 class java.util.PriorityQueue$1 extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =2 name =PriorityIterator )
@dalvik.annotation.EnclosingClass (value =Ljava/util/PriorityQueue; )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Iterator<TE;>; )
 class java.util.PriorityQueue$PriorityIterator extends java.lang.Object implements java.util.Iterator

----------------FIELDS----------------

private boolean allowRemove

private int currentIndex

final java.util.PriorityQueue this$0
----------------METHODS----------------

private void <init>(
java.util.PriorityQueue)

 void <init>(
java.util.PriorityQueue
java.util.PriorityQueue$1)

public boolean hasNext()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object next()

public void remove()

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/util/AbstractQueue<TE;>;Ljava/io/Serializable; )
@dalvik.annotation.MemberClasses (value =Ljava/util/PriorityQueue$1;Ljava/util/PriorityQueue$PriorityIterator; )
public class java.util.PriorityQueue extends java.util.AbstractQueue implements java.io.Serializable

----------------FIELDS----------------

private static final int DEFAULT_CAPACITY

private static final int DEFAULT_CAPACITY_RATIO

private static final double DEFAULT_INIT_CAPACITY_RATIO

private static final long serialVersionUID
@dalvik.annotation.Signature (value =Ljava/util/Comparator<-TE;>; )
private java.util.Comparator comparator
@dalvik.annotation.Signature (value =[TE; )
private transient java.lang.Object[] elements

private int size
----------------METHODS----------------

public void <init>()

public void <init>(
int)
@dalvik.annotation.Signature (value =(ILjava/util/Comparator<-TE;>;)V )
public void <init>(
int
java.util.Comparator)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<+TE;>;)V )
public void <init>(
java.util.Collection)
@dalvik.annotation.Signature (value =(Ljava/util/PriorityQueue<+TE;>;)V )
public void <init>(
java.util.PriorityQueue)
@dalvik.annotation.Signature (value =(Ljava/util/SortedSet<+TE;>;)V )
public void <init>(
java.util.SortedSet)

static int access$100(
java.util.PriorityQueue)

static java.lang.Object[] access$200(
java.util.PriorityQueue)

static void access$300(
java.util.PriorityQueue
int)
@dalvik.annotation.Signature (value =(TE;TE;)I )
private int compare(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/PriorityQueue<+TE;>;)V )
private void getFromPriorityQueue(
java.util.PriorityQueue)
@dalvik.annotation.Signature (value =(Ljava/util/SortedSet<+TE;>;)V )
private void getFromSortedSet(
java.util.SortedSet)

private void growToSize(
int)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<+TE;>;)V )
private void initSize(
java.util.Collection)
@dalvik.annotation.Signature (value =(I)[TE; )
private java.lang.Object[] newElementArray(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)

private void removeAt(
int)

private void siftDown(
int)

private void siftUp(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)
@dalvik.annotation.Signature (value =(TE;)Z )
public boolean add(
java.lang.Object)

public void clear()
@dalvik.annotation.Signature (value =()Ljava/util/Comparator<-TE;>; )
public java.util.Comparator comparator()
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TE;>; )
public java.util.Iterator iterator()
@dalvik.annotation.Signature (value =(TE;)Z )
public boolean offer(
java.lang.Object)
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object peek()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object poll()

public boolean remove(
java.lang.Object)

public int size()

________________CLASS________________


public abstract interface class org.xml.sax.ErrorHandler extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public abstract void error(
org.xml.sax.SAXParseException)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public abstract void fatalError(
org.xml.sax.SAXParseException)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public abstract void warning(
org.xml.sax.SAXParseException)

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
 class java.util.Properties$1 extends java.lang.Object implements org.xml.sax.ErrorHandler

----------------FIELDS----------------

final java.util.Properties this$0
----------------METHODS----------------

 void <init>(
java.util.Properties)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void error(
org.xml.sax.SAXParseException)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void fatalError(
org.xml.sax.SAXParseException)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void warning(
org.xml.sax.SAXParseException)

________________CLASS________________


public abstract interface class org.xml.sax.EntityResolver extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException;Ljava/io/IOException; )
public abstract org.xml.sax.InputSource resolveEntity(
java.lang.String
java.lang.String)

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
 class java.util.Properties$2 extends java.lang.Object implements org.xml.sax.EntityResolver

----------------FIELDS----------------

final java.util.Properties this$0
----------------METHODS----------------

 void <init>(
java.util.Properties)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException;Ljava/io/IOException; )
public org.xml.sax.InputSource resolveEntity(
java.lang.String
java.lang.String)

________________CLASS________________


public final class java.util.PropertyPermission extends java.security.BasicPermission

----------------FIELDS----------------

private static final java.io.ObjectStreamField[] serialPersistentFields

private static final long serialVersionUID

private transient boolean read

private transient boolean write
----------------METHODS----------------

static void <clinit>()

public void <init>(
java.lang.String
java.lang.String)

private void decodeActions(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

public boolean equals(
java.lang.Object)

public java.lang.String getActions()

public int hashCode()

public boolean implies(
java.security.Permission)

public java.security.PermissionCollection newPermissionCollection()

________________CLASS________________


 class java.util.PropertyPermissionCollection extends java.security.PermissionCollection

----------------FIELDS----------------

private static final java.io.ObjectStreamField[] serialPersistentFields

private static final long serialVersionUID
@dalvik.annotation.Signature (value =Ljava/util/Hashtable<Ljava/lang/String;Ljava/security/Permission;>; )
 java.util.Hashtable permissions
----------------METHODS----------------

static void <clinit>()

 void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

public void add(
java.security.Permission)
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<Ljava/security/Permission;>; )
public java.util.Enumeration elements()

public boolean implies(
java.security.Permission)

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Enumeration<Ljava/lang/String;>; )
 class java.util.PropertyResourceBundle$1 extends java.lang.Object implements java.util.Enumeration

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Enumeration<Ljava/lang/String;>; )
 java.util.Enumeration local

 java.lang.String nextElement
@dalvik.annotation.Signature (value =Ljava/util/Enumeration<Ljava/lang/String;>; )
 java.util.Enumeration pEnum

final java.util.PropertyResourceBundle this$0
----------------METHODS----------------

 void <init>(
java.util.PropertyResourceBundle)

private boolean findNext()

public boolean hasMoreElements()

public volatile java.lang.Object nextElement()

public java.lang.String nextElement()

________________CLASS________________


public class java.util.PropertyResourceBundle extends java.util.ResourceBundle

----------------FIELDS----------------

 java.util.Properties resources
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.io.InputStream)

static java.util.Enumeration access$000(
java.util.PropertyResourceBundle)
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<Ljava/lang/String;>; )
private java.util.Enumeration getLocalKeys()
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<Ljava/lang/String;>; )
public java.util.Enumeration getKeys()

public java.lang.Object handleGetObject(
java.lang.String)

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/io/InputStream;>; )
final class java.util.ResourceBundle$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final java.lang.String val$fileName

final java.lang.ClassLoader val$loader
----------------METHODS----------------

 void <init>(
java.lang.ClassLoader
java.lang.String)

public java.io.InputStream run()

public volatile java.lang.Object run()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/ResourceBundle; )
@dalvik.annotation.InnerClass (accessFlags =8 name =MissingBundle )
 class java.util.ResourceBundle$MissingBundle extends java.util.ResourceBundle

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<Ljava/lang/String;>; )
public java.util.Enumeration getKeys()

public java.lang.Object handleGetObject(
java.lang.String)

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Enum<Ljava/util/Scanner$DataType;>; )
@dalvik.annotation.InnerClass (accessFlags =16410 name =DataType )
@dalvik.annotation.EnclosingClass (value =Ljava/util/Scanner; )
final class java.util.Scanner$DataType extends java.lang.Enum

----------------FIELDS----------------

private static final java.util.Scanner$DataType[] $VALUES

public static final java.util.Scanner$DataType FLOAT

public static final java.util.Scanner$DataType INT
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Signature (value =()V )
private void <init>(
java.lang.String
int)

public static java.util.Scanner$DataType valueOf(
java.lang.String)

public static java.util.Scanner$DataType[] values()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/Scanner$DataType; )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Iterator<Ljava/lang/String;>; )
public final class java.util.Scanner extends java.lang.Object implements java.util.Iterator

----------------FIELDS----------------

private static final java.util.regex.Pattern ANY_PATTERN

private static final java.util.regex.Pattern BOOLEAN_PATTERN

private static final java.util.regex.Pattern DEFAULT_DELIMITER

private static final int DEFAULT_RADIX

private static final int DEFAULT_TRUNK_SIZE

private static final int DIPLOID

private static final java.util.regex.Pattern LINE_PATTERN

private static final java.util.regex.Pattern LINE_TERMINATOR

private static final java.util.regex.Pattern MULTI_LINE_TERMINATOR

private java.nio.CharBuffer buffer

private int bufferLength

private java.lang.Object cacheHasNextValue

private int cachehasNextIndex

private boolean closed

private java.text.DecimalFormat decimalFormat

private java.util.regex.Pattern delimiter

private int findStartIndex

private java.lang.Readable input

private boolean inputExhausted

private int integerRadix

private java.io.IOException lastIOException

private java.util.Locale locale

private boolean matchSuccessful

private java.util.regex.Matcher matcher

private int preStartIndex
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Throws (value =Ljava/io/FileNotFoundException; )
public void <init>(
java.io.File)
@dalvik.annotation.Throws (value =Ljava/io/FileNotFoundException; )
public void <init>(
java.io.File
java.lang.String)

public void <init>(
java.io.InputStream)

public void <init>(
java.io.InputStream
java.lang.String)

public void <init>(
java.lang.Readable)

public void <init>(
java.lang.String)

public void <init>(
java.nio.channels.ReadableByteChannel)

public void <init>(
java.nio.channels.ReadableByteChannel
java.lang.String)

private java.lang.StringBuilder addNegativeSign(
java.lang.StringBuilder)

private java.lang.StringBuilder addPositiveSign(
java.lang.StringBuilder)

private void checkClosed()

private void checkNull(
java.util.regex.Pattern)

private void expandBuffer()

private int findPostDelimiter()

private int findPreDelimiter()

private java.util.regex.Pattern getFloatPattern()

private java.util.regex.Pattern getIntegerPattern(
int)

private java.lang.StringBuilder getNumeral(
java.lang.StringBuilder
java.lang.StringBuilder)

private void initialization()

private void readMore()

private void recoverPreviousStatus()

private java.lang.String removeLocaleInfo(
java.lang.String
java.util.Scanner$DataType)

private java.lang.String removeLocaleInfoFromFloat(
java.lang.String)

private boolean removeLocaleSign(
java.lang.StringBuilder)

private void resetMatcher()

private void saveCurrentStatus()

private boolean setHeadTokenRegion(
int)

private boolean setTokenRegion()

public void close()

public java.util.regex.Pattern delimiter()

public java.lang.String findInLine(
java.lang.String)

public java.lang.String findInLine(
java.util.regex.Pattern)

public java.lang.String findWithinHorizon(
java.lang.String
int)

public java.lang.String findWithinHorizon(
java.util.regex.Pattern
int)

public boolean hasNext()

public boolean hasNext(
java.lang.String)

public boolean hasNext(
java.util.regex.Pattern)

public boolean hasNextBigDecimal()

public boolean hasNextBigInteger()

public boolean hasNextBigInteger(
int)

public boolean hasNextBoolean()

public boolean hasNextByte()

public boolean hasNextByte(
int)

public boolean hasNextDouble()

public boolean hasNextFloat()

public boolean hasNextInt()

public boolean hasNextInt(
int)

public boolean hasNextLine()

public boolean hasNextLong()

public boolean hasNextLong(
int)

public boolean hasNextShort()

public boolean hasNextShort(
int)

public java.io.IOException ioException()

public java.util.Locale locale()

public java.util.regex.MatchResult match()

public volatile java.lang.Object next()

public java.lang.String next()

public java.lang.String next(
java.lang.String)

public java.lang.String next(
java.util.regex.Pattern)

public java.math.BigDecimal nextBigDecimal()

public java.math.BigInteger nextBigInteger()

public java.math.BigInteger nextBigInteger(
int)

public boolean nextBoolean()

public byte nextByte()

public byte nextByte(
int)

public double nextDouble()

public float nextFloat()

public int nextInt()

public int nextInt(
int)

public java.lang.String nextLine()

public long nextLong()

public long nextLong(
int)

public short nextShort()

public short nextShort(
int)

public int radix()

public void remove()

public java.util.Scanner skip(
java.lang.String)

public java.util.Scanner skip(
java.util.regex.Pattern)

public java.lang.String toString()

public java.util.Scanner useDelimiter(
java.lang.String)

public java.util.Scanner useDelimiter(
java.util.regex.Pattern)

public java.util.Scanner useLocale(
java.util.Locale)

public java.util.Scanner useRadix(
int)

________________CLASS________________


public abstract class java.util.TimeZone extends java.lang.Object implements java.io.Serializable, java.lang.Cloneable

----------------FIELDS----------------

private static java.util.TimeZone Default

static java.util.TimeZone GMT

public static final int LONG

public static final int SHORT

private static final long serialVersionUID

private java.lang.String ID
----------------METHODS----------------

static void <clinit>()

public void <init>()

private void appendNumber(
java.lang.StringBuffer
int
int)

private static java.lang.String formatTimeZoneName(
java.lang.String
int)

public static java.lang.String[] getAvailableIDs()

public static java.lang.String[] getAvailableIDs(
int)

public static java.util.TimeZone getDefault()

public static java.util.TimeZone getTimeZone(
java.lang.String)

private static int parseNumber(
java.lang.String
int
int[])

public static void setDefault(
java.util.TimeZone)

public java.lang.Object clone()

public int getDSTSavings()

public final java.lang.String getDisplayName()

public final java.lang.String getDisplayName(
java.util.Locale)

public final java.lang.String getDisplayName(
boolean
int)

public java.lang.String getDisplayName(
boolean
int
java.util.Locale)

public java.lang.String getID()

public abstract int getOffset(
int
int
int
int
int
int)

public int getOffset(
long)

public abstract int getRawOffset()

public boolean hasSameRules(
java.util.TimeZone)

public abstract boolean inDaylightTime(
java.util.Date)

public void setID(
java.lang.String)

public abstract void setRawOffset(
int)

public abstract boolean useDaylightTime()

________________CLASS________________


public class java.util.SimpleTimeZone extends java.util.TimeZone

----------------FIELDS----------------

private static final int DOM_MODE

private static final int DOW_GE_DOM_MODE

private static final int DOW_IN_MONTH_MODE

private static final int DOW_LE_DOM_MODE

public static final int STANDARD_TIME

public static final int UTC_TIME

public static final int WALL_TIME

private static final java.io.ObjectStreamField[] serialPersistentFields

private static final long serialVersionUID

private java.util.GregorianCalendar daylightSavings

private int dstSavings

private int endDay

private int endDayOfWeek

private int endMode

private int endMonth

private int endTime

private int rawOffset

private int startDay

private int startDayOfWeek

private int startMode

private int startMonth

private int startTime

private int startYear

private boolean useDaylight
----------------METHODS----------------

static void <clinit>()

public void <init>(
int
java.lang.String)

public void <init>(
int
java.lang.String
int
int
int
int
int
int
int
int)

public void <init>(
int
java.lang.String
int
int
int
int
int
int
int
int
int)

public void <init>(
int
java.lang.String
int
int
int
int
int
int
int
int
int
int
int)

private void checkDay(
int
int)

private void checkRange(
int
int
int)

private boolean isLeapYear(
int)

private int mod7(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)

private void setEndMode()

private void setStartMode()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

public java.lang.Object clone()

public boolean equals(
java.lang.Object)

public int getDSTSavings()

public int getOffset(
int
int
int
int
int
int)

public int getOffset(
long)

public int getRawOffset()

public boolean hasSameRules(
java.util.TimeZone)

public int hashCode()

public boolean inDaylightTime(
java.util.Date)

public void setDSTSavings(
int)

public void setEndRule(
int
int
int)

public void setEndRule(
int
int
int
int)

public void setEndRule(
int
int
int
int
boolean)

public void setRawOffset(
int)

public void setStartRule(
int
int
int)

public void setStartRule(
int
int
int
int)

public void setStartRule(
int
int
int
int
boolean)

public void setStartYear(
int)

public java.lang.String toString()

public boolean useDaylightTime()

________________CLASS________________


final class java.util.SpecialAccess extends java.lang.Object

----------------FIELDS----------------

static final org.apache.harmony.kernel.vm.LangAccess LANG
----------------METHODS----------------

static void <clinit>()

 void <init>()

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/util/AbstractList<TE;>;Ljava/util/List<TE;>;Ljava/util/RandomAccess;Ljava/lang/Cloneable;Ljava/io/Serializable; )
public class java.util.Vector extends java.util.AbstractList implements java.util.List, java.util.RandomAccess, java.lang.Cloneable, java.io.Serializable

----------------FIELDS----------------

static final boolean $assertionsDisabled

private static final int DEFAULT_SIZE

private static final long serialVersionUID

protected int capacityIncrement

protected int elementCount

protected java.lang.Object[] elementData
----------------METHODS----------------

static void <clinit>()

public void <init>()

public void <init>(
int)

public void <init>(
int
int)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<+TE;>;)V )
public void <init>(
java.util.Collection)

private void grow(
int)

private void growBy(
int)

private void growByOne()
@dalvik.annotation.Signature (value =(I)[TE; )
private java.lang.Object[] newElementArray(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)
@dalvik.annotation.Signature (value =(ITE;)V )
public void add(
int
java.lang.Object)
@dalvik.annotation.Signature (value =(TE;)Z )
public boolean add(
java.lang.Object)
@dalvik.annotation.Signature (value =(ILjava/util/Collection<+TE;>;)Z )
public boolean addAll(
int
java.util.Collection)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<+TE;>;)Z )
public boolean addAll(
java.util.Collection)
@dalvik.annotation.Signature (value =(TE;)V )
public void addElement(
java.lang.Object)

public int capacity()

public void clear()

public java.lang.Object clone()

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public boolean containsAll(
java.util.Collection)

public void copyInto(
java.lang.Object[])
@dalvik.annotation.Signature (value =(I)TE; )
public java.lang.Object elementAt(
int)
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<TE;>; )
public java.util.Enumeration elements()

public void ensureCapacity(
int)

public boolean equals(
java.lang.Object)
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object firstElement()
@dalvik.annotation.Signature (value =(I)TE; )
public java.lang.Object get(
int)

public int hashCode()

public int indexOf(
java.lang.Object)

public int indexOf(
java.lang.Object
int)
@dalvik.annotation.Signature (value =(TE;I)V )
public void insertElementAt(
java.lang.Object
int)

public boolean isEmpty()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object lastElement()

public int lastIndexOf(
java.lang.Object)

public int lastIndexOf(
java.lang.Object
int)
@dalvik.annotation.Signature (value =(I)TE; )
public java.lang.Object remove(
int)

public boolean remove(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public boolean removeAll(
java.util.Collection)

public void removeAllElements()

public boolean removeElement(
java.lang.Object)

public void removeElementAt(
int)

protected void removeRange(
int
int)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public boolean retainAll(
java.util.Collection)
@dalvik.annotation.Signature (value =(ITE;)TE; )
public java.lang.Object set(
int
java.lang.Object)
@dalvik.annotation.Signature (value =(TE;I)V )
public void setElementAt(
java.lang.Object
int)

public void setSize(
int)

public int size()
@dalvik.annotation.Signature (value =(II)Ljava/util/List<TE;>; )
public java.util.List subList(
int
int)

public java.lang.Object[] toArray()
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>([TT;)[TT; )
public java.lang.Object[] toArray(
java.lang.Object[])

public java.lang.String toString()

public void trimToSize()

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/util/Vector<TE;>; )
public class java.util.Stack extends java.util.Vector

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public boolean empty()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object peek()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object pop()
@dalvik.annotation.Signature (value =(TE;)TE; )
public java.lang.Object push(
java.lang.Object)

public int search(
java.lang.Object)

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Enumeration<Ljava/lang/Object;>; )
public class java.util.StringTokenizer extends java.lang.Object implements java.util.Enumeration

----------------FIELDS----------------

private java.lang.String delimiters

private int position

private boolean returnDelimiters

private java.lang.String string
----------------METHODS----------------

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.String)

public void <init>(
java.lang.String
java.lang.String
boolean)

public int countTokens()

public boolean hasMoreElements()

public boolean hasMoreTokens()

public java.lang.Object nextElement()

public java.lang.String nextToken()

public java.lang.String nextToken(
java.lang.String)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/Timer; )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
 class java.util.Timer$1 extends java.lang.Object

----------------FIELDS----------------

final java.util.Timer this$0
----------------METHODS----------------

 void <init>(
java.util.Timer)

protected void finalize()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =26 name =TimerNode )
@dalvik.annotation.EnclosingClass (value =Ljava/util/Timer$TimerImpl; )
final class java.util.Timer$TimerImpl$TimerNode extends java.lang.Object

----------------FIELDS----------------

 java.util.Timer$TimerImpl$TimerNode left

 java.util.Timer$TimerImpl$TimerNode parent

 java.util.Timer$TimerImpl$TimerNode right

 java.util.TimerTask task
----------------METHODS----------------

public void <init>(
java.util.TimerTask)

public void deleteIfCancelled(
java.util.Timer$TimerImpl$TimerTree)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =26 name =TimerTree )
@dalvik.annotation.EnclosingClass (value =Ljava/util/Timer$TimerImpl; )
final class java.util.Timer$TimerImpl$TimerTree extends java.lang.Object

----------------FIELDS----------------

 int deletedCancelledNumber

 java.util.Timer$TimerImpl$TimerNode root
----------------METHODS----------------

private void <init>()

 void <init>(
java.util.Timer$1)

private java.util.Timer$TimerImpl$TimerNode minimum(
java.util.Timer$TimerImpl$TimerNode)

private java.util.Timer$TimerImpl$TimerNode successor(
java.util.Timer$TimerImpl$TimerNode)

 void delete(
java.util.Timer$TimerImpl$TimerNode)

 void insert(
java.util.Timer$TimerImpl$TimerNode)

 boolean isEmpty()

 java.util.Timer$TimerImpl$TimerNode minimum()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/Timer; )
@dalvik.annotation.InnerClass (accessFlags =26 name =TimerImpl )
@dalvik.annotation.MemberClasses (value =Ljava/util/Timer$TimerImpl$TimerTree;Ljava/util/Timer$TimerImpl$TimerNode; )
final class java.util.Timer$TimerImpl extends java.lang.Thread

----------------FIELDS----------------

private boolean cancelled

private boolean finished

private java.util.Timer$TimerImpl$TimerTree tasks
----------------METHODS----------------

 void <init>(
java.lang.String
boolean)

 void <init>(
boolean)

static boolean access$202(
java.util.Timer$TimerImpl
boolean)

static boolean access$300(
java.util.Timer$TimerImpl)

static void access$400(
java.util.Timer$TimerImpl
java.util.TimerTask)

private void insertTask(
java.util.TimerTask)

public void cancel()

public int purge()

public void run()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/Timer$TimerImpl; )
public class java.util.Timer extends java.lang.Object

----------------FIELDS----------------

private java.lang.Object finalizer

private java.util.Timer$TimerImpl impl
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
boolean)

public void <init>(
boolean)

static java.util.Timer$TimerImpl access$100(
java.util.Timer)

private void scheduleImpl(
java.util.TimerTask
long
long
boolean)

public void cancel()

public int purge()

public void schedule(
java.util.TimerTask
long)

public void schedule(
java.util.TimerTask
long
long)

public void schedule(
java.util.TimerTask
java.util.Date)

public void schedule(
java.util.TimerTask
java.util.Date
long)

public void scheduleAtFixedRate(
java.util.TimerTask
long
long)

public void scheduleAtFixedRate(
java.util.TimerTask
java.util.Date
long)

________________CLASS________________


public abstract class java.util.TimerTask extends java.lang.Object implements java.lang.Runnable

----------------FIELDS----------------

 boolean cancelled

 boolean fixedRate

final java.lang.Object lock

 long period

private long scheduledTime

 long when
----------------METHODS----------------

protected void <init>()

public boolean cancel()

 long getWhen()

 boolean isScheduled()

public abstract void run()

public long scheduledExecutionTime()

 void setScheduledTime(
long)

________________CLASS________________


public class java.util.TooManyListenersException extends java.lang.Exception

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.Signature (value =Ljava/util/AbstractSet<Ljava/util/Map$Entry<TK;TV;>;>; )
 class java.util.TreeMap$1 extends java.util.AbstractSet

----------------FIELDS----------------

final java.util.TreeMap this$0
----------------METHODS----------------

 void <init>(
java.util.TreeMap)

public void clear()

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<Ljava/util/Map$Entry<TK;TV;>;>; )
public java.util.Iterator iterator()

public int size()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/util/AbstractSet<TK;>; )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
 class java.util.TreeMap$2 extends java.util.AbstractSet

----------------FIELDS----------------

final java.util.TreeMap this$0
----------------METHODS----------------

 void <init>(
java.util.TreeMap)

public void clear()

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TK;>; )
public java.util.Iterator iterator()

public int size()

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.Signature (value =Ljava/util/AbstractCollection<TV;>; )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
 class java.util.TreeMap$3 extends java.util.AbstractCollection

----------------FIELDS----------------

final java.util.TreeMap this$0
----------------METHODS----------------

 void <init>(
java.util.TreeMap)

public void clear()

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TV;>; )
public java.util.Iterator iterator()

public int size()

________________CLASS________________

@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/lang/Object; )
@dalvik.annotation.InnerClass (accessFlags =10 name =AbstractMapIterator )
@dalvik.annotation.EnclosingClass (value =Ljava/util/TreeMap; )
 class java.util.TreeMap$AbstractMapIterator extends java.lang.Object

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/TreeMap<TK;TV;>; )
 java.util.TreeMap backingMap

 int expectedModCount
@dalvik.annotation.Signature (value =Ljava/util/TreeMap$Entry<TK;TV;>; )
 java.util.TreeMap$Entry lastNode
@dalvik.annotation.Signature (value =Ljava/util/TreeMap$Entry<TK;TV;>; )
 java.util.TreeMap$Entry node
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/TreeMap<TK;TV;>;Ljava/util/TreeMap$Entry<TK;TV;>;)V )
 void <init>(
java.util.TreeMap
java.util.TreeMap$Entry)

public boolean hasNext()

final void makeNext()

public final void remove()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =10 name =ComparableBoundedIterator )
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/util/TreeMap$AbstractMapIterator<TK;TV;>; )
@dalvik.annotation.EnclosingClass (value =Ljava/util/TreeMap; )
 class java.util.TreeMap$ComparableBoundedIterator extends java.util.TreeMap$AbstractMapIterator

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/lang/Comparable<TK;>; )
private final java.lang.Comparable endKey
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/TreeMap<TK;TV;>;Ljava/util/TreeMap$Entry<TK;TV;>;Ljava/lang/Comparable<TK;>;)V )
public void <init>(
java.util.TreeMap
java.util.TreeMap$Entry
java.lang.Comparable)

final void cleanNext()

public boolean hasNext()

________________CLASS________________

@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/util/TreeMap$ComparableBoundedIterator<TK;TV;>;Ljava/util/Iterator<Ljava/util/Map$Entry<TK;TV;>;>; )
@dalvik.annotation.InnerClass (accessFlags =10 name =ComparableBoundedEntryIterator )
@dalvik.annotation.EnclosingClass (value =Ljava/util/TreeMap; )
 class java.util.TreeMap$ComparableBoundedEntryIterator extends java.util.TreeMap$ComparableBoundedIterator implements java.util.Iterator

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/TreeMap<TK;TV;>;Ljava/util/TreeMap$Entry<TK;TV;>;Ljava/lang/Comparable<TK;>;)V )
 void <init>(
java.util.TreeMap
java.util.TreeMap$Entry
java.lang.Comparable)

public volatile java.lang.Object next()
@dalvik.annotation.Signature (value =()Ljava/util/Map$Entry<TK;TV;>; )
public java.util.Map$Entry next()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/TreeMap; )
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/util/TreeMap$ComparableBoundedIterator<TK;TV;>;Ljava/util/Iterator<TK;>; )
@dalvik.annotation.InnerClass (accessFlags =10 name =ComparableBoundedKeyIterator )
 class java.util.TreeMap$ComparableBoundedKeyIterator extends java.util.TreeMap$ComparableBoundedIterator implements java.util.Iterator

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/TreeMap<TK;TV;>;Ljava/util/TreeMap$Entry<TK;TV;>;Ljava/lang/Comparable<TK;>;)V )
 void <init>(
java.util.TreeMap
java.util.TreeMap$Entry
java.lang.Comparable)
@dalvik.annotation.Signature (value =()TK; )
public java.lang.Object next()

________________CLASS________________

@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/util/TreeMap$ComparableBoundedIterator<TK;TV;>;Ljava/util/Iterator<TV;>; )
@dalvik.annotation.InnerClass (accessFlags =10 name =ComparableBoundedValueIterator )
@dalvik.annotation.EnclosingClass (value =Ljava/util/TreeMap; )
 class java.util.TreeMap$ComparableBoundedValueIterator extends java.util.TreeMap$ComparableBoundedIterator implements java.util.Iterator

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/TreeMap<TK;TV;>;Ljava/util/TreeMap$Entry<TK;TV;>;Ljava/lang/Comparable<TK;>;)V )
 void <init>(
java.util.TreeMap
java.util.TreeMap$Entry
java.lang.Comparable)
@dalvik.annotation.Signature (value =()TV; )
public java.lang.Object next()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =10 name =ComparatorBoundedIterator )
@dalvik.annotation.EnclosingClass (value =Ljava/util/TreeMap; )
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/util/TreeMap$AbstractMapIterator<TK;TV;>; )
 class java.util.TreeMap$ComparatorBoundedIterator extends java.util.TreeMap$AbstractMapIterator

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Comparator<-TK;>; )
private final java.util.Comparator cmp
@dalvik.annotation.Signature (value =TK; )
private final java.lang.Object endKey
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/TreeMap<TK;TV;>;Ljava/util/TreeMap$Entry<TK;TV;>;TK;)V )
 void <init>(
java.util.TreeMap
java.util.TreeMap$Entry
java.lang.Object)

final void cleanNext()

public boolean hasNext()

________________CLASS________________

@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/util/TreeMap$ComparatorBoundedIterator<TK;TV;>;Ljava/util/Iterator<Ljava/util/Map$Entry<TK;TV;>;>; )
@dalvik.annotation.EnclosingClass (value =Ljava/util/TreeMap; )
@dalvik.annotation.InnerClass (accessFlags =10 name =ComparatorBoundedEntryIterator )
 class java.util.TreeMap$ComparatorBoundedEntryIterator extends java.util.TreeMap$ComparatorBoundedIterator implements java.util.Iterator

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/TreeMap<TK;TV;>;Ljava/util/TreeMap$Entry<TK;TV;>;TK;)V )
 void <init>(
java.util.TreeMap
java.util.TreeMap$Entry
java.lang.Object)

public volatile java.lang.Object next()
@dalvik.annotation.Signature (value =()Ljava/util/Map$Entry<TK;TV;>; )
public java.util.Map$Entry next()

________________CLASS________________

@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/util/TreeMap$ComparatorBoundedIterator<TK;TV;>;Ljava/util/Iterator<TK;>; )
@dalvik.annotation.InnerClass (accessFlags =10 name =ComparatorBoundedKeyIterator )
@dalvik.annotation.EnclosingClass (value =Ljava/util/TreeMap; )
 class java.util.TreeMap$ComparatorBoundedKeyIterator extends java.util.TreeMap$ComparatorBoundedIterator implements java.util.Iterator

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/TreeMap<TK;TV;>;Ljava/util/TreeMap$Entry<TK;TV;>;TK;)V )
 void <init>(
java.util.TreeMap
java.util.TreeMap$Entry
java.lang.Object)
@dalvik.annotation.Signature (value =()TK; )
public java.lang.Object next()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =10 name =ComparatorBoundedValueIterator )
@dalvik.annotation.EnclosingClass (value =Ljava/util/TreeMap; )
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/util/TreeMap$ComparatorBoundedIterator<TK;TV;>;Ljava/util/Iterator<TV;>; )
 class java.util.TreeMap$ComparatorBoundedValueIterator extends java.util.TreeMap$ComparatorBoundedIterator implements java.util.Iterator

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/TreeMap<TK;TV;>;Ljava/util/TreeMap$Entry<TK;TV;>;TK;)V )
 void <init>(
java.util.TreeMap
java.util.TreeMap$Entry
java.lang.Object)
@dalvik.annotation.Signature (value =()TV; )
public java.lang.Object next()

________________CLASS________________

@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/util/MapEntry<TK;TV;>; )
@dalvik.annotation.InnerClass (accessFlags =8 name =Entry )
@dalvik.annotation.EnclosingClass (value =Ljava/util/TreeMap; )
 class java.util.TreeMap$Entry extends java.util.MapEntry

----------------FIELDS----------------

 boolean color
@dalvik.annotation.Signature (value =Ljava/util/TreeMap$Entry<TK;TV;>; )
 java.util.TreeMap$Entry left
@dalvik.annotation.Signature (value =Ljava/util/TreeMap$Entry<TK;TV;>; )
 java.util.TreeMap$Entry parent
@dalvik.annotation.Signature (value =Ljava/util/TreeMap$Entry<TK;TV;>; )
 java.util.TreeMap$Entry right
----------------METHODS----------------
@dalvik.annotation.Signature (value =(TK;)V )
 void <init>(
java.lang.Object)
@dalvik.annotation.Signature (value =(TK;TV;)V )
 void <init>(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/TreeMap$Entry<TK;TV;>;)Ljava/util/TreeMap$Entry<TK;TV;>; )
 java.util.TreeMap$Entry clone(
java.util.TreeMap$Entry)

________________CLASS________________

@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/util/AbstractMap<TK;TV;>;Ljava/util/SortedMap<TK;TV;>;Ljava/io/Serializable; )
@dalvik.annotation.InnerClass (accessFlags =24 name =SubMap )
@dalvik.annotation.EnclosingClass (value =Ljava/util/TreeMap; )
final class java.util.TreeMap$SubMap extends java.util.AbstractMap implements java.util.SortedMap, java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID
@dalvik.annotation.Signature (value =Ljava/util/TreeMap<TK;TV;>; )
private java.util.TreeMap backingMap
@dalvik.annotation.Signature (value =TK; )
 java.lang.Object endKey
@dalvik.annotation.Signature (value =Ljava/util/Set<Ljava/util/Map$Entry<TK;TV;>;>; )
transient java.util.Set entrySet

 boolean hasEnd

 boolean hasStart
@dalvik.annotation.Signature (value =TK; )
 java.lang.Object startKey
----------------METHODS----------------
@dalvik.annotation.Signature (value =(TK;Ljava/util/TreeMap<TK;TV;>;)V )
 void <init>(
java.lang.Object
java.util.TreeMap)
@dalvik.annotation.Signature (value =(TK;Ljava/util/TreeMap<TK;TV;>;TK;)V )
 void <init>(
java.lang.Object
java.util.TreeMap
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/TreeMap<TK;TV;>;TK;)V )
 void <init>(
java.util.TreeMap
java.lang.Object)

static java.util.TreeMap access$200(
java.util.TreeMap$SubMap)

static boolean access$300(
java.util.TreeMap$SubMap
java.lang.Object)
@dalvik.annotation.Signature (value =(TK;)Z )
private boolean checkLowerBound(
java.lang.Object)
@dalvik.annotation.Signature (value =(TK;)V )
private void checkRange(
java.lang.Object)
@dalvik.annotation.Signature (value =(TK;)Z )
private boolean checkUpperBound(
java.lang.Object)
@dalvik.annotation.Signature (value =(TK;)Z )
private boolean isInRange(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Comparator<-TK;>; )
public java.util.Comparator comparator()

public boolean containsKey(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/util/Map$Entry<TK;TV;>;>; )
public java.util.Set entrySet()
@dalvik.annotation.Signature (value =()Ljava/util/TreeMap$Entry<TK;TV;>; )
 java.util.TreeMap$Entry firstEntry()
@dalvik.annotation.Signature (value =()TK; )
public java.lang.Object firstKey()
@dalvik.annotation.Signature (value =(Ljava/lang/Object;)TV; )
public java.lang.Object get(
java.lang.Object)
@dalvik.annotation.Signature (value =(TK;)Ljava/util/SortedMap<TK;TV;>; )
public java.util.SortedMap headMap(
java.lang.Object)

public boolean isEmpty()
@dalvik.annotation.Signature (value =()Ljava/util/Set<TK;>; )
public java.util.Set keySet()
@dalvik.annotation.Signature (value =()TK; )
public java.lang.Object lastKey()
@dalvik.annotation.Signature (value =(TK;TV;)TV; )
public java.lang.Object put(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;)TV; )
public java.lang.Object remove(
java.lang.Object)
@dalvik.annotation.Signature (value =(TK;TK;)Ljava/util/SortedMap<TK;TV;>; )
public java.util.SortedMap subMap(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(TK;)Ljava/util/SortedMap<TK;TV;>; )
public java.util.SortedMap tailMap(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Collection<TV;>; )
public java.util.Collection values()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =SubMapEntrySet )
@dalvik.annotation.EnclosingClass (value =Ljava/util/TreeMap; )
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/util/AbstractSet<Ljava/util/Map$Entry<TK;TV;>;>;Ljava/util/Set<Ljava/util/Map$Entry<TK;TV;>;>; )
 class java.util.TreeMap$SubMapEntrySet extends java.util.AbstractSet implements java.util.Set

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/TreeMap$SubMap<TK;TV;>; )
 java.util.TreeMap$SubMap subMap
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/TreeMap$SubMap<TK;TV;>;)V )
 void <init>(
java.util.TreeMap$SubMap)

public boolean contains(
java.lang.Object)

public boolean isEmpty()
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<Ljava/util/Map$Entry<TK;TV;>;>; )
public java.util.Iterator iterator()

public int size()

________________CLASS________________

@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/util/AbstractSet<TK;>;Ljava/util/Set<TK;>; )
@dalvik.annotation.InnerClass (accessFlags =8 name =SubMapKeySet )
@dalvik.annotation.EnclosingClass (value =Ljava/util/TreeMap; )
 class java.util.TreeMap$SubMapKeySet extends java.util.AbstractSet implements java.util.Set

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/TreeMap$SubMap<TK;TV;>; )
 java.util.TreeMap$SubMap subMap
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/TreeMap$SubMap<TK;TV;>;)V )
 void <init>(
java.util.TreeMap$SubMap)

public boolean contains(
java.lang.Object)

public boolean isEmpty()
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TK;>; )
public java.util.Iterator iterator()

public int size()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/TreeMap; )
@dalvik.annotation.InnerClass (accessFlags =8 name =SubMapValuesCollection )
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/util/AbstractCollection<TV;>; )
 class java.util.TreeMap$SubMapValuesCollection extends java.util.AbstractCollection

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/TreeMap$SubMap<TK;TV;>; )
 java.util.TreeMap$SubMap subMap
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/TreeMap$SubMap<TK;TV;>;)V )
public void <init>(
java.util.TreeMap$SubMap)

public boolean isEmpty()
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TV;>; )
public java.util.Iterator iterator()

public int size()

________________CLASS________________

@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/util/TreeMap$AbstractMapIterator<TK;TV;>;Ljava/util/Iterator<Ljava/util/Map$Entry<TK;TV;>;>; )
@dalvik.annotation.EnclosingClass (value =Ljava/util/TreeMap; )
@dalvik.annotation.InnerClass (accessFlags =10 name =UnboundedEntryIterator )
 class java.util.TreeMap$UnboundedEntryIterator extends java.util.TreeMap$AbstractMapIterator implements java.util.Iterator

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/TreeMap<TK;TV;>;)V )
 void <init>(
java.util.TreeMap)
@dalvik.annotation.Signature (value =(Ljava/util/TreeMap<TK;TV;>;Ljava/util/TreeMap$Entry<TK;TV;>;)V )
 void <init>(
java.util.TreeMap
java.util.TreeMap$Entry)

public volatile java.lang.Object next()
@dalvik.annotation.Signature (value =()Ljava/util/Map$Entry<TK;TV;>; )
public java.util.Map$Entry next()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/TreeMap; )
@dalvik.annotation.InnerClass (accessFlags =8 name =UnboundedKeyIterator )
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/util/TreeMap$AbstractMapIterator<TK;TV;>;Ljava/util/Iterator<TK;>; )
 class java.util.TreeMap$UnboundedKeyIterator extends java.util.TreeMap$AbstractMapIterator implements java.util.Iterator

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/TreeMap<TK;TV;>;)V )
public void <init>(
java.util.TreeMap)
@dalvik.annotation.Signature (value =(Ljava/util/TreeMap<TK;TV;>;Ljava/util/TreeMap$Entry<TK;TV;>;)V )
public void <init>(
java.util.TreeMap
java.util.TreeMap$Entry)
@dalvik.annotation.Signature (value =()TK; )
public java.lang.Object next()

________________CLASS________________

@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/util/TreeMap$AbstractMapIterator<TK;TV;>;Ljava/util/Iterator<TV;>; )
@dalvik.annotation.InnerClass (accessFlags =8 name =UnboundedValueIterator )
@dalvik.annotation.EnclosingClass (value =Ljava/util/TreeMap; )
 class java.util.TreeMap$UnboundedValueIterator extends java.util.TreeMap$AbstractMapIterator implements java.util.Iterator

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/TreeMap<TK;TV;>;)V )
public void <init>(
java.util.TreeMap)
@dalvik.annotation.Signature (value =(Ljava/util/TreeMap<TK;TV;>;Ljava/util/TreeMap$Entry<TK;TV;>;)V )
public void <init>(
java.util.TreeMap
java.util.TreeMap$Entry)
@dalvik.annotation.Signature (value =()TV; )
public java.lang.Object next()

________________CLASS________________

@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/util/AbstractMap<TK;TV;>;Ljava/util/SortedMap<TK;TV;>;Ljava/lang/Cloneable;Ljava/io/Serializable; )
@dalvik.annotation.MemberClasses (value =Ljava/util/TreeMap$SubMapValuesCollection;Ljava/util/TreeMap$SubMapKeySet;Ljava/util/TreeMap$SubMapEntrySet;Ljava/util/TreeMap$SubMap;Ljava/util/TreeMap$ComparableBoundedValueIterator;Ljava/util/TreeMap$ComparableBoundedKeyIterator;Ljava/util/TreeMap$ComparableBoundedEntryIterator;Ljava/util/TreeMap$ComparableBoundedIterator;Ljava/util/TreeMap$ComparatorBoundedValueIterator;Ljava/util/TreeMap$ComparatorBoundedKeyIterator;Ljava/util/TreeMap$ComparatorBoundedEntryIterator;Ljava/util/TreeMap$ComparatorBoundedIterator;Ljava/util/TreeMap$UnboundedValueIterator;Ljava/util/TreeMap$UnboundedKeyIterator;Ljava/util/TreeMap$UnboundedEntryIterator;Ljava/util/TreeMap$AbstractMapIterator;Ljava/util/TreeMap$Entry; )
public class java.util.TreeMap extends java.util.AbstractMap implements java.util.SortedMap, java.lang.Cloneable, java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID
@dalvik.annotation.Signature (value =Ljava/util/Comparator<-TK;>; )
private java.util.Comparator comparator
@dalvik.annotation.Signature (value =Ljava/util/Set<Ljava/util/Map$Entry<TK;TV;>;>; )
transient java.util.Set entrySet

transient int modCount
@dalvik.annotation.Signature (value =Ljava/util/TreeMap$Entry<TK;TV;>; )
transient java.util.TreeMap$Entry root

transient int size
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Signature (value =(Ljava/util/Comparator<-TK;>;)V )
public void <init>(
java.util.Comparator)
@dalvik.annotation.Signature (value =(Ljava/util/Map<+TK;+TV;>;)V )
public void <init>(
java.util.Map)
@dalvik.annotation.Signature (value =(Ljava/util/SortedMap<TK;+TV;>;)V )
public void <init>(
java.util.SortedMap)

static java.util.Comparator access$000(
java.util.TreeMap)

static java.lang.Comparable access$100(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/TreeMap$Entry<TK;TV;>;Ljava/lang/Object;)Z )
private boolean containsValue(
java.util.TreeMap$Entry
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;)Ljava/util/TreeMap$Entry<TK;TV;>; )
private java.util.TreeMap$Entry find(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/TreeMap$Entry<TK;TV;>;)V )
private void fixup(
java.util.TreeMap$Entry)
@dalvik.annotation.Signature (value =(Ljava/util/TreeMap$Entry<TK;TV;>;)V )
private void leftRotate(
java.util.TreeMap$Entry)
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>(Ljava/util/TreeMap$Entry<TK;TV;>;)Ljava/util/TreeMap$Entry<TK;TV;>; )
static java.util.TreeMap$Entry maximum(
java.util.TreeMap$Entry)
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>(Ljava/util/TreeMap$Entry<TK;TV;>;)Ljava/util/TreeMap$Entry<TK;TV;>; )
static java.util.TreeMap$Entry minimum(
java.util.TreeMap$Entry)
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>(Ljava/util/TreeMap$Entry<TK;TV;>;)Ljava/util/TreeMap$Entry<TK;TV;>; )
static java.util.TreeMap$Entry predecessor(
java.util.TreeMap$Entry)
@dalvik.annotation.Signature (value =(TK;)Ljava/util/TreeMap$Entry<TK;TV;>; )
private java.util.TreeMap$Entry rbInsert(
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)
@dalvik.annotation.Signature (value =(Ljava/util/TreeMap$Entry<TK;TV;>;)V )
private void rightRotate(
java.util.TreeMap$Entry)
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>(Ljava/util/TreeMap$Entry<TK;TV;>;)Ljava/util/TreeMap$Entry<TK;TV;>; )
static java.util.TreeMap$Entry successor(
java.util.TreeMap$Entry)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(TT;)Ljava/lang/Comparable<TT;>; )
private static java.lang.Comparable toComparable(
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)
@dalvik.annotation.Signature (value =(Ljava/util/TreeMap$Entry<TK;TV;>;)V )
 void balance(
java.util.TreeMap$Entry)

public void clear()

public java.lang.Object clone()
@dalvik.annotation.Signature (value =()Ljava/util/Comparator<-TK;>; )
public java.util.Comparator comparator()

public boolean containsKey(
java.lang.Object)

public boolean containsValue(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/util/Map$Entry<TK;TV;>;>; )
public java.util.Set entrySet()
@dalvik.annotation.Signature (value =(Ljava/lang/Object;)Ljava/util/TreeMap$Entry<TK;TV;>; )
 java.util.TreeMap$Entry findAfter(
java.lang.Object)
@dalvik.annotation.Signature (value =(TK;)Ljava/util/TreeMap$Entry<TK;TV;>; )
 java.util.TreeMap$Entry findBefore(
java.lang.Object)
@dalvik.annotation.Signature (value =()TK; )
public java.lang.Object firstKey()
@dalvik.annotation.Signature (value =(Ljava/lang/Object;)TV; )
public java.lang.Object get(
java.lang.Object)
@dalvik.annotation.Signature (value =(TK;)Ljava/util/SortedMap<TK;TV;>; )
public java.util.SortedMap headMap(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Set<TK;>; )
public java.util.Set keySet()
@dalvik.annotation.Signature (value =()TK; )
public java.lang.Object lastKey()
@dalvik.annotation.Signature (value =(TK;TV;)TV; )
public java.lang.Object put(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Map<+TK;+TV;>;)V )
public void putAll(
java.util.Map)
@dalvik.annotation.Signature (value =(Ljava/util/TreeMap$Entry<TK;TV;>;)V )
 void rbDelete(
java.util.TreeMap$Entry)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;)TV; )
public java.lang.Object remove(
java.lang.Object)

public int size()
@dalvik.annotation.Signature (value =(TK;TK;)Ljava/util/SortedMap<TK;TV;>; )
public java.util.SortedMap subMap(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(TK;)Ljava/util/SortedMap<TK;TV;>; )
public java.util.SortedMap tailMap(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Collection<TV;>; )
public java.util.Collection values()

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/util/AbstractSet<TE;>;Ljava/util/SortedSet<TE;>;Ljava/lang/Cloneable;Ljava/io/Serializable; )
public class java.util.TreeSet extends java.util.AbstractSet implements java.util.SortedSet, java.lang.Cloneable, java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID
@dalvik.annotation.Signature (value =Ljava/util/SortedMap<TE;TE;>; )
private transient java.util.SortedMap backingMap
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Signature (value =(Ljava/util/Collection<+TE;>;)V )
public void <init>(
java.util.Collection)
@dalvik.annotation.Signature (value =(Ljava/util/Comparator<-TE;>;)V )
public void <init>(
java.util.Comparator)
@dalvik.annotation.Signature (value =(Ljava/util/SortedMap<TE;TE;>;)V )
private void <init>(
java.util.SortedMap)
@dalvik.annotation.Signature (value =(Ljava/util/SortedSet<TE;>;)V )
public void <init>(
java.util.SortedSet)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)
@dalvik.annotation.Signature (value =(TE;)Z )
public boolean add(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<+TE;>;)Z )
public boolean addAll(
java.util.Collection)

public void clear()

public java.lang.Object clone()
@dalvik.annotation.Signature (value =()Ljava/util/Comparator<-TE;>; )
public java.util.Comparator comparator()

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object first()
@dalvik.annotation.Signature (value =(TE;)Ljava/util/SortedSet<TE;>; )
public java.util.SortedSet headSet(
java.lang.Object)

public boolean isEmpty()
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TE;>; )
public java.util.Iterator iterator()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object last()

public boolean remove(
java.lang.Object)

public int size()
@dalvik.annotation.Signature (value =(TE;TE;)Ljava/util/SortedSet<TE;>; )
public java.util.SortedSet subSet(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(TE;)Ljava/util/SortedSet<TE;>; )
public java.util.SortedSet tailSet(
java.lang.Object)

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/io/Serializable;Ljava/lang/Comparable<Ljava/util/UUID;>; )
public final class java.util.UUID extends java.lang.Object implements java.io.Serializable, java.lang.Comparable

----------------FIELDS----------------

static final boolean $assertionsDisabled

private static java.security.SecureRandom rng

private static final long serialVersionUID

private transient int clockSequence

private transient int hash

private long leastSigBits

private long mostSigBits

private transient long node

private transient long timestamp

private transient int variant

private transient int version
----------------METHODS----------------

static void <clinit>()

public void <init>(
long
long)

public static java.util.UUID fromString(
java.lang.String)

private void init()

public static java.util.UUID nameUUIDFromBytes(
byte[])

public static java.util.UUID randomUUID()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)

public int clockSequence()

public volatile int compareTo(
java.lang.Object)

public int compareTo(
java.util.UUID)

public boolean equals(
java.lang.Object)

public long getLeastSignificantBits()

public long getMostSignificantBits()

public int hashCode()

public long node()

public long timestamp()

public java.lang.String toString()

public int variant()

public int version()

________________CLASS________________


public class java.util.UnknownFormatConversionException extends java.util.IllegalFormatException

----------------FIELDS----------------

private static final long serialVersionUID

private java.lang.String s
----------------METHODS----------------

public void <init>(
java.lang.String)

public java.lang.String getConversion()

public java.lang.String getMessage()

________________CLASS________________


public class java.util.UnknownFormatFlagsException extends java.util.IllegalFormatException

----------------FIELDS----------------

private static final long serialVersionUID

private java.lang.String flags
----------------METHODS----------------

public void <init>(
java.lang.String)

public java.lang.String getFlags()

public java.lang.String getMessage()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Enumeration<TE;>; )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
 class java.util.Vector$1 extends java.lang.Object implements java.util.Enumeration

----------------FIELDS----------------

 int pos

final java.util.Vector this$0
----------------METHODS----------------

 void <init>(
java.util.Vector)

public boolean hasMoreElements()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object nextElement()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =1544 name =Type )
@dalvik.annotation.Signature (value =<R:Ljava/lang/Object;K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/lang/Object; )
@dalvik.annotation.EnclosingClass (value =Ljava/util/WeakHashMap$Entry; )
abstract interface class java.util.WeakHashMap$Entry$Type extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/Map$Entry<TK;TV;>;)TR; )
public abstract java.lang.Object get(
java.util.Map$Entry)

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/WeakHashMap$Entry$Type<Ljava/util/Map$Entry<TK;TV;>;TK;TV;>; )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
 class java.util.WeakHashMap$1$1 extends java.lang.Object implements java.util.WeakHashMap$Entry$Type

----------------FIELDS----------------

final java.util.WeakHashMap$1 this$1
----------------METHODS----------------

 void <init>(
java.util.WeakHashMap$1)

public volatile java.lang.Object get(
java.util.Map$Entry)
@dalvik.annotation.Signature (value =(Ljava/util/Map$Entry<TK;TV;>;)Ljava/util/Map$Entry<TK;TV;>; )
public java.util.Map$Entry get(
java.util.Map$Entry)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.Signature (value =Ljava/util/AbstractSet<Ljava/util/Map$Entry<TK;TV;>;>; )
 class java.util.WeakHashMap$1 extends java.util.AbstractSet

----------------FIELDS----------------

final java.util.WeakHashMap this$0
----------------METHODS----------------

 void <init>(
java.util.WeakHashMap)

public void clear()

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<Ljava/util/Map$Entry<TK;TV;>;>; )
public java.util.Iterator iterator()

public boolean remove(
java.lang.Object)

public int size()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/WeakHashMap$Entry$Type<TK;TK;TV;>; )
 class java.util.WeakHashMap$2$1 extends java.lang.Object implements java.util.WeakHashMap$Entry$Type

----------------FIELDS----------------

final java.util.WeakHashMap$2 this$1
----------------METHODS----------------

 void <init>(
java.util.WeakHashMap$2)
@dalvik.annotation.Signature (value =(Ljava/util/Map$Entry<TK;TV;>;)TK; )
public java.lang.Object get(
java.util.Map$Entry)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.Signature (value =Ljava/util/AbstractSet<TK;>; )
@dalvik.annotation.EnclosingMethod (value =null )
 class java.util.WeakHashMap$2 extends java.util.AbstractSet

----------------FIELDS----------------

final java.util.WeakHashMap this$0
----------------METHODS----------------

 void <init>(
java.util.WeakHashMap)

public void clear()

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TK;>; )
public java.util.Iterator iterator()

public boolean remove(
java.lang.Object)

public int size()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/WeakHashMap$Entry$Type<TV;TK;TV;>; )
 class java.util.WeakHashMap$3$1 extends java.lang.Object implements java.util.WeakHashMap$Entry$Type

----------------FIELDS----------------

final java.util.WeakHashMap$3 this$1
----------------METHODS----------------

 void <init>(
java.util.WeakHashMap$3)
@dalvik.annotation.Signature (value =(Ljava/util/Map$Entry<TK;TV;>;)TV; )
public java.lang.Object get(
java.util.Map$Entry)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.Signature (value =Ljava/util/AbstractCollection<TV;>; )
 class java.util.WeakHashMap$3 extends java.util.AbstractCollection

----------------FIELDS----------------

final java.util.WeakHashMap this$0
----------------METHODS----------------

 void <init>(
java.util.WeakHashMap)

public void clear()

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TV;>; )
public java.util.Iterator iterator()

public int size()

________________CLASS________________

@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/lang/ref/WeakReference<TK;>;Ljava/util/Map$Entry<TK;TV;>; )
@dalvik.annotation.MemberClasses (value =Ljava/util/WeakHashMap$Entry$Type; )
@dalvik.annotation.EnclosingClass (value =Ljava/util/WeakHashMap; )
@dalvik.annotation.InnerClass (accessFlags =26 name =Entry )
final class java.util.WeakHashMap$Entry extends java.lang.ref.WeakReference implements java.util.Map$Entry

----------------FIELDS----------------

 int hash

 boolean isNull
@dalvik.annotation.Signature (value =Ljava/util/WeakHashMap$Entry<TK;TV;>; )
 java.util.WeakHashMap$Entry next
@dalvik.annotation.Signature (value =TV; )
 java.lang.Object value
----------------METHODS----------------
@dalvik.annotation.Signature (value =(TK;TV;Ljava/lang/ref/ReferenceQueue<TK;>;)V )
 void <init>(
java.lang.Object
java.lang.Object
java.lang.ref.ReferenceQueue)

public boolean equals(
java.lang.Object)
@dalvik.annotation.Signature (value =()TK; )
public java.lang.Object getKey()
@dalvik.annotation.Signature (value =()TV; )
public java.lang.Object getValue()

public int hashCode()
@dalvik.annotation.Signature (value =(TV;)TV; )
public java.lang.Object setValue(
java.lang.Object)

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =HashIterator )
@dalvik.annotation.EnclosingClass (value =Ljava/util/WeakHashMap; )
@dalvik.annotation.Signature (value =<R:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Iterator<TR;>; )
 class java.util.WeakHashMap$HashIterator extends java.lang.Object implements java.util.Iterator

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/WeakHashMap$Entry<TK;TV;>; )
private java.util.WeakHashMap$Entry currentEntry

private int expectedModCount
@dalvik.annotation.Signature (value =Ljava/util/WeakHashMap$Entry<TK;TV;>; )
private java.util.WeakHashMap$Entry nextEntry
@dalvik.annotation.Signature (value =TK; )
private java.lang.Object nextKey

private int position

final java.util.WeakHashMap this$0
@dalvik.annotation.Signature (value =Ljava/util/WeakHashMap$Entry$Type<TR;TK;TV;>; )
final java.util.WeakHashMap$Entry$Type type
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/WeakHashMap$Entry$Type<TR;TK;TV;>;)V )
 void <init>(
java.util.WeakHashMap
java.util.WeakHashMap$Entry$Type)

public boolean hasNext()
@dalvik.annotation.Signature (value =()TR; )
public java.lang.Object next()

public void remove()

________________CLASS________________

@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/util/AbstractMap<TK;TV;>;Ljava/util/Map<TK;TV;>; )
@dalvik.annotation.MemberClasses (value =Ljava/util/WeakHashMap$HashIterator;Ljava/util/WeakHashMap$Entry; )
public class java.util.WeakHashMap extends java.util.AbstractMap implements java.util.Map

----------------FIELDS----------------

private static final int DEFAULT_SIZE

 int elementCount
@dalvik.annotation.Signature (value =[Ljava/util/WeakHashMap$Entry<TK;TV;>; )
 java.util.WeakHashMap$Entry[] elementData

private final int loadFactor

volatile int modCount
@dalvik.annotation.Signature (value =Ljava/lang/ref/ReferenceQueue<TK;>; )
private final java.lang.ref.ReferenceQueue referenceQueue

private int threshold
----------------METHODS----------------

public void <init>()

public void <init>(
int)

public void <init>(
int
float)
@dalvik.annotation.Signature (value =(Ljava/util/Map<+TK;+TV;>;)V )
public void <init>(
java.util.Map)

private void computeMaxSize()
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>(I)[Ljava/util/WeakHashMap$Entry<TK;TV;>; )
private static java.util.WeakHashMap$Entry[] newEntryArray(
int)
@dalvik.annotation.Signature (value =(Ljava/util/Map<+TK;+TV;>;)V )
private void putAllImpl(
java.util.Map)

private void rehash()

public void clear()

public boolean containsKey(
java.lang.Object)

public boolean containsValue(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/util/Map$Entry<TK;TV;>;>; )
public java.util.Set entrySet()
@dalvik.annotation.Signature (value =(Ljava/lang/Object;)TV; )
public java.lang.Object get(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;)Ljava/util/WeakHashMap$Entry<TK;TV;>; )
 java.util.WeakHashMap$Entry getEntry(
java.lang.Object)

public boolean isEmpty()
@dalvik.annotation.Signature (value =()Ljava/util/Set<TK;>; )
public java.util.Set keySet()

 void poll()
@dalvik.annotation.Signature (value =(TK;TV;)TV; )
public java.lang.Object put(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Map<+TK;+TV;>;)V )
public void putAll(
java.util.Map)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;)TV; )
public java.lang.Object remove(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/WeakHashMap$Entry<TK;TV;>;)V )
 void removeEntry(
java.util.WeakHashMap$Entry)

public int size()
@dalvik.annotation.Signature (value =()Ljava/util/Collection<TV;>; )
public java.util.Collection values()

________________CLASS________________


 class java.util.ZoneInfo extends java.util.TimeZone

----------------FIELDS----------------

private static final int[] LEAP

private static final long MILLISECONDS_PER_400_YEARS

private static final long MILLISECONDS_PER_DAY

private static final int[] NORMAL

private static final long UNIX_OFFSET

private java.lang.String mDaylightName

private int[] mGmtOffs

private byte[] mIsDsts

private int mRawOffset

private java.lang.String mStandardName

private int[] mTransitions

private byte[] mTypes

private boolean mUseDst
----------------METHODS----------------

static void <clinit>()

 void <init>(
java.lang.String
int[]
byte[]
int[]
byte[]
byte[]
byte[]
int)

public static java.util.TimeZone getTimeZone(
java.lang.String)

private static java.lang.String nullName(
byte[]
int
int)

public int getOffset(
int
int
int
int
int
int)

public int getOffset(
long)

public int getRawOffset()

public boolean inDaylightTime(
java.util.Date)

public void setRawOffset(
int)

public boolean useDaylightTime()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/ZoneInfoDB; )
@dalvik.annotation.InnerClass (accessFlags =8 name =MinimalTimeZone )
 class java.util.ZoneInfoDB$MinimalTimeZone extends java.util.TimeZone

----------------FIELDS----------------

private int rawOffset
----------------METHODS----------------

public void <init>(
int)

public int getOffset(
int
int
int
int
int
int)

public int getRawOffset()

public boolean inDaylightTime(
java.util.Date)

public void setRawOffset(
int)

public boolean useDaylightTime()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/ZoneInfoDB$MinimalTimeZone; )
final class java.util.ZoneInfoDB extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.String INDEX_FILE_NAME

private static final int TZINT_LENGTH

private static final int TZNAME_LENGTH

private static final java.lang.String ZONE_DIRECTORY_NAME

private static final java.lang.String ZONE_FILE_NAME

private static java.util.TimeZone defaultZone

private static int[] lengths

private static java.lang.Object lock

private static java.lang.String[] names

private static int[] offsets

private static int[] starts
----------------METHODS----------------

static void <clinit>()

private void <init>()

private static java.lang.String[] _getAvailableIDs(
int
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
static java.util.TimeZone _getTimeZone(
java.lang.String)

public static java.lang.String[] getAvailableIDs()

public static java.lang.String[] getAvailableIDs(
int)

public static java.util.TimeZone getDefault()

public static java.util.TimeZone getTimeZone(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private static void init()

private static int parseNumericZone(
java.lang.String)

private static int read4(
byte[]
int)

private static void scanForZones(
java.io.File
java.util.Set
int)

public static void setDefault(
java.util.TimeZone)

________________CLASS________________


public abstract interface class java.util.concurrent.Executor extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract void execute(
java.lang.Runnable)

________________CLASS________________


public abstract interface class java.util.concurrent.ExecutorService extends java.lang.Object implements java.util.concurrent.Executor

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public abstract boolean awaitTermination(
long
java.util.concurrent.TimeUnit)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/util/Collection<Ljava/util/concurrent/Callable<TT;>;>;)Ljava/util/List<Ljava/util/concurrent/Future<TT;>;>; )
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public abstract java.util.List invokeAll(
java.util.Collection)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/util/Collection<Ljava/util/concurrent/Callable<TT;>;>;JLjava/util/concurrent/TimeUnit;)Ljava/util/List<Ljava/util/concurrent/Future<TT;>;>; )
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public abstract java.util.List invokeAll(
java.util.Collection
long
java.util.concurrent.TimeUnit)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException;Ljava/util/concurrent/ExecutionException; )
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/util/Collection<Ljava/util/concurrent/Callable<TT;>;>;)TT; )
public abstract java.lang.Object invokeAny(
java.util.Collection)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException;Ljava/util/concurrent/ExecutionException;Ljava/util/concurrent/TimeoutException; )
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/util/Collection<Ljava/util/concurrent/Callable<TT;>;>;JLjava/util/concurrent/TimeUnit;)TT; )
public abstract java.lang.Object invokeAny(
java.util.Collection
long
java.util.concurrent.TimeUnit)

public abstract boolean isShutdown()

public abstract boolean isTerminated()

public abstract void shutdown()
@dalvik.annotation.Signature (value =()Ljava/util/List<Ljava/lang/Runnable;>; )
public abstract java.util.List shutdownNow()
@dalvik.annotation.Signature (value =(Ljava/lang/Runnable;)Ljava/util/concurrent/Future<*>; )
public abstract java.util.concurrent.Future submit(
java.lang.Runnable)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/lang/Runnable;TT;)Ljava/util/concurrent/Future<TT;>; )
public abstract java.util.concurrent.Future submit(
java.lang.Runnable
java.lang.Object)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/util/concurrent/Callable<TT;>;)Ljava/util/concurrent/Future<TT;>; )
public abstract java.util.concurrent.Future submit(
java.util.concurrent.Callable)

________________CLASS________________


public abstract class java.util.concurrent.AbstractExecutorService extends java.lang.Object implements java.util.concurrent.ExecutorService

----------------FIELDS----------------

static final boolean $assertionsDisabled
----------------METHODS----------------

static void <clinit>()

public void <init>()
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException;Ljava/util/concurrent/ExecutionException;Ljava/util/concurrent/TimeoutException; )
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/util/Collection<Ljava/util/concurrent/Callable<TT;>;>;ZJ)TT; )
private java.lang.Object doInvokeAny(
java.util.Collection
boolean
long)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/util/Collection<Ljava/util/concurrent/Callable<TT;>;>;)Ljava/util/List<Ljava/util/concurrent/Future<TT;>;>; )
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public java.util.List invokeAll(
java.util.Collection)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/util/Collection<Ljava/util/concurrent/Callable<TT;>;>;JLjava/util/concurrent/TimeUnit;)Ljava/util/List<Ljava/util/concurrent/Future<TT;>;>; )
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public java.util.List invokeAll(
java.util.Collection
long
java.util.concurrent.TimeUnit)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/util/Collection<Ljava/util/concurrent/Callable<TT;>;>;)TT; )
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException;Ljava/util/concurrent/ExecutionException; )
public java.lang.Object invokeAny(
java.util.Collection)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/util/Collection<Ljava/util/concurrent/Callable<TT;>;>;JLjava/util/concurrent/TimeUnit;)TT; )
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException;Ljava/util/concurrent/ExecutionException;Ljava/util/concurrent/TimeoutException; )
public java.lang.Object invokeAny(
java.util.Collection
long
java.util.concurrent.TimeUnit)
@dalvik.annotation.Signature (value =(Ljava/lang/Runnable;)Ljava/util/concurrent/Future<*>; )
public java.util.concurrent.Future submit(
java.lang.Runnable)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/lang/Runnable;TT;)Ljava/util/concurrent/Future<TT;>; )
public java.util.concurrent.Future submit(
java.lang.Runnable
java.lang.Object)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/util/concurrent/Callable<TT;>;)Ljava/util/concurrent/Future<TT;>; )
public java.util.concurrent.Future submit(
java.util.concurrent.Callable)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =2 name =Itr )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Iterator<TE;>; )
@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/ArrayBlockingQueue; )
 class java.util.concurrent.ArrayBlockingQueue$Itr extends java.lang.Object implements java.util.Iterator

----------------FIELDS----------------

private int lastRet

private int nextIndex
@dalvik.annotation.Signature (value =TE; )
private java.lang.Object nextItem

final java.util.concurrent.ArrayBlockingQueue this$0
----------------METHODS----------------

 void <init>(
java.util.concurrent.ArrayBlockingQueue)

private void checkNext()

public boolean hasNext()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object next()

public void remove()

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Queue<TE;>; )
public abstract interface class java.util.concurrent.BlockingQueue extends java.lang.Object implements java.util.Queue

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =(TE;)Z )
public abstract boolean add(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<-TE;>;)I )
public abstract int drainTo(
java.util.Collection)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<-TE;>;I)I )
public abstract int drainTo(
java.util.Collection
int)
@dalvik.annotation.Signature (value =(TE;)Z )
public abstract boolean offer(
java.lang.Object)
@dalvik.annotation.Signature (value =(TE;JLjava/util/concurrent/TimeUnit;)Z )
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public abstract boolean offer(
java.lang.Object
long
java.util.concurrent.TimeUnit)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
@dalvik.annotation.Signature (value =(JLjava/util/concurrent/TimeUnit;)TE; )
public abstract java.lang.Object poll(
long
java.util.concurrent.TimeUnit)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
@dalvik.annotation.Signature (value =(TE;)V )
public abstract void put(
java.lang.Object)

public abstract int remainingCapacity()
@dalvik.annotation.Signature (value =()TE; )
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public abstract java.lang.Object take()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/concurrent/ArrayBlockingQueue$Itr; )
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/util/AbstractQueue<TE;>;Ljava/util/concurrent/BlockingQueue<TE;>;Ljava/io/Serializable; )
public class java.util.concurrent.ArrayBlockingQueue extends java.util.AbstractQueue implements java.util.concurrent.BlockingQueue, java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

private int count
@dalvik.annotation.Signature (value =[TE; )
private final java.lang.Object[] items

private final java.util.concurrent.locks.ReentrantLock lock

private final java.util.concurrent.locks.Condition notEmpty

private final java.util.concurrent.locks.Condition notFull

private transient int putIndex

private transient int takeIndex
----------------METHODS----------------

public void <init>(
int)

public void <init>(
int
boolean)
@dalvik.annotation.Signature (value =(IZLjava/util/Collection<+TE;>;)V )
public void <init>(
int
boolean
java.util.Collection)

static int access$000(
java.util.concurrent.ArrayBlockingQueue)

static int access$100(
java.util.concurrent.ArrayBlockingQueue)

static java.lang.Object[] access$200(
java.util.concurrent.ArrayBlockingQueue)

static int access$300(
java.util.concurrent.ArrayBlockingQueue)

static java.util.concurrent.locks.ReentrantLock access$400(
java.util.concurrent.ArrayBlockingQueue)
@dalvik.annotation.Signature (value =()TE; )
private java.lang.Object extract()
@dalvik.annotation.Signature (value =(TE;)V )
private void insert(
java.lang.Object)

public void clear()

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<-TE;>;)I )
public int drainTo(
java.util.Collection)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<-TE;>;I)I )
public int drainTo(
java.util.Collection
int)

final int inc(
int)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TE;>; )
public java.util.Iterator iterator()
@dalvik.annotation.Signature (value =(TE;)Z )
public boolean offer(
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
@dalvik.annotation.Signature (value =(TE;JLjava/util/concurrent/TimeUnit;)Z )
public boolean offer(
java.lang.Object
long
java.util.concurrent.TimeUnit)
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object peek()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object poll()
@dalvik.annotation.Signature (value =(JLjava/util/concurrent/TimeUnit;)TE; )
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public java.lang.Object poll(
long
java.util.concurrent.TimeUnit)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
@dalvik.annotation.Signature (value =(TE;)V )
public void put(
java.lang.Object)

public int remainingCapacity()

public boolean remove(
java.lang.Object)

 void removeAt(
int)

public int size()
@dalvik.annotation.Signature (value =()TE; )
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public java.lang.Object take()

public java.lang.Object[] toArray()
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>([TT;)[TT; )
public java.lang.Object[] toArray(
java.lang.Object[])

public java.lang.String toString()

________________CLASS________________


public class java.util.concurrent.BrokenBarrierException extends java.lang.Exception

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________

@dalvik.annotation.Signature (value =<V:Ljava/lang/Object;>Ljava/lang/Object; )
public abstract interface class java.util.concurrent.Callable extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/lang/Exception; )
@dalvik.annotation.Signature (value =()TV; )
public abstract java.lang.Object call()

________________CLASS________________


public class java.util.concurrent.CancellationException extends java.lang.IllegalStateException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________

@dalvik.annotation.Signature (value =<V:Ljava/lang/Object;>Ljava/lang/Object; )
public abstract interface class java.util.concurrent.CompletionService extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =()Ljava/util/concurrent/Future<TV;>; )
public abstract java.util.concurrent.Future poll()
@dalvik.annotation.Signature (value =(JLjava/util/concurrent/TimeUnit;)Ljava/util/concurrent/Future<TV;>; )
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public abstract java.util.concurrent.Future poll(
long
java.util.concurrent.TimeUnit)
@dalvik.annotation.Signature (value =(Ljava/lang/Runnable;TV;)Ljava/util/concurrent/Future<TV;>; )
public abstract java.util.concurrent.Future submit(
java.lang.Runnable
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/concurrent/Callable<TV;>;)Ljava/util/concurrent/Future<TV;>; )
public abstract java.util.concurrent.Future submit(
java.util.concurrent.Callable)
@dalvik.annotation.Signature (value =()Ljava/util/concurrent/Future<TV;>; )
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public abstract java.util.concurrent.Future take()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/ConcurrentHashMap; )
@dalvik.annotation.InnerClass (accessFlags =1024 name =HashIterator )
abstract class java.util.concurrent.ConcurrentHashMap$HashIterator extends java.lang.Object

----------------FIELDS----------------

 java.util.concurrent.ConcurrentHashMap$HashEntry[] currentTable
@dalvik.annotation.Signature (value =Ljava/util/concurrent/ConcurrentHashMap$HashEntry<TK;TV;>; )
 java.util.concurrent.ConcurrentHashMap$HashEntry lastReturned
@dalvik.annotation.Signature (value =Ljava/util/concurrent/ConcurrentHashMap$HashEntry<TK;TV;>; )
 java.util.concurrent.ConcurrentHashMap$HashEntry nextEntry

 int nextSegmentIndex

 int nextTableIndex

final java.util.concurrent.ConcurrentHashMap this$0
----------------METHODS----------------

 void <init>(
java.util.concurrent.ConcurrentHashMap)

final void advance()

public boolean hasMoreElements()

public boolean hasNext()
@dalvik.annotation.Signature (value =()Ljava/util/concurrent/ConcurrentHashMap$HashEntry<TK;TV;>; )
 java.util.concurrent.ConcurrentHashMap$HashEntry nextEntry()

public void remove()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/ConcurrentHashMap; )
@dalvik.annotation.Signature (value =Ljava/util/concurrent/ConcurrentHashMap<TK;TV;>.HashIterator;Ljava/util/Map$Entry<TK;TV;>;Ljava/util/Iterator<Ljava/util/Map$Entry<TK;TV;>;>; )
@dalvik.annotation.InnerClass (accessFlags =16 name =EntryIterator )
final class java.util.concurrent.ConcurrentHashMap$EntryIterator extends java.util.concurrent.ConcurrentHashMap$HashIterator implements java.util.Map$Entry, java.util.Iterator

----------------FIELDS----------------

final java.util.concurrent.ConcurrentHashMap this$0
----------------METHODS----------------

 void <init>(
java.util.concurrent.ConcurrentHashMap)

 boolean eq(
java.lang.Object
java.lang.Object)

public boolean equals(
java.lang.Object)
@dalvik.annotation.Signature (value =()TK; )
public java.lang.Object getKey()
@dalvik.annotation.Signature (value =()TV; )
public java.lang.Object getValue()

public int hashCode()

public volatile java.lang.Object next()
@dalvik.annotation.Signature (value =()Ljava/util/Map$Entry<TK;TV;>; )
public java.util.Map$Entry next()
@dalvik.annotation.Signature (value =(TV;)TV; )
public java.lang.Object setValue(
java.lang.Object)

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/ConcurrentHashMap; )
@dalvik.annotation.Signature (value =Ljava/util/AbstractSet<Ljava/util/Map$Entry<TK;TV;>;>; )
@dalvik.annotation.InnerClass (accessFlags =16 name =EntrySet )
final class java.util.concurrent.ConcurrentHashMap$EntrySet extends java.util.AbstractSet

----------------FIELDS----------------

final java.util.concurrent.ConcurrentHashMap this$0
----------------METHODS----------------

 void <init>(
java.util.concurrent.ConcurrentHashMap)

public void clear()

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<Ljava/util/Map$Entry<TK;TV;>;>; )
public java.util.Iterator iterator()

public boolean remove(
java.lang.Object)

public int size()

public java.lang.Object[] toArray()
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>([TT;)[TT; )
public java.lang.Object[] toArray(
java.lang.Object[])

________________CLASS________________

@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/lang/Object; )
@dalvik.annotation.InnerClass (accessFlags =24 name =HashEntry )
@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/ConcurrentHashMap; )
final class java.util.concurrent.ConcurrentHashMap$HashEntry extends java.lang.Object

----------------FIELDS----------------

final int hash
@dalvik.annotation.Signature (value =TK; )
final java.lang.Object key
@dalvik.annotation.Signature (value =Ljava/util/concurrent/ConcurrentHashMap$HashEntry<TK;TV;>; )
final java.util.concurrent.ConcurrentHashMap$HashEntry next
@dalvik.annotation.Signature (value =TV; )
 java.lang.Object value
----------------METHODS----------------
@dalvik.annotation.Signature (value =(ITK;TV;Ljava/util/concurrent/ConcurrentHashMap$HashEntry<TK;TV;>;)V )
 void <init>(
int
java.lang.Object
java.lang.Object
java.util.concurrent.ConcurrentHashMap$HashEntry)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =16 name =KeyIterator )
@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/ConcurrentHashMap; )
@dalvik.annotation.Signature (value =Ljava/util/concurrent/ConcurrentHashMap<TK;TV;>.HashIterator;Ljava/util/Iterator<TK;>;Ljava/util/Enumeration<TK;>; )
final class java.util.concurrent.ConcurrentHashMap$KeyIterator extends java.util.concurrent.ConcurrentHashMap$HashIterator implements java.util.Iterator, java.util.Enumeration

----------------FIELDS----------------

final java.util.concurrent.ConcurrentHashMap this$0
----------------METHODS----------------

 void <init>(
java.util.concurrent.ConcurrentHashMap)
@dalvik.annotation.Signature (value =()TK; )
public java.lang.Object next()
@dalvik.annotation.Signature (value =()TK; )
public java.lang.Object nextElement()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/ConcurrentHashMap; )
@dalvik.annotation.Signature (value =Ljava/util/AbstractSet<TK;>; )
@dalvik.annotation.InnerClass (accessFlags =16 name =KeySet )
final class java.util.concurrent.ConcurrentHashMap$KeySet extends java.util.AbstractSet

----------------FIELDS----------------

final java.util.concurrent.ConcurrentHashMap this$0
----------------METHODS----------------

 void <init>(
java.util.concurrent.ConcurrentHashMap)

public void clear()

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TK;>; )
public java.util.Iterator iterator()

public boolean remove(
java.lang.Object)

public int size()

________________CLASS________________


public abstract interface class java.util.concurrent.locks.Lock extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract void lock()
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public abstract void lockInterruptibly()

public abstract java.util.concurrent.locks.Condition newCondition()

public abstract boolean tryLock()
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public abstract boolean tryLock(
long
java.util.concurrent.TimeUnit)

public abstract void unlock()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/concurrent/locks/ReentrantLock$FairSync;Ljava/util/concurrent/locks/ReentrantLock$NonfairSync;Ljava/util/concurrent/locks/ReentrantLock$Sync; )
public class java.util.concurrent.locks.ReentrantLock extends java.lang.Object implements java.util.concurrent.locks.Lock, java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

private final java.util.concurrent.locks.ReentrantLock$Sync sync
----------------METHODS----------------

public void <init>()

public void <init>(
boolean)

public int getHoldCount()

protected java.lang.Thread getOwner()

public final int getQueueLength()
@dalvik.annotation.Signature (value =()Ljava/util/Collection<Ljava/lang/Thread;>; )
protected java.util.Collection getQueuedThreads()

public int getWaitQueueLength(
java.util.concurrent.locks.Condition)
@dalvik.annotation.Signature (value =(Ljava/util/concurrent/locks/Condition;)Ljava/util/Collection<Ljava/lang/Thread;>; )
protected java.util.Collection getWaitingThreads(
java.util.concurrent.locks.Condition)

public final boolean hasQueuedThread(
java.lang.Thread)

public final boolean hasQueuedThreads()

public boolean hasWaiters(
java.util.concurrent.locks.Condition)

public final boolean isFair()

public boolean isHeldByCurrentThread()

public boolean isLocked()

public void lock()
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public void lockInterruptibly()

public java.util.concurrent.locks.Condition newCondition()

public java.lang.String toString()

public boolean tryLock()
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public boolean tryLock(
long
java.util.concurrent.TimeUnit)

public void unlock()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/ConcurrentHashMap; )
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/util/concurrent/locks/ReentrantLock;Ljava/io/Serializable; )
@dalvik.annotation.InnerClass (accessFlags =24 name =Segment )
final class java.util.concurrent.ConcurrentHashMap$Segment extends java.util.concurrent.locks.ReentrantLock implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

transient volatile int count

final float loadFactor

transient int modCount

transient java.util.concurrent.ConcurrentHashMap$HashEntry[] table

transient int threshold
----------------METHODS----------------

 void <init>(
int
float)

 void clear()

 boolean containsKey(
java.lang.Object
int)

 boolean containsValue(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;I)TV; )
 java.lang.Object get(
java.lang.Object
int)
@dalvik.annotation.Signature (value =(TK;ITV;Z)TV; )
 java.lang.Object put(
java.lang.Object
int
java.lang.Object
boolean)

 java.util.concurrent.ConcurrentHashMap$HashEntry[] rehash(
java.util.concurrent.ConcurrentHashMap$HashEntry[])
@dalvik.annotation.Signature (value =(Ljava/lang/Object;ILjava/lang/Object;)TV; )
 java.lang.Object remove(
java.lang.Object
int
java.lang.Object)
@dalvik.annotation.Signature (value =(TK;ITV;)TV; )
 java.lang.Object replace(
java.lang.Object
int
java.lang.Object)
@dalvik.annotation.Signature (value =(TK;ITV;TV;)Z )
 boolean replace(
java.lang.Object
int
java.lang.Object
java.lang.Object)

 void setTable(
java.util.concurrent.ConcurrentHashMap$HashEntry[])

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =24 name =SimpleEntry )
@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/ConcurrentHashMap; )
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Map$Entry<TK;TV;>; )
final class java.util.concurrent.ConcurrentHashMap$SimpleEntry extends java.lang.Object implements java.util.Map$Entry

----------------FIELDS----------------
@dalvik.annotation.Signature (value =TK; )
 java.lang.Object key
@dalvik.annotation.Signature (value =TV; )
 java.lang.Object value
----------------METHODS----------------
@dalvik.annotation.Signature (value =(TK;TV;)V )
public void <init>(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Map$Entry<TK;TV;>;)V )
public void <init>(
java.util.Map$Entry)

static boolean eq(
java.lang.Object
java.lang.Object)

public boolean equals(
java.lang.Object)
@dalvik.annotation.Signature (value =()TK; )
public java.lang.Object getKey()
@dalvik.annotation.Signature (value =()TV; )
public java.lang.Object getValue()

public int hashCode()
@dalvik.annotation.Signature (value =(TV;)TV; )
public java.lang.Object setValue(
java.lang.Object)

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/ConcurrentHashMap; )
@dalvik.annotation.Signature (value =Ljava/util/concurrent/ConcurrentHashMap<TK;TV;>.HashIterator;Ljava/util/Iterator<TV;>;Ljava/util/Enumeration<TV;>; )
@dalvik.annotation.InnerClass (accessFlags =16 name =ValueIterator )
final class java.util.concurrent.ConcurrentHashMap$ValueIterator extends java.util.concurrent.ConcurrentHashMap$HashIterator implements java.util.Iterator, java.util.Enumeration

----------------FIELDS----------------

final java.util.concurrent.ConcurrentHashMap this$0
----------------METHODS----------------

 void <init>(
java.util.concurrent.ConcurrentHashMap)
@dalvik.annotation.Signature (value =()TV; )
public java.lang.Object next()
@dalvik.annotation.Signature (value =()TV; )
public java.lang.Object nextElement()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/ConcurrentHashMap; )
@dalvik.annotation.Signature (value =Ljava/util/AbstractCollection<TV;>; )
@dalvik.annotation.InnerClass (accessFlags =16 name =Values )
final class java.util.concurrent.ConcurrentHashMap$Values extends java.util.AbstractCollection

----------------FIELDS----------------

final java.util.concurrent.ConcurrentHashMap this$0
----------------METHODS----------------

 void <init>(
java.util.concurrent.ConcurrentHashMap)

public void clear()

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TV;>; )
public java.util.Iterator iterator()

public int size()

________________CLASS________________

@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Map<TK;TV;>; )
public abstract interface class java.util.concurrent.ConcurrentMap extends java.lang.Object implements java.util.Map

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =(TK;TV;)TV; )
public abstract java.lang.Object putIfAbsent(
java.lang.Object
java.lang.Object)

public abstract boolean remove(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(TK;TV;)TV; )
public abstract java.lang.Object replace(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(TK;TV;TV;)Z )
public abstract boolean replace(
java.lang.Object
java.lang.Object
java.lang.Object)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/concurrent/ConcurrentHashMap$SimpleEntry;Ljava/util/concurrent/ConcurrentHashMap$EntrySet;Ljava/util/concurrent/ConcurrentHashMap$Values;Ljava/util/concurrent/ConcurrentHashMap$KeySet;Ljava/util/concurrent/ConcurrentHashMap$EntryIterator;Ljava/util/concurrent/ConcurrentHashMap$ValueIterator;Ljava/util/concurrent/ConcurrentHashMap$KeyIterator;Ljava/util/concurrent/ConcurrentHashMap$HashIterator;Ljava/util/concurrent/ConcurrentHashMap$HashEntry;Ljava/util/concurrent/ConcurrentHashMap$Segment; )
@dalvik.annotation.Signature (value =<K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/util/AbstractMap<TK;TV;>;Ljava/util/concurrent/ConcurrentMap<TK;TV;>;Ljava/io/Serializable; )
public class java.util.concurrent.ConcurrentHashMap extends java.util.AbstractMap implements java.util.concurrent.ConcurrentMap, java.io.Serializable

----------------FIELDS----------------

static int DEFAULT_INITIAL_CAPACITY

static final float DEFAULT_LOAD_FACTOR

static final int DEFAULT_SEGMENTS

static final int MAXIMUM_CAPACITY

static final int MAX_SEGMENTS

private static final long serialVersionUID
@dalvik.annotation.Signature (value =Ljava/util/Set<Ljava/util/Map$Entry<TK;TV;>;>; )
transient java.util.Set entrySet
@dalvik.annotation.Signature (value =Ljava/util/Set<TK;>; )
transient java.util.Set keySet

final int segmentMask

final int segmentShift

final java.util.concurrent.ConcurrentHashMap$Segment[] segments
@dalvik.annotation.Signature (value =Ljava/util/Collection<TV;>; )
transient java.util.Collection values
----------------METHODS----------------

static void <clinit>()

public void <init>()

public void <init>(
int)

public void <init>(
int
float
int)
@dalvik.annotation.Signature (value =(Ljava/util/Map<+TK;+TV;>;)V )
public void <init>(
java.util.Map)

static int hash(
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

public void clear()

public boolean contains(
java.lang.Object)

public boolean containsKey(
java.lang.Object)

public boolean containsValue(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<TV;>; )
public java.util.Enumeration elements()
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/util/Map$Entry<TK;TV;>;>; )
public java.util.Set entrySet()
@dalvik.annotation.Signature (value =(Ljava/lang/Object;)TV; )
public java.lang.Object get(
java.lang.Object)

public boolean isEmpty()
@dalvik.annotation.Signature (value =()Ljava/util/Set<TK;>; )
public java.util.Set keySet()
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<TK;>; )
public java.util.Enumeration keys()
@dalvik.annotation.Signature (value =(TK;TV;)TV; )
public java.lang.Object put(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Map<+TK;+TV;>;)V )
public void putAll(
java.util.Map)
@dalvik.annotation.Signature (value =(TK;TV;)TV; )
public java.lang.Object putIfAbsent(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;)TV; )
public java.lang.Object remove(
java.lang.Object)

public boolean remove(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(TK;TV;)TV; )
public java.lang.Object replace(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(TK;TV;TV;)Z )
public boolean replace(
java.lang.Object
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(I)Ljava/util/concurrent/ConcurrentHashMap$Segment<TK;TV;>; )
final java.util.concurrent.ConcurrentHashMap$Segment segmentFor(
int)

public int size()
@dalvik.annotation.Signature (value =()Ljava/util/Collection<TV;>; )
public java.util.Collection values()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =2 name =Itr )
@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/ConcurrentLinkedQueue; )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Iterator<TE;>; )
 class java.util.concurrent.ConcurrentLinkedQueue$Itr extends java.lang.Object implements java.util.Iterator

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/concurrent/ConcurrentLinkedQueue$Node<TE;>; )
private java.util.concurrent.ConcurrentLinkedQueue$Node lastRet
@dalvik.annotation.Signature (value =TE; )
private java.lang.Object nextItem
@dalvik.annotation.Signature (value =Ljava/util/concurrent/ConcurrentLinkedQueue$Node<TE;>; )
private java.util.concurrent.ConcurrentLinkedQueue$Node nextNode

final java.util.concurrent.ConcurrentLinkedQueue this$0
----------------METHODS----------------

 void <init>(
java.util.concurrent.ConcurrentLinkedQueue)
@dalvik.annotation.Signature (value =()TE; )
private java.lang.Object advance()

public boolean hasNext()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object next()

public void remove()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =10 name =Node )
@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/ConcurrentLinkedQueue; )
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/lang/Object; )
 class java.util.concurrent.ConcurrentLinkedQueue$Node extends java.lang.Object

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/concurrent/atomic/AtomicReferenceFieldUpdater<Ljava/util/concurrent/ConcurrentLinkedQueue$Node;Ljava/lang/Object;>; )
private static final java.util.concurrent.atomic.AtomicReferenceFieldUpdater itemUpdater
@dalvik.annotation.Signature (value =Ljava/util/concurrent/atomic/AtomicReferenceFieldUpdater<Ljava/util/concurrent/ConcurrentLinkedQueue$Node;Ljava/util/concurrent/ConcurrentLinkedQueue$Node;>; )
private static final java.util.concurrent.atomic.AtomicReferenceFieldUpdater nextUpdater
@dalvik.annotation.Signature (value =TE; )
private volatile java.lang.Object item
@dalvik.annotation.Signature (value =Ljava/util/concurrent/ConcurrentLinkedQueue$Node<TE;>; )
private volatile java.util.concurrent.ConcurrentLinkedQueue$Node next
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Signature (value =(TE;)V )
 void <init>(
java.lang.Object)
@dalvik.annotation.Signature (value =(TE;Ljava/util/concurrent/ConcurrentLinkedQueue$Node<TE;>;)V )
 void <init>(
java.lang.Object
java.util.concurrent.ConcurrentLinkedQueue$Node)
@dalvik.annotation.Signature (value =(TE;TE;)Z )
 boolean casItem(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/concurrent/ConcurrentLinkedQueue$Node<TE;>;Ljava/util/concurrent/ConcurrentLinkedQueue$Node<TE;>;)Z )
 boolean casNext(
java.util.concurrent.ConcurrentLinkedQueue$Node
java.util.concurrent.ConcurrentLinkedQueue$Node)
@dalvik.annotation.Signature (value =()TE; )
 java.lang.Object getItem()
@dalvik.annotation.Signature (value =()Ljava/util/concurrent/ConcurrentLinkedQueue$Node<TE;>; )
 java.util.concurrent.ConcurrentLinkedQueue$Node getNext()
@dalvik.annotation.Signature (value =(TE;)V )
 void setItem(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/concurrent/ConcurrentLinkedQueue$Node<TE;>;)V )
 void setNext(
java.util.concurrent.ConcurrentLinkedQueue$Node)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/concurrent/ConcurrentLinkedQueue$Itr;Ljava/util/concurrent/ConcurrentLinkedQueue$Node; )
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/util/AbstractQueue<TE;>;Ljava/util/Queue<TE;>;Ljava/io/Serializable; )
public class java.util.concurrent.ConcurrentLinkedQueue extends java.util.AbstractQueue implements java.util.Queue, java.io.Serializable

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/concurrent/atomic/AtomicReferenceFieldUpdater<Ljava/util/concurrent/ConcurrentLinkedQueue;Ljava/util/concurrent/ConcurrentLinkedQueue$Node;>; )
private static final java.util.concurrent.atomic.AtomicReferenceFieldUpdater headUpdater

private static final long serialVersionUID
@dalvik.annotation.Signature (value =Ljava/util/concurrent/atomic/AtomicReferenceFieldUpdater<Ljava/util/concurrent/ConcurrentLinkedQueue;Ljava/util/concurrent/ConcurrentLinkedQueue$Node;>; )
private static final java.util.concurrent.atomic.AtomicReferenceFieldUpdater tailUpdater
@dalvik.annotation.Signature (value =Ljava/util/concurrent/ConcurrentLinkedQueue$Node<TE;>; )
private transient volatile java.util.concurrent.ConcurrentLinkedQueue$Node head
@dalvik.annotation.Signature (value =Ljava/util/concurrent/ConcurrentLinkedQueue$Node<TE;>; )
private transient volatile java.util.concurrent.ConcurrentLinkedQueue$Node tail
----------------METHODS----------------

static void <clinit>()

public void <init>()
@dalvik.annotation.Signature (value =(Ljava/util/Collection<+TE;>;)V )
public void <init>(
java.util.Collection)
@dalvik.annotation.Signature (value =(Ljava/util/concurrent/ConcurrentLinkedQueue$Node<TE;>;Ljava/util/concurrent/ConcurrentLinkedQueue$Node<TE;>;)Z )
private boolean casHead(
java.util.concurrent.ConcurrentLinkedQueue$Node
java.util.concurrent.ConcurrentLinkedQueue$Node)
@dalvik.annotation.Signature (value =(Ljava/util/concurrent/ConcurrentLinkedQueue$Node<TE;>;Ljava/util/concurrent/ConcurrentLinkedQueue$Node<TE;>;)Z )
private boolean casTail(
java.util.concurrent.ConcurrentLinkedQueue$Node
java.util.concurrent.ConcurrentLinkedQueue$Node)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)
@dalvik.annotation.Signature (value =(TE;)Z )
public boolean add(
java.lang.Object)

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/concurrent/ConcurrentLinkedQueue$Node<TE;>; )
 java.util.concurrent.ConcurrentLinkedQueue$Node first()

public boolean isEmpty()
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TE;>; )
public java.util.Iterator iterator()
@dalvik.annotation.Signature (value =(TE;)Z )
public boolean offer(
java.lang.Object)
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object peek()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object poll()

public boolean remove(
java.lang.Object)

public int size()

public java.lang.Object[] toArray()
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>([TT;)[TT; )
public java.lang.Object[] toArray(
java.lang.Object[])

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/CopyOnWriteArrayList; )
@dalvik.annotation.InnerClass (accessFlags =4104 name =null )
 class java.util.concurrent.CopyOnWriteArrayList$1 extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/CopyOnWriteArrayList; )
@dalvik.annotation.InnerClass (accessFlags =10 name =ListIteratorImpl )
 class java.util.concurrent.CopyOnWriteArrayList$ListIteratorImpl extends java.lang.Object implements java.util.ListIterator

----------------FIELDS----------------

private final java.lang.Object[] arr

private int current

private final int size
----------------METHODS----------------

public void <init>(
java.lang.Object[]
int)

public void add(
java.lang.Object)

public boolean hasNext()

public boolean hasPrevious()

public java.lang.Object next()

public int nextIndex()

public java.lang.Object previous()

public int previousIndex()

public void remove()

public void set(
java.lang.Object)

final int size()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/CopyOnWriteArrayList$SubList; )
@dalvik.annotation.InnerClass (accessFlags =2 name =SubListIterator )
 class java.util.concurrent.CopyOnWriteArrayList$SubList$SubListIterator extends java.util.concurrent.CopyOnWriteArrayList$ListIteratorImpl

----------------FIELDS----------------

private final java.util.concurrent.CopyOnWriteArrayList$SubListReadData dataR

final java.util.concurrent.CopyOnWriteArrayList$SubList this$0
----------------METHODS----------------

private void <init>(
java.util.concurrent.CopyOnWriteArrayList$SubList
int
java.util.concurrent.CopyOnWriteArrayList$SubListReadData)

 void <init>(
java.util.concurrent.CopyOnWriteArrayList$SubList
int
java.util.concurrent.CopyOnWriteArrayList$SubListReadData
java.util.concurrent.CopyOnWriteArrayList$1)

public boolean hasNext()

public boolean hasPrevious()

public int nextIndex()

public int previousIndex()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =SubList )
@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/CopyOnWriteArrayList; )
@dalvik.annotation.MemberClasses (value =Ljava/util/concurrent/CopyOnWriteArrayList$SubList$SubListIterator; )
 class java.util.concurrent.CopyOnWriteArrayList$SubList extends java.lang.Object implements java.util.List

----------------FIELDS----------------

private final java.util.concurrent.CopyOnWriteArrayList list

private volatile java.util.concurrent.CopyOnWriteArrayList$SubListReadData read

private final int start
----------------METHODS----------------

public void <init>(
java.util.concurrent.CopyOnWriteArrayList
int
int)

static int access$200(
java.util.concurrent.CopyOnWriteArrayList$SubList)

private void checkModifications()

public void add(
int
java.lang.Object)

public boolean add(
java.lang.Object)

public boolean addAll(
int
java.util.Collection)

public boolean addAll(
java.util.Collection)

public void clear()

public boolean contains(
java.lang.Object)

public boolean containsAll(
java.util.Collection)

public java.lang.Object get(
int)

public int indexOf(
java.lang.Object)

public boolean isEmpty()

public java.util.Iterator iterator()

public int lastIndexOf(
java.lang.Object)

public java.util.ListIterator listIterator()

public java.util.ListIterator listIterator(
int)

public java.lang.Object remove(
int)

public boolean remove(
java.lang.Object)

public boolean removeAll(
java.util.Collection)

public boolean retainAll(
java.util.Collection)

public java.lang.Object set(
int
java.lang.Object)

public int size()

public java.util.List subList(
int
int)

public java.lang.Object[] toArray()

public java.lang.Object[] toArray(
java.lang.Object[])

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =24 name =SubListReadData )
@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/CopyOnWriteArrayList; )
final class java.util.concurrent.CopyOnWriteArrayList$SubListReadData extends java.lang.Object

----------------FIELDS----------------

final java.lang.Object[] data

final int size
----------------METHODS----------------

 void <init>(
int
java.lang.Object[])

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/concurrent/CopyOnWriteArrayList$1;Ljava/util/concurrent/CopyOnWriteArrayList$SubList;Ljava/util/concurrent/CopyOnWriteArrayList$SubListReadData;Ljava/util/concurrent/CopyOnWriteArrayList$ListIteratorImpl; )
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/List<TE;>;Ljava/util/RandomAccess;Ljava/lang/Cloneable;Ljava/io/Serializable; )
public class java.util.concurrent.CopyOnWriteArrayList extends java.lang.Object implements java.util.List, java.util.RandomAccess, java.lang.Cloneable, java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID
@dalvik.annotation.Signature (value =[TE; )
private transient volatile java.lang.Object[] arr

private final transient java.util.concurrent.locks.ReentrantLock lock
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Signature (value =(Ljava/util/Collection<+TE;>;)V )
public void <init>(
java.util.Collection)
@dalvik.annotation.Signature (value =([TE;)V )
public void <init>(
java.lang.Object[])

static java.util.concurrent.locks.ReentrantLock access$100(
java.util.concurrent.CopyOnWriteArrayList)

static final void checkIndexExlusive(
int
int)

static final void checkIndexInclusive(
int
int)

static final boolean containsAll(
java.util.Collection
java.lang.Object[]
int
int)

static final int indexOf(
java.lang.Object
java.lang.Object[]
int
int)

static final int lastIndexOf(
java.lang.Object
java.lang.Object[]
int
int)
@dalvik.annotation.Signature (value =(I)[TE; )
private final java.lang.Object[] newElementArray(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)
@dalvik.annotation.Signature (value =([TE;)V )
private final void setData(
java.lang.Object[])

static java.lang.Object[] toArray(
java.lang.Object[]
int
int)

static java.lang.Object[] toArray(
java.lang.Object[]
java.lang.Object[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)
@dalvik.annotation.Signature (value =(ITE;)V )
public void add(
int
java.lang.Object)
@dalvik.annotation.Signature (value =(TE;)Z )
public boolean add(
java.lang.Object)
@dalvik.annotation.Signature (value =(ILjava/util/Collection<+TE;>;)Z )
public boolean addAll(
int
java.util.Collection)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<+TE;>;)Z )
public boolean addAll(
java.util.Collection)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<+TE;>;)I )
public int addAllAbsent(
java.util.Collection)
@dalvik.annotation.Signature (value =(TE;)Z )
public boolean addIfAbsent(
java.lang.Object)

public void clear()

public java.lang.Object clone()

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public boolean containsAll(
java.util.Collection)

public boolean equals(
java.lang.Object)
@dalvik.annotation.Signature (value =(I)TE; )
public java.lang.Object get(
int)
@dalvik.annotation.Signature (value =()[TE; )
final java.lang.Object[] getData()

public int hashCode()

public int indexOf(
java.lang.Object)
@dalvik.annotation.Signature (value =(TE;I)I )
public int indexOf(
java.lang.Object
int)

public boolean isEmpty()
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TE;>; )
public java.util.Iterator iterator()

public int lastIndexOf(
java.lang.Object)
@dalvik.annotation.Signature (value =(TE;I)I )
public int lastIndexOf(
java.lang.Object
int)
@dalvik.annotation.Signature (value =()Ljava/util/ListIterator<TE;>; )
public java.util.ListIterator listIterator()
@dalvik.annotation.Signature (value =(I)Ljava/util/ListIterator<TE;>; )
public java.util.ListIterator listIterator(
int)
@dalvik.annotation.Signature (value =(I)TE; )
public java.lang.Object remove(
int)

public boolean remove(
java.lang.Object)

final int removeAll(
java.util.Collection
int
int)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public boolean removeAll(
java.util.Collection)
@dalvik.annotation.Signature (value =(II)TE; )
 java.lang.Object removeRange(
int
int)

 int retainAll(
java.util.Collection
int
int)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public boolean retainAll(
java.util.Collection)
@dalvik.annotation.Signature (value =(ITE;)TE; )
public java.lang.Object set(
int
java.lang.Object)

public int size()
@dalvik.annotation.Signature (value =(II)Ljava/util/List<TE;>; )
public java.util.List subList(
int
int)

public java.lang.Object[] toArray()
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>([TT;)[TT; )
public java.lang.Object[] toArray(
java.lang.Object[])

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/util/AbstractSet<TE;>;Ljava/io/Serializable; )
public class java.util.concurrent.CopyOnWriteArraySet extends java.util.AbstractSet implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID
@dalvik.annotation.Signature (value =Ljava/util/concurrent/CopyOnWriteArrayList<TE;>; )
private final java.util.concurrent.CopyOnWriteArrayList al
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Signature (value =(Ljava/util/Collection<+TE;>;)V )
public void <init>(
java.util.Collection)
@dalvik.annotation.Signature (value =(TE;)Z )
public boolean add(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<+TE;>;)Z )
public boolean addAll(
java.util.Collection)

public void clear()

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public boolean containsAll(
java.util.Collection)

public boolean isEmpty()
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TE;>; )
public java.util.Iterator iterator()

public boolean remove(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public boolean removeAll(
java.util.Collection)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public boolean retainAll(
java.util.Collection)

public int size()

public java.lang.Object[] toArray()
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>([TT;)[TT; )
public java.lang.Object[] toArray(
java.lang.Object[])

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/concurrent/locks/AbstractQueuedSynchronizer$ConditionObject;Ljava/util/concurrent/locks/AbstractQueuedSynchronizer$Node; )
public abstract class java.util.concurrent.locks.AbstractQueuedSynchronizer extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------

private static final long headOffset

private static final long serialVersionUID

private static final long stateOffset

private static final long tailOffset

private static final sun.misc.Unsafe unsafe

private static final long waitStatusOffset

private transient volatile java.util.concurrent.locks.AbstractQueuedSynchronizer$Node head

private volatile int state

private transient volatile java.util.concurrent.locks.AbstractQueuedSynchronizer$Node tail
----------------METHODS----------------

static void <clinit>()

protected void <init>()

static void access$000()

private java.util.concurrent.locks.AbstractQueuedSynchronizer$Node addWaiter(
java.util.concurrent.locks.AbstractQueuedSynchronizer$Node)

private void cancelAcquire(
java.util.concurrent.locks.AbstractQueuedSynchronizer$Node)

private final boolean compareAndSetHead(
java.util.concurrent.locks.AbstractQueuedSynchronizer$Node)

private final boolean compareAndSetTail(
java.util.concurrent.locks.AbstractQueuedSynchronizer$Node
java.util.concurrent.locks.AbstractQueuedSynchronizer$Node)

private static final boolean compareAndSetWaitStatus(
java.util.concurrent.locks.AbstractQueuedSynchronizer$Node
int
int)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
private void doAcquireInterruptibly(
int)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
private boolean doAcquireNanos(
int
long)

private void doAcquireShared(
int)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
private void doAcquireSharedInterruptibly(
int)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
private boolean doAcquireSharedNanos(
int
long)

private java.util.concurrent.locks.AbstractQueuedSynchronizer$Node enq(
java.util.concurrent.locks.AbstractQueuedSynchronizer$Node)

private boolean findNodeFromTail(
java.util.concurrent.locks.AbstractQueuedSynchronizer$Node)

private java.lang.Thread fullGetFirstQueuedThread()

private static boolean parkAndCheckInterrupt()

private static void selfInterrupt()

private void setHead(
java.util.concurrent.locks.AbstractQueuedSynchronizer$Node)

private void setHeadAndPropagate(
java.util.concurrent.locks.AbstractQueuedSynchronizer$Node
int)

private static boolean shouldParkAfterFailedAcquire(
java.util.concurrent.locks.AbstractQueuedSynchronizer$Node
java.util.concurrent.locks.AbstractQueuedSynchronizer$Node)

private void unparkSuccessor(
java.util.concurrent.locks.AbstractQueuedSynchronizer$Node)

public final void acquire(
int)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public final void acquireInterruptibly(
int)

final boolean acquireQueued(
java.util.concurrent.locks.AbstractQueuedSynchronizer$Node
int)

public final void acquireShared(
int)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public final void acquireSharedInterruptibly(
int)

protected final boolean compareAndSetState(
int
int)

final int fullyRelease(
java.util.concurrent.locks.AbstractQueuedSynchronizer$Node)
@dalvik.annotation.Signature (value =()Ljava/util/Collection<Ljava/lang/Thread;>; )
public final java.util.Collection getExclusiveQueuedThreads()

public final java.lang.Thread getFirstQueuedThread()

public final int getQueueLength()
@dalvik.annotation.Signature (value =()Ljava/util/Collection<Ljava/lang/Thread;>; )
public final java.util.Collection getQueuedThreads()
@dalvik.annotation.Signature (value =()Ljava/util/Collection<Ljava/lang/Thread;>; )
public final java.util.Collection getSharedQueuedThreads()

protected final int getState()

public final int getWaitQueueLength(
java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
@dalvik.annotation.Signature (value =(Ljava/util/concurrent/locks/AbstractQueuedSynchronizer$ConditionObject;)Ljava/util/Collection<Ljava/lang/Thread;>; )
public final java.util.Collection getWaitingThreads(
java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)

public final boolean hasContended()

public final boolean hasQueuedThreads()

public final boolean hasWaiters(
java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)

protected boolean isHeldExclusively()

final boolean isOnSyncQueue(
java.util.concurrent.locks.AbstractQueuedSynchronizer$Node)

public final boolean isQueued(
java.lang.Thread)

public final boolean owns(
java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)

public final boolean release(
int)

public final boolean releaseShared(
int)

protected final void setState(
int)

public java.lang.String toString()

final boolean transferAfterCancelledWait(
java.util.concurrent.locks.AbstractQueuedSynchronizer$Node)

final boolean transferForSignal(
java.util.concurrent.locks.AbstractQueuedSynchronizer$Node)

protected boolean tryAcquire(
int)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public final boolean tryAcquireNanos(
int
long)

protected int tryAcquireShared(
int)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public final boolean tryAcquireSharedNanos(
int
long)

protected boolean tryRelease(
int)

protected boolean tryReleaseShared(
int)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/CountDownLatch; )
@dalvik.annotation.InnerClass (accessFlags =26 name =Sync )
final class java.util.concurrent.CountDownLatch$Sync extends java.util.concurrent.locks.AbstractQueuedSynchronizer

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
int)

 int getCount()

public int tryAcquireShared(
int)

public boolean tryReleaseShared(
int)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/concurrent/CountDownLatch$Sync; )
public class java.util.concurrent.CountDownLatch extends java.lang.Object

----------------FIELDS----------------

private final java.util.concurrent.CountDownLatch$Sync sync
----------------METHODS----------------

public void <init>(
int)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public void await()
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public boolean await(
long
java.util.concurrent.TimeUnit)

public void countDown()

public long getCount()

public java.lang.String toString()

________________CLASS________________


public class java.util.concurrent.CyclicBarrier extends java.lang.Object

----------------FIELDS----------------

private final java.lang.Runnable barrierCommand

private boolean broken

private int count

private long generation

private final java.util.concurrent.locks.ReentrantLock lock

private final int parties

private final java.util.concurrent.locks.Condition trip
----------------METHODS----------------

public void <init>(
int)

public void <init>(
int
java.lang.Runnable)

private void breakBarrier()
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException;Ljava/util/concurrent/BrokenBarrierException;Ljava/util/concurrent/TimeoutException; )
private int dowait(
boolean
long)

private void nextGeneration()
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException;Ljava/util/concurrent/BrokenBarrierException; )
public int await()
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException;Ljava/util/concurrent/BrokenBarrierException;Ljava/util/concurrent/TimeoutException; )
public int await(
long
java.util.concurrent.TimeUnit)

public int getNumberWaiting()

public int getParties()

public boolean isBroken()

public void reset()

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Iterator<TE;>; )
@dalvik.annotation.InnerClass (accessFlags =2 name =Itr )
@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/DelayQueue; )
 class java.util.concurrent.DelayQueue$Itr extends java.lang.Object implements java.util.Iterator

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Iterator<TE;>; )
private final java.util.Iterator iter

final java.util.concurrent.DelayQueue this$0
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/Iterator<TE;>;)V )
 void <init>(
java.util.concurrent.DelayQueue
java.util.Iterator)

public boolean hasNext()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object next()

public void remove()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/concurrent/DelayQueue$Itr; )
@dalvik.annotation.Signature (value =<E::Ljava/util/concurrent/Delayed;>Ljava/util/AbstractQueue<TE;>;Ljava/util/concurrent/BlockingQueue<TE;>; )
public class java.util.concurrent.DelayQueue extends java.util.AbstractQueue implements java.util.concurrent.BlockingQueue

----------------FIELDS----------------

static final boolean $assertionsDisabled

private final transient java.util.concurrent.locks.Condition available

private final transient java.util.concurrent.locks.ReentrantLock lock
@dalvik.annotation.Signature (value =Ljava/util/PriorityQueue<TE;>; )
private final java.util.PriorityQueue q
----------------METHODS----------------

static void <clinit>()

public void <init>()
@dalvik.annotation.Signature (value =(Ljava/util/Collection<+TE;>;)V )
public void <init>(
java.util.Collection)

static java.util.concurrent.locks.ReentrantLock access$000(
java.util.concurrent.DelayQueue)

public volatile boolean add(
java.lang.Object)
@dalvik.annotation.Signature (value =(TE;)Z )
public boolean add(
java.util.concurrent.Delayed)

public void clear()
@dalvik.annotation.Signature (value =(Ljava/util/Collection<-TE;>;)I )
public int drainTo(
java.util.Collection)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<-TE;>;I)I )
public int drainTo(
java.util.Collection
int)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TE;>; )
public java.util.Iterator iterator()

public volatile boolean offer(
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public volatile boolean offer(
java.lang.Object
long
java.util.concurrent.TimeUnit)
@dalvik.annotation.Signature (value =(TE;)Z )
public boolean offer(
java.util.concurrent.Delayed)
@dalvik.annotation.Signature (value =(TE;JLjava/util/concurrent/TimeUnit;)Z )
public boolean offer(
java.util.concurrent.Delayed
long
java.util.concurrent.TimeUnit)

public volatile java.lang.Object peek()
@dalvik.annotation.Signature (value =()TE; )
public java.util.concurrent.Delayed peek()

public volatile java.lang.Object poll()
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public volatile java.lang.Object poll(
long
java.util.concurrent.TimeUnit)
@dalvik.annotation.Signature (value =()TE; )
public java.util.concurrent.Delayed poll()
@dalvik.annotation.Signature (value =(JLjava/util/concurrent/TimeUnit;)TE; )
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public java.util.concurrent.Delayed poll(
long
java.util.concurrent.TimeUnit)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public volatile void put(
java.lang.Object)
@dalvik.annotation.Signature (value =(TE;)V )
public void put(
java.util.concurrent.Delayed)

public int remainingCapacity()

public boolean remove(
java.lang.Object)

public int size()
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public volatile java.lang.Object take()
@dalvik.annotation.Signature (value =()TE; )
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public java.util.concurrent.Delayed take()

public java.lang.Object[] toArray()
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>([TT;)[TT; )
public java.lang.Object[] toArray(
java.lang.Object[])

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/lang/Comparable<Ljava/util/concurrent/Delayed;>; )
public abstract interface class java.util.concurrent.Delayed extends java.lang.Object implements java.lang.Comparable

----------------FIELDS----------------
----------------METHODS----------------

public abstract long getDelay(
java.util.concurrent.TimeUnit)

________________CLASS________________

@dalvik.annotation.Signature (value =<V:Ljava/lang/Object;>Ljava/lang/Object; )
public class java.util.concurrent.Exchanger extends java.lang.Object

----------------FIELDS----------------

private int arrivalCount
@dalvik.annotation.Signature (value =TV; )
private java.lang.Object item

private final java.util.concurrent.locks.ReentrantLock lock

private final java.util.concurrent.locks.Condition taken
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Signature (value =(TV;ZJ)TV; )
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException;Ljava/util/concurrent/TimeoutException; )
private java.lang.Object doExchange(
java.lang.Object
boolean
long)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
@dalvik.annotation.Signature (value =(TV;)TV; )
public java.lang.Object exchange(
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException;Ljava/util/concurrent/TimeoutException; )
@dalvik.annotation.Signature (value =(TV;JLjava/util/concurrent/TimeUnit;)TV; )
public java.lang.Object exchange(
java.lang.Object
long
java.util.concurrent.TimeUnit)

________________CLASS________________


public class java.util.concurrent.ExecutionException extends java.lang.Exception

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

protected void <init>()

protected void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.Throwable)

public void <init>(
java.lang.Throwable)

________________CLASS________________

@dalvik.annotation.Signature (value =<V:Ljava/lang/Object;>Ljava/lang/Object; )
public abstract interface class java.util.concurrent.Future extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract boolean cancel(
boolean)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException;Ljava/util/concurrent/ExecutionException; )
@dalvik.annotation.Signature (value =()TV; )
public abstract java.lang.Object get()
@dalvik.annotation.Signature (value =(JLjava/util/concurrent/TimeUnit;)TV; )
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException;Ljava/util/concurrent/ExecutionException;Ljava/util/concurrent/TimeoutException; )
public abstract java.lang.Object get(
long
java.util.concurrent.TimeUnit)

public abstract boolean isCancelled()

public abstract boolean isDone()

________________CLASS________________

@dalvik.annotation.Signature (value =<V:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/concurrent/Future<TV;>;Ljava/lang/Runnable; )
@dalvik.annotation.MemberClasses (value =Ljava/util/concurrent/FutureTask$Sync; )
public class java.util.concurrent.FutureTask extends java.lang.Object implements java.util.concurrent.Future, java.lang.Runnable

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/concurrent/FutureTask<TV;>.Sync; )
private final java.util.concurrent.FutureTask$Sync sync
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/lang/Runnable;TV;)V )
public void <init>(
java.lang.Runnable
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/concurrent/Callable<TV;>;)V )
public void <init>(
java.util.concurrent.Callable)

public boolean cancel(
boolean)

protected void done()
@dalvik.annotation.Signature (value =()TV; )
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException;Ljava/util/concurrent/ExecutionException; )
public java.lang.Object get()
@dalvik.annotation.Signature (value =(JLjava/util/concurrent/TimeUnit;)TV; )
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException;Ljava/util/concurrent/ExecutionException;Ljava/util/concurrent/TimeoutException; )
public java.lang.Object get(
long
java.util.concurrent.TimeUnit)

public boolean isCancelled()

public boolean isDone()

public void run()

protected boolean runAndReset()
@dalvik.annotation.Signature (value =(TV;)V )
protected void set(
java.lang.Object)

protected void setException(
java.lang.Throwable)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =2 name =QueueingFuture )
@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/ExecutorCompletionService; )
@dalvik.annotation.Signature (value =Ljava/util/concurrent/FutureTask<TV;>; )
 class java.util.concurrent.ExecutorCompletionService$QueueingFuture extends java.util.concurrent.FutureTask

----------------FIELDS----------------

final java.util.concurrent.ExecutorCompletionService this$0
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/lang/Runnable;TV;)V )
 void <init>(
java.util.concurrent.ExecutorCompletionService
java.lang.Runnable
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/concurrent/Callable<TV;>;)V )
 void <init>(
java.util.concurrent.ExecutorCompletionService
java.util.concurrent.Callable)

protected void done()

________________CLASS________________

@dalvik.annotation.Signature (value =<V:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/concurrent/CompletionService<TV;>; )
@dalvik.annotation.MemberClasses (value =Ljava/util/concurrent/ExecutorCompletionService$QueueingFuture; )
public class java.util.concurrent.ExecutorCompletionService extends java.lang.Object implements java.util.concurrent.CompletionService

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/concurrent/BlockingQueue<Ljava/util/concurrent/Future<TV;>;>; )
private final java.util.concurrent.BlockingQueue completionQueue

private final java.util.concurrent.Executor executor
----------------METHODS----------------

public void <init>(
java.util.concurrent.Executor)
@dalvik.annotation.Signature (value =(Ljava/util/concurrent/Executor;Ljava/util/concurrent/BlockingQueue<Ljava/util/concurrent/Future<TV;>;>;)V )
public void <init>(
java.util.concurrent.Executor
java.util.concurrent.BlockingQueue)

static java.util.concurrent.BlockingQueue access$000(
java.util.concurrent.ExecutorCompletionService)
@dalvik.annotation.Signature (value =()Ljava/util/concurrent/Future<TV;>; )
public java.util.concurrent.Future poll()
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
@dalvik.annotation.Signature (value =(JLjava/util/concurrent/TimeUnit;)Ljava/util/concurrent/Future<TV;>; )
public java.util.concurrent.Future poll(
long
java.util.concurrent.TimeUnit)
@dalvik.annotation.Signature (value =(Ljava/lang/Runnable;TV;)Ljava/util/concurrent/Future<TV;>; )
public java.util.concurrent.Future submit(
java.lang.Runnable
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/concurrent/Callable<TV;>;)Ljava/util/concurrent/Future<TV;>; )
public java.util.concurrent.Future submit(
java.util.concurrent.Callable)
@dalvik.annotation.Signature (value =()Ljava/util/concurrent/Future<TV;>; )
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public java.util.concurrent.Future take()

________________CLASS________________


public abstract interface class java.util.concurrent.ThreadFactory extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.lang.Thread newThread(
java.lang.Runnable)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/Executors; )
@dalvik.annotation.InnerClass (accessFlags =8 name =DefaultThreadFactory )
 class java.util.concurrent.Executors$DefaultThreadFactory extends java.lang.Object implements java.util.concurrent.ThreadFactory

----------------FIELDS----------------

static final java.util.concurrent.atomic.AtomicInteger poolNumber

final java.lang.ThreadGroup group

final java.lang.String namePrefix

final java.util.concurrent.atomic.AtomicInteger threadNumber
----------------METHODS----------------

static void <clinit>()

 void <init>()

public java.lang.Thread newThread(
java.lang.Runnable)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/Executors; )
@dalvik.annotation.InnerClass (accessFlags =8 name =DelegatedExecutorService )
 class java.util.concurrent.Executors$DelegatedExecutorService extends java.util.concurrent.AbstractExecutorService

----------------FIELDS----------------

private final java.util.concurrent.ExecutorService e
----------------METHODS----------------

 void <init>(
java.util.concurrent.ExecutorService)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public boolean awaitTermination(
long
java.util.concurrent.TimeUnit)

public void execute(
java.lang.Runnable)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/util/Collection<Ljava/util/concurrent/Callable<TT;>;>;)Ljava/util/List<Ljava/util/concurrent/Future<TT;>;>; )
public java.util.List invokeAll(
java.util.Collection)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/util/Collection<Ljava/util/concurrent/Callable<TT;>;>;JLjava/util/concurrent/TimeUnit;)Ljava/util/List<Ljava/util/concurrent/Future<TT;>;>; )
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public java.util.List invokeAll(
java.util.Collection
long
java.util.concurrent.TimeUnit)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException;Ljava/util/concurrent/ExecutionException; )
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/util/Collection<Ljava/util/concurrent/Callable<TT;>;>;)TT; )
public java.lang.Object invokeAny(
java.util.Collection)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/util/Collection<Ljava/util/concurrent/Callable<TT;>;>;JLjava/util/concurrent/TimeUnit;)TT; )
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException;Ljava/util/concurrent/ExecutionException;Ljava/util/concurrent/TimeoutException; )
public java.lang.Object invokeAny(
java.util.Collection
long
java.util.concurrent.TimeUnit)

public boolean isShutdown()

public boolean isTerminated()

public void shutdown()
@dalvik.annotation.Signature (value =()Ljava/util/List<Ljava/lang/Runnable;>; )
public java.util.List shutdownNow()
@dalvik.annotation.Signature (value =(Ljava/lang/Runnable;)Ljava/util/concurrent/Future<*>; )
public java.util.concurrent.Future submit(
java.lang.Runnable)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/lang/Runnable;TT;)Ljava/util/concurrent/Future<TT;>; )
public java.util.concurrent.Future submit(
java.lang.Runnable
java.lang.Object)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/util/concurrent/Callable<TT;>;)Ljava/util/concurrent/Future<TT;>; )
public java.util.concurrent.Future submit(
java.util.concurrent.Callable)

________________CLASS________________


public abstract interface class java.util.concurrent.ScheduledExecutorService extends java.lang.Object implements java.util.concurrent.ExecutorService

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/lang/Runnable;JLjava/util/concurrent/TimeUnit;)Ljava/util/concurrent/ScheduledFuture<*>; )
public abstract java.util.concurrent.ScheduledFuture schedule(
java.lang.Runnable
long
java.util.concurrent.TimeUnit)
@dalvik.annotation.Signature (value =<V:Ljava/lang/Object;>(Ljava/util/concurrent/Callable<TV;>;JLjava/util/concurrent/TimeUnit;)Ljava/util/concurrent/ScheduledFuture<TV;>; )
public abstract java.util.concurrent.ScheduledFuture schedule(
java.util.concurrent.Callable
long
java.util.concurrent.TimeUnit)
@dalvik.annotation.Signature (value =(Ljava/lang/Runnable;JJLjava/util/concurrent/TimeUnit;)Ljava/util/concurrent/ScheduledFuture<*>; )
public abstract java.util.concurrent.ScheduledFuture scheduleAtFixedRate(
java.lang.Runnable
long
long
java.util.concurrent.TimeUnit)
@dalvik.annotation.Signature (value =(Ljava/lang/Runnable;JJLjava/util/concurrent/TimeUnit;)Ljava/util/concurrent/ScheduledFuture<*>; )
public abstract java.util.concurrent.ScheduledFuture scheduleWithFixedDelay(
java.lang.Runnable
long
long
java.util.concurrent.TimeUnit)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/Executors; )
@dalvik.annotation.InnerClass (accessFlags =8 name =DelegatedScheduledExecutorService )
 class java.util.concurrent.Executors$DelegatedScheduledExecutorService extends java.util.concurrent.Executors$DelegatedExecutorService implements java.util.concurrent.ScheduledExecutorService

----------------FIELDS----------------

private final java.util.concurrent.ScheduledExecutorService e
----------------METHODS----------------

 void <init>(
java.util.concurrent.ScheduledExecutorService)
@dalvik.annotation.Signature (value =(Ljava/lang/Runnable;JLjava/util/concurrent/TimeUnit;)Ljava/util/concurrent/ScheduledFuture<*>; )
public java.util.concurrent.ScheduledFuture schedule(
java.lang.Runnable
long
java.util.concurrent.TimeUnit)
@dalvik.annotation.Signature (value =<V:Ljava/lang/Object;>(Ljava/util/concurrent/Callable<TV;>;JLjava/util/concurrent/TimeUnit;)Ljava/util/concurrent/ScheduledFuture<TV;>; )
public java.util.concurrent.ScheduledFuture schedule(
java.util.concurrent.Callable
long
java.util.concurrent.TimeUnit)
@dalvik.annotation.Signature (value =(Ljava/lang/Runnable;JJLjava/util/concurrent/TimeUnit;)Ljava/util/concurrent/ScheduledFuture<*>; )
public java.util.concurrent.ScheduledFuture scheduleAtFixedRate(
java.lang.Runnable
long
long
java.util.concurrent.TimeUnit)
@dalvik.annotation.Signature (value =(Ljava/lang/Runnable;JJLjava/util/concurrent/TimeUnit;)Ljava/util/concurrent/ScheduledFuture<*>; )
public java.util.concurrent.ScheduledFuture scheduleWithFixedDelay(
java.lang.Runnable
long
long
java.util.concurrent.TimeUnit)

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/concurrent/Callable<Ljava/lang/Object;>; )
@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/Executors; )
@dalvik.annotation.InnerClass (accessFlags =24 name =PrivilegedActionAdapter )
final class java.util.concurrent.Executors$PrivilegedActionAdapter extends java.lang.Object implements java.util.concurrent.Callable

----------------FIELDS----------------

private final java.security.PrivilegedAction action
----------------METHODS----------------

 void <init>(
java.security.PrivilegedAction)

public java.lang.Object call()

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
 class java.util.concurrent.Executors$PrivilegedCallable$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final java.util.concurrent.Executors$PrivilegedCallable this$0
----------------METHODS----------------

 void <init>(
java.util.concurrent.Executors$PrivilegedCallable)

public java.lang.Object run()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/Executors; )
@dalvik.annotation.InnerClass (accessFlags =24 name =PrivilegedCallable )
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/concurrent/Callable<TT;>; )
final class java.util.concurrent.Executors$PrivilegedCallable extends java.lang.Object implements java.util.concurrent.Callable

----------------FIELDS----------------

private final java.security.AccessControlContext acc

private java.lang.Exception exception
@dalvik.annotation.Signature (value =TT; )
private java.lang.Object result
@dalvik.annotation.Signature (value =Ljava/util/concurrent/Callable<TT;>; )
private final java.util.concurrent.Callable task
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/concurrent/Callable<TT;>;)V )
 void <init>(
java.util.concurrent.Callable)

static java.lang.Object access$002(
java.util.concurrent.Executors$PrivilegedCallable
java.lang.Object)

static java.util.concurrent.Callable access$100(
java.util.concurrent.Executors$PrivilegedCallable)

static java.lang.Exception access$202(
java.util.concurrent.Executors$PrivilegedCallable
java.lang.Exception)
@dalvik.annotation.Signature (value =()TT; )
@dalvik.annotation.Throws (value =Ljava/lang/Exception; )
public java.lang.Object call()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
 class java.util.concurrent.Executors$PrivilegedCallableUsingCurrentClassLoader$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final java.util.concurrent.Executors$PrivilegedCallableUsingCurrentClassLoader this$0
----------------METHODS----------------

 void <init>(
java.util.concurrent.Executors$PrivilegedCallableUsingCurrentClassLoader)

public java.lang.Object run()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/Executors; )
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/concurrent/Callable<TT;>; )
@dalvik.annotation.InnerClass (accessFlags =24 name =PrivilegedCallableUsingCurrentClassLoader )
final class java.util.concurrent.Executors$PrivilegedCallableUsingCurrentClassLoader extends java.lang.Object implements java.util.concurrent.Callable

----------------FIELDS----------------

private final java.security.AccessControlContext acc

private final java.lang.ClassLoader ccl

private java.lang.Exception exception
@dalvik.annotation.Signature (value =TT; )
private java.lang.Object result
@dalvik.annotation.Signature (value =Ljava/util/concurrent/Callable<TT;>; )
private final java.util.concurrent.Callable task
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/concurrent/Callable<TT;>;)V )
 void <init>(
java.util.concurrent.Callable)

static java.lang.ClassLoader access$300(
java.util.concurrent.Executors$PrivilegedCallableUsingCurrentClassLoader)

static java.lang.Object access$402(
java.util.concurrent.Executors$PrivilegedCallableUsingCurrentClassLoader
java.lang.Object)

static java.util.concurrent.Callable access$500(
java.util.concurrent.Executors$PrivilegedCallableUsingCurrentClassLoader)

static java.lang.Exception access$602(
java.util.concurrent.Executors$PrivilegedCallableUsingCurrentClassLoader
java.lang.Exception)
@dalvik.annotation.Signature (value =()TT; )
@dalvik.annotation.Throws (value =Ljava/lang/Exception; )
public java.lang.Object call()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =24 name =PrivilegedExceptionActionAdapter )
@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/Executors; )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/concurrent/Callable<Ljava/lang/Object;>; )
final class java.util.concurrent.Executors$PrivilegedExceptionActionAdapter extends java.lang.Object implements java.util.concurrent.Callable

----------------FIELDS----------------

private final java.security.PrivilegedExceptionAction action
----------------METHODS----------------

 void <init>(
java.security.PrivilegedExceptionAction)
@dalvik.annotation.Throws (value =Ljava/lang/Exception; )
public java.lang.Object call()

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
 class java.util.concurrent.Executors$PrivilegedThreadFactory$1$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final java.util.concurrent.Executors$PrivilegedThreadFactory$1 this$1
----------------METHODS----------------

 void <init>(
java.util.concurrent.Executors$PrivilegedThreadFactory$1)

public java.lang.Object run()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
 class java.util.concurrent.Executors$PrivilegedThreadFactory$1 extends java.lang.Object implements java.lang.Runnable

----------------FIELDS----------------

final java.util.concurrent.Executors$PrivilegedThreadFactory this$0

final java.lang.Runnable val$r
----------------METHODS----------------

 void <init>(
java.util.concurrent.Executors$PrivilegedThreadFactory
java.lang.Runnable)

public void run()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/Executors; )
@dalvik.annotation.InnerClass (accessFlags =8 name =PrivilegedThreadFactory )
 class java.util.concurrent.Executors$PrivilegedThreadFactory extends java.util.concurrent.Executors$DefaultThreadFactory

----------------FIELDS----------------

private final java.security.AccessControlContext acc

private final java.lang.ClassLoader ccl
----------------METHODS----------------

 void <init>()

static java.lang.ClassLoader access$700(
java.util.concurrent.Executors$PrivilegedThreadFactory)

static java.security.AccessControlContext access$800(
java.util.concurrent.Executors$PrivilegedThreadFactory)

public java.lang.Thread newThread(
java.lang.Runnable)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/Executors; )
@dalvik.annotation.InnerClass (accessFlags =24 name =RunnableAdapter )
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/concurrent/Callable<TT;>; )
final class java.util.concurrent.Executors$RunnableAdapter extends java.lang.Object implements java.util.concurrent.Callable

----------------FIELDS----------------
@dalvik.annotation.Signature (value =TT; )
final java.lang.Object result

final java.lang.Runnable task
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/lang/Runnable;TT;)V )
 void <init>(
java.lang.Runnable
java.lang.Object)
@dalvik.annotation.Signature (value =()TT; )
public java.lang.Object call()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/concurrent/Executors$DelegatedScheduledExecutorService;Ljava/util/concurrent/Executors$DelegatedExecutorService;Ljava/util/concurrent/Executors$PrivilegedThreadFactory;Ljava/util/concurrent/Executors$DefaultThreadFactory;Ljava/util/concurrent/Executors$PrivilegedCallableUsingCurrentClassLoader;Ljava/util/concurrent/Executors$PrivilegedCallable;Ljava/util/concurrent/Executors$PrivilegedExceptionActionAdapter;Ljava/util/concurrent/Executors$PrivilegedActionAdapter;Ljava/util/concurrent/Executors$RunnableAdapter; )
public class java.util.concurrent.Executors extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

private void <init>()
@dalvik.annotation.Signature (value =(Ljava/lang/Runnable;)Ljava/util/concurrent/Callable<Ljava/lang/Object;>; )
public static java.util.concurrent.Callable callable(
java.lang.Runnable)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/lang/Runnable;TT;)Ljava/util/concurrent/Callable<TT;>; )
public static java.util.concurrent.Callable callable(
java.lang.Runnable
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/security/PrivilegedAction;)Ljava/util/concurrent/Callable<Ljava/lang/Object;>; )
public static java.util.concurrent.Callable callable(
java.security.PrivilegedAction)
@dalvik.annotation.Signature (value =(Ljava/security/PrivilegedExceptionAction;)Ljava/util/concurrent/Callable<Ljava/lang/Object;>; )
public static java.util.concurrent.Callable callable(
java.security.PrivilegedExceptionAction)

public static java.util.concurrent.ThreadFactory defaultThreadFactory()

public static java.util.concurrent.ExecutorService newCachedThreadPool()

public static java.util.concurrent.ExecutorService newCachedThreadPool(
java.util.concurrent.ThreadFactory)

public static java.util.concurrent.ExecutorService newFixedThreadPool(
int)

public static java.util.concurrent.ExecutorService newFixedThreadPool(
int
java.util.concurrent.ThreadFactory)

public static java.util.concurrent.ScheduledExecutorService newScheduledThreadPool(
int)

public static java.util.concurrent.ScheduledExecutorService newScheduledThreadPool(
int
java.util.concurrent.ThreadFactory)

public static java.util.concurrent.ExecutorService newSingleThreadExecutor()

public static java.util.concurrent.ExecutorService newSingleThreadExecutor(
java.util.concurrent.ThreadFactory)

public static java.util.concurrent.ScheduledExecutorService newSingleThreadScheduledExecutor()

public static java.util.concurrent.ScheduledExecutorService newSingleThreadScheduledExecutor(
java.util.concurrent.ThreadFactory)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/util/concurrent/Callable<TT;>;)Ljava/util/concurrent/Callable<TT;>; )
public static java.util.concurrent.Callable privilegedCallable(
java.util.concurrent.Callable)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/util/concurrent/Callable<TT;>;)Ljava/util/concurrent/Callable<TT;>; )
public static java.util.concurrent.Callable privilegedCallableUsingCurrentClassLoader(
java.util.concurrent.Callable)

public static java.util.concurrent.ThreadFactory privilegedThreadFactory()

public static java.util.concurrent.ExecutorService unconfigurableExecutorService(
java.util.concurrent.ExecutorService)

public static java.util.concurrent.ScheduledExecutorService unconfigurableScheduledExecutorService(
java.util.concurrent.ScheduledExecutorService)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/FutureTask; )
@dalvik.annotation.InnerClass (accessFlags =18 name =Sync )
final class java.util.concurrent.FutureTask$Sync extends java.util.concurrent.locks.AbstractQueuedSynchronizer

----------------FIELDS----------------

private static final int CANCELLED

private static final int RAN

private static final int RUNNING
@dalvik.annotation.Signature (value =Ljava/util/concurrent/Callable<TV;>; )
private final java.util.concurrent.Callable callable

private java.lang.Throwable exception
@dalvik.annotation.Signature (value =TV; )
private java.lang.Object result

private volatile java.lang.Thread runner

final java.util.concurrent.FutureTask this$0
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/concurrent/Callable<TV;>;)V )
 void <init>(
java.util.concurrent.FutureTask
java.util.concurrent.Callable)

private boolean ranOrCancelled(
int)

 boolean innerCancel(
boolean)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException;Ljava/util/concurrent/ExecutionException; )
@dalvik.annotation.Signature (value =()TV; )
 java.lang.Object innerGet()
@dalvik.annotation.Signature (value =(J)TV; )
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException;Ljava/util/concurrent/ExecutionException;Ljava/util/concurrent/TimeoutException; )
 java.lang.Object innerGet(
long)

 boolean innerIsCancelled()

 boolean innerIsDone()

 void innerRun()

 boolean innerRunAndReset()
@dalvik.annotation.Signature (value =(TV;)V )
 void innerSet(
java.lang.Object)

 void innerSetException(
java.lang.Throwable)

protected int tryAcquireShared(
int)

protected boolean tryReleaseShared(
int)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/LinkedBlockingQueue; )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Iterator<TE;>; )
@dalvik.annotation.InnerClass (accessFlags =2 name =Itr )
 class java.util.concurrent.LinkedBlockingQueue$Itr extends java.lang.Object implements java.util.Iterator

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/concurrent/LinkedBlockingQueue$Node<TE;>; )
private java.util.concurrent.LinkedBlockingQueue$Node current
@dalvik.annotation.Signature (value =TE; )
private java.lang.Object currentElement
@dalvik.annotation.Signature (value =Ljava/util/concurrent/LinkedBlockingQueue$Node<TE;>; )
private java.util.concurrent.LinkedBlockingQueue$Node lastRet

final java.util.concurrent.LinkedBlockingQueue this$0
----------------METHODS----------------

 void <init>(
java.util.concurrent.LinkedBlockingQueue)

public boolean hasNext()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object next()

public void remove()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =Node )
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/lang/Object; )
@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/LinkedBlockingQueue; )
 class java.util.concurrent.LinkedBlockingQueue$Node extends java.lang.Object

----------------FIELDS----------------
@dalvik.annotation.Signature (value =TE; )
volatile java.lang.Object item
@dalvik.annotation.Signature (value =Ljava/util/concurrent/LinkedBlockingQueue$Node<TE;>; )
 java.util.concurrent.LinkedBlockingQueue$Node next
----------------METHODS----------------
@dalvik.annotation.Signature (value =(TE;)V )
 void <init>(
java.lang.Object)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/concurrent/LinkedBlockingQueue$Itr;Ljava/util/concurrent/LinkedBlockingQueue$Node; )
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/util/AbstractQueue<TE;>;Ljava/util/concurrent/BlockingQueue<TE;>;Ljava/io/Serializable; )
public class java.util.concurrent.LinkedBlockingQueue extends java.util.AbstractQueue implements java.util.concurrent.BlockingQueue, java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

private final int capacity

private final java.util.concurrent.atomic.AtomicInteger count
@dalvik.annotation.Signature (value =Ljava/util/concurrent/LinkedBlockingQueue$Node<TE;>; )
private transient java.util.concurrent.LinkedBlockingQueue$Node head
@dalvik.annotation.Signature (value =Ljava/util/concurrent/LinkedBlockingQueue$Node<TE;>; )
private transient java.util.concurrent.LinkedBlockingQueue$Node last

private final java.util.concurrent.locks.Condition notEmpty

private final java.util.concurrent.locks.Condition notFull

private final java.util.concurrent.locks.ReentrantLock putLock

private final java.util.concurrent.locks.ReentrantLock takeLock
----------------METHODS----------------

public void <init>()

public void <init>(
int)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<+TE;>;)V )
public void <init>(
java.util.Collection)

static java.util.concurrent.locks.ReentrantLock access$000(
java.util.concurrent.LinkedBlockingQueue)

static java.util.concurrent.locks.ReentrantLock access$100(
java.util.concurrent.LinkedBlockingQueue)

static java.util.concurrent.LinkedBlockingQueue$Node access$200(
java.util.concurrent.LinkedBlockingQueue)

static java.util.concurrent.atomic.AtomicInteger access$300(
java.util.concurrent.LinkedBlockingQueue)

static int access$400(
java.util.concurrent.LinkedBlockingQueue)

static java.util.concurrent.locks.Condition access$500(
java.util.concurrent.LinkedBlockingQueue)
@dalvik.annotation.Signature (value =()TE; )
private java.lang.Object extract()

private void fullyLock()

private void fullyUnlock()
@dalvik.annotation.Signature (value =(TE;)V )
private void insert(
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)

private void signalNotEmpty()

private void signalNotFull()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

public void clear()
@dalvik.annotation.Signature (value =(Ljava/util/Collection<-TE;>;)I )
public int drainTo(
java.util.Collection)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<-TE;>;I)I )
public int drainTo(
java.util.Collection
int)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TE;>; )
public java.util.Iterator iterator()
@dalvik.annotation.Signature (value =(TE;)Z )
public boolean offer(
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
@dalvik.annotation.Signature (value =(TE;JLjava/util/concurrent/TimeUnit;)Z )
public boolean offer(
java.lang.Object
long
java.util.concurrent.TimeUnit)
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object peek()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object poll()
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
@dalvik.annotation.Signature (value =(JLjava/util/concurrent/TimeUnit;)TE; )
public java.lang.Object poll(
long
java.util.concurrent.TimeUnit)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
@dalvik.annotation.Signature (value =(TE;)V )
public void put(
java.lang.Object)

public int remainingCapacity()

public boolean remove(
java.lang.Object)

public int size()
@dalvik.annotation.Signature (value =()TE; )
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public java.lang.Object take()

public java.lang.Object[] toArray()
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>([TT;)[TT; )
public java.lang.Object[] toArray(
java.lang.Object[])

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =2 name =Itr )
@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/PriorityBlockingQueue; )
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Iterator<TE;>; )
 class java.util.concurrent.PriorityBlockingQueue$Itr extends java.lang.Object implements java.util.Iterator

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Iterator<TE;>; )
private final java.util.Iterator iter

final java.util.concurrent.PriorityBlockingQueue this$0
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/Iterator<TE;>;)V )
 void <init>(
java.util.concurrent.PriorityBlockingQueue
java.util.Iterator)

public boolean hasNext()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object next()

public void remove()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/concurrent/PriorityBlockingQueue$Itr; )
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/util/AbstractQueue<TE;>;Ljava/util/concurrent/BlockingQueue<TE;>;Ljava/io/Serializable; )
public class java.util.concurrent.PriorityBlockingQueue extends java.util.AbstractQueue implements java.util.concurrent.BlockingQueue, java.io.Serializable

----------------FIELDS----------------

static final boolean $assertionsDisabled

private static final long serialVersionUID

private final java.util.concurrent.locks.ReentrantLock lock

private final java.util.concurrent.locks.Condition notEmpty
@dalvik.annotation.Signature (value =Ljava/util/PriorityQueue<TE;>; )
private final java.util.PriorityQueue q
----------------METHODS----------------

static void <clinit>()

public void <init>()

public void <init>(
int)
@dalvik.annotation.Signature (value =(ILjava/util/Comparator<-TE;>;)V )
public void <init>(
int
java.util.Comparator)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<+TE;>;)V )
public void <init>(
java.util.Collection)

static java.util.concurrent.locks.ReentrantLock access$000(
java.util.concurrent.PriorityBlockingQueue)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)
@dalvik.annotation.Signature (value =(TE;)Z )
public boolean add(
java.lang.Object)

public void clear()
@dalvik.annotation.Signature (value =()Ljava/util/Comparator<-TE;>; )
public java.util.Comparator comparator()

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<-TE;>;)I )
public int drainTo(
java.util.Collection)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<-TE;>;I)I )
public int drainTo(
java.util.Collection
int)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TE;>; )
public java.util.Iterator iterator()
@dalvik.annotation.Signature (value =(TE;)Z )
public boolean offer(
java.lang.Object)
@dalvik.annotation.Signature (value =(TE;JLjava/util/concurrent/TimeUnit;)Z )
public boolean offer(
java.lang.Object
long
java.util.concurrent.TimeUnit)
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object peek()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object poll()
@dalvik.annotation.Signature (value =(JLjava/util/concurrent/TimeUnit;)TE; )
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public java.lang.Object poll(
long
java.util.concurrent.TimeUnit)
@dalvik.annotation.Signature (value =(TE;)V )
public void put(
java.lang.Object)

public int remainingCapacity()

public boolean remove(
java.lang.Object)

public int size()
@dalvik.annotation.Signature (value =()TE; )
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public java.lang.Object take()

public java.lang.Object[] toArray()
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>([TT;)[TT; )
public java.lang.Object[] toArray(
java.lang.Object[])

public java.lang.String toString()

________________CLASS________________


public class java.util.concurrent.RejectedExecutionException extends java.lang.RuntimeException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.Throwable)

public void <init>(
java.lang.Throwable)

________________CLASS________________


public abstract interface class java.util.concurrent.RejectedExecutionHandler extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract void rejectedExecution(
java.lang.Runnable
java.util.concurrent.ThreadPoolExecutor)

________________CLASS________________

@dalvik.annotation.Signature (value =<V:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/concurrent/Delayed;Ljava/util/concurrent/Future<TV;>; )
public abstract interface class java.util.concurrent.ScheduledFuture extends java.lang.Object implements java.util.concurrent.Delayed, java.util.concurrent.Future

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/ScheduledThreadPoolExecutor; )
@dalvik.annotation.InnerClass (accessFlags =4104 name =null )
 class java.util.concurrent.ScheduledThreadPoolExecutor$1 extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Iterator<Ljava/lang/Runnable;>; )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
 class java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue$1 extends java.lang.Object implements java.util.Iterator

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Iterator<Ljava/util/concurrent/ScheduledThreadPoolExecutor$ScheduledFutureTask;>; )
private java.util.Iterator it

final java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue this$0
----------------METHODS----------------

 void <init>(
java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue)

public boolean hasNext()

public volatile java.lang.Object next()

public java.lang.Runnable next()

public void remove()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =10 name =DelayedWorkQueue )
@dalvik.annotation.Signature (value =Ljava/util/AbstractCollection<Ljava/lang/Runnable;>;Ljava/util/concurrent/BlockingQueue<Ljava/lang/Runnable;>; )
@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/ScheduledThreadPoolExecutor; )
 class java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue extends java.util.AbstractCollection implements java.util.concurrent.BlockingQueue

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/concurrent/DelayQueue<Ljava/util/concurrent/ScheduledThreadPoolExecutor$ScheduledFutureTask;>; )
private final java.util.concurrent.DelayQueue dq
----------------METHODS----------------

private void <init>()

 void <init>(
java.util.concurrent.ScheduledThreadPoolExecutor$1)

static java.util.concurrent.DelayQueue access$500(
java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue)

public volatile boolean add(
java.lang.Object)

public boolean add(
java.lang.Runnable)

public void clear()

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<-Ljava/lang/Runnable;>;)I )
public int drainTo(
java.util.Collection)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<-Ljava/lang/Runnable;>;I)I )
public int drainTo(
java.util.Collection
int)

public volatile java.lang.Object element()

public java.lang.Runnable element()

public boolean isEmpty()
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<Ljava/lang/Runnable;>; )
public java.util.Iterator iterator()

public volatile boolean offer(
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public volatile boolean offer(
java.lang.Object
long
java.util.concurrent.TimeUnit)

public boolean offer(
java.lang.Runnable)

public boolean offer(
java.lang.Runnable
long
java.util.concurrent.TimeUnit)

public volatile java.lang.Object peek()

public java.lang.Runnable peek()

public volatile java.lang.Object poll()
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public volatile java.lang.Object poll(
long
java.util.concurrent.TimeUnit)

public java.lang.Runnable poll()
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public java.lang.Runnable poll(
long
java.util.concurrent.TimeUnit)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public volatile void put(
java.lang.Object)

public void put(
java.lang.Runnable)

public int remainingCapacity()

public volatile java.lang.Object remove()

public java.lang.Runnable remove()

public boolean remove(
java.lang.Object)

public int size()
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public volatile java.lang.Object take()
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public java.lang.Runnable take()

public java.lang.Object[] toArray()
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>([TT;)[TT; )
public java.lang.Object[] toArray(
java.lang.Object[])

________________CLASS________________

@dalvik.annotation.Signature (value =<V:Ljava/lang/Object;>Ljava/util/concurrent/FutureTask<TV;>;Ljava/util/concurrent/ScheduledFuture<TV;>; )
@dalvik.annotation.InnerClass (accessFlags =2 name =ScheduledFutureTask )
@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/ScheduledThreadPoolExecutor; )
 class java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask extends java.util.concurrent.FutureTask implements java.util.concurrent.ScheduledFuture

----------------FIELDS----------------

private final long period

private final long sequenceNumber

final java.util.concurrent.ScheduledThreadPoolExecutor this$0

private long time
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/lang/Runnable;TV;J)V )
 void <init>(
java.util.concurrent.ScheduledThreadPoolExecutor
java.lang.Runnable
java.lang.Object
long)
@dalvik.annotation.Signature (value =(Ljava/lang/Runnable;TV;JJ)V )
 void <init>(
java.util.concurrent.ScheduledThreadPoolExecutor
java.lang.Runnable
java.lang.Object
long
long)
@dalvik.annotation.Signature (value =(Ljava/util/concurrent/Callable<TV;>;J)V )
 void <init>(
java.util.concurrent.ScheduledThreadPoolExecutor
java.util.concurrent.Callable
long)

static boolean access$101(
java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask)

static void access$301(
java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask)

private void runPeriodic()

public volatile int compareTo(
java.lang.Object)

public int compareTo(
java.util.concurrent.Delayed)

public long getDelay(
java.util.concurrent.TimeUnit)

 boolean isPeriodic()

public void run()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/concurrent/ThreadPoolExecutor$DiscardOldestPolicy;Ljava/util/concurrent/ThreadPoolExecutor$DiscardPolicy;Ljava/util/concurrent/ThreadPoolExecutor$AbortPolicy;Ljava/util/concurrent/ThreadPoolExecutor$CallerRunsPolicy;Ljava/util/concurrent/ThreadPoolExecutor$Worker; )
public class java.util.concurrent.ThreadPoolExecutor extends java.util.concurrent.AbstractExecutorService

----------------FIELDS----------------

static final boolean $assertionsDisabled

private static final java.lang.Runnable[] EMPTY_RUNNABLE_ARRAY

static final int RUNNING

static final int SHUTDOWN

static final int STOP

static final int TERMINATED

private static final java.util.concurrent.RejectedExecutionHandler defaultHandler

private static final java.lang.RuntimePermission shutdownPerm

private long completedTaskCount

private volatile int corePoolSize

private volatile java.util.concurrent.RejectedExecutionHandler handler

private volatile long keepAliveTime

private int largestPoolSize

private final java.util.concurrent.locks.ReentrantLock mainLock

private volatile int maximumPoolSize

private volatile int poolSize

volatile int runState

private final java.util.concurrent.locks.Condition termination

private volatile java.util.concurrent.ThreadFactory threadFactory
@dalvik.annotation.Signature (value =Ljava/util/concurrent/BlockingQueue<Ljava/lang/Runnable;>; )
private final java.util.concurrent.BlockingQueue workQueue
@dalvik.annotation.Signature (value =Ljava/util/HashSet<Ljava/util/concurrent/ThreadPoolExecutor$Worker;>; )
private final java.util.HashSet workers
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Signature (value =(IIJLjava/util/concurrent/TimeUnit;Ljava/util/concurrent/BlockingQueue<Ljava/lang/Runnable;>;)V )
public void <init>(
int
int
long
java.util.concurrent.TimeUnit
java.util.concurrent.BlockingQueue)
@dalvik.annotation.Signature (value =(IIJLjava/util/concurrent/TimeUnit;Ljava/util/concurrent/BlockingQueue<Ljava/lang/Runnable;>;Ljava/util/concurrent/RejectedExecutionHandler;)V )
public void <init>(
int
int
long
java.util.concurrent.TimeUnit
java.util.concurrent.BlockingQueue
java.util.concurrent.RejectedExecutionHandler)
@dalvik.annotation.Signature (value =(IIJLjava/util/concurrent/TimeUnit;Ljava/util/concurrent/BlockingQueue<Ljava/lang/Runnable;>;Ljava/util/concurrent/ThreadFactory;)V )
public void <init>(
int
int
long
java.util.concurrent.TimeUnit
java.util.concurrent.BlockingQueue
java.util.concurrent.ThreadFactory)
@dalvik.annotation.Signature (value =(IIJLjava/util/concurrent/TimeUnit;Ljava/util/concurrent/BlockingQueue<Ljava/lang/Runnable;>;Ljava/util/concurrent/ThreadFactory;Ljava/util/concurrent/RejectedExecutionHandler;)V )
public void <init>(
int
int
long
java.util.concurrent.TimeUnit
java.util.concurrent.BlockingQueue
java.util.concurrent.ThreadFactory
java.util.concurrent.RejectedExecutionHandler)

private boolean addIfUnderCorePoolSize(
java.lang.Runnable)

private java.lang.Runnable addIfUnderMaximumPoolSize(
java.lang.Runnable)

private java.lang.Thread addThread(
java.lang.Runnable)

protected void afterExecute(
java.lang.Runnable
java.lang.Throwable)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public boolean awaitTermination(
long
java.util.concurrent.TimeUnit)

protected void beforeExecute(
java.lang.Thread
java.lang.Runnable)

public void execute(
java.lang.Runnable)

protected void finalize()

public int getActiveCount()

public long getCompletedTaskCount()

public int getCorePoolSize()

public long getKeepAliveTime(
java.util.concurrent.TimeUnit)

public int getLargestPoolSize()

public int getMaximumPoolSize()

public int getPoolSize()
@dalvik.annotation.Signature (value =()Ljava/util/concurrent/BlockingQueue<Ljava/lang/Runnable;>; )
public java.util.concurrent.BlockingQueue getQueue()

public java.util.concurrent.RejectedExecutionHandler getRejectedExecutionHandler()
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
 java.lang.Runnable getTask()

public long getTaskCount()

public java.util.concurrent.ThreadFactory getThreadFactory()

 void interruptIdleWorkers()

public boolean isShutdown()

public boolean isTerminated()

public boolean isTerminating()

public int prestartAllCoreThreads()

public boolean prestartCoreThread()

public void purge()

 void reject(
java.lang.Runnable)

public boolean remove(
java.lang.Runnable)

public void setCorePoolSize(
int)

public void setKeepAliveTime(
long
java.util.concurrent.TimeUnit)

public void setMaximumPoolSize(
int)

public void setRejectedExecutionHandler(
java.util.concurrent.RejectedExecutionHandler)

public void setThreadFactory(
java.util.concurrent.ThreadFactory)

public void shutdown()
@dalvik.annotation.Signature (value =()Ljava/util/List<Ljava/lang/Runnable;>; )
public java.util.List shutdownNow()

protected void terminated()

 void workerDone(
java.util.concurrent.ThreadPoolExecutor$Worker)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/concurrent/ScheduledThreadPoolExecutor$1;Ljava/util/concurrent/ScheduledThreadPoolExecutor$DelayedWorkQueue;Ljava/util/concurrent/ScheduledThreadPoolExecutor$ScheduledFutureTask; )
public class java.util.concurrent.ScheduledThreadPoolExecutor extends java.util.concurrent.ThreadPoolExecutor implements java.util.concurrent.ScheduledExecutorService

----------------FIELDS----------------

private static final long NANO_ORIGIN

private static final java.util.concurrent.atomic.AtomicLong sequencer

private volatile boolean continueExistingPeriodicTasksAfterShutdown

private volatile boolean executeExistingDelayedTasksAfterShutdown
----------------METHODS----------------

static void <clinit>()

public void <init>(
int)

public void <init>(
int
java.util.concurrent.RejectedExecutionHandler)

public void <init>(
int
java.util.concurrent.ThreadFactory)

public void <init>(
int
java.util.concurrent.ThreadFactory
java.util.concurrent.RejectedExecutionHandler)

static java.util.concurrent.atomic.AtomicLong access$000()

static java.util.concurrent.BlockingQueue access$201(
java.util.concurrent.ScheduledThreadPoolExecutor)

private void cancelUnwantedTasks()

private void delayedExecute(
java.lang.Runnable)

public void execute(
java.lang.Runnable)

public boolean getContinueExistingPeriodicTasksAfterShutdownPolicy()

public boolean getExecuteExistingDelayedTasksAfterShutdownPolicy()
@dalvik.annotation.Signature (value =()Ljava/util/concurrent/BlockingQueue<Ljava/lang/Runnable;>; )
public java.util.concurrent.BlockingQueue getQueue()

final long now()

public boolean remove(
java.lang.Runnable)
@dalvik.annotation.Signature (value =(Ljava/lang/Runnable;JLjava/util/concurrent/TimeUnit;)Ljava/util/concurrent/ScheduledFuture<*>; )
public java.util.concurrent.ScheduledFuture schedule(
java.lang.Runnable
long
java.util.concurrent.TimeUnit)
@dalvik.annotation.Signature (value =<V:Ljava/lang/Object;>(Ljava/util/concurrent/Callable<TV;>;JLjava/util/concurrent/TimeUnit;)Ljava/util/concurrent/ScheduledFuture<TV;>; )
public java.util.concurrent.ScheduledFuture schedule(
java.util.concurrent.Callable
long
java.util.concurrent.TimeUnit)
@dalvik.annotation.Signature (value =(Ljava/lang/Runnable;JJLjava/util/concurrent/TimeUnit;)Ljava/util/concurrent/ScheduledFuture<*>; )
public java.util.concurrent.ScheduledFuture scheduleAtFixedRate(
java.lang.Runnable
long
long
java.util.concurrent.TimeUnit)
@dalvik.annotation.Signature (value =(Ljava/lang/Runnable;JJLjava/util/concurrent/TimeUnit;)Ljava/util/concurrent/ScheduledFuture<*>; )
public java.util.concurrent.ScheduledFuture scheduleWithFixedDelay(
java.lang.Runnable
long
long
java.util.concurrent.TimeUnit)

public void setContinueExistingPeriodicTasksAfterShutdownPolicy(
boolean)

public void setExecuteExistingDelayedTasksAfterShutdownPolicy(
boolean)

public void shutdown()
@dalvik.annotation.Signature (value =()Ljava/util/List<Ljava/lang/Runnable;>; )
public java.util.List shutdownNow()
@dalvik.annotation.Signature (value =(Ljava/lang/Runnable;)Ljava/util/concurrent/Future<*>; )
public java.util.concurrent.Future submit(
java.lang.Runnable)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/lang/Runnable;TT;)Ljava/util/concurrent/Future<TT;>; )
public java.util.concurrent.Future submit(
java.lang.Runnable
java.lang.Object)
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/util/concurrent/Callable<TT;>;)Ljava/util/concurrent/Future<TT;>; )
public java.util.concurrent.Future submit(
java.util.concurrent.Callable)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =1032 name =Sync )
@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/Semaphore; )
abstract class java.util.concurrent.Semaphore$Sync extends java.util.concurrent.locks.AbstractQueuedSynchronizer

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
int)

final int drainPermits()

final int getPermits()

final int nonfairTryAcquireShared(
int)

final void reducePermits(
int)

protected final boolean tryReleaseShared(
int)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/Semaphore; )
@dalvik.annotation.InnerClass (accessFlags =24 name =FairSync )
final class java.util.concurrent.Semaphore$FairSync extends java.util.concurrent.Semaphore$Sync

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
int)

protected int tryAcquireShared(
int)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =24 name =NonfairSync )
@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/Semaphore; )
final class java.util.concurrent.Semaphore$NonfairSync extends java.util.concurrent.Semaphore$Sync

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
int)

protected int tryAcquireShared(
int)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/concurrent/Semaphore$FairSync;Ljava/util/concurrent/Semaphore$NonfairSync;Ljava/util/concurrent/Semaphore$Sync; )
public class java.util.concurrent.Semaphore extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

private final java.util.concurrent.Semaphore$Sync sync
----------------METHODS----------------

public void <init>(
int)

public void <init>(
int
boolean)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public void acquire()
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public void acquire(
int)

public void acquireUninterruptibly()

public void acquireUninterruptibly(
int)

public int availablePermits()

public int drainPermits()

public final int getQueueLength()
@dalvik.annotation.Signature (value =()Ljava/util/Collection<Ljava/lang/Thread;>; )
protected java.util.Collection getQueuedThreads()

public final boolean hasQueuedThreads()

public boolean isFair()

protected void reducePermits(
int)

public void release()

public void release(
int)

public java.lang.String toString()

public boolean tryAcquire()

public boolean tryAcquire(
int)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public boolean tryAcquire(
int
long
java.util.concurrent.TimeUnit)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public boolean tryAcquire(
long
java.util.concurrent.TimeUnit)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =EmptyIterator )
@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/SynchronousQueue; )
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Iterator<TE;>; )
 class java.util.concurrent.SynchronousQueue$EmptyIterator extends java.lang.Object implements java.util.Iterator

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public boolean hasNext()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object next()

public void remove()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =1032 name =WaitQueue )
@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/SynchronousQueue; )
abstract class java.util.concurrent.SynchronousQueue$WaitQueue extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

abstract java.util.concurrent.SynchronousQueue$Node deq()

abstract java.util.concurrent.SynchronousQueue$Node enq(
java.lang.Object)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =24 name =FifoWaitQueue )
@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/SynchronousQueue; )
final class java.util.concurrent.SynchronousQueue$FifoWaitQueue extends java.util.concurrent.SynchronousQueue$WaitQueue implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

private transient java.util.concurrent.SynchronousQueue$Node head

private transient java.util.concurrent.SynchronousQueue$Node last
----------------METHODS----------------

 void <init>()

 java.util.concurrent.SynchronousQueue$Node deq()

 java.util.concurrent.SynchronousQueue$Node enq(
java.lang.Object)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =24 name =LifoWaitQueue )
@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/SynchronousQueue; )
final class java.util.concurrent.SynchronousQueue$LifoWaitQueue extends java.util.concurrent.SynchronousQueue$WaitQueue implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

private transient java.util.concurrent.SynchronousQueue$Node head
----------------METHODS----------------

 void <init>()

 java.util.concurrent.SynchronousQueue$Node deq()

 java.util.concurrent.SynchronousQueue$Node enq(
java.lang.Object)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/SynchronousQueue; )
@dalvik.annotation.InnerClass (accessFlags =24 name =Node )
final class java.util.concurrent.SynchronousQueue$Node extends java.util.concurrent.locks.AbstractQueuedSynchronizer

----------------FIELDS----------------

private static final int ACK

private static final int CANCEL

 java.lang.Object item

 java.util.concurrent.SynchronousQueue$Node next
----------------METHODS----------------

 void <init>(
java.lang.Object)

 void <init>(
java.lang.Object
java.util.concurrent.SynchronousQueue$Node)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
private void checkCancellationOnInterrupt(
java.lang.InterruptedException)

private java.lang.Object extract()

 java.lang.Object getItem()

 boolean setItem(
java.lang.Object)

protected boolean tryAcquire(
int)

protected boolean tryRelease(
int)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
 java.lang.Object waitForPut()
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
 java.lang.Object waitForPut(
long)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
 void waitForTake()
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
 boolean waitForTake(
long)

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/util/AbstractQueue<TE;>;Ljava/util/concurrent/BlockingQueue<TE;>;Ljava/io/Serializable; )
@dalvik.annotation.MemberClasses (value =Ljava/util/concurrent/SynchronousQueue$EmptyIterator;Ljava/util/concurrent/SynchronousQueue$Node;Ljava/util/concurrent/SynchronousQueue$LifoWaitQueue;Ljava/util/concurrent/SynchronousQueue$FifoWaitQueue;Ljava/util/concurrent/SynchronousQueue$WaitQueue; )
public class java.util.concurrent.SynchronousQueue extends java.util.AbstractQueue implements java.util.concurrent.BlockingQueue, java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

private final java.util.concurrent.locks.ReentrantLock qlock

private final java.util.concurrent.SynchronousQueue$WaitQueue waitingConsumers

private final java.util.concurrent.SynchronousQueue$WaitQueue waitingProducers
----------------METHODS----------------

public void <init>()

public void <init>(
boolean)

public void clear()

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public boolean containsAll(
java.util.Collection)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<-TE;>;)I )
public int drainTo(
java.util.Collection)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<-TE;>;I)I )
public int drainTo(
java.util.Collection
int)

public boolean isEmpty()
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TE;>; )
public java.util.Iterator iterator()
@dalvik.annotation.Signature (value =(TE;)Z )
public boolean offer(
java.lang.Object)
@dalvik.annotation.Signature (value =(TE;JLjava/util/concurrent/TimeUnit;)Z )
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public boolean offer(
java.lang.Object
long
java.util.concurrent.TimeUnit)
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object peek()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object poll()
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
@dalvik.annotation.Signature (value =(JLjava/util/concurrent/TimeUnit;)TE; )
public java.lang.Object poll(
long
java.util.concurrent.TimeUnit)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
@dalvik.annotation.Signature (value =(TE;)V )
public void put(
java.lang.Object)

public int remainingCapacity()

public boolean remove(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public boolean removeAll(
java.util.Collection)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public boolean retainAll(
java.util.Collection)

public int size()
@dalvik.annotation.Signature (value =()TE; )
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public java.lang.Object take()

public java.lang.Object[] toArray()
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>([TT;)[TT; )
public java.lang.Object[] toArray(
java.lang.Object[])

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/ThreadPoolExecutor; )
@dalvik.annotation.InnerClass (accessFlags =9 name =AbortPolicy )
public class java.util.concurrent.ThreadPoolExecutor$AbortPolicy extends java.lang.Object implements java.util.concurrent.RejectedExecutionHandler

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public void rejectedExecution(
java.lang.Runnable
java.util.concurrent.ThreadPoolExecutor)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/ThreadPoolExecutor; )
@dalvik.annotation.InnerClass (accessFlags =9 name =CallerRunsPolicy )
public class java.util.concurrent.ThreadPoolExecutor$CallerRunsPolicy extends java.lang.Object implements java.util.concurrent.RejectedExecutionHandler

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public void rejectedExecution(
java.lang.Runnable
java.util.concurrent.ThreadPoolExecutor)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =DiscardOldestPolicy )
@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/ThreadPoolExecutor; )
public class java.util.concurrent.ThreadPoolExecutor$DiscardOldestPolicy extends java.lang.Object implements java.util.concurrent.RejectedExecutionHandler

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public void rejectedExecution(
java.lang.Runnable
java.util.concurrent.ThreadPoolExecutor)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =DiscardPolicy )
@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/ThreadPoolExecutor; )
public class java.util.concurrent.ThreadPoolExecutor$DiscardPolicy extends java.lang.Object implements java.util.concurrent.RejectedExecutionHandler

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public void rejectedExecution(
java.lang.Runnable
java.util.concurrent.ThreadPoolExecutor)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =2 name =Worker )
@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/ThreadPoolExecutor; )
 class java.util.concurrent.ThreadPoolExecutor$Worker extends java.lang.Object implements java.lang.Runnable

----------------FIELDS----------------

volatile long completedTasks

private java.lang.Runnable firstTask

private final java.util.concurrent.locks.ReentrantLock runLock

final java.util.concurrent.ThreadPoolExecutor this$0

 java.lang.Thread thread
----------------METHODS----------------

 void <init>(
java.util.concurrent.ThreadPoolExecutor
java.lang.Runnable)

private void runTask(
java.lang.Runnable)

 void interruptIfIdle()

 void interruptNow()

 boolean isActive()

public void run()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Enum<Ljava/util/concurrent/TimeUnit;>; )
public final class java.util.concurrent.TimeUnit extends java.lang.Enum

----------------FIELDS----------------

private static final java.util.concurrent.TimeUnit[] $VALUES

public static final java.util.concurrent.TimeUnit MICROSECONDS

public static final java.util.concurrent.TimeUnit MILLISECONDS

public static final java.util.concurrent.TimeUnit NANOSECONDS

public static final java.util.concurrent.TimeUnit SECONDS

private static final int[] multipliers

private static final long[] overflows

private final int index
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Signature (value =(I)V )
private void <init>(
java.lang.String
int
int)

private static long doConvert(
int
long)

private int excessNanos(
long
long)

public static java.util.concurrent.TimeUnit valueOf(
java.lang.String)

public static java.util.concurrent.TimeUnit[] values()

public long convert(
long
java.util.concurrent.TimeUnit)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public void sleep(
long)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public void timedJoin(
java.lang.Thread
long)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public void timedWait(
java.lang.Object
long)

public long toMicros(
long)

public long toMillis(
long)

public long toNanos(
long)

public long toSeconds(
long)

________________CLASS________________


public class java.util.concurrent.TimeoutException extends java.lang.Exception

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class java.util.concurrent.atomic.AtomicBoolean extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

private static final sun.misc.Unsafe unsafe

private static final long valueOffset

private volatile int value
----------------METHODS----------------

static void <clinit>()

public void <init>()

public void <init>(
boolean)

public final boolean compareAndSet(
boolean
boolean)

public final boolean get()

public final boolean getAndSet(
boolean)

public final void set(
boolean)

public java.lang.String toString()

public boolean weakCompareAndSet(
boolean
boolean)

________________CLASS________________


public class java.util.concurrent.atomic.AtomicInteger extends java.lang.Number implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

private static final sun.misc.Unsafe unsafe

private static final long valueOffset

private volatile int value
----------------METHODS----------------

static void <clinit>()

public void <init>()

public void <init>(
int)

public final int addAndGet(
int)

public final boolean compareAndSet(
int
int)

public final int decrementAndGet()

public double doubleValue()

public float floatValue()

public final int get()

public final int getAndAdd(
int)

public final int getAndDecrement()

public final int getAndIncrement()

public final int getAndSet(
int)

public final int incrementAndGet()

public int intValue()

public long longValue()

public final void set(
int)

public java.lang.String toString()

public final boolean weakCompareAndSet(
int
int)

________________CLASS________________


public class java.util.concurrent.atomic.AtomicIntegerArray extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------

private static final int base

private static final int scale

private static final long serialVersionUID

private static final sun.misc.Unsafe unsafe

private final int[] array
----------------METHODS----------------

static void <clinit>()

public void <init>(
int)

public void <init>(
int[])

private long rawIndex(
int)

public final int addAndGet(
int
int)

public final boolean compareAndSet(
int
int
int)

public final int decrementAndGet(
int)

public final int get(
int)

public final int getAndAdd(
int
int)

public final int getAndDecrement(
int)

public final int getAndIncrement(
int)

public final int getAndSet(
int
int)

public final int incrementAndGet(
int)

public final int length()

public final void set(
int
int)

public java.lang.String toString()

public final boolean weakCompareAndSet(
int
int
int)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/concurrent/atomic/AtomicIntegerFieldUpdater$AtomicIntegerFieldUpdaterImpl; )
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>Ljava/lang/Object; )
public abstract class java.util.concurrent.atomic.AtomicIntegerFieldUpdater extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

protected void <init>()
@dalvik.annotation.Signature (value =<U:Ljava/lang/Object;>(Ljava/lang/Class<TU;>;Ljava/lang/String;)Ljava/util/concurrent/atomic/AtomicIntegerFieldUpdater<TU;>; )
public static java.util.concurrent.atomic.AtomicIntegerFieldUpdater newUpdater(
java.lang.Class
java.lang.String)
@dalvik.annotation.Signature (value =(TT;I)I )
public int addAndGet(
java.lang.Object
int)
@dalvik.annotation.Signature (value =(TT;II)Z )
public abstract boolean compareAndSet(
java.lang.Object
int
int)
@dalvik.annotation.Signature (value =(TT;)I )
public int decrementAndGet(
java.lang.Object)
@dalvik.annotation.Signature (value =(TT;)I )
public abstract int get(
java.lang.Object)
@dalvik.annotation.Signature (value =(TT;I)I )
public int getAndAdd(
java.lang.Object
int)
@dalvik.annotation.Signature (value =(TT;)I )
public int getAndDecrement(
java.lang.Object)
@dalvik.annotation.Signature (value =(TT;)I )
public int getAndIncrement(
java.lang.Object)
@dalvik.annotation.Signature (value =(TT;I)I )
public int getAndSet(
java.lang.Object
int)
@dalvik.annotation.Signature (value =(TT;)I )
public int incrementAndGet(
java.lang.Object)
@dalvik.annotation.Signature (value =(TT;I)V )
public abstract void set(
java.lang.Object
int)
@dalvik.annotation.Signature (value =(TT;II)Z )
public abstract boolean weakCompareAndSet(
java.lang.Object
int
int)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =10 name =AtomicIntegerFieldUpdaterImpl )
@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/atomic/AtomicIntegerFieldUpdater; )
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>Ljava/util/concurrent/atomic/AtomicIntegerFieldUpdater<TT;>; )
 class java.util.concurrent.atomic.AtomicIntegerFieldUpdater$AtomicIntegerFieldUpdaterImpl extends java.util.concurrent.atomic.AtomicIntegerFieldUpdater

----------------FIELDS----------------

private static final sun.misc.Unsafe unsafe

private final long offset
@dalvik.annotation.Signature (value =Ljava/lang/Class<TT;>; )
private final java.lang.Class tclass
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Signature (value =(Ljava/lang/Class<TT;>;Ljava/lang/String;)V )
 void <init>(
java.lang.Class
java.lang.String)
@dalvik.annotation.Signature (value =(TT;II)Z )
public boolean compareAndSet(
java.lang.Object
int
int)
@dalvik.annotation.Signature (value =(TT;)I )
public final int get(
java.lang.Object)
@dalvik.annotation.Signature (value =(TT;I)V )
public void set(
java.lang.Object
int)
@dalvik.annotation.Signature (value =(TT;II)Z )
public boolean weakCompareAndSet(
java.lang.Object
int
int)

________________CLASS________________


public class java.util.concurrent.atomic.AtomicLong extends java.lang.Number implements java.io.Serializable

----------------FIELDS----------------

static final boolean VM_SUPPORTS_LONG_CAS

private static final long serialVersionUID

private static final sun.misc.Unsafe unsafe

private static final long valueOffset

private volatile long value
----------------METHODS----------------

static void <clinit>()

public void <init>()

public void <init>(
long)

private static native boolean VMSupportsCS8()

public final long addAndGet(
long)

public final boolean compareAndSet(
long
long)

public final long decrementAndGet()

public double doubleValue()

public float floatValue()

public final long get()

public final long getAndAdd(
long)

public final long getAndDecrement()

public final long getAndIncrement()

public final long getAndSet(
long)

public final long incrementAndGet()

public int intValue()

public long longValue()

public final void set(
long)

public java.lang.String toString()

public final boolean weakCompareAndSet(
long
long)

________________CLASS________________


public class java.util.concurrent.atomic.AtomicLongArray extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------

private static final int base

private static final int scale

private static final long serialVersionUID

private static final sun.misc.Unsafe unsafe

private final long[] array
----------------METHODS----------------

static void <clinit>()

public void <init>(
int)

public void <init>(
long[])

private long rawIndex(
int)

public long addAndGet(
int
long)

public final boolean compareAndSet(
int
long
long)

public final long decrementAndGet(
int)

public final long get(
int)

public final long getAndAdd(
int
long)

public final long getAndDecrement(
int)

public final long getAndIncrement(
int)

public final long getAndSet(
int
long)

public final long incrementAndGet(
int)

public final int length()

public final void set(
int
long)

public java.lang.String toString()

public final boolean weakCompareAndSet(
int
long
long)

________________CLASS________________

@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>Ljava/lang/Object; )
@dalvik.annotation.MemberClasses (value =Ljava/util/concurrent/atomic/AtomicLongFieldUpdater$LockedUpdater;Ljava/util/concurrent/atomic/AtomicLongFieldUpdater$CASUpdater; )
public abstract class java.util.concurrent.atomic.AtomicLongFieldUpdater extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

protected void <init>()
@dalvik.annotation.Signature (value =<U:Ljava/lang/Object;>(Ljava/lang/Class<TU;>;Ljava/lang/String;)Ljava/util/concurrent/atomic/AtomicLongFieldUpdater<TU;>; )
public static java.util.concurrent.atomic.AtomicLongFieldUpdater newUpdater(
java.lang.Class
java.lang.String)
@dalvik.annotation.Signature (value =(TT;J)J )
public long addAndGet(
java.lang.Object
long)
@dalvik.annotation.Signature (value =(TT;JJ)Z )
public abstract boolean compareAndSet(
java.lang.Object
long
long)
@dalvik.annotation.Signature (value =(TT;)J )
public long decrementAndGet(
java.lang.Object)
@dalvik.annotation.Signature (value =(TT;)J )
public abstract long get(
java.lang.Object)
@dalvik.annotation.Signature (value =(TT;J)J )
public long getAndAdd(
java.lang.Object
long)
@dalvik.annotation.Signature (value =(TT;)J )
public long getAndDecrement(
java.lang.Object)
@dalvik.annotation.Signature (value =(TT;)J )
public long getAndIncrement(
java.lang.Object)
@dalvik.annotation.Signature (value =(TT;J)J )
public long getAndSet(
java.lang.Object
long)
@dalvik.annotation.Signature (value =(TT;)J )
public long incrementAndGet(
java.lang.Object)
@dalvik.annotation.Signature (value =(TT;J)V )
public abstract void set(
java.lang.Object
long)
@dalvik.annotation.Signature (value =(TT;JJ)Z )
public abstract boolean weakCompareAndSet(
java.lang.Object
long
long)

________________CLASS________________

@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>Ljava/util/concurrent/atomic/AtomicLongFieldUpdater<TT;>; )
@dalvik.annotation.InnerClass (accessFlags =10 name =CASUpdater )
@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/atomic/AtomicLongFieldUpdater; )
 class java.util.concurrent.atomic.AtomicLongFieldUpdater$CASUpdater extends java.util.concurrent.atomic.AtomicLongFieldUpdater

----------------FIELDS----------------

private static final sun.misc.Unsafe unsafe

private final long offset
@dalvik.annotation.Signature (value =Ljava/lang/Class<TT;>; )
private final java.lang.Class tclass
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Signature (value =(Ljava/lang/Class<TT;>;Ljava/lang/String;)V )
 void <init>(
java.lang.Class
java.lang.String)
@dalvik.annotation.Signature (value =(TT;JJ)Z )
public boolean compareAndSet(
java.lang.Object
long
long)
@dalvik.annotation.Signature (value =(TT;)J )
public long get(
java.lang.Object)
@dalvik.annotation.Signature (value =(TT;J)V )
public void set(
java.lang.Object
long)
@dalvik.annotation.Signature (value =(TT;JJ)Z )
public boolean weakCompareAndSet(
java.lang.Object
long
long)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =10 name =LockedUpdater )
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>Ljava/util/concurrent/atomic/AtomicLongFieldUpdater<TT;>; )
@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/atomic/AtomicLongFieldUpdater; )
 class java.util.concurrent.atomic.AtomicLongFieldUpdater$LockedUpdater extends java.util.concurrent.atomic.AtomicLongFieldUpdater

----------------FIELDS----------------

private static final sun.misc.Unsafe unsafe

private final long offset
@dalvik.annotation.Signature (value =Ljava/lang/Class<TT;>; )
private final java.lang.Class tclass
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Signature (value =(Ljava/lang/Class<TT;>;Ljava/lang/String;)V )
 void <init>(
java.lang.Class
java.lang.String)
@dalvik.annotation.Signature (value =(TT;JJ)Z )
public boolean compareAndSet(
java.lang.Object
long
long)
@dalvik.annotation.Signature (value =(TT;)J )
public long get(
java.lang.Object)
@dalvik.annotation.Signature (value =(TT;J)V )
public void set(
java.lang.Object
long)
@dalvik.annotation.Signature (value =(TT;JJ)Z )
public boolean weakCompareAndSet(
java.lang.Object
long
long)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =10 name =ReferenceBooleanPair )
@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/atomic/AtomicMarkableReference; )
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>Ljava/lang/Object; )
 class java.util.concurrent.atomic.AtomicMarkableReference$ReferenceBooleanPair extends java.lang.Object

----------------FIELDS----------------

private final boolean bit
@dalvik.annotation.Signature (value =TT; )
private final java.lang.Object reference
----------------METHODS----------------
@dalvik.annotation.Signature (value =(TT;Z)V )
 void <init>(
java.lang.Object
boolean)

static java.lang.Object access$000(
java.util.concurrent.atomic.AtomicMarkableReference$ReferenceBooleanPair)

static boolean access$100(
java.util.concurrent.atomic.AtomicMarkableReference$ReferenceBooleanPair)

________________CLASS________________

@dalvik.annotation.Signature (value =<V:Ljava/lang/Object;>Ljava/lang/Object; )
@dalvik.annotation.MemberClasses (value =Ljava/util/concurrent/atomic/AtomicMarkableReference$ReferenceBooleanPair; )
public class java.util.concurrent.atomic.AtomicMarkableReference extends java.lang.Object

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/concurrent/atomic/AtomicReference<Ljava/util/concurrent/atomic/AtomicMarkableReference$ReferenceBooleanPair<TV;>;>; )
private final java.util.concurrent.atomic.AtomicReference atomicRef
----------------METHODS----------------
@dalvik.annotation.Signature (value =(TV;Z)V )
public void <init>(
java.lang.Object
boolean)
@dalvik.annotation.Signature (value =(TV;Z)Z )
public boolean attemptMark(
java.lang.Object
boolean)
@dalvik.annotation.Signature (value =(TV;TV;ZZ)Z )
public boolean compareAndSet(
java.lang.Object
java.lang.Object
boolean
boolean)
@dalvik.annotation.Signature (value =([Z)TV; )
public java.lang.Object get(
boolean[])
@dalvik.annotation.Signature (value =()TV; )
public java.lang.Object getReference()

public boolean isMarked()
@dalvik.annotation.Signature (value =(TV;Z)V )
public void set(
java.lang.Object
boolean)
@dalvik.annotation.Signature (value =(TV;TV;ZZ)Z )
public boolean weakCompareAndSet(
java.lang.Object
java.lang.Object
boolean
boolean)

________________CLASS________________

@dalvik.annotation.Signature (value =<V:Ljava/lang/Object;>Ljava/lang/Object;Ljava/io/Serializable; )
public class java.util.concurrent.atomic.AtomicReference extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

private static final sun.misc.Unsafe unsafe

private static final long valueOffset
@dalvik.annotation.Signature (value =TV; )
private volatile java.lang.Object value
----------------METHODS----------------

static void <clinit>()

public void <init>()
@dalvik.annotation.Signature (value =(TV;)V )
public void <init>(
java.lang.Object)
@dalvik.annotation.Signature (value =(TV;TV;)Z )
public final boolean compareAndSet(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =()TV; )
public final java.lang.Object get()
@dalvik.annotation.Signature (value =(TV;)TV; )
public final java.lang.Object getAndSet(
java.lang.Object)
@dalvik.annotation.Signature (value =(TV;)V )
public final void set(
java.lang.Object)

public java.lang.String toString()
@dalvik.annotation.Signature (value =(TV;TV;)Z )
public final boolean weakCompareAndSet(
java.lang.Object
java.lang.Object)

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/lang/Object;Ljava/io/Serializable; )
public class java.util.concurrent.atomic.AtomicReferenceArray extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------

private static final int base

private static final int scale

private static final long serialVersionUID

private static final sun.misc.Unsafe unsafe

private final java.lang.Object[] array
----------------METHODS----------------

static void <clinit>()

public void <init>(
int)
@dalvik.annotation.Signature (value =([TE;)V )
public void <init>(
java.lang.Object[])

private long rawIndex(
int)
@dalvik.annotation.Signature (value =(ITE;TE;)Z )
public final boolean compareAndSet(
int
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(I)TE; )
public final java.lang.Object get(
int)
@dalvik.annotation.Signature (value =(ITE;)TE; )
public final java.lang.Object getAndSet(
int
java.lang.Object)

public final int length()
@dalvik.annotation.Signature (value =(ITE;)V )
public final void set(
int
java.lang.Object)

public java.lang.String toString()
@dalvik.annotation.Signature (value =(ITE;TE;)Z )
public final boolean weakCompareAndSet(
int
java.lang.Object
java.lang.Object)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/concurrent/atomic/AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl; )
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/lang/Object; )
public abstract class java.util.concurrent.atomic.AtomicReferenceFieldUpdater extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

protected void <init>()
@dalvik.annotation.Signature (value =<U:Ljava/lang/Object;W:Ljava/lang/Object;>(Ljava/lang/Class<TU;>;Ljava/lang/Class<TW;>;Ljava/lang/String;)Ljava/util/concurrent/atomic/AtomicReferenceFieldUpdater<TU;TW;>; )
public static java.util.concurrent.atomic.AtomicReferenceFieldUpdater newUpdater(
java.lang.Class
java.lang.Class
java.lang.String)
@dalvik.annotation.Signature (value =(TT;TV;TV;)Z )
public abstract boolean compareAndSet(
java.lang.Object
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(TT;)TV; )
public abstract java.lang.Object get(
java.lang.Object)
@dalvik.annotation.Signature (value =(TT;TV;)TV; )
public java.lang.Object getAndSet(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(TT;TV;)V )
public abstract void set(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(TT;TV;TV;)Z )
public abstract boolean weakCompareAndSet(
java.lang.Object
java.lang.Object
java.lang.Object)

________________CLASS________________

@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/util/concurrent/atomic/AtomicReferenceFieldUpdater<TT;TV;>; )
@dalvik.annotation.InnerClass (accessFlags =10 name =AtomicReferenceFieldUpdaterImpl )
@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/atomic/AtomicReferenceFieldUpdater; )
 class java.util.concurrent.atomic.AtomicReferenceFieldUpdater$AtomicReferenceFieldUpdaterImpl extends java.util.concurrent.atomic.AtomicReferenceFieldUpdater

----------------FIELDS----------------

private static final sun.misc.Unsafe unsafe

private final long offset
@dalvik.annotation.Signature (value =Ljava/lang/Class<TT;>; )
private final java.lang.Class tclass
@dalvik.annotation.Signature (value =Ljava/lang/Class<TV;>; )
private final java.lang.Class vclass
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Signature (value =(Ljava/lang/Class<TT;>;Ljava/lang/Class<TV;>;Ljava/lang/String;)V )
 void <init>(
java.lang.Class
java.lang.Class
java.lang.String)
@dalvik.annotation.Signature (value =(TT;TV;TV;)Z )
public boolean compareAndSet(
java.lang.Object
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(TT;)TV; )
public java.lang.Object get(
java.lang.Object)
@dalvik.annotation.Signature (value =(TT;TV;)V )
public void set(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(TT;TV;TV;)Z )
public boolean weakCompareAndSet(
java.lang.Object
java.lang.Object
java.lang.Object)

________________CLASS________________

@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>Ljava/lang/Object; )
@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/atomic/AtomicStampedReference; )
@dalvik.annotation.InnerClass (accessFlags =10 name =ReferenceIntegerPair )
 class java.util.concurrent.atomic.AtomicStampedReference$ReferenceIntegerPair extends java.lang.Object

----------------FIELDS----------------

private final int integer
@dalvik.annotation.Signature (value =TT; )
private final java.lang.Object reference
----------------METHODS----------------
@dalvik.annotation.Signature (value =(TT;I)V )
 void <init>(
java.lang.Object
int)

static java.lang.Object access$000(
java.util.concurrent.atomic.AtomicStampedReference$ReferenceIntegerPair)

static int access$100(
java.util.concurrent.atomic.AtomicStampedReference$ReferenceIntegerPair)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/concurrent/atomic/AtomicStampedReference$ReferenceIntegerPair; )
@dalvik.annotation.Signature (value =<V:Ljava/lang/Object;>Ljava/lang/Object; )
public class java.util.concurrent.atomic.AtomicStampedReference extends java.lang.Object

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/concurrent/atomic/AtomicReference<Ljava/util/concurrent/atomic/AtomicStampedReference$ReferenceIntegerPair<TV;>;>; )
private final java.util.concurrent.atomic.AtomicReference atomicRef
----------------METHODS----------------
@dalvik.annotation.Signature (value =(TV;I)V )
public void <init>(
java.lang.Object
int)
@dalvik.annotation.Signature (value =(TV;I)Z )
public boolean attemptStamp(
java.lang.Object
int)
@dalvik.annotation.Signature (value =(TV;TV;II)Z )
public boolean compareAndSet(
java.lang.Object
java.lang.Object
int
int)
@dalvik.annotation.Signature (value =([I)TV; )
public java.lang.Object get(
int[])
@dalvik.annotation.Signature (value =()TV; )
public java.lang.Object getReference()

public int getStamp()
@dalvik.annotation.Signature (value =(TV;I)V )
public void set(
java.lang.Object
int)
@dalvik.annotation.Signature (value =(TV;TV;II)Z )
public boolean weakCompareAndSet(
java.lang.Object
java.lang.Object
int
int)

________________CLASS________________


final class java.util.concurrent.atomic.UnsafeAccess extends java.lang.Object

----------------FIELDS----------------

static final sun.misc.Unsafe THE_ONE
----------------METHODS----------------

static void <clinit>()

private void <init>()

________________CLASS________________


public abstract interface class java.util.concurrent.locks.Condition extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public abstract void await()
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public abstract boolean await(
long
java.util.concurrent.TimeUnit)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public abstract long awaitNanos(
long)

public abstract void awaitUninterruptibly()
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public abstract boolean awaitUntil(
java.util.Date)

public abstract void signal()

public abstract void signalAll()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/locks/AbstractQueuedSynchronizer; )
@dalvik.annotation.InnerClass (accessFlags =1 name =ConditionObject )
public class java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject extends java.lang.Object implements java.util.concurrent.locks.Condition, java.io.Serializable

----------------FIELDS----------------

private static final int REINTERRUPT

private static final int THROW_IE

private static final long serialVersionUID

private transient java.util.concurrent.locks.AbstractQueuedSynchronizer$Node firstWaiter

private transient java.util.concurrent.locks.AbstractQueuedSynchronizer$Node lastWaiter

final java.util.concurrent.locks.AbstractQueuedSynchronizer this$0
----------------METHODS----------------

public void <init>(
java.util.concurrent.locks.AbstractQueuedSynchronizer)

private java.util.concurrent.locks.AbstractQueuedSynchronizer$Node addConditionWaiter()

private int checkInterruptWhileWaiting(
java.util.concurrent.locks.AbstractQueuedSynchronizer$Node)

private void doSignal(
java.util.concurrent.locks.AbstractQueuedSynchronizer$Node)

private void doSignalAll(
java.util.concurrent.locks.AbstractQueuedSynchronizer$Node)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
private void reportInterruptAfterWait(
int)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public final void await()
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public final boolean await(
long
java.util.concurrent.TimeUnit)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public final long awaitNanos(
long)

public final void awaitUninterruptibly()
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public final boolean awaitUntil(
java.util.Date)

protected final int getWaitQueueLength()
@dalvik.annotation.Signature (value =()Ljava/util/Collection<Ljava/lang/Thread;>; )
protected final java.util.Collection getWaitingThreads()

protected final boolean hasWaiters()

final boolean isOwnedBy(
java.util.concurrent.locks.AbstractQueuedSynchronizer)

public final void signal()

public final void signalAll()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =24 name =Node )
@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/locks/AbstractQueuedSynchronizer; )
final class java.util.concurrent.locks.AbstractQueuedSynchronizer$Node extends java.lang.Object

----------------FIELDS----------------

static final int CANCELLED

static final int CONDITION

static final java.util.concurrent.locks.AbstractQueuedSynchronizer$Node EXCLUSIVE

static final java.util.concurrent.locks.AbstractQueuedSynchronizer$Node SHARED

static final int SIGNAL

volatile java.util.concurrent.locks.AbstractQueuedSynchronizer$Node next

 java.util.concurrent.locks.AbstractQueuedSynchronizer$Node nextWaiter

volatile java.util.concurrent.locks.AbstractQueuedSynchronizer$Node prev

volatile java.lang.Thread thread

volatile int waitStatus
----------------METHODS----------------

static void <clinit>()

 void <init>()

 void <init>(
java.lang.Thread
int)

 void <init>(
java.lang.Thread
java.util.concurrent.locks.AbstractQueuedSynchronizer$Node)

final boolean isShared()
@dalvik.annotation.Throws (value =Ljava/lang/NullPointerException; )
final java.util.concurrent.locks.AbstractQueuedSynchronizer$Node predecessor()

________________CLASS________________


public class java.util.concurrent.locks.LockSupport extends java.lang.Object

----------------FIELDS----------------

private static final sun.misc.Unsafe unsafe
----------------METHODS----------------

static void <clinit>()

private void <init>()

public static void park()

public static void parkNanos(
long)

public static void parkUntil(
long)

public static void unpark(
java.lang.Thread)

________________CLASS________________


public abstract interface class java.util.concurrent.locks.ReadWriteLock extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.util.concurrent.locks.Lock readLock()

public abstract java.util.concurrent.locks.Lock writeLock()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/locks/ReentrantLock; )
@dalvik.annotation.InnerClass (accessFlags =1032 name =Sync )
abstract class java.util.concurrent.locks.ReentrantLock$Sync extends java.util.concurrent.locks.AbstractQueuedSynchronizer

----------------FIELDS----------------

transient java.lang.Thread owner
----------------METHODS----------------

 void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)

final int getHoldCount()

final java.lang.Thread getOwner()

protected final boolean isHeldExclusively()

final boolean isLocked()

abstract void lock()

final java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject newCondition()

final boolean nonfairTryAcquire(
int)

protected final boolean tryRelease(
int)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/locks/ReentrantLock; )
@dalvik.annotation.InnerClass (accessFlags =24 name =FairSync )
final class java.util.concurrent.locks.ReentrantLock$FairSync extends java.util.concurrent.locks.ReentrantLock$Sync

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

final void lock()

protected final boolean tryAcquire(
int)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =24 name =NonfairSync )
@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/locks/ReentrantLock; )
final class java.util.concurrent.locks.ReentrantLock$NonfairSync extends java.util.concurrent.locks.ReentrantLock$Sync

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

final void lock()

protected final boolean tryAcquire(
int)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =1032 name =Sync )
@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/locks/ReentrantReadWriteLock; )
abstract class java.util.concurrent.locks.ReentrantReadWriteLock$Sync extends java.util.concurrent.locks.AbstractQueuedSynchronizer

----------------FIELDS----------------

transient java.lang.Thread owner
----------------METHODS----------------

 void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)

final int getCount()

final java.lang.Thread getOwner()

final int getReadLockCount()

final int getWriteHoldCount()

protected final boolean isHeldExclusively()

final boolean isWriteLocked()

final java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject newCondition()

final boolean nonfairTryAcquire(
int)

final int nonfairTryAcquireShared(
int)

protected final boolean tryRelease(
int)

protected final boolean tryReleaseShared(
int)

abstract void wlock()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =24 name =FairSync )
@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/locks/ReentrantReadWriteLock; )
final class java.util.concurrent.locks.ReentrantReadWriteLock$FairSync extends java.util.concurrent.locks.ReentrantReadWriteLock$Sync

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

protected final boolean tryAcquire(
int)

protected final int tryAcquireShared(
int)

final void wlock()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/locks/ReentrantReadWriteLock; )
@dalvik.annotation.InnerClass (accessFlags =24 name =NonfairSync )
final class java.util.concurrent.locks.ReentrantReadWriteLock$NonfairSync extends java.util.concurrent.locks.ReentrantReadWriteLock$Sync

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

protected final boolean tryAcquire(
int)

protected final int tryAcquireShared(
int)

final void wlock()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/locks/ReentrantReadWriteLock; )
@dalvik.annotation.InnerClass (accessFlags =9 name =ReadLock )
public class java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock extends java.lang.Object implements java.util.concurrent.locks.Lock, java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

private final java.util.concurrent.locks.ReentrantReadWriteLock$Sync sync
----------------METHODS----------------

protected void <init>(
java.util.concurrent.locks.ReentrantReadWriteLock)

public void lock()
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public void lockInterruptibly()

public java.util.concurrent.locks.Condition newCondition()

public java.lang.String toString()

public boolean tryLock()
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public boolean tryLock(
long
java.util.concurrent.TimeUnit)

public void unlock()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/concurrent/locks/ReentrantReadWriteLock; )
@dalvik.annotation.InnerClass (accessFlags =9 name =WriteLock )
public class java.util.concurrent.locks.ReentrantReadWriteLock$WriteLock extends java.lang.Object implements java.util.concurrent.locks.Lock, java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

private final java.util.concurrent.locks.ReentrantReadWriteLock$Sync sync
----------------METHODS----------------

protected void <init>(
java.util.concurrent.locks.ReentrantReadWriteLock)

public void lock()
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public void lockInterruptibly()

public java.util.concurrent.locks.Condition newCondition()

public java.lang.String toString()

public boolean tryLock()
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
public boolean tryLock(
long
java.util.concurrent.TimeUnit)

public void unlock()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/concurrent/locks/ReentrantReadWriteLock$WriteLock;Ljava/util/concurrent/locks/ReentrantReadWriteLock$ReadLock;Ljava/util/concurrent/locks/ReentrantReadWriteLock$FairSync;Ljava/util/concurrent/locks/ReentrantReadWriteLock$NonfairSync;Ljava/util/concurrent/locks/ReentrantReadWriteLock$Sync; )
public class java.util.concurrent.locks.ReentrantReadWriteLock extends java.lang.Object implements java.util.concurrent.locks.ReadWriteLock, java.io.Serializable

----------------FIELDS----------------

static final int EXCLUSIVE_MASK

static final int SHARED_SHIFT

static final int SHARED_UNIT

private static final long serialVersionUID

private final java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock readerLock

private final java.util.concurrent.locks.ReentrantReadWriteLock$Sync sync

private final java.util.concurrent.locks.ReentrantReadWriteLock$WriteLock writerLock
----------------METHODS----------------

public void <init>()

public void <init>(
boolean)

static java.util.concurrent.locks.ReentrantReadWriteLock$Sync access$000(
java.util.concurrent.locks.ReentrantReadWriteLock)

static int exclusiveCount(
int)

static int sharedCount(
int)

protected java.lang.Thread getOwner()

public final int getQueueLength()
@dalvik.annotation.Signature (value =()Ljava/util/Collection<Ljava/lang/Thread;>; )
protected java.util.Collection getQueuedReaderThreads()
@dalvik.annotation.Signature (value =()Ljava/util/Collection<Ljava/lang/Thread;>; )
protected java.util.Collection getQueuedThreads()
@dalvik.annotation.Signature (value =()Ljava/util/Collection<Ljava/lang/Thread;>; )
protected java.util.Collection getQueuedWriterThreads()

public int getReadLockCount()

public int getWaitQueueLength(
java.util.concurrent.locks.Condition)
@dalvik.annotation.Signature (value =(Ljava/util/concurrent/locks/Condition;)Ljava/util/Collection<Ljava/lang/Thread;>; )
protected java.util.Collection getWaitingThreads(
java.util.concurrent.locks.Condition)

public int getWriteHoldCount()

public final boolean hasQueuedThread(
java.lang.Thread)

public final boolean hasQueuedThreads()

public boolean hasWaiters(
java.util.concurrent.locks.Condition)

public final boolean isFair()

public boolean isWriteLocked()

public boolean isWriteLockedByCurrentThread()

public volatile java.util.concurrent.locks.Lock readLock()

public java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock readLock()

public java.lang.String toString()

public volatile java.util.concurrent.locks.Lock writeLock()

public java.util.concurrent.locks.ReentrantReadWriteLock$WriteLock writeLock()

________________CLASS________________


final class java.util.concurrent.locks.UnsafeAccess extends java.lang.Object

----------------FIELDS----------------

static final sun.misc.Unsafe THE_ONE
----------------METHODS----------------

static void <clinit>()

private void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/jar/Attributes; )
@dalvik.annotation.InnerClass (accessFlags =9 name =Name )
public class java.util.jar.Attributes$Name extends java.lang.Object

----------------FIELDS----------------

public static final java.util.jar.Attributes$Name CLASS_PATH

public static final java.util.jar.Attributes$Name CONTENT_TYPE

public static final java.util.jar.Attributes$Name EXTENSION_INSTALLATION

public static final java.util.jar.Attributes$Name EXTENSION_LIST

public static final java.util.jar.Attributes$Name EXTENSION_NAME

public static final java.util.jar.Attributes$Name IMPLEMENTATION_TITLE

public static final java.util.jar.Attributes$Name IMPLEMENTATION_URL

public static final java.util.jar.Attributes$Name IMPLEMENTATION_VENDOR

public static final java.util.jar.Attributes$Name IMPLEMENTATION_VENDOR_ID

public static final java.util.jar.Attributes$Name IMPLEMENTATION_VERSION

public static final java.util.jar.Attributes$Name MAIN_CLASS

public static final java.util.jar.Attributes$Name MANIFEST_VERSION

public static final java.util.jar.Attributes$Name SEALED

public static final java.util.jar.Attributes$Name SIGNATURE_VERSION

public static final java.util.jar.Attributes$Name SPECIFICATION_TITLE

public static final java.util.jar.Attributes$Name SPECIFICATION_VENDOR

public static final java.util.jar.Attributes$Name SPECIFICATION_VERSION

private int hashCode

private final java.lang.String name
----------------METHODS----------------

static void <clinit>()

public void <init>(
java.lang.String)

public boolean equals(
java.lang.Object)

public int hashCode()

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/lang/Cloneable;Ljava/util/Map<Ljava/lang/Object;Ljava/lang/Object;>; )
@dalvik.annotation.MemberClasses (value =Ljava/util/jar/Attributes$Name; )
public class java.util.jar.Attributes extends java.lang.Object implements java.lang.Cloneable, java.util.Map

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Map<Ljava/lang/Object;Ljava/lang/Object;>; )
protected java.util.Map map
----------------METHODS----------------

public void <init>()

public void <init>(
int)

public void <init>(
java.util.jar.Attributes)

public void clear()

public java.lang.Object clone()

public boolean containsKey(
java.lang.Object)

public boolean containsValue(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/util/Map$Entry<Ljava/lang/Object;Ljava/lang/Object;>;>; )
public java.util.Set entrySet()

public boolean equals(
java.lang.Object)

public java.lang.Object get(
java.lang.Object)

public java.lang.String getValue(
java.lang.String)

public java.lang.String getValue(
java.util.jar.Attributes$Name)

public int hashCode()

public boolean isEmpty()
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/lang/Object;>; )
public java.util.Set keySet()

public java.lang.Object put(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Map<**>;)V )
public void putAll(
java.util.Map)

public java.lang.String putValue(
java.lang.String
java.lang.String)

public java.lang.Object remove(
java.lang.Object)

public int size()
@dalvik.annotation.Signature (value =()Ljava/util/Collection<Ljava/lang/Object;>; )
public java.util.Collection values()

________________CLASS________________


 class java.util.jar.InitManifest extends java.lang.Object

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Map<Ljava/lang/String;Ljava/util/jar/Attributes$Name;>; )
private final java.util.Map attributeNames

private byte[] buffer

private char[] charbuf

private java.lang.String encoding

private final byte[] inbuf

private int inbufCount

private int inbufPos

private final byte[] mainAttributesChunk

private final java.io.ByteArrayOutputStream out

private boolean usingUTF8
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
@dalvik.annotation.Signature (value =(Ljava/io/InputStream;Ljava/util/jar/Attributes;Ljava/util/Map<Ljava/lang/String;Ljava/util/jar/Attributes;>;Ljava/util/Map<Ljava/lang/String;[B>;Ljava/lang/String;)V )
 void <init>(
java.io.InputStream
java.util.jar.Attributes
java.util.Map
java.util.Map
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void addAttribute(
java.lang.String
java.util.jar.Attributes)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
@dalvik.annotation.Signature (value =(ILjava/util/List<Ljava/lang/String;>;)V )
private void addLine(
int
java.util.List)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
@dalvik.annotation.Signature (value =(Ljava/io/InputStream;Ljava/util/List<Ljava/lang/String;>;)[B )
private byte[] nextChunk(
java.io.InputStream
java.util.List)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
@dalvik.annotation.Signature (value =(Ljava/io/InputStream;Ljava/util/List<Ljava/lang/String;>;)Z )
private boolean readLines(
java.io.InputStream
java.util.List)

 byte[] getMainAttributesChunk()

________________CLASS________________


abstract interface class java.util.zip.ZipConstants extends java.lang.Object

----------------FIELDS----------------

public static final int CENATT

public static final int CENATX

public static final int CENCOM

public static final int CENCRC

public static final int CENDSK

public static final int CENEXT

public static final int CENFLG

public static final int CENHDR

public static final int CENHOW

public static final int CENLEN

public static final int CENNAM

public static final int CENOFF

public static final long CENSIG

public static final int CENSIZ

public static final int CENTIM

public static final int CENVEM

public static final int CENVER

public static final int ENDCOM

public static final int ENDHDR

public static final int ENDOFF

public static final long ENDSIG

public static final int ENDSIZ

public static final int ENDSUB

public static final int ENDTOT

public static final int EXTCRC

public static final int EXTHDR

public static final int EXTLEN

public static final long EXTSIG

public static final int EXTSIZ

public static final int LOCCRC

public static final int LOCEXT

public static final int LOCFLG

public static final int LOCHDR

public static final int LOCHOW

public static final int LOCLEN

public static final int LOCNAM

public static final long LOCSIG

public static final int LOCSIZ

public static final int LOCTIM

public static final int LOCVER
----------------METHODS----------------

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/zip/ZipEntry$LittleEndianReader; )
public class java.util.zip.ZipEntry extends java.lang.Object implements java.util.zip.ZipConstants, java.lang.Cloneable

----------------FIELDS----------------

public static final int DEFLATED

public static final int STORED

static final int USES_DATA_DESCR

 java.lang.String comment

 int commentLen

 long compressedSize

 int compressionMethod

 long crc

 byte[] extra

 int extraLen

private int mDiskNumberStart

private long mExternalAttrs

private int mGPBitFlag

private int mInternalAttrs

 long mLocalHeaderRelOffset

private int mVersionMadeBy

private int mVersionToExtract

 int modDate

 java.lang.String name

 int nameLen

 long size

 int time
----------------METHODS----------------

public void <init>(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void <init>(
java.util.zip.ZipEntry$LittleEndianReader
java.io.InputStream)

public void <init>(
java.util.zip.ZipEntry)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void myReadFully(
java.io.InputStream
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
static long readIntLE(
java.io.RandomAccessFile)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
static int readShortLE(
java.io.RandomAccessFile)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
static void writeIntLE(
java.io.OutputStream
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
static void writeShortLE(
java.io.OutputStream
int)

public java.lang.Object clone()

public java.lang.String getComment()

public long getCompressedSize()

public long getCrc()

public byte[] getExtra()

 int getGPBitFlag()

 long getLocalHeaderRelOffset()

public int getMethod()

public java.lang.String getName()

public long getSize()

public long getTime()

public int hashCode()

public boolean isDirectory()

public void setComment(
java.lang.String)

public void setCompressedSize(
long)

public void setCrc(
long)

 void setDateTime(
int
int)

public void setExtra(
byte[])

 void setGPBitFlag(
int)

 void setLocalHeaderRelOffset(
long)

public void setMethod(
int)

public void setSize(
long)

public void setTime(
long)

 void setVersionToExtract(
int)

public java.lang.String toString()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 int writeCDE(
java.io.OutputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 int writeDD(
java.io.OutputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 int writeLFH(
java.io.OutputStream)

________________CLASS________________


public class java.util.jar.JarEntry extends java.util.zip.ZipEntry

----------------FIELDS----------------

private java.util.jar.Attributes attributes

private java.security.cert.CertificateFactory factory

private boolean isFactoryChecked

 java.util.jar.JarFile parentJar

 java.security.CodeSigner[] signers
----------------METHODS----------------

public void <init>(
java.lang.String)

public void <init>(
java.util.jar.JarEntry)

public void <init>(
java.util.zip.ZipEntry)
@dalvik.annotation.Signature (value =(Ljava/util/ArrayList<Ljava/security/CodeSigner;>;Ljava/util/List<Ljava/security/cert/Certificate;>;)V )
private void addCodeSigner(
java.util.ArrayList
java.util.List)

private java.security.CodeSigner[] getCodeSigners(
java.security.cert.Certificate[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.util.jar.Attributes getAttributes()

public java.security.cert.Certificate[] getCertificates()

public java.security.CodeSigner[] getCodeSigners()

 void setAttributes(
java.util.jar.Attributes)

________________CLASS________________


public class java.util.zip.ZipException extends java.io.IOException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class java.util.jar.JarException extends java.util.zip.ZipException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Enumeration<Ljava/util/jar/JarEntry;>; )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =0 name =JarFileEnumerator )
 class java.util.jar.JarFile$1JarFileEnumerator extends java.lang.Object implements java.util.Enumeration

----------------FIELDS----------------

 java.util.jar.JarFile jf

final java.util.jar.JarFile this$0
@dalvik.annotation.Signature (value =Ljava/util/Enumeration<+Ljava/util/zip/ZipEntry;>; )
 java.util.Enumeration ze
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/Enumeration<+Ljava/util/zip/ZipEntry;>;Ljava/util/jar/JarFile;)V )
 void <init>(
java.util.jar.JarFile
java.util.Enumeration
java.util.jar.JarFile)

public boolean hasMoreElements()

public volatile java.lang.Object nextElement()

public java.util.jar.JarEntry nextElement()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =24 name =JarFileInputStream )
@dalvik.annotation.EnclosingClass (value =Ljava/util/jar/JarFile; )
final class java.util.jar.JarFile$JarFileInputStream extends java.io.FilterInputStream

----------------FIELDS----------------

private long count

private java.security.MessageDigest digest

private java.util.jar.JarVerifier$VerifierEntry entry

private java.util.jar.JarVerifier verifier

private java.util.zip.ZipEntry zipEntry
----------------METHODS----------------

 void <init>(
java.io.InputStream
java.util.zip.ZipEntry
java.util.jar.JarVerifier)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long skip(
long)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/zip/ZipFile$RAFStream; )
public class java.util.zip.ZipFile extends java.lang.Object implements java.util.zip.ZipConstants

----------------FIELDS----------------

public static final int OPEN_DELETE

public static final int OPEN_READ

 java.lang.String fileName

 java.io.File fileToDeleteOnClose

 java.util.zip.ZipEntry$LittleEndianReader ler
@dalvik.annotation.Signature (value =Ljava/util/ArrayList<Ljava/util/zip/ZipEntry;>; )
private java.util.ArrayList mEntryList
@dalvik.annotation.Signature (value =Ljava/util/HashMap<Ljava/lang/String;Ljava/util/zip/ZipEntry;>; )
private java.util.HashMap mFastLookup

private java.io.RandomAccessFile mRaf
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/util/zip/ZipException;Ljava/io/IOException; )
public void <init>(
java.io.File)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.io.File
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.lang.String)

static java.io.RandomAccessFile access$000(
java.util.zip.ZipFile)

static java.util.ArrayList access$100(
java.util.zip.ZipFile)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void readCentralDir()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<+Ljava/util/zip/ZipEntry;>; )
public java.util.Enumeration entries()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void finalize()

public java.util.zip.ZipEntry getEntry(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.io.InputStream getInputStream(
java.util.zip.ZipEntry)

public java.lang.String getName()

public int size()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/jar/JarFile$JarFileInputStream; )
public class java.util.jar.JarFile extends java.util.zip.ZipFile

----------------FIELDS----------------

public static final java.lang.String MANIFEST_NAME

static final java.lang.String META_DIR

private boolean closed

private java.util.jar.Manifest manifest

private java.util.zip.ZipEntry manifestEntry

 java.util.jar.JarVerifier verifier
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.io.File)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.io.File
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.io.File
boolean
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.lang.String
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private byte[] getAllBytesFromStreamAndClose(
java.io.InputStream)

private java.util.zip.ZipEntry[] getMetaEntriesImpl(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void readMetaEntries()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<Ljava/util/jar/JarEntry;>; )
public java.util.Enumeration entries()

public java.util.zip.ZipEntry getEntry(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.io.InputStream getInputStream(
java.util.zip.ZipEntry)

public java.util.jar.JarEntry getJarEntry(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.util.jar.Manifest getManifest()

________________CLASS________________


public class java.util.zip.InflaterInputStream extends java.io.FilterInputStream

----------------FIELDS----------------

static final int BUF_SIZE

protected byte[] buf

 boolean closed

 boolean eof

protected java.util.zip.Inflater inf

protected int len

 int nativeEndBufSize
----------------METHODS----------------

public void <init>(
java.io.InputStream)

public void <init>(
java.io.InputStream
java.util.zip.Inflater)

public void <init>(
java.io.InputStream
java.util.zip.Inflater
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int available()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void fill()

public void mark(
int)

public boolean markSupported()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void reset()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long skip(
long)

________________CLASS________________


public class java.util.zip.ZipInputStream extends java.util.zip.InflaterInputStream implements java.util.zip.ZipConstants

----------------FIELDS----------------

static final int DEFLATED

static final int STORED

static final int ZIPDataDescriptorFlag

static final int ZIPLocalHeaderVersionNeeded

private char[] charBuf

private final java.util.zip.CRC32 crc

 java.util.zip.ZipEntry currentEntry

private boolean entriesEnd

private int entryIn

private boolean hasDD

private final byte[] hdrBuf

private int inRead

private int lastRead

private byte[] nameBuf

private boolean zipClosed
----------------METHODS----------------

public void <init>(
java.io.InputStream)

private long getLong(
byte[]
int)

private int getShort(
byte[]
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int available()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void closeEntry()

protected java.util.zip.ZipEntry createZipEntry(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.util.zip.ZipEntry getNextEntry()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long skip(
long)

________________CLASS________________


public class java.util.jar.JarInputStream extends java.util.zip.ZipInputStream

----------------FIELDS----------------

private boolean eos

private boolean isMeta

private java.util.jar.JarEntry jarEntry

private java.util.jar.JarEntry mEntry

private java.util.jar.Manifest manifest

private java.io.OutputStream verStream

private java.util.jar.JarVerifier verifier
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.io.InputStream
boolean)

protected java.util.zip.ZipEntry createZipEntry(
java.lang.String)

public java.util.jar.Manifest getManifest()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.util.zip.ZipEntry getNextEntry()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.util.jar.JarEntry getNextJarEntry()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[]
int
int)

________________CLASS________________


public class java.util.zip.DeflaterOutputStream extends java.io.FilterOutputStream

----------------FIELDS----------------

static final int BUF_SIZE

protected byte[] buf

protected java.util.zip.Deflater def

 boolean done
----------------METHODS----------------

public void <init>(
java.io.OutputStream)

public void <init>(
java.io.OutputStream
java.util.zip.Deflater)

public void <init>(
java.io.OutputStream
java.util.zip.Deflater
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void deflate()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void finish()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
byte[]
int
int)

________________CLASS________________


public class java.util.zip.ZipOutputStream extends java.util.zip.DeflaterOutputStream implements java.util.zip.ZipConstants

----------------FIELDS----------------

public static final int DEFLATED

public static final int STORED

static final int ZIPDataDescriptorFlag

static final int ZIPLocalHeaderVersionNeeded

private java.io.ByteArrayOutputStream cDir

private java.lang.String comment

private int compressLevel

private int compressMethod

private final java.util.zip.CRC32 crc

private int curOffset

private java.util.zip.ZipEntry currentEntry
@dalvik.annotation.Signature (value =Ljava/util/Vector<Ljava/lang/String;>; )
private final java.util.Vector entries

private byte[] nameBytes

private int nameLength

private int offset
----------------METHODS----------------

public void <init>(
java.io.OutputStream)

static byte[] toUTF8Bytes(
java.lang.String
int)

static int utf8Count(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private long writeLong(
java.io.OutputStream
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private int writeShort(
java.io.OutputStream
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void closeEntry()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void finish()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void putNextEntry(
java.util.zip.ZipEntry)

public void setComment(
java.lang.String)

public void setLevel(
int)

public void setMethod(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
byte[]
int
int)

________________CLASS________________


public class java.util.jar.JarOutputStream extends java.util.zip.ZipOutputStream

----------------FIELDS----------------

private java.util.jar.Manifest manifest
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.io.OutputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.io.OutputStream
java.util.jar.Manifest)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void putNextEntry(
java.util.zip.ZipEntry)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/jar/JarVerifier; )
@dalvik.annotation.InnerClass (accessFlags =8 name =VerifierEntry )
 class java.util.jar.JarVerifier$VerifierEntry extends java.io.OutputStream

----------------FIELDS----------------

 java.security.cert.Certificate[] certificates

 java.security.MessageDigest digest

 byte[] hash
----------------METHODS----------------

 void <init>(
java.security.MessageDigest
byte[]
java.security.cert.Certificate[])

public void write(
int)

public void write(
byte[]
int
int)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/jar/JarVerifier$VerifierEntry; )
 class java.util.jar.JarVerifier extends java.lang.Object

----------------FIELDS----------------

private static long averageTime

private static long measureCount
@dalvik.annotation.Signature (value =Ljava/util/Hashtable<Ljava/lang/String;[Ljava/security/cert/Certificate;>; )
private final java.util.Hashtable certificates

private final java.lang.String jarName

 byte[] mainAttributesChunk

private java.util.jar.Manifest man
@dalvik.annotation.Signature (value =Ljava/util/HashMap<Ljava/lang/String;[B>; )
private java.util.HashMap metaEntries
@dalvik.annotation.Signature (value =Ljava/util/Hashtable<Ljava/lang/String;Ljava/util/HashMap<Ljava/lang/String;Ljava/util/jar/Attributes;>;>; )
private final java.util.Hashtable signatures
@dalvik.annotation.Signature (value =Ljava/util/Hashtable<Ljava/lang/String;[Ljava/security/cert/Certificate;>; )
private final java.util.Hashtable verifiedEntries
----------------METHODS----------------

static void <clinit>()

 void <init>(
java.lang.String)
@dalvik.annotation.Signature (value =(Ljava/lang/String;Ljava/util/Map<Ljava/lang/String;[Ljava/security/cert/Certificate;>;)Ljava/util/Vector<Ljava/security/cert/Certificate;>; )
public static java.util.Vector getSignerCertificates(
java.lang.String
java.util.Map)

private static void log(
java.lang.String
java.lang.String)

private boolean verify(
java.util.jar.Attributes
java.lang.String
byte[]
boolean
boolean)

private void verifyCertificate(
java.lang.String)

 void addMetaEntry(
java.lang.String
byte[])

 java.security.cert.Certificate[] getCertificates(
java.lang.String)

 java.util.jar.JarVerifier$VerifierEntry initEntry(
java.lang.String)

 boolean isSignedJar()

 boolean readCertificates()

 void removeMetaEntries()

 void setManifest(
java.util.jar.Manifest)

 void verifySignatures(
java.util.jar.JarVerifier$VerifierEntry
java.util.zip.ZipEntry)

________________CLASS________________


public class java.util.jar.Manifest extends java.lang.Object implements java.lang.Cloneable

----------------FIELDS----------------

private static final int LINE_LENGTH_LIMIT

private static final byte[] LINE_SEPARATOR

private static final java.util.jar.Attributes$Name NAME_ATTRIBUTE
@dalvik.annotation.Signature (value =Ljava/util/HashMap<Ljava/lang/String;[B>; )
private java.util.HashMap chunks
@dalvik.annotation.Signature (value =Ljava/util/HashMap<Ljava/lang/String;Ljava/util/jar/Attributes;>; )
private java.util.HashMap entryAttributes

private java.util.jar.Attributes mainAttributes

private byte[] mainAttributesChunk
----------------METHODS----------------

static void <clinit>()

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void <init>(
java.io.InputStream
boolean)

public void <init>(
java.util.jar.Manifest)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
static void write(
java.util.jar.Manifest
java.io.OutputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private static void writeEntry(
java.io.OutputStream
java.nio.charset.Charset
java.util.jar.Attributes$Name
java.lang.String)

public void clear()

public java.lang.Object clone()

public boolean equals(
java.lang.Object)

public java.util.jar.Attributes getAttributes(
java.lang.String)

 byte[] getChunk(
java.lang.String)
@dalvik.annotation.Signature (value =()Ljava/util/Map<Ljava/lang/String;Ljava/util/jar/Attributes;>; )
public java.util.Map getEntries()

public java.util.jar.Attributes getMainAttributes()

 byte[] getMainAttributesChunk()

public int hashCode()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void read(
java.io.InputStream)

 void removeChunks()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
java.io.OutputStream)

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/Object;>; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
final class java.util.jar.Pack200$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public java.lang.Object run()

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/Object;>; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class java.util.jar.Pack200$2 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public java.lang.Object run()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =1545 name =Packer )
@dalvik.annotation.EnclosingClass (value =Ljava/util/jar/Pack200; )
public abstract interface class java.util.jar.Pack200$Packer extends java.lang.Object

----------------FIELDS----------------

public static final java.lang.String CLASS_ATTRIBUTE_PFX

public static final java.lang.String CODE_ATTRIBUTE_PFX

public static final java.lang.String DEFLATE_HINT

public static final java.lang.String EFFORT

public static final java.lang.String ERROR

public static final java.lang.String FALSE

public static final java.lang.String FIELD_ATTRIBUTE_PFX

public static final java.lang.String KEEP

public static final java.lang.String KEEP_FILE_ORDER

public static final java.lang.String LATEST

public static final java.lang.String METHOD_ATTRIBUTE_PFX

public static final java.lang.String MODIFICATION_TIME

public static final java.lang.String PASS

public static final java.lang.String PASS_FILE_PFX

public static final java.lang.String PROGRESS

public static final java.lang.String SEGMENT_LIMIT

public static final java.lang.String STRIP

public static final java.lang.String TRUE

public static final java.lang.String UNKNOWN_ATTRIBUTE
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void pack(
java.util.jar.JarFile
java.io.OutputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void pack(
java.util.jar.JarInputStream
java.io.OutputStream)
@dalvik.annotation.Signature (value =()Ljava/util/SortedMap<Ljava/lang/String;Ljava/lang/String;>; )
public abstract java.util.SortedMap properties()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/jar/Pack200; )
@dalvik.annotation.InnerClass (accessFlags =1545 name =Unpacker )
public abstract interface class java.util.jar.Pack200$Unpacker extends java.lang.Object

----------------FIELDS----------------

public static final java.lang.String DEFLATE_HINT

public static final java.lang.String FALSE

public static final java.lang.String KEEP

public static final java.lang.String PROGRESS

public static final java.lang.String TRUE
----------------METHODS----------------
@dalvik.annotation.Signature (value =()Ljava/util/SortedMap<Ljava/lang/String;Ljava/lang/String;>; )
public abstract java.util.SortedMap properties()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void unpack(
java.io.File
java.util.jar.JarOutputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void unpack(
java.io.InputStream
java.util.jar.JarOutputStream)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/jar/Pack200$Unpacker;Ljava/util/jar/Pack200$Packer; )
public abstract class java.util.jar.Pack200 extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.String SYSTEM_PROPERTY_PACKER

private static final java.lang.String SYSTEM_PROPERTY_UNPACKER
----------------METHODS----------------

private void <init>()

public static java.util.jar.Pack200$Packer newPacker()

public static java.util.jar.Pack200$Unpacker newUnpacker()

________________CLASS________________


public abstract class java.util.logging.Handler extends java.lang.Object

----------------FIELDS----------------

private static final java.util.logging.Level DEFAULT_LEVEL

private java.lang.String encoding

private java.util.logging.ErrorManager errorMan

private java.util.logging.Filter filter

private java.util.logging.Formatter formatter

private java.util.logging.Level level

private java.lang.String prefix
----------------METHODS----------------

static void <clinit>()

protected void <init>()
@dalvik.annotation.Throws (value =Ljava/lang/Exception; )
private java.lang.Object getCustomizeInstance(
java.lang.String)

private java.lang.Object getDefaultInstance(
java.lang.String)

public abstract void close()

public abstract void flush()

public java.lang.String getEncoding()

public java.util.logging.ErrorManager getErrorManager()

public java.util.logging.Filter getFilter()

public java.util.logging.Formatter getFormatter()

public java.util.logging.Level getLevel()

 void initProperties(
java.lang.String
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/UnsupportedEncodingException; )
 void internalSetEncoding(
java.lang.String)

 void internalSetFormatter(
java.util.logging.Formatter)

public boolean isLoggable(
java.util.logging.LogRecord)

 void printInvalidPropMessage(
java.lang.String
java.lang.String
java.lang.Exception)

public abstract void publish(
java.util.logging.LogRecord)

protected void reportError(
java.lang.String
java.lang.Exception
int)
@dalvik.annotation.Throws (value =Ljava/lang/SecurityException;Ljava/io/UnsupportedEncodingException; )
public void setEncoding(
java.lang.String)

public void setErrorManager(
java.util.logging.ErrorManager)

public void setFilter(
java.util.logging.Filter)

public void setFormatter(
java.util.logging.Formatter)

public void setLevel(
java.util.logging.Level)

________________CLASS________________


public class java.util.logging.StreamHandler extends java.util.logging.Handler

----------------FIELDS----------------

private java.io.OutputStream os

private java.io.Writer writer

private boolean writerNotInitialized
----------------METHODS----------------

public void <init>()

 void <init>(
java.io.OutputStream)

public void <init>(
java.io.OutputStream
java.util.logging.Formatter)

 void <init>(
java.lang.String
java.lang.String
java.lang.String
java.lang.String)

private void initializeWritter()

private void write(
java.lang.String)

public void close()

 void close(
boolean)

public void flush()

 void internalSetOutputStream(
java.io.OutputStream)

public boolean isLoggable(
java.util.logging.LogRecord)

public void publish(
java.util.logging.LogRecord)
@dalvik.annotation.Throws (value =Ljava/lang/SecurityException;Ljava/io/UnsupportedEncodingException; )
public void setEncoding(
java.lang.String)

protected void setOutputStream(
java.io.OutputStream)

________________CLASS________________


public class java.util.logging.ConsoleHandler extends java.util.logging.StreamHandler

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public void close()

public void publish(
java.util.logging.LogRecord)

________________CLASS________________


public class java.util.logging.ErrorManager extends java.lang.Object

----------------FIELDS----------------

public static final int CLOSE_FAILURE

private static final java.lang.String[] FAILURES

public static final int FLUSH_FAILURE

public static final int FORMAT_FAILURE

public static final int GENERIC_FAILURE

public static final int OPEN_FAILURE

public static final int WRITE_FAILURE

private boolean called
----------------METHODS----------------

static void <clinit>()

public void <init>()

public void error(
java.lang.String
java.lang.Exception
int)

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/Object;>; )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
 class java.util.logging.FileHandler$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final java.util.logging.FileHandler this$0
----------------METHODS----------------

 void <init>(
java.util.logging.FileHandler)

public java.lang.Object run()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =MeasureOutputStream )
@dalvik.annotation.EnclosingClass (value =Ljava/util/logging/FileHandler; )
 class java.util.logging.FileHandler$MeasureOutputStream extends java.io.OutputStream

----------------FIELDS----------------

 long length

 java.io.OutputStream wrapped
----------------METHODS----------------

public void <init>(
java.io.OutputStream)

public void <init>(
java.io.OutputStream
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void flush()

public long getLength()

public void setLength(
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
byte[]
int
int)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/logging/FileHandler$MeasureOutputStream; )
public class java.util.logging.FileHandler extends java.util.logging.StreamHandler

----------------FIELDS----------------

private static final boolean DEFAULT_APPEND

private static final int DEFAULT_COUNT

private static final int DEFAULT_LIMIT

private static final java.lang.String DEFAULT_PATTERN

private static final java.lang.String LCK_EXT
@dalvik.annotation.Signature (value =Ljava/util/Hashtable<Ljava/lang/String;Ljava/nio/channels/FileLock;>; )
private static final java.util.Hashtable allLocks

private boolean append

private int count

 java.lang.String fileName

private java.io.File[] files

private int limit

 java.nio.channels.FileLock lock

private java.util.logging.LogManager manager

private java.util.logging.FileHandler$MeasureOutputStream output

private java.lang.String pattern

 int uniqueID
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.lang.String
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.lang.String
int
int
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.lang.String
boolean)

private boolean getBooleanProperty(
java.lang.String
boolean)

private int getIntProperty(
java.lang.String
int)

private java.lang.String getStringProperty(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void init(
java.lang.String
java.lang.Boolean
java.lang.Integer
java.lang.Integer)
@dalvik.annotation.Throws (value =Ljava/io/FileNotFoundException;Ljava/io/IOException; )
private void initOutputFiles()

private void initProperties(
java.lang.String
java.lang.Boolean
java.lang.Integer
java.lang.Integer)

private java.lang.String parseFileName(
int)

public void close()

 void findNextGeneration()

public void publish(
java.util.logging.LogRecord)

________________CLASS________________


public abstract interface class java.util.logging.Filter extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract boolean isLoggable(
java.util.logging.LogRecord)

________________CLASS________________


public abstract class java.util.logging.Formatter extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

protected void <init>()

public abstract java.lang.String format(
java.util.logging.LogRecord)

public java.lang.String formatMessage(
java.util.logging.LogRecord)

public java.lang.String getHead(
java.util.logging.Handler)

public java.lang.String getTail(
java.util.logging.Handler)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedExceptionAction<Ljava/lang/Class<*>;>; )
 class java.util.logging.Handler$1 extends java.lang.Object implements java.security.PrivilegedExceptionAction

----------------FIELDS----------------

final java.util.logging.Handler this$0

final java.lang.String val$className
----------------METHODS----------------

 void <init>(
java.util.logging.Handler
java.lang.String)
@dalvik.annotation.Signature (value =()Ljava/lang/Class<*>; )
@dalvik.annotation.Throws (value =Ljava/lang/Exception; )
public java.lang.Class run()
@dalvik.annotation.Throws (value =Ljava/lang/Exception; )
public volatile java.lang.Object run()

________________CLASS________________


public class java.util.logging.Level extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------

public static final java.util.logging.Level ALL

public static final java.util.logging.Level CONFIG

public static final java.util.logging.Level FINE

public static final java.util.logging.Level FINER

public static final java.util.logging.Level FINEST

public static final java.util.logging.Level INFO

public static final java.util.logging.Level OFF

public static final java.util.logging.Level SEVERE

public static final java.util.logging.Level WARNING
@dalvik.annotation.Signature (value =Ljava/util/List<Ljava/util/logging/Level;>; )
private static final java.util.List levels

private static final long serialVersionUID

private final java.lang.String name

private transient java.util.ResourceBundle rb

private final java.lang.String resourceBundleName

private final int value
----------------METHODS----------------

static void <clinit>()

protected void <init>(
java.lang.String
int)

protected void <init>(
java.lang.String
int
java.lang.String)

public static final java.util.logging.Level parse(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)

private java.lang.Object readResolve()

public boolean equals(
java.lang.Object)

public java.lang.String getLocalizedName()

public java.lang.String getName()

public java.lang.String getResourceBundleName()

public int hashCode()

public final int intValue()

public final java.lang.String toString()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/Object;>; )
@dalvik.annotation.EnclosingClass (value =Ljava/util/logging/LogManager; )
final class java.util.logging.LogManager$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public java.lang.Object run()

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
 class java.util.logging.LogManager$2$1 extends java.lang.Thread

----------------FIELDS----------------

final java.util.logging.LogManager$2 this$1
----------------METHODS----------------

 void <init>(
java.util.logging.LogManager$2)

public void run()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/Void;>; )
@dalvik.annotation.EnclosingMethod (value =null )
 class java.util.logging.LogManager$2 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final java.util.logging.LogManager this$0
----------------METHODS----------------

 void <init>(
java.util.logging.LogManager)

public volatile java.lang.Object run()

public java.lang.Void run()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/String;>; )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class java.util.logging.LogManager$3 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final java.lang.String val$key
----------------METHODS----------------

 void <init>(
java.lang.String)

public volatile java.lang.Object run()

public java.lang.String run()

________________CLASS________________


public class java.util.logging.LogManager extends java.lang.Object

----------------FIELDS----------------

public static final java.lang.String LOGGING_MXBEAN_NAME

private static final java.lang.String lineSeparator

static java.util.logging.LogManager manager

private static final java.util.logging.LoggingPermission perm
@dalvik.annotation.Signature (value =Ljava/util/Hashtable<Ljava/lang/String;Ljava/util/logging/Logger;>; )
private java.util.Hashtable loggers

private java.util.Properties props
----------------METHODS----------------

static void <clinit>()

protected void <init>()

private void addToFamilyTree(
java.util.logging.Logger
java.lang.String)

static java.lang.Object getInstanceByClass(
java.lang.String)

public static java.util.logging.LogManager getLogManager()

static java.lang.String getPrivilegedSystemProperty(
java.lang.String)

static java.lang.String getSystemLineSeparator()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void readConfigurationImpl(
java.io.InputStream)

public boolean addLogger(
java.util.logging.Logger)

public void checkAccess()

public java.util.logging.Logger getLogger(
java.lang.String)
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<Ljava/lang/String;>; )
public java.util.Enumeration getLoggerNames()

public java.lang.String getProperty(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void readConfiguration()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void readConfiguration(
java.io.InputStream)

public void reset()

________________CLASS________________


public class java.util.logging.LogRecord extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------

private static final int MAJOR

private static final int MINOR

private static long currentSequenceNumber
@dalvik.annotation.Signature (value =Ljava/lang/ThreadLocal<Ljava/lang/Integer;>; )
private static java.lang.ThreadLocal currentThreadId

private static int initThreadId

private static final long serialVersionUID

private java.util.logging.Level level

private java.lang.String loggerName

private java.lang.String message

private long millis

private transient java.lang.Object[] parameters

private transient java.util.ResourceBundle resourceBundle

private java.lang.String resourceBundleName

private long sequenceNumber

private java.lang.String sourceClassName

private transient boolean sourceInited

private java.lang.String sourceMethodName

private int threadID

private java.lang.Throwable thrown
----------------METHODS----------------

static void <clinit>()

public void <init>(
java.util.logging.Level
java.lang.String)

private void initSource()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

public java.util.logging.Level getLevel()

public java.lang.String getLoggerName()

public java.lang.String getMessage()

public long getMillis()

public java.lang.Object[] getParameters()

public java.util.ResourceBundle getResourceBundle()

public java.lang.String getResourceBundleName()

public long getSequenceNumber()

public java.lang.String getSourceClassName()

public java.lang.String getSourceMethodName()

public int getThreadID()

public java.lang.Throwable getThrown()

public void setLevel(
java.util.logging.Level)

public void setLoggerName(
java.lang.String)

public void setMessage(
java.lang.String)

public void setMillis(
long)

public void setParameters(
java.lang.Object[])

public void setResourceBundle(
java.util.ResourceBundle)

public void setResourceBundleName(
java.lang.String)

public void setSequenceNumber(
long)

public void setSourceClassName(
java.lang.String)

public void setSourceMethodName(
java.lang.String)

public void setThreadID(
int)

public void setThrown(
java.lang.Throwable)

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/ClassLoader;>; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class java.util.logging.Logger$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public java.lang.ClassLoader run()

public volatile java.lang.Object run()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/ClassLoader;>; )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class java.util.logging.Logger$2 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public java.lang.ClassLoader run()

public volatile java.lang.Object run()

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<[Ljava/lang/Class<*>;>; )
final class java.util.logging.Logger$3 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public volatile java.lang.Object run()
@dalvik.annotation.Signature (value =()[Ljava/lang/Class<*>; )
public java.lang.Class[] run()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/ClassLoader;>; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
final class java.util.logging.Logger$4 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final java.lang.Class[] val$classes

final int val$index
----------------METHODS----------------

 void <init>(
java.lang.Class[]
int)

public java.lang.ClassLoader run()

public volatile java.lang.Object run()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =PrivateSecurityManager )
@dalvik.annotation.EnclosingClass (value =Ljava/util/logging/Logger; )
 class java.util.logging.Logger$PrivateSecurityManager extends java.lang.SecurityManager

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()
@dalvik.annotation.Signature (value =()[Ljava/lang/Class<*>; )
public java.lang.Class[] privateGetClassContext()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/logging/Logger$PrivateSecurityManager; )
public class java.util.logging.Logger extends java.lang.Object

----------------FIELDS----------------

public static final java.util.logging.Logger global
@dalvik.annotation.Signature (value =Ljava/util/List<Ljava/util/logging/Logger;>; )
private java.util.List childs

private java.util.logging.Filter filter

private volatile boolean handlerInited
@dalvik.annotation.Signature (value =Ljava/util/List<Ljava/util/logging/Handler;>; )
private java.util.List handlers

private boolean isNamed

private volatile int levelIntVal

private volatile java.util.logging.Level levelObjVal

private java.util.logging.LogManager manager

private volatile java.lang.String name

private boolean notifyParentHandlers

private java.util.logging.Logger parent

private java.util.ResourceBundle resBundle

private java.lang.String resBundleName
----------------METHODS----------------

static void <clinit>()

protected void <init>(
java.lang.String
java.lang.String)

private void forceChildsToInherit()

public static java.util.logging.Logger getAnonymousLogger()

public static java.util.logging.Logger getAnonymousLogger(
java.lang.String)

public static java.util.logging.Logger getLogger(
java.lang.String)

public static java.util.logging.Logger getLogger(
java.lang.String
java.lang.String)

private static java.util.logging.Logger getLoggerWithRes(
java.lang.String
java.lang.String
boolean)

private void initHandler()

private boolean internalIsLoggable(
java.util.logging.Level)

static java.util.ResourceBundle loadResourceBundle(
java.lang.String)

private void setLevelImpl(
java.util.logging.Level)

private void setResourceBundle(
java.util.logging.LogRecord)

private static void updateResourceBundle(
java.util.logging.Logger
java.lang.String)

final void addChild(
java.util.logging.Logger)

public void addHandler(
java.util.logging.Handler)

public void config(
java.lang.String)

public void entering(
java.lang.String
java.lang.String)

public void entering(
java.lang.String
java.lang.String
java.lang.Object)

public void entering(
java.lang.String
java.lang.String
java.lang.Object[])

public void exiting(
java.lang.String
java.lang.String)

public void exiting(
java.lang.String
java.lang.String
java.lang.Object)

public void fine(
java.lang.String)

public void finer(
java.lang.String)

public void finest(
java.lang.String)

public java.util.logging.Filter getFilter()

public java.util.logging.Handler[] getHandlers()

public java.util.logging.Level getLevel()

public java.lang.String getName()

public java.util.logging.Logger getParent()

public java.util.ResourceBundle getResourceBundle()

public java.lang.String getResourceBundleName()

public boolean getUseParentHandlers()

public void info(
java.lang.String)

 void internalSetParent(
java.util.logging.Logger)

public boolean isLoggable(
java.util.logging.Level)

public void log(
java.util.logging.Level
java.lang.String)

public void log(
java.util.logging.Level
java.lang.String
java.lang.Object)

public void log(
java.util.logging.Level
java.lang.String
java.lang.Throwable)

public void log(
java.util.logging.Level
java.lang.String
java.lang.Object[])

public void log(
java.util.logging.LogRecord)

public void logp(
java.util.logging.Level
java.lang.String
java.lang.String
java.lang.String)

public void logp(
java.util.logging.Level
java.lang.String
java.lang.String
java.lang.String
java.lang.Object)

public void logp(
java.util.logging.Level
java.lang.String
java.lang.String
java.lang.String
java.lang.Throwable)

public void logp(
java.util.logging.Level
java.lang.String
java.lang.String
java.lang.String
java.lang.Object[])

public void logrb(
java.util.logging.Level
java.lang.String
java.lang.String
java.lang.String
java.lang.String)

public void logrb(
java.util.logging.Level
java.lang.String
java.lang.String
java.lang.String
java.lang.String
java.lang.Object)

public void logrb(
java.util.logging.Level
java.lang.String
java.lang.String
java.lang.String
java.lang.String
java.lang.Throwable)

public void logrb(
java.util.logging.Level
java.lang.String
java.lang.String
java.lang.String
java.lang.String
java.lang.Object[])

final void removeChild(
java.util.logging.Logger)

public void removeHandler(
java.util.logging.Handler)

 void reset()

public void setFilter(
java.util.logging.Filter)

public void setLevel(
java.util.logging.Level)

 void setManager(
java.util.logging.LogManager)

public void setParent(
java.util.logging.Logger)

public void setUseParentHandlers(
boolean)

public void severe(
java.lang.String)

public void throwing(
java.lang.String
java.lang.String
java.lang.Throwable)

public void warning(
java.lang.String)

________________CLASS________________


public abstract interface class java.util.logging.LoggingMXBean extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.lang.String getLoggerLevel(
java.lang.String)
@dalvik.annotation.Signature (value =()Ljava/util/List<Ljava/lang/String;>; )
public abstract java.util.List getLoggerNames()

public abstract java.lang.String getParentLoggerName(
java.lang.String)

public abstract void setLoggerLevel(
java.lang.String
java.lang.String)

________________CLASS________________


public final class java.util.logging.LoggingPermission extends java.security.BasicPermission implements java.security.Guard, java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>(
java.lang.String
java.lang.String)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedExceptionAction<Ljava/lang/Class<*>;>; )
 class java.util.logging.MemoryHandler$1 extends java.lang.Object implements java.security.PrivilegedExceptionAction

----------------FIELDS----------------

final java.util.logging.MemoryHandler this$0

final java.lang.String val$targetName
----------------METHODS----------------

 void <init>(
java.util.logging.MemoryHandler
java.lang.String)
@dalvik.annotation.Signature (value =()Ljava/lang/Class<*>; )
@dalvik.annotation.Throws (value =Ljava/lang/Exception; )
public java.lang.Class run()
@dalvik.annotation.Throws (value =Ljava/lang/Exception; )
public volatile java.lang.Object run()

________________CLASS________________


public class java.util.logging.MemoryHandler extends java.util.logging.Handler

----------------FIELDS----------------

private static final int DEFAULT_SIZE

private java.util.logging.LogRecord[] buffer

private int cursor

private final java.util.logging.LogManager manager

private java.util.logging.Level push

private int size

private java.util.logging.Handler target
----------------METHODS----------------

public void <init>()

public void <init>(
java.util.logging.Handler
int
java.util.logging.Level)

public void close()

public void flush()

public java.util.logging.Level getPushLevel()

public boolean isLoggable(
java.util.logging.LogRecord)

public void publish(
java.util.logging.LogRecord)

public void push()

public void setPushLevel(
java.util.logging.Level)

________________CLASS________________


public class java.util.logging.SimpleFormatter extends java.util.logging.Formatter

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public java.lang.String format(
java.util.logging.LogRecord)

________________CLASS________________


public class java.util.logging.SocketHandler extends java.util.logging.StreamHandler

----------------FIELDS----------------

private static final java.lang.String DEFAULT_FORMATTER

private static final java.lang.String DEFAULT_LEVEL

private java.net.Socket socket
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void initSocket(
java.lang.String
java.lang.String)

public void close()

public void publish(
java.util.logging.LogRecord)

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/String;>; )
final class java.util.logging.XMLFormatter$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final java.lang.String val$key
----------------METHODS----------------

 void <init>(
java.lang.String)

public volatile java.lang.Object run()

public java.lang.String run()

________________CLASS________________


public class java.util.logging.XMLFormatter extends java.util.logging.Formatter

----------------FIELDS----------------

private static final java.lang.String indent

private static final java.lang.String lineSeperator
----------------METHODS----------------

static void <clinit>()

public void <init>()

private void formatMessages(
java.util.logging.LogRecord
java.lang.StringBuilder)

private void formatThrowable(
java.util.logging.LogRecord
java.lang.StringBuilder)

private static java.lang.String getSystemProperty(
java.lang.String)

public java.lang.String format(
java.util.logging.LogRecord)

public java.lang.String getHead(
java.util.logging.Handler)

public java.lang.String getTail(
java.util.logging.Handler)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Ljava/util/prefs/AbstractPreferences; )
final class java.util.prefs.AbstractPreferences$1 extends java.lang.Thread

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public void run()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/prefs/AbstractPreferences; )
@dalvik.annotation.InnerClass (accessFlags =10 name =EventDispatcher )
 class java.util.prefs.AbstractPreferences$EventDispatcher extends java.lang.Thread

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
java.lang.String)
@dalvik.annotation.Signature (value =(Ljava/util/prefs/NodeChangeEvent;Ljava/util/List<Ljava/util/EventListener;>;)V )
private void dispatchNodeAdd(
java.util.prefs.NodeChangeEvent
java.util.List)
@dalvik.annotation.Signature (value =(Ljava/util/prefs/NodeChangeEvent;Ljava/util/List<Ljava/util/EventListener;>;)V )
private void dispatchNodeRemove(
java.util.prefs.NodeChangeEvent
java.util.List)
@dalvik.annotation.Signature (value =(Ljava/util/prefs/PreferenceChangeEvent;Ljava/util/List<Ljava/util/EventListener;>;)V )
private void dispatchPrefChange(
java.util.prefs.PreferenceChangeEvent
java.util.List)
@dalvik.annotation.Throws (value =Ljava/lang/InterruptedException; )
private java.util.EventObject getEventObject()

public void run()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/prefs/AbstractPreferences; )
@dalvik.annotation.InnerClass (accessFlags =10 name =Lock )
 class java.util.prefs.AbstractPreferences$Lock extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

private void <init>()

 void <init>(
java.util.prefs.AbstractPreferences$1)

________________CLASS________________


public class java.util.prefs.NodeChangeEvent extends java.util.EventObject implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

private final java.util.prefs.Preferences child

private final java.util.prefs.Preferences parent
----------------METHODS----------------

public void <init>(
java.util.prefs.Preferences
java.util.prefs.Preferences)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

public java.util.prefs.Preferences getChild()

public java.util.prefs.Preferences getParent()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =10 name =NodeAddEvent )
@dalvik.annotation.EnclosingClass (value =Ljava/util/prefs/AbstractPreferences; )
 class java.util.prefs.AbstractPreferences$NodeAddEvent extends java.util.prefs.NodeChangeEvent

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>(
java.util.prefs.Preferences
java.util.prefs.Preferences)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =10 name =NodeRemoveEvent )
@dalvik.annotation.EnclosingClass (value =Ljava/util/prefs/AbstractPreferences; )
 class java.util.prefs.AbstractPreferences$NodeRemoveEvent extends java.util.prefs.NodeChangeEvent

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>(
java.util.prefs.Preferences
java.util.prefs.Preferences)

________________CLASS________________


public abstract class java.util.prefs.Preferences extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.String CONFIGURATION_FILE_COMMENT

private static final java.lang.String CONFIGURATION_FILE_ENCODING

private static final java.lang.String FACTORY_CONFIGURATION_FILE_NAME

public static final int MAX_KEY_LENGTH

public static final int MAX_NAME_LENGTH

public static final int MAX_VALUE_LENGTH

private static final java.lang.RuntimePermission PREFS_PERM

private static final java.util.prefs.PreferencesFactory factory
----------------METHODS----------------

static void <clinit>()

protected void <init>()

private static void checkSecurity()
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;)Ljava/lang/String; )
private static java.lang.String getNodeName(
java.lang.Class)
@dalvik.annotation.Throws (value =Ljava/util/prefs/InvalidPreferencesFormatException;Ljava/io/IOException; )
public static void importPreferences(
java.io.InputStream)
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;)Ljava/util/prefs/Preferences; )
public static java.util.prefs.Preferences systemNodeForPackage(
java.lang.Class)

public static java.util.prefs.Preferences systemRoot()
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;)Ljava/util/prefs/Preferences; )
public static java.util.prefs.Preferences userNodeForPackage(
java.lang.Class)

public static java.util.prefs.Preferences userRoot()

public abstract java.lang.String absolutePath()

public abstract void addNodeChangeListener(
java.util.prefs.NodeChangeListener)

public abstract void addPreferenceChangeListener(
java.util.prefs.PreferenceChangeListener)
@dalvik.annotation.Throws (value =Ljava/util/prefs/BackingStoreException; )
public abstract java.lang.String[] childrenNames()
@dalvik.annotation.Throws (value =Ljava/util/prefs/BackingStoreException; )
public abstract void clear()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/util/prefs/BackingStoreException; )
public abstract void exportNode(
java.io.OutputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/util/prefs/BackingStoreException; )
public abstract void exportSubtree(
java.io.OutputStream)
@dalvik.annotation.Throws (value =Ljava/util/prefs/BackingStoreException; )
public abstract void flush()

public abstract java.lang.String get(
java.lang.String
java.lang.String)

public abstract boolean getBoolean(
java.lang.String
boolean)

public abstract byte[] getByteArray(
java.lang.String
byte[])

public abstract double getDouble(
java.lang.String
double)

public abstract float getFloat(
java.lang.String
float)

public abstract int getInt(
java.lang.String
int)

public abstract long getLong(
java.lang.String
long)

public abstract boolean isUserNode()
@dalvik.annotation.Throws (value =Ljava/util/prefs/BackingStoreException; )
public abstract java.lang.String[] keys()

public abstract java.lang.String name()

public abstract java.util.prefs.Preferences node(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/util/prefs/BackingStoreException; )
public abstract boolean nodeExists(
java.lang.String)

public abstract java.util.prefs.Preferences parent()

public abstract void put(
java.lang.String
java.lang.String)

public abstract void putBoolean(
java.lang.String
boolean)

public abstract void putByteArray(
java.lang.String
byte[])

public abstract void putDouble(
java.lang.String
double)

public abstract void putFloat(
java.lang.String
float)

public abstract void putInt(
java.lang.String
int)

public abstract void putLong(
java.lang.String
long)

public abstract void remove(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/util/prefs/BackingStoreException; )
public abstract void removeNode()

public abstract void removeNodeChangeListener(
java.util.prefs.NodeChangeListener)

public abstract void removePreferenceChangeListener(
java.util.prefs.PreferenceChangeListener)
@dalvik.annotation.Throws (value =Ljava/util/prefs/BackingStoreException; )
public abstract void sync()

public abstract java.lang.String toString()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljava/util/prefs/AbstractPreferences$NodeRemoveEvent;Ljava/util/prefs/AbstractPreferences$NodeAddEvent;Ljava/util/prefs/AbstractPreferences$EventDispatcher;Ljava/util/prefs/AbstractPreferences$Lock; )
public abstract class java.util.prefs.AbstractPreferences extends java.util.prefs.Preferences

----------------FIELDS----------------

private static final java.util.prefs.AbstractPreferences$EventDispatcher dispatcher
@dalvik.annotation.Signature (value =Ljava/util/List<Ljava/util/EventObject;>; )
private static final java.util.List events
@dalvik.annotation.Signature (value =Ljava/util/Map<Ljava/lang/String;Ljava/util/prefs/AbstractPreferences;>; )
private java.util.Map cachedNode

private boolean isRemoved

protected final java.lang.Object lock

protected boolean newNode
@dalvik.annotation.Signature (value =Ljava/util/List<Ljava/util/EventListener;>; )
private java.util.List nodeChangeListeners

private java.lang.String nodeName

private java.util.prefs.AbstractPreferences parentPref
@dalvik.annotation.Signature (value =Ljava/util/List<Ljava/util/EventListener;>; )
private java.util.List preferenceChangeListeners

private java.util.prefs.AbstractPreferences root

 boolean userNode
----------------METHODS----------------

static void <clinit>()

protected void <init>(
java.util.prefs.AbstractPreferences
java.lang.String)

static java.util.List access$100(
java.util.prefs.AbstractPreferences)

static java.util.List access$200(
java.util.prefs.AbstractPreferences)

static java.util.List access$300()

private void checkState()
@dalvik.annotation.Throws (value =Ljava/util/prefs/BackingStoreException; )
private java.util.prefs.AbstractPreferences getNodeFromBackend(
boolean
java.util.prefs.AbstractPreferences
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/util/prefs/BackingStoreException; )
private java.util.prefs.AbstractPreferences nodeImpl(
java.lang.String
boolean)

private void notifyChildAdded(
java.util.prefs.Preferences)

private void notifyChildRemoved(
java.util.prefs.Preferences)

private void notifyPreferenceChange(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/util/prefs/BackingStoreException; )
private void removeNodeImpl()

private void validateName(
java.lang.String)

public java.lang.String absolutePath()

public void addNodeChangeListener(
java.util.prefs.NodeChangeListener)

public void addPreferenceChangeListener(
java.util.prefs.PreferenceChangeListener)

protected final java.util.prefs.AbstractPreferences[] cachedChildren()

protected abstract java.util.prefs.AbstractPreferences childSpi(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/util/prefs/BackingStoreException; )
public java.lang.String[] childrenNames()
@dalvik.annotation.Throws (value =Ljava/util/prefs/BackingStoreException; )
protected abstract java.lang.String[] childrenNamesSpi()
@dalvik.annotation.Throws (value =Ljava/util/prefs/BackingStoreException; )
public void clear()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/util/prefs/BackingStoreException; )
public void exportNode(
java.io.OutputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/util/prefs/BackingStoreException; )
public void exportSubtree(
java.io.OutputStream)
@dalvik.annotation.Throws (value =Ljava/util/prefs/BackingStoreException; )
public void flush()
@dalvik.annotation.Throws (value =Ljava/util/prefs/BackingStoreException; )
protected abstract void flushSpi()

public java.lang.String get(
java.lang.String
java.lang.String)

public boolean getBoolean(
java.lang.String
boolean)

public byte[] getByteArray(
java.lang.String
byte[])
@dalvik.annotation.Throws (value =Ljava/util/prefs/BackingStoreException; )
protected java.util.prefs.AbstractPreferences getChild(
java.lang.String)

public double getDouble(
java.lang.String
double)

public float getFloat(
java.lang.String
float)

public int getInt(
java.lang.String
int)

public long getLong(
java.lang.String
long)

protected abstract java.lang.String getSpi(
java.lang.String)

protected boolean isRemoved()

public boolean isUserNode()
@dalvik.annotation.Throws (value =Ljava/util/prefs/BackingStoreException; )
public java.lang.String[] keys()
@dalvik.annotation.Throws (value =Ljava/util/prefs/BackingStoreException; )
protected abstract java.lang.String[] keysSpi()

public java.lang.String name()

public java.util.prefs.Preferences node(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/util/prefs/BackingStoreException; )
public boolean nodeExists(
java.lang.String)

public java.util.prefs.Preferences parent()

public void put(
java.lang.String
java.lang.String)

public void putBoolean(
java.lang.String
boolean)

public void putByteArray(
java.lang.String
byte[])

public void putDouble(
java.lang.String
double)

public void putFloat(
java.lang.String
float)

public void putInt(
java.lang.String
int)

public void putLong(
java.lang.String
long)

protected abstract void putSpi(
java.lang.String
java.lang.String)

public void remove(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/util/prefs/BackingStoreException; )
public void removeNode()

public void removeNodeChangeListener(
java.util.prefs.NodeChangeListener)
@dalvik.annotation.Throws (value =Ljava/util/prefs/BackingStoreException; )
protected abstract void removeNodeSpi()

public void removePreferenceChangeListener(
java.util.prefs.PreferenceChangeListener)

protected abstract void removeSpi(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/util/prefs/BackingStoreException; )
public void sync()
@dalvik.annotation.Throws (value =Ljava/util/prefs/BackingStoreException; )
protected abstract void syncSpi()

public java.lang.String toString()

________________CLASS________________


public class java.util.prefs.BackingStoreException extends java.lang.Exception

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>(
java.lang.String)

public void <init>(
java.lang.Throwable)

________________CLASS________________


public abstract interface class java.util.prefs.PreferencesFactory extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.util.prefs.Preferences systemRoot()

public abstract java.util.prefs.Preferences userRoot()

________________CLASS________________


 class java.util.prefs.FilePreferencesFactoryImpl extends java.lang.Object implements java.util.prefs.PreferencesFactory

----------------FIELDS----------------

private static final java.util.prefs.Preferences SYSTEM_ROOT

private static final java.util.prefs.Preferences USER_ROOT
----------------METHODS----------------

static void <clinit>()

public void <init>()

public java.util.prefs.Preferences systemRoot()

public java.util.prefs.Preferences userRoot()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Ljava/util/prefs/FilePreferencesImpl; )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/Void;>; )
final class java.util.prefs.FilePreferencesImpl$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public volatile java.lang.Object run()

public java.lang.Void run()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/Boolean;>; )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
 class java.util.prefs.FilePreferencesImpl$2 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final java.util.prefs.FilePreferencesImpl this$0
----------------METHODS----------------

 void <init>(
java.util.prefs.FilePreferencesImpl)

public java.lang.Boolean run()

public volatile java.lang.Object run()

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
 class java.util.prefs.FilePreferencesImpl$3$1 extends java.lang.Object implements java.io.FilenameFilter

----------------FIELDS----------------

final java.util.prefs.FilePreferencesImpl$3 this$1
----------------METHODS----------------

 void <init>(
java.util.prefs.FilePreferencesImpl$3)

public boolean accept(
java.io.File
java.lang.String)

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<[Ljava/lang/String;>; )
 class java.util.prefs.FilePreferencesImpl$3 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final java.util.prefs.FilePreferencesImpl this$0
----------------METHODS----------------

 void <init>(
java.util.prefs.FilePreferencesImpl)

public volatile java.lang.Object run()

public java.lang.String[] run()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/Boolean;>; )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
 class java.util.prefs.FilePreferencesImpl$4 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final java.util.prefs.FilePreferencesImpl this$0
----------------METHODS----------------

 void <init>(
java.util.prefs.FilePreferencesImpl)

public java.lang.Boolean run()

public volatile java.lang.Object run()

________________CLASS________________


 class java.util.prefs.FilePreferencesImpl extends java.util.prefs.AbstractPreferences

----------------FIELDS----------------

private static final java.lang.String PREFS_FILE_NAME

private static java.lang.String SYSTEM_HOME

private static java.lang.String USER_HOME

private java.io.File dir

private java.lang.String path

private java.util.Properties prefs

private java.io.File prefsFile
@dalvik.annotation.Signature (value =Ljava/util/Set<Ljava/lang/String;>; )
private java.util.Set removed
@dalvik.annotation.Signature (value =Ljava/util/Set<Ljava/lang/String;>; )
private java.util.Set updated
----------------METHODS----------------

static void <clinit>()

private void <init>(
java.util.prefs.AbstractPreferences
java.lang.String)

 void <init>(
boolean)

static java.lang.String access$002(
java.lang.String)

static java.lang.String access$102(
java.lang.String)

static java.io.File access$200(
java.util.prefs.FilePreferencesImpl)

static java.lang.String access$300(
java.util.prefs.FilePreferencesImpl)

static java.io.File access$400(
java.util.prefs.FilePreferencesImpl)

private void initPrefs()

protected java.util.prefs.AbstractPreferences childSpi(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/util/prefs/BackingStoreException; )
protected java.lang.String[] childrenNamesSpi()
@dalvik.annotation.Throws (value =Ljava/util/prefs/BackingStoreException; )
protected void flushSpi()

protected java.lang.String getSpi(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/util/prefs/BackingStoreException; )
protected java.lang.String[] keysSpi()

protected void putSpi(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/util/prefs/BackingStoreException; )
protected void removeNodeSpi()

protected void removeSpi(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/util/prefs/BackingStoreException; )
protected void syncSpi()

________________CLASS________________


public class java.util.prefs.InvalidPreferencesFormatException extends java.lang.Exception

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.Throwable)

public void <init>(
java.lang.Throwable)

________________CLASS________________


public abstract interface class java.util.prefs.NodeChangeListener extends java.lang.Object implements java.util.EventListener

----------------FIELDS----------------
----------------METHODS----------------

public abstract void childAdded(
java.util.prefs.NodeChangeEvent)

public abstract void childRemoved(
java.util.prefs.NodeChangeEvent)

________________CLASS________________


public abstract interface class org.w3c.dom.NodeList extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract int getLength()

public abstract org.w3c.dom.Node item(
int)

________________CLASS________________


 class java.util.prefs.NodeSet extends java.lang.Object implements org.w3c.dom.NodeList

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/ArrayList<Lorg/w3c/dom/Node;>; )
 java.util.ArrayList list
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/Iterator<Lorg/w3c/dom/Node;>;)V )
public void <init>(
java.util.Iterator)

public int getLength()

public org.w3c.dom.Node item(
int)

________________CLASS________________


public class java.util.prefs.PreferenceChangeEvent extends java.util.EventObject implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

private final java.lang.String key

private final java.util.prefs.Preferences node

private final java.lang.String value
----------------METHODS----------------

public void <init>(
java.util.prefs.Preferences
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void readObject(
java.io.ObjectInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

public java.lang.String getKey()

public java.lang.String getNewValue()

public java.util.prefs.Preferences getNode()

________________CLASS________________


public abstract interface class java.util.prefs.PreferenceChangeListener extends java.lang.Object implements java.util.EventListener

----------------FIELDS----------------
----------------METHODS----------------

public abstract void preferenceChange(
java.util.prefs.PreferenceChangeEvent)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/prefs/Preferences; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/String;>; )
final class java.util.prefs.Preferences$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public volatile java.lang.Object run()

public java.lang.String run()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/prefs/XMLParser; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class java.util.prefs.XMLParser$1 extends java.lang.Object implements org.xml.sax.EntityResolver

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException;Ljava/io/IOException; )
public org.xml.sax.InputSource resolveEntity(
java.lang.String
java.lang.String)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Ljava/util/prefs/XMLParser; )
final class java.util.prefs.XMLParser$2 extends java.lang.Object implements org.xml.sax.ErrorHandler

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void error(
org.xml.sax.SAXParseException)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void fatalError(
org.xml.sax.SAXParseException)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void warning(
org.xml.sax.SAXParseException)

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/util/Properties;>; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class java.util.prefs.XMLParser$3 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final java.io.File val$file
----------------METHODS----------------

 void <init>(
java.io.File)

public volatile java.lang.Object run()

public java.util.Properties run()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedExceptionAction<Ljava/lang/Object;>; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
final class java.util.prefs.XMLParser$4 extends java.lang.Object implements java.security.PrivilegedExceptionAction

----------------FIELDS----------------

final java.io.File val$file

final java.util.Properties val$prefs
----------------METHODS----------------

 void <init>(
java.io.File
java.util.Properties)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object run()

________________CLASS________________


 class java.util.prefs.XMLParser extends java.lang.Object

----------------FIELDS----------------

static final java.lang.String DOCTYPE

private static final java.lang.String[] EMPTY_SARRAY

private static final java.lang.String FILE_PREFS

static final java.lang.String HEADER

static final java.lang.String PREFS_DTD

static final java.lang.String PREFS_DTD_NAME

private static final float XML_VERSION

private static final javax.xml.parsers.DocumentBuilder builder

private static int indent
----------------METHODS----------------

static void <clinit>()

private void <init>()
@dalvik.annotation.Throws (value =Ljava/util/prefs/BackingStoreException;Ljava/io/IOException; )
private static void exportEntries(
java.util.prefs.Preferences
java.io.BufferedWriter)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private static void exportEntries(
java.lang.String[]
java.lang.String[]
java.io.BufferedWriter)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/util/prefs/BackingStoreException; )
private static void exportNode(
java.util.StringTokenizer
java.util.prefs.Preferences
boolean
java.io.BufferedWriter)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/util/prefs/BackingStoreException; )
static void exportPrefs(
java.util.prefs.Preferences
java.io.OutputStream
boolean)
@dalvik.annotation.Throws (value =Ljava/util/prefs/BackingStoreException;Ljava/io/IOException; )
private static void exportSubTree(
java.util.prefs.Preferences
java.io.BufferedWriter)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private static void flushEmptyElement(
java.lang.String
java.io.BufferedWriter)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private static void flushEmptyElement(
java.lang.String
java.lang.String[]
java.lang.String[]
java.io.BufferedWriter)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private static void flushEndTag(
java.lang.String
java.io.BufferedWriter)
@dalvik.annotation.Throws (value =Ljava/security/PrivilegedActionException; )
static void flushFilePrefs(
java.io.File
java.util.Properties)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
static void flushFilePrefsImpl(
java.io.File
java.util.Properties)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private static void flushIndent(
int
java.io.BufferedWriter)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private static void flushPairs(
java.lang.String[]
java.lang.String[]
java.io.BufferedWriter)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private static void flushStartTag(
java.lang.String
java.io.BufferedWriter)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private static void flushStartTag(
java.lang.String
java.lang.String[]
java.lang.String[]
java.io.BufferedWriter)

private static java.lang.String htmlEncode(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/util/prefs/InvalidPreferencesFormatException; )
static void importPrefs(
java.io.InputStream)

static java.util.Properties loadFilePrefs(
java.io.File)

static java.util.Properties loadFilePrefsImpl(
java.io.File)

private static void loadNode(
java.util.prefs.Preferences
org.w3c.dom.Element)

private static org.w3c.dom.NodeList selectNodeList(
org.w3c.dom.Element
java.lang.String)

________________CLASS________________


public abstract interface class java.util.regex.MatchResult extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract int end()

public abstract int end(
int)

public abstract java.lang.String group()

public abstract java.lang.String group(
int)

public abstract int groupCount()

public abstract int start()

public abstract int start(
int)

________________CLASS________________


 class java.util.regex.MatchResultImpl extends java.lang.Object implements java.util.regex.MatchResult

----------------FIELDS----------------

private int[] offsets

private java.lang.String text
----------------METHODS----------------

 void <init>(
java.lang.String
int[])

public int end()

public int end(
int)

public java.lang.String group()

public java.lang.String group(
int)

public int groupCount()

public int start()

public int start(
int)

________________CLASS________________


public final class java.util.regex.Matcher extends java.lang.Object implements java.util.regex.MatchResult

----------------FIELDS----------------

private boolean anchoringBounds

private int appendPos

private int findPos

private java.lang.String input

private boolean matchFound

private int[] matchOffsets

private int nativePattern

private java.util.regex.Pattern pattern

private int regionEnd

private int regionStart

private boolean searching

private boolean transparentBounds
----------------METHODS----------------

 void <init>(
java.util.regex.Pattern
java.lang.CharSequence)

private void appendEvaluated(
java.lang.StringBuffer
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalStateException; )
private void ensureMatch()

public static java.lang.String quoteReplacement(
java.lang.String)

private java.util.regex.Matcher reset(
java.lang.CharSequence
int
int)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalStateException; )
public java.util.regex.Matcher appendReplacement(
java.lang.StringBuffer
java.lang.String)

public java.lang.StringBuffer appendTail(
java.lang.StringBuffer)

public int end()

public int end(
int)

protected void finalize()

public boolean find()

public boolean find(
int)

public java.lang.String group()

public java.lang.String group(
int)

public int groupCount()

public boolean hasAnchoringBounds()

public boolean hasTransparentBounds()

public boolean hitEnd()

public boolean lookingAt()

public boolean matches()

public java.util.regex.Pattern pattern()

public java.util.regex.Matcher region(
int
int)

public int regionEnd()

public int regionStart()

public java.lang.String replaceAll(
java.lang.String)

public java.lang.String replaceFirst(
java.lang.String)

public boolean requireEnd()

public java.util.regex.Matcher reset()

public java.util.regex.Matcher reset(
java.lang.CharSequence)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalStateException; )
public int start()
@dalvik.annotation.Throws (value =Ljava/lang/IllegalStateException; )
public int start(
int)

public java.util.regex.MatchResult toMatchResult()

public java.util.regex.Matcher useAnchoringBounds(
boolean)

public java.util.regex.Matcher usePattern(
java.util.regex.Pattern)

public java.util.regex.Matcher useTransparentBounds(
boolean)

________________CLASS________________


public final class java.util.regex.Pattern extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------

public static final int CANON_EQ

public static final int CASE_INSENSITIVE

public static final int COMMENTS

public static final int DOTALL

public static final int LITERAL

public static final int MULTILINE

public static final int UNICODE_CASE

public static final int UNIX_LINES

private static final long serialVersionUID

private int flags

transient int mGroupCount

transient int mNativePattern

private java.lang.String pattern
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/util/regex/PatternSyntaxException; )
private void <init>(
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/util/regex/PatternSyntaxException; )
public static java.util.regex.Pattern compile(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/util/regex/PatternSyntaxException; )
public static java.util.regex.Pattern compile(
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/util/regex/PatternSyntaxException; )
private void compileImpl(
java.lang.String
int)

public static boolean matches(
java.lang.String
java.lang.CharSequence)

public static java.lang.String quote(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)

protected void finalize()

public int flags()

public java.util.regex.Matcher matcher(
java.lang.CharSequence)

public java.lang.String pattern()

public java.lang.String[] split(
java.lang.CharSequence)

public java.lang.String[] split(
java.lang.CharSequence
int)

public java.lang.String toString()

________________CLASS________________


public class java.util.regex.PatternSyntaxException extends java.lang.IllegalArgumentException

----------------FIELDS----------------

private static final long serialVersionUID

private java.lang.String description

private int index

private java.lang.String pattern
----------------METHODS----------------

public void <init>(
java.lang.String
java.lang.String
int)

public java.lang.String getDescription()

public int getIndex()

public java.lang.String getMessage()

public java.lang.String getPattern()

________________CLASS________________


public abstract interface class java.util.zip.Checksum extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract long getValue()

public abstract void reset()

public abstract void update(
int)

public abstract void update(
byte[]
int
int)

________________CLASS________________


public class java.util.zip.Adler32 extends java.lang.Object implements java.util.zip.Checksum

----------------FIELDS----------------

private long adler
----------------METHODS----------------

public void <init>()

private native long updateByteImpl(
int
long)

private native long updateImpl(
byte[]
int
int
long)

public long getValue()

public void reset()

public void update(
int)

public void update(
byte[])

public void update(
byte[]
int
int)

________________CLASS________________


public class java.util.zip.CRC32 extends java.lang.Object implements java.util.zip.Checksum

----------------FIELDS----------------

private long crc

 long tbytes
----------------METHODS----------------

public void <init>()

private native long updateByteImpl(
byte
long)

private native long updateImpl(
byte[]
int
int
long)

public long getValue()

public void reset()

public void update(
int)

public void update(
byte[])

public void update(
byte[]
int
int)

________________CLASS________________


public class java.util.zip.CheckedInputStream extends java.io.FilterInputStream

----------------FIELDS----------------

private final java.util.zip.Checksum check
----------------METHODS----------------

public void <init>(
java.io.InputStream
java.util.zip.Checksum)

public java.util.zip.Checksum getChecksum()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long skip(
long)

________________CLASS________________


public class java.util.zip.CheckedOutputStream extends java.io.FilterOutputStream

----------------FIELDS----------------

private final java.util.zip.Checksum check
----------------METHODS----------------

public void <init>(
java.io.OutputStream
java.util.zip.Checksum)

public java.util.zip.Checksum getChecksum()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
byte[]
int
int)

________________CLASS________________


public class java.util.zip.DataFormatException extends java.lang.Exception

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class java.util.zip.Deflater extends java.lang.Object

----------------FIELDS----------------

public static final int BEST_COMPRESSION

public static final int BEST_SPEED

public static final int DEFAULT_COMPRESSION

public static final int DEFAULT_STRATEGY

public static final int DEFLATED

public static final int FILTERED

public static final int HUFFMAN_ONLY

public static final int NO_COMPRESSION

private static final byte[] STUB_INPUT_BUFFER

private static final int Z_FINISH

private static final int Z_NO_FLUSH

private int compressLevel

private boolean finished

private int flushParm

private int inLength

private int inRead

private byte[] inputBuffer

private int strategy

private long streamHandle
----------------METHODS----------------

static void <clinit>()

public void <init>()

public void <init>(
int)

public void <init>(
int
boolean)

private native long createStream(
int
int
boolean)

private synchronized native int deflateImpl(
byte[]
int
int
long
int)

private synchronized native void endImpl(
long)

private synchronized native int getAdlerImpl(
long)

private synchronized native long getTotalInImpl(
long)

private synchronized native long getTotalOutImpl(
long)

private static native void oneTimeInitialization()

private synchronized native void resetImpl(
long)

private synchronized native void setDictionaryImpl(
byte[]
int
int
long)

private synchronized native void setInputImpl(
byte[]
int
int
long)

private synchronized native void setLevelsImpl(
int
int
long)

public int deflate(
byte[])

public int deflate(
byte[]
int
int)

public void end()

protected void finalize()

public void finish()

public boolean finished()

public int getAdler()

public long getBytesRead()

public long getBytesWritten()

public int getTotalIn()

public int getTotalOut()

public boolean needsInput()

public void reset()

public void setDictionary(
byte[])

public void setDictionary(
byte[]
int
int)

public void setInput(
byte[])

public void setInput(
byte[]
int
int)

public void setLevel(
int)

public void setStrategy(
int)

________________CLASS________________


public class java.util.zip.GZIPInputStream extends java.util.zip.InflaterInputStream

----------------FIELDS----------------

private static final int FCOMMENT

private static final int FEXTRA

private static final int FHCRC

private static final int FNAME

public static final int GZIP_MAGIC

protected java.util.zip.CRC32 crc

protected boolean eos
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.io.InputStream
int)

private long getLong(
byte[]
int)

private int getShort(
byte[]
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void readFully(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void readZeroTerminated(
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[]
int
int)

________________CLASS________________


public class java.util.zip.GZIPOutputStream extends java.util.zip.DeflaterOutputStream

----------------FIELDS----------------

protected java.util.zip.CRC32 crc
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.io.OutputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.io.OutputStream
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private long writeLong(
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private int writeShort(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void finish()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
byte[]
int
int)

________________CLASS________________


public class java.util.zip.Inflater extends java.lang.Object

----------------FIELDS----------------

private static final byte MAGIC_NUMBER

private boolean finished

private boolean gotFirstByte

 int inLength

 int inRead

private boolean needsDictionary

private boolean pass_magic_number_check

private long streamHandle
----------------METHODS----------------

static void <clinit>()

public void <init>()

public void <init>(
boolean)

private native long createStream(
boolean)

private synchronized native void endImpl(
long)

private synchronized native int getAdlerImpl(
long)

private synchronized native long getTotalInImpl(
long)

private synchronized native long getTotalOutImpl(
long)

private synchronized native int inflateImpl(
byte[]
int
int
long)

private static native void oneTimeInitialization()

private synchronized native void resetImpl(
long)

private synchronized native void setDictionaryImpl(
byte[]
int
int
long)

private synchronized native int setFileInputImpl(
java.io.FileDescriptor
long
int
long)

private synchronized native void setInputImpl(
byte[]
int
int
long)

public void end()

protected void finalize()

public boolean finished()

public int getAdler()

public long getBytesRead()

public long getBytesWritten()

public int getRemaining()

public int getTotalIn()

public int getTotalOut()
@dalvik.annotation.Throws (value =Ljava/util/zip/DataFormatException; )
public int inflate(
byte[])
@dalvik.annotation.Throws (value =Ljava/util/zip/DataFormatException; )
public int inflate(
byte[]
int
int)

public boolean needsDictionary()

public boolean needsInput()

public void reset()

public void setDictionary(
byte[])

public void setDictionary(
byte[]
int
int)

 int setFileInput(
java.io.FileDescriptor
long
int)

public void setInput(
byte[])

public void setInput(
byte[]
int
int)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljava/util/zip/ZipEntry; )
@dalvik.annotation.InnerClass (accessFlags =8 name =LittleEndianReader )
 class java.util.zip.ZipEntry$LittleEndianReader extends java.lang.Object

----------------FIELDS----------------

private byte[] b

 byte[] hdrBuf
----------------METHODS----------------

 void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 long readIntLE(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 int readShortLE(
java.io.InputStream)

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/Object;>; )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
 class java.util.zip.ZipFile$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final java.util.zip.ZipFile this$0
----------------METHODS----------------

 void <init>(
java.util.zip.ZipFile)

public java.lang.Object run()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Enumeration<Ljava/util/zip/ZipEntry;>; )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
 class java.util.zip.ZipFile$2 extends java.lang.Object implements java.util.Enumeration

----------------FIELDS----------------

private int i

final java.util.zip.ZipFile this$0
----------------METHODS----------------

 void <init>(
java.util.zip.ZipFile)

public boolean hasMoreElements()

public volatile java.lang.Object nextElement()

public java.util.zip.ZipEntry nextElement()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =RAFStream )
@dalvik.annotation.EnclosingClass (value =Ljava/util/zip/ZipFile; )
 class java.util.zip.ZipFile$RAFStream extends java.io.InputStream

----------------FIELDS----------------

 long mLength

 long mOffset

 java.io.RandomAccessFile mSharedRaf

private byte[] singleByteBuf
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.io.RandomAccessFile
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int available()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long skip(
long)

________________CLASS________________


public class javax.crypto.BadPaddingException extends java.security.GeneralSecurityException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class javax.crypto.Cipher extends java.lang.Object

----------------FIELDS----------------

public static final int DECRYPT_MODE

public static final int ENCRYPT_MODE

public static final int PRIVATE_KEY

public static final int PUBLIC_KEY

public static final int SECRET_KEY

private static final java.lang.String SERVICE

public static final int UNWRAP_MODE

public static final int WRAP_MODE

private static final org.apache.harmony.security.fortress.Engine engine

private static java.security.SecureRandom sec_rand

private int mode

private java.security.Provider provider

private javax.crypto.CipherSpi spiImpl

private java.lang.String transformation
----------------METHODS----------------

static void <clinit>()

protected void <init>(
javax.crypto.CipherSpi
java.security.Provider
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
private static java.lang.String[] checkTransformation(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljavax/crypto/NoSuchPaddingException; )
private static javax.crypto.Cipher getCipher(
java.lang.String
java.security.Provider)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljavax/crypto/NoSuchPaddingException; )
public static final javax.crypto.Cipher getInstance(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/NoSuchProviderException;Ljavax/crypto/NoSuchPaddingException; )
public static final javax.crypto.Cipher getInstance(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljavax/crypto/NoSuchPaddingException; )
public static final javax.crypto.Cipher getInstance(
java.lang.String
java.security.Provider)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public static final int getMaxAllowedKeyLength(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public static final java.security.spec.AlgorithmParameterSpec getMaxAllowedParameterSpec(
java.lang.String)
@dalvik.annotation.Throws (value =Ljavax/crypto/ShortBufferException;Ljavax/crypto/IllegalBlockSizeException;Ljavax/crypto/BadPaddingException; )
public final int doFinal(
java.nio.ByteBuffer
java.nio.ByteBuffer)
@dalvik.annotation.Throws (value =Ljavax/crypto/IllegalBlockSizeException;Ljavax/crypto/ShortBufferException;Ljavax/crypto/BadPaddingException; )
public final int doFinal(
byte[]
int)
@dalvik.annotation.Throws (value =Ljavax/crypto/ShortBufferException;Ljavax/crypto/IllegalBlockSizeException;Ljavax/crypto/BadPaddingException; )
public final int doFinal(
byte[]
int
int
byte[])
@dalvik.annotation.Throws (value =Ljavax/crypto/ShortBufferException;Ljavax/crypto/IllegalBlockSizeException;Ljavax/crypto/BadPaddingException; )
public final int doFinal(
byte[]
int
int
byte[]
int)
@dalvik.annotation.Throws (value =Ljavax/crypto/IllegalBlockSizeException;Ljavax/crypto/BadPaddingException; )
public final byte[] doFinal()
@dalvik.annotation.Throws (value =Ljavax/crypto/IllegalBlockSizeException;Ljavax/crypto/BadPaddingException; )
public final byte[] doFinal(
byte[])
@dalvik.annotation.Throws (value =Ljavax/crypto/IllegalBlockSizeException;Ljavax/crypto/BadPaddingException; )
public final byte[] doFinal(
byte[]
int
int)

public final java.lang.String getAlgorithm()

public final int getBlockSize()

public final javax.crypto.ExemptionMechanism getExemptionMechanism()

public final byte[] getIV()

public final int getOutputSize(
int)

public final java.security.AlgorithmParameters getParameters()

public final java.security.Provider getProvider()
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
public final void init(
int
java.security.Key)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljava/security/InvalidAlgorithmParameterException; )
public final void init(
int
java.security.Key
java.security.AlgorithmParameters)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljava/security/InvalidAlgorithmParameterException; )
public final void init(
int
java.security.Key
java.security.AlgorithmParameters
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
public final void init(
int
java.security.Key
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljava/security/InvalidAlgorithmParameterException; )
public final void init(
int
java.security.Key
java.security.spec.AlgorithmParameterSpec)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljava/security/InvalidAlgorithmParameterException; )
public final void init(
int
java.security.Key
java.security.spec.AlgorithmParameterSpec
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
public final void init(
int
java.security.cert.Certificate)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
public final void init(
int
java.security.cert.Certificate
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljava/security/NoSuchAlgorithmException; )
public final java.security.Key unwrap(
byte[]
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljavax/crypto/ShortBufferException; )
public final int update(
java.nio.ByteBuffer
java.nio.ByteBuffer)
@dalvik.annotation.Throws (value =Ljavax/crypto/ShortBufferException; )
public final int update(
byte[]
int
int
byte[])
@dalvik.annotation.Throws (value =Ljavax/crypto/ShortBufferException; )
public final int update(
byte[]
int
int
byte[]
int)

public final byte[] update(
byte[])

public final byte[] update(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljavax/crypto/IllegalBlockSizeException;Ljava/security/InvalidKeyException; )
public final byte[] wrap(
java.security.Key)

________________CLASS________________


public class javax.crypto.CipherInputStream extends java.io.FilterInputStream

----------------FIELDS----------------

private final int I_BUFFER_SIZE

private final javax.crypto.Cipher cipher

private boolean finished

private final byte[] i_buffer

private int index

private byte[] o_buffer
----------------METHODS----------------

protected void <init>(
java.io.InputStream)

public void <init>(
java.io.InputStream
javax.crypto.Cipher)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int available()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()

public boolean markSupported()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long skip(
long)

________________CLASS________________


public class javax.crypto.CipherOutputStream extends java.io.FilterOutputStream

----------------FIELDS----------------

private final byte[] arr

private final javax.crypto.Cipher cipher
----------------METHODS----------------

protected void <init>(
java.io.OutputStream)

public void <init>(
java.io.OutputStream
javax.crypto.Cipher)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void flush()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
byte[]
int
int)

________________CLASS________________


public abstract class javax.crypto.CipherSpi extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljavax/crypto/ShortBufferException;Ljavax/crypto/IllegalBlockSizeException;Ljavax/crypto/BadPaddingException; )
protected int engineDoFinal(
java.nio.ByteBuffer
java.nio.ByteBuffer)
@dalvik.annotation.Throws (value =Ljavax/crypto/ShortBufferException;Ljavax/crypto/IllegalBlockSizeException;Ljavax/crypto/BadPaddingException; )
protected abstract int engineDoFinal(
byte[]
int
int
byte[]
int)
@dalvik.annotation.Throws (value =Ljavax/crypto/IllegalBlockSizeException;Ljavax/crypto/BadPaddingException; )
protected abstract byte[] engineDoFinal(
byte[]
int
int)

protected abstract int engineGetBlockSize()

protected abstract byte[] engineGetIV()
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
protected int engineGetKeySize(
java.security.Key)

protected abstract int engineGetOutputSize(
int)

protected abstract java.security.AlgorithmParameters engineGetParameters()
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljava/security/InvalidAlgorithmParameterException; )
protected abstract void engineInit(
int
java.security.Key
java.security.AlgorithmParameters
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
protected abstract void engineInit(
int
java.security.Key
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljava/security/InvalidAlgorithmParameterException; )
protected abstract void engineInit(
int
java.security.Key
java.security.spec.AlgorithmParameterSpec
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
protected abstract void engineSetMode(
java.lang.String)
@dalvik.annotation.Throws (value =Ljavax/crypto/NoSuchPaddingException; )
protected abstract void engineSetPadding(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljava/security/NoSuchAlgorithmException; )
protected java.security.Key engineUnwrap(
byte[]
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljavax/crypto/ShortBufferException; )
protected int engineUpdate(
java.nio.ByteBuffer
java.nio.ByteBuffer)
@dalvik.annotation.Throws (value =Ljavax/crypto/ShortBufferException; )
protected abstract int engineUpdate(
byte[]
int
int
byte[]
int)

protected abstract byte[] engineUpdate(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljavax/crypto/IllegalBlockSizeException;Ljava/security/InvalidKeyException; )
protected byte[] engineWrap(
java.security.Key)

________________CLASS________________


public abstract interface class org.apache.harmony.security.asn1.ASN1Constants extends java.lang.Object

----------------FIELDS----------------

public static final int CLASS_APPLICATION

public static final int CLASS_CONTEXTSPECIFIC

public static final int CLASS_PRIVATE

public static final int CLASS_UNIVERSAL

public static final int PC_CONSTRUCTED

public static final int PC_PRIMITIVE

public static final int TAG_ANY

public static final int TAG_BITSTRING

public static final int TAG_BMPSTRING

public static final int TAG_BOOLEAN

public static final int TAG_CHOICE

public static final int TAG_C_BITSTRING

public static final int TAG_C_GENERALIZEDTIME

public static final int TAG_C_OCTETSTRING

public static final int TAG_C_SEQUENCE

public static final int TAG_C_SEQUENCEOF

public static final int TAG_C_SET

public static final int TAG_C_SETOF

public static final int TAG_C_UTCTIME

public static final int TAG_C_UTF8STRING

public static final int TAG_EMBEDDEDPDV

public static final int TAG_ENUM

public static final int TAG_EXTERNAL

public static final int TAG_GENERALIZEDTIME

public static final int TAG_GENERALSTRING

public static final int TAG_GRAPHICSTRING

public static final int TAG_IA5STRING

public static final int TAG_INSTANCEOF

public static final int TAG_INTEGER

public static final int TAG_ISO646STRING

public static final int TAG_NULL

public static final int TAG_NUMERICSTRING

public static final int TAG_OBJDESCRIPTOR

public static final int TAG_OCTETSTRING

public static final int TAG_OID

public static final int TAG_PRINTABLESTRING

public static final int TAG_REAL

public static final int TAG_RELATIVEOID

public static final int TAG_SEQUENCE

public static final int TAG_SEQUENCEOF

public static final int TAG_SET

public static final int TAG_SETOF

public static final int TAG_T61STRING

public static final int TAG_TELETEXSTRING

public static final int TAG_UNIVERSALSTRING

public static final int TAG_UTCTIME

public static final int TAG_UTF8STRING

public static final int TAG_VIDEOTEXSTRING

public static final int TAG_VISIBLESTRING
----------------METHODS----------------

________________CLASS________________


public abstract class org.apache.harmony.security.asn1.ASN1Type extends java.lang.Object implements org.apache.harmony.security.asn1.ASN1Constants

----------------FIELDS----------------

public final int constrId

public final int id
----------------METHODS----------------

public void <init>(
int)

public void <init>(
int
int)

public abstract boolean checkTag(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final java.lang.Object decode(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract java.lang.Object decode(
org.apache.harmony.security.asn1.BerInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final java.lang.Object decode(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final java.lang.Object decode(
byte[]
int
int)

public final byte[] encode(
java.lang.Object)

public abstract void encodeASN(
org.apache.harmony.security.asn1.BerOutputStream)

public abstract void encodeContent(
org.apache.harmony.security.asn1.BerOutputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

public int getEncodedLength(
org.apache.harmony.security.asn1.BerOutputStream)

public abstract void setEncodingContent(
org.apache.harmony.security.asn1.BerOutputStream)

public java.lang.String toString()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final void verify(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final void verify(
byte[])

________________CLASS________________


public abstract class org.apache.harmony.security.asn1.ASN1Constructured extends org.apache.harmony.security.asn1.ASN1Type

----------------FIELDS----------------
----------------METHODS----------------

public void <init>(
int)

public void <init>(
int
int)

public final boolean checkTag(
int)

public void encodeASN(
org.apache.harmony.security.asn1.BerOutputStream)

________________CLASS________________


public abstract class org.apache.harmony.security.asn1.ASN1TypeCollection extends org.apache.harmony.security.asn1.ASN1Constructured

----------------FIELDS----------------

public final java.lang.Object[] DEFAULT

public final boolean[] OPTIONAL

public final org.apache.harmony.security.asn1.ASN1Type[] type
----------------METHODS----------------

public void <init>(
int
org.apache.harmony.security.asn1.ASN1Type[])

protected void getValues(
java.lang.Object
java.lang.Object[])

protected final void setDefault(
java.lang.Object
int)

protected final void setOptional(
int)

________________CLASS________________


public class org.apache.harmony.security.asn1.ASN1Sequence extends org.apache.harmony.security.asn1.ASN1TypeCollection

----------------FIELDS----------------
----------------METHODS----------------

public void <init>(
org.apache.harmony.security.asn1.ASN1Type[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object decode(
org.apache.harmony.security.asn1.BerInputStream)

public final void encodeContent(
org.apache.harmony.security.asn1.BerOutputStream)

public final void setEncodingContent(
org.apache.harmony.security.asn1.BerOutputStream)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljavax/crypto/EncryptedPrivateKeyInfo; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class javax.crypto.EncryptedPrivateKeyInfo$1 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Ljavax/crypto/EncryptedPrivateKeyInfo; )
final class javax.crypto.EncryptedPrivateKeyInfo$2 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])

________________CLASS________________


public class javax.crypto.EncryptedPrivateKeyInfo extends java.lang.Object

----------------FIELDS----------------

private static final org.apache.harmony.security.asn1.ASN1SetOf ASN1Attributes

private static final org.apache.harmony.security.asn1.ASN1Sequence ASN1PrivateKeyInfo

private static final org.apache.harmony.security.asn1.ASN1Sequence asn1

private static final byte[] nullParam

private java.lang.String algName

private final java.security.AlgorithmParameters algParameters

private volatile byte[] encoded

private final byte[] encryptedData

private java.lang.String oid
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public void <init>(
java.lang.String
byte[])
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public void <init>(
java.security.AlgorithmParameters
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
byte[])

static java.security.AlgorithmParameters access$000(
javax.crypto.EncryptedPrivateKeyInfo)

static byte[] access$100()

static java.lang.String access$200(
javax.crypto.EncryptedPrivateKeyInfo)

static byte[] access$300(
javax.crypto.EncryptedPrivateKeyInfo)

private static boolean isNullValue(
byte[])

private boolean mapAlgName()

public java.lang.String getAlgName()

public java.security.AlgorithmParameters getAlgParameters()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public byte[] getEncoded()

public byte[] getEncryptedData()
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/InvalidKeyException; )
public java.security.spec.PKCS8EncodedKeySpec getKeySpec(
java.security.Key)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchProviderException;Ljava/security/NoSuchAlgorithmException;Ljava/security/InvalidKeyException; )
public java.security.spec.PKCS8EncodedKeySpec getKeySpec(
java.security.Key
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/InvalidKeyException; )
public java.security.spec.PKCS8EncodedKeySpec getKeySpec(
java.security.Key
java.security.Provider)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidKeySpecException; )
public java.security.spec.PKCS8EncodedKeySpec getKeySpec(
javax.crypto.Cipher)

________________CLASS________________


public class javax.crypto.ExemptionMechanism extends java.lang.Object

----------------FIELDS----------------

private static final org.apache.harmony.security.fortress.Engine engine

private boolean generated

private java.security.Key initKey

private boolean isInit

private final java.lang.String mechanism

private final java.security.Provider provider

private final javax.crypto.ExemptionMechanismSpi spiImpl
----------------METHODS----------------

static void <clinit>()

protected void <init>(
javax.crypto.ExemptionMechanismSpi
java.security.Provider
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public static final javax.crypto.ExemptionMechanism getInstance(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/NoSuchProviderException; )
public static final javax.crypto.ExemptionMechanism getInstance(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public static final javax.crypto.ExemptionMechanism getInstance(
java.lang.String
java.security.Provider)

protected void finalize()
@dalvik.annotation.Throws (value =Ljava/lang/IllegalStateException;Ljavax/crypto/ShortBufferException;Ljavax/crypto/ExemptionMechanismException; )
public final int genExemptionBlob(
byte[])
@dalvik.annotation.Throws (value =Ljava/lang/IllegalStateException;Ljavax/crypto/ShortBufferException;Ljavax/crypto/ExemptionMechanismException; )
public final int genExemptionBlob(
byte[]
int)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalStateException;Ljavax/crypto/ExemptionMechanismException; )
public final byte[] genExemptionBlob()

public final java.lang.String getName()
@dalvik.annotation.Throws (value =Ljava/lang/IllegalStateException; )
public final int getOutputSize(
int)

public final java.security.Provider getProvider()
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljavax/crypto/ExemptionMechanismException; )
public final void init(
java.security.Key)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljava/security/InvalidAlgorithmParameterException;Ljavax/crypto/ExemptionMechanismException; )
public final void init(
java.security.Key
java.security.AlgorithmParameters)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljava/security/InvalidAlgorithmParameterException;Ljavax/crypto/ExemptionMechanismException; )
public final void init(
java.security.Key
java.security.spec.AlgorithmParameterSpec)
@dalvik.annotation.Throws (value =Ljavax/crypto/ExemptionMechanismException; )
public final boolean isCryptoAllowed(
java.security.Key)

________________CLASS________________


public class javax.crypto.ExemptionMechanismException extends java.security.GeneralSecurityException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public abstract class javax.crypto.ExemptionMechanismSpi extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljavax/crypto/ShortBufferException;Ljavax/crypto/ExemptionMechanismException; )
protected abstract int engineGenExemptionBlob(
byte[]
int)
@dalvik.annotation.Throws (value =Ljavax/crypto/ExemptionMechanismException; )
protected abstract byte[] engineGenExemptionBlob()

protected abstract int engineGetOutputSize(
int)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljavax/crypto/ExemptionMechanismException; )
protected abstract void engineInit(
java.security.Key)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljava/security/InvalidAlgorithmParameterException;Ljavax/crypto/ExemptionMechanismException; )
protected abstract void engineInit(
java.security.Key
java.security.AlgorithmParameters)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljava/security/InvalidAlgorithmParameterException;Ljavax/crypto/ExemptionMechanismException; )
protected abstract void engineInit(
java.security.Key
java.security.spec.AlgorithmParameterSpec)

________________CLASS________________


public abstract class javax.crypto.MacSpi extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/lang/CloneNotSupportedException; )
public java.lang.Object clone()

protected abstract byte[] engineDoFinal()

protected abstract int engineGetMacLength()
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljava/security/InvalidAlgorithmParameterException; )
protected abstract void engineInit(
java.security.Key
java.security.spec.AlgorithmParameterSpec)

protected abstract void engineReset()

protected abstract void engineUpdate(
byte)

protected void engineUpdate(
java.nio.ByteBuffer)

protected abstract void engineUpdate(
byte[]
int
int)

________________CLASS________________


 class javax.crypto.HmacSpi extends javax.crypto.MacSpi

----------------FIELDS----------------

private java.io.ByteArrayOutputStream mData

private java.security.Key mKey

private java.lang.Object mSync
----------------METHODS----------------

 void <init>()

private native byte[] native_compute_sha1_hmac(
byte[]
byte[])

protected byte[] engineDoFinal()

protected int engineGetMacLength()
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljava/security/InvalidAlgorithmParameterException; )
protected void engineInit(
java.security.Key
java.security.spec.AlgorithmParameterSpec)

protected void engineReset()

protected void engineUpdate(
byte)

protected void engineUpdate(
byte[]
int
int)

________________CLASS________________


public class javax.crypto.IllegalBlockSizeException extends java.security.GeneralSecurityException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class javax.crypto.KeyAgreement extends java.lang.Object

----------------FIELDS----------------

private static final org.apache.harmony.security.fortress.Engine engine

private static final java.security.SecureRandom rndm

private final java.lang.String algorithm

private final java.security.Provider provider

private final javax.crypto.KeyAgreementSpi spiImpl
----------------METHODS----------------

static void <clinit>()

protected void <init>(
javax.crypto.KeyAgreementSpi
java.security.Provider
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public static final javax.crypto.KeyAgreement getInstance(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/NoSuchProviderException; )
public static final javax.crypto.KeyAgreement getInstance(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public static final javax.crypto.KeyAgreement getInstance(
java.lang.String
java.security.Provider)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljava/lang/IllegalStateException; )
public final java.security.Key doPhase(
java.security.Key
boolean)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalStateException;Ljavax/crypto/ShortBufferException; )
public final int generateSecret(
byte[]
int)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalStateException;Ljava/security/NoSuchAlgorithmException;Ljava/security/InvalidKeyException; )
public final javax.crypto.SecretKey generateSecret(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalStateException; )
public final byte[] generateSecret()

public final java.lang.String getAlgorithm()

public final java.security.Provider getProvider()
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
public final void init(
java.security.Key)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
public final void init(
java.security.Key
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljava/security/InvalidAlgorithmParameterException; )
public final void init(
java.security.Key
java.security.spec.AlgorithmParameterSpec)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljava/security/InvalidAlgorithmParameterException; )
public final void init(
java.security.Key
java.security.spec.AlgorithmParameterSpec
java.security.SecureRandom)

________________CLASS________________


public abstract class javax.crypto.KeyAgreementSpi extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljava/lang/IllegalStateException; )
protected abstract java.security.Key engineDoPhase(
java.security.Key
boolean)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalStateException;Ljavax/crypto/ShortBufferException; )
protected abstract int engineGenerateSecret(
byte[]
int)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalStateException;Ljava/security/NoSuchAlgorithmException;Ljava/security/InvalidKeyException; )
protected abstract javax.crypto.SecretKey engineGenerateSecret(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalStateException; )
protected abstract byte[] engineGenerateSecret()
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
protected abstract void engineInit(
java.security.Key
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljava/security/InvalidAlgorithmParameterException; )
protected abstract void engineInit(
java.security.Key
java.security.spec.AlgorithmParameterSpec
java.security.SecureRandom)

________________CLASS________________


public class javax.crypto.KeyGenerator extends java.lang.Object

----------------FIELDS----------------

private static final org.apache.harmony.security.fortress.Engine engine

private static final java.security.SecureRandom rndm

private final java.lang.String algorithm

private final java.security.Provider provider

private final javax.crypto.KeyGeneratorSpi spiImpl
----------------METHODS----------------

static void <clinit>()

protected void <init>(
javax.crypto.KeyGeneratorSpi
java.security.Provider
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public static final javax.crypto.KeyGenerator getInstance(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/NoSuchProviderException; )
public static final javax.crypto.KeyGenerator getInstance(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public static final javax.crypto.KeyGenerator getInstance(
java.lang.String
java.security.Provider)

public final javax.crypto.SecretKey generateKey()

public final java.lang.String getAlgorithm()

public final java.security.Provider getProvider()

public final void init(
int)

public final void init(
int
java.security.SecureRandom)

public final void init(
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/InvalidAlgorithmParameterException; )
public final void init(
java.security.spec.AlgorithmParameterSpec)
@dalvik.annotation.Throws (value =Ljava/security/InvalidAlgorithmParameterException; )
public final void init(
java.security.spec.AlgorithmParameterSpec
java.security.SecureRandom)

________________CLASS________________


public abstract class javax.crypto.KeyGeneratorSpi extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

protected abstract javax.crypto.SecretKey engineGenerateKey()

protected abstract void engineInit(
int
java.security.SecureRandom)

protected abstract void engineInit(
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/InvalidAlgorithmParameterException; )
protected abstract void engineInit(
java.security.spec.AlgorithmParameterSpec
java.security.SecureRandom)

________________CLASS________________


public class javax.crypto.Mac extends java.lang.Object implements java.lang.Cloneable

----------------FIELDS----------------

private static final org.apache.harmony.security.fortress.Engine engine

private final java.lang.String algorithm

private boolean isInitMac

private final java.security.Provider provider

private final javax.crypto.MacSpi spiImpl
----------------METHODS----------------

static void <clinit>()

protected void <init>(
javax.crypto.MacSpi
java.security.Provider
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public static final javax.crypto.Mac getInstance(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/NoSuchProviderException; )
public static final javax.crypto.Mac getInstance(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public static final javax.crypto.Mac getInstance(
java.lang.String
java.security.Provider)
@dalvik.annotation.Throws (value =Ljava/lang/CloneNotSupportedException; )
public final java.lang.Object clone()
@dalvik.annotation.Throws (value =Ljavax/crypto/ShortBufferException;Ljava/lang/IllegalStateException; )
public final void doFinal(
byte[]
int)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalStateException; )
public final byte[] doFinal()
@dalvik.annotation.Throws (value =Ljava/lang/IllegalStateException; )
public final byte[] doFinal(
byte[])

public final java.lang.String getAlgorithm()

public final int getMacLength()

public final java.security.Provider getProvider()
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
public final void init(
java.security.Key)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljava/security/InvalidAlgorithmParameterException; )
public final void init(
java.security.Key
java.security.spec.AlgorithmParameterSpec)

public final void reset()
@dalvik.annotation.Throws (value =Ljava/lang/IllegalStateException; )
public final void update(
byte)

public final void update(
java.nio.ByteBuffer)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalStateException; )
public final void update(
byte[])
@dalvik.annotation.Throws (value =Ljava/lang/IllegalStateException; )
public final void update(
byte[]
int
int)

________________CLASS________________


public class javax.crypto.NoSuchPaddingException extends java.security.GeneralSecurityException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class javax.crypto.NullCipher extends javax.crypto.Cipher

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________


public class javax.crypto.SealedObject extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

protected byte[] encodedParams

private byte[] encryptedContent

private java.lang.String paramsAlg

private java.lang.String sealAlg
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljavax/crypto/IllegalBlockSizeException; )
public void <init>(
java.io.Serializable
javax.crypto.Cipher)

protected void <init>(
javax.crypto.SealedObject)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)

public final java.lang.String getAlgorithm()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException;Ljava/security/NoSuchAlgorithmException;Ljava/security/InvalidKeyException; )
public final java.lang.Object getObject(
java.security.Key)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException;Ljava/security/NoSuchAlgorithmException;Ljava/security/NoSuchProviderException;Ljava/security/InvalidKeyException; )
public final java.lang.Object getObject(
java.security.Key
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException;Ljavax/crypto/IllegalBlockSizeException;Ljavax/crypto/BadPaddingException; )
public final java.lang.Object getObject(
javax.crypto.Cipher)

________________CLASS________________


public abstract interface class javax.crypto.SecretKey extends java.lang.Object implements java.security.Key

----------------FIELDS----------------

public static final long serialVersionUID
----------------METHODS----------------

________________CLASS________________


public class javax.crypto.SecretKeyFactory extends java.lang.Object

----------------FIELDS----------------

private static final org.apache.harmony.security.fortress.Engine engine

private final java.lang.String algorithm

private final java.security.Provider provider

private final javax.crypto.SecretKeyFactorySpi spiImpl
----------------METHODS----------------

static void <clinit>()

protected void <init>(
javax.crypto.SecretKeyFactorySpi
java.security.Provider
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public static final javax.crypto.SecretKeyFactory getInstance(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/NoSuchProviderException; )
public static final javax.crypto.SecretKeyFactory getInstance(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public static final javax.crypto.SecretKeyFactory getInstance(
java.lang.String
java.security.Provider)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidKeySpecException; )
public final javax.crypto.SecretKey generateSecret(
java.security.spec.KeySpec)

public final java.lang.String getAlgorithm()
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidKeySpecException; )
public final java.security.spec.KeySpec getKeySpec(
javax.crypto.SecretKey
java.lang.Class)

public final java.security.Provider getProvider()
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
public final javax.crypto.SecretKey translateKey(
javax.crypto.SecretKey)

________________CLASS________________


public abstract class javax.crypto.SecretKeyFactorySpi extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidKeySpecException; )
protected abstract javax.crypto.SecretKey engineGenerateSecret(
java.security.spec.KeySpec)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidKeySpecException; )
protected abstract java.security.spec.KeySpec engineGetKeySpec(
javax.crypto.SecretKey
java.lang.Class)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
protected abstract javax.crypto.SecretKey engineTranslateKey(
javax.crypto.SecretKey)

________________CLASS________________


public class javax.crypto.ShortBufferException extends java.security.GeneralSecurityException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public abstract interface class javax.crypto.interfaces.DHKey extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract javax.crypto.spec.DHParameterSpec getParams()

________________CLASS________________


public abstract interface class javax.crypto.interfaces.DHPrivateKey extends java.lang.Object implements javax.crypto.interfaces.DHKey, java.security.PrivateKey

----------------FIELDS----------------

public static final long serialVersionUID
----------------METHODS----------------

public abstract java.math.BigInteger getX()

________________CLASS________________


public abstract interface class javax.crypto.interfaces.DHPublicKey extends java.lang.Object implements javax.crypto.interfaces.DHKey, java.security.PublicKey

----------------FIELDS----------------

public static final long serialVersionUID
----------------METHODS----------------

public abstract java.math.BigInteger getY()

________________CLASS________________


public abstract interface class javax.crypto.interfaces.PBEKey extends java.lang.Object implements javax.crypto.SecretKey

----------------FIELDS----------------

public static final long serialVersionUID
----------------METHODS----------------

public abstract int getIterationCount()

public abstract char[] getPassword()

public abstract byte[] getSalt()

________________CLASS________________


public class javax.crypto.spec.DESKeySpec extends java.lang.Object implements java.security.spec.KeySpec

----------------FIELDS----------------

public static final int DES_KEY_LEN

private static final byte[][] SEMIWEAKS

private final byte[] key
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
public void <init>(
byte[])
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
public void <init>(
byte[]
int)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
public static boolean isParityAdjusted(
byte[]
int)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
public static boolean isWeak(
byte[]
int)

public byte[] getKey()

________________CLASS________________


public class javax.crypto.spec.DESedeKeySpec extends java.lang.Object implements java.security.spec.KeySpec

----------------FIELDS----------------

public static final int DES_EDE_KEY_LEN

private final byte[] key
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
public void <init>(
byte[])
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
public void <init>(
byte[]
int)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
public static boolean isParityAdjusted(
byte[]
int)

public byte[] getKey()

________________CLASS________________


public class javax.crypto.spec.DHGenParameterSpec extends java.lang.Object implements java.security.spec.AlgorithmParameterSpec

----------------FIELDS----------------

private final int exponentSize

private final int primeSize
----------------METHODS----------------

public void <init>(
int
int)

public int getExponentSize()

public int getPrimeSize()

________________CLASS________________


public class javax.crypto.spec.DHParameterSpec extends java.lang.Object implements java.security.spec.AlgorithmParameterSpec

----------------FIELDS----------------

private final java.math.BigInteger g

private final int l

private final java.math.BigInteger p
----------------METHODS----------------

public void <init>(
java.math.BigInteger
java.math.BigInteger)

public void <init>(
java.math.BigInteger
java.math.BigInteger
int)

public java.math.BigInteger getG()

public int getL()

public java.math.BigInteger getP()

________________CLASS________________


public class javax.crypto.spec.DHPrivateKeySpec extends java.lang.Object implements java.security.spec.KeySpec

----------------FIELDS----------------

private final java.math.BigInteger g

private final java.math.BigInteger p

private final java.math.BigInteger x
----------------METHODS----------------

public void <init>(
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger)

public java.math.BigInteger getG()

public java.math.BigInteger getP()

public java.math.BigInteger getX()

________________CLASS________________


public class javax.crypto.spec.DHPublicKeySpec extends java.lang.Object implements java.security.spec.KeySpec

----------------FIELDS----------------

private final java.math.BigInteger g

private final java.math.BigInteger p

private final java.math.BigInteger y
----------------METHODS----------------

public void <init>(
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger)

public java.math.BigInteger getG()

public java.math.BigInteger getP()

public java.math.BigInteger getY()

________________CLASS________________


public class javax.crypto.spec.IvParameterSpec extends java.lang.Object implements java.security.spec.AlgorithmParameterSpec

----------------FIELDS----------------

private final byte[] iv
----------------METHODS----------------

public void <init>(
byte[])

public void <init>(
byte[]
int
int)

public byte[] getIV()

________________CLASS________________


public class javax.crypto.spec.OAEPParameterSpec extends java.lang.Object implements java.security.spec.AlgorithmParameterSpec

----------------FIELDS----------------

public static final javax.crypto.spec.OAEPParameterSpec DEFAULT

private final java.lang.String mdName

private final java.lang.String mgfName

private final java.security.spec.AlgorithmParameterSpec mgfSpec

private final javax.crypto.spec.PSource pSrc
----------------METHODS----------------

static void <clinit>()

private void <init>()

public void <init>(
java.lang.String
java.lang.String
java.security.spec.AlgorithmParameterSpec
javax.crypto.spec.PSource)

public java.lang.String getDigestAlgorithm()

public java.lang.String getMGFAlgorithm()

public java.security.spec.AlgorithmParameterSpec getMGFParameters()

public javax.crypto.spec.PSource getPSource()

________________CLASS________________


public class javax.crypto.spec.PBEKeySpec extends java.lang.Object implements java.security.spec.KeySpec

----------------FIELDS----------------

private final int iterationCount

private final int keyLength

private char[] password

private final byte[] salt
----------------METHODS----------------

public void <init>(
char[])

public void <init>(
char[]
byte[]
int)

public void <init>(
char[]
byte[]
int
int)

public final void clearPassword()

public final int getIterationCount()

public final int getKeyLength()

public final char[] getPassword()

public final byte[] getSalt()

________________CLASS________________


public class javax.crypto.spec.PBEParameterSpec extends java.lang.Object implements java.security.spec.AlgorithmParameterSpec

----------------FIELDS----------------

private final int iterationCount

private final byte[] salt
----------------METHODS----------------

public void <init>(
byte[]
int)

public int getIterationCount()

public byte[] getSalt()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljavax/crypto/spec/PSource$PSpecified; )
public class javax.crypto.spec.PSource extends java.lang.Object

----------------FIELDS----------------

private java.lang.String pSrcName
----------------METHODS----------------

private void <init>()

protected void <init>(
java.lang.String)

public java.lang.String getAlgorithm()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljavax/crypto/spec/PSource; )
@dalvik.annotation.InnerClass (accessFlags =25 name =PSpecified )
public final class javax.crypto.spec.PSource$PSpecified extends javax.crypto.spec.PSource

----------------FIELDS----------------

public static final javax.crypto.spec.PSource$PSpecified DEFAULT

private final byte[] p
----------------METHODS----------------

static void <clinit>()

private void <init>()

public void <init>(
byte[])

public byte[] getValue()

________________CLASS________________


public class javax.crypto.spec.RC2ParameterSpec extends java.lang.Object implements java.security.spec.AlgorithmParameterSpec

----------------FIELDS----------------

private final int effectiveKeyBits

private final byte[] iv
----------------METHODS----------------

public void <init>(
int)

public void <init>(
int
byte[])

public void <init>(
int
byte[]
int)

public boolean equals(
java.lang.Object)

public int getEffectiveKeyBits()

public byte[] getIV()

public int hashCode()

________________CLASS________________


public class javax.crypto.spec.RC5ParameterSpec extends java.lang.Object implements java.security.spec.AlgorithmParameterSpec

----------------FIELDS----------------

private final byte[] iv

private final int rounds

private final int version

private final int wordSize
----------------METHODS----------------

public void <init>(
int
int
int)

public void <init>(
int
int
int
byte[])

public void <init>(
int
int
int
byte[]
int)

public boolean equals(
java.lang.Object)

public byte[] getIV()

public int getRounds()

public int getVersion()

public int getWordSize()

public int hashCode()

________________CLASS________________


public class javax.crypto.spec.SecretKeySpec extends java.lang.Object implements javax.crypto.SecretKey, java.security.spec.KeySpec, java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

private final java.lang.String algorithm

private final java.lang.String format

private final byte[] key
----------------METHODS----------------

public void <init>(
byte[]
int
int
java.lang.String)

public void <init>(
byte[]
java.lang.String)

public boolean equals(
java.lang.Object)

public java.lang.String getAlgorithm()

public byte[] getEncoded()

public java.lang.String getFormat()

public int hashCode()

________________CLASS________________


public abstract class javax.net.ServerSocketFactory extends java.lang.Object

----------------FIELDS----------------

static javax.net.ServerSocketFactory defaultFactory
----------------METHODS----------------

protected void <init>()

public static javax.net.ServerSocketFactory getDefault()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.net.ServerSocket createServerSocket()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract java.net.ServerSocket createServerSocket(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract java.net.ServerSocket createServerSocket(
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract java.net.ServerSocket createServerSocket(
int
int
java.net.InetAddress)

________________CLASS________________


 class javax.net.DefaultServerSocketFactory extends javax.net.ServerSocketFactory

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.net.ServerSocket createServerSocket(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.net.ServerSocket createServerSocket(
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.net.ServerSocket createServerSocket(
int
int
java.net.InetAddress)

________________CLASS________________


public abstract class javax.net.SocketFactory extends java.lang.Object

----------------FIELDS----------------

static javax.net.SocketFactory defaultFactory
----------------METHODS----------------

protected void <init>()

public static javax.net.SocketFactory getDefault()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.net.Socket createSocket()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/net/UnknownHostException; )
public abstract java.net.Socket createSocket(
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/net/UnknownHostException; )
public abstract java.net.Socket createSocket(
java.lang.String
int
java.net.InetAddress
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract java.net.Socket createSocket(
java.net.InetAddress
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract java.net.Socket createSocket(
java.net.InetAddress
int
java.net.InetAddress
int)

________________CLASS________________


 class javax.net.DefaultSocketFactory extends javax.net.SocketFactory

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.net.Socket createSocket()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/net/UnknownHostException; )
public java.net.Socket createSocket(
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/net/UnknownHostException; )
public java.net.Socket createSocket(
java.lang.String
int
java.net.InetAddress
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.net.Socket createSocket(
java.net.InetAddress
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.net.Socket createSocket(
java.net.InetAddress
int
java.net.InetAddress
int)

________________CLASS________________


public abstract interface class javax.net.ssl.ManagerFactoryParameters extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________


public class javax.net.ssl.CertPathTrustManagerParameters extends java.lang.Object implements javax.net.ssl.ManagerFactoryParameters

----------------FIELDS----------------

private java.security.cert.CertPathParameters param
----------------METHODS----------------

public void <init>(
java.security.cert.CertPathParameters)

public java.security.cert.CertPathParameters getParameters()

________________CLASS________________


public class javax.net.ssl.SSLContext extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.String SERVICE

private static org.apache.harmony.security.fortress.Engine engine

private final java.lang.String protocol

private final java.security.Provider provider

private final javax.net.ssl.SSLContextSpi spiImpl
----------------METHODS----------------

static void <clinit>()

protected void <init>(
javax.net.ssl.SSLContextSpi
java.security.Provider
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public static javax.net.ssl.SSLContext getInstance(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/NoSuchProviderException; )
public static javax.net.ssl.SSLContext getInstance(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public static javax.net.ssl.SSLContext getInstance(
java.lang.String
java.security.Provider)

public final javax.net.ssl.SSLEngine createSSLEngine()

public final javax.net.ssl.SSLEngine createSSLEngine(
java.lang.String
int)

public final javax.net.ssl.SSLSessionContext getClientSessionContext()

public final java.lang.String getProtocol()

public final java.security.Provider getProvider()

public final javax.net.ssl.SSLSessionContext getServerSessionContext()

public final javax.net.ssl.SSLServerSocketFactory getServerSocketFactory()

public final javax.net.ssl.SSLSocketFactory getSocketFactory()
@dalvik.annotation.Throws (value =Ljava/security/KeyManagementException; )
public final void init(
javax.net.ssl.KeyManager[]
javax.net.ssl.TrustManager[]
java.security.SecureRandom)

________________CLASS________________


 class javax.net.ssl.ContextImpl extends javax.net.ssl.SSLContext

----------------FIELDS----------------
----------------METHODS----------------

public void <init>(
javax.net.ssl.SSLContextSpi
java.security.Provider
java.lang.String)

________________CLASS________________


public abstract interface class javax.net.ssl.HostnameVerifier extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract boolean verify(
java.lang.String
javax.net.ssl.SSLSession)

________________CLASS________________


 class javax.net.ssl.DefaultHostnameVerifier extends java.lang.Object implements javax.net.ssl.HostnameVerifier

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public boolean verify(
java.lang.String
javax.net.ssl.SSLSession)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljavax/net/ssl/SSLContext;>; )
final class javax.net.ssl.DefaultSSLContext$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public volatile java.lang.Object run()

public javax.net.ssl.SSLContext run()

________________CLASS________________


 class javax.net.ssl.DefaultSSLContext extends java.lang.Object

----------------FIELDS----------------

private static javax.net.ssl.SSLContext defaultSSLContext
----------------METHODS----------------

 void <init>()

static javax.net.ssl.SSLContext access$000()

private static javax.net.ssl.SSLContext findDefault()

public static javax.net.ssl.SSLContext getContext()

________________CLASS________________


public abstract class javax.net.ssl.SSLServerSocketFactory extends javax.net.ServerSocketFactory

----------------FIELDS----------------

private static java.lang.String defaultName

private static javax.net.ServerSocketFactory defaultServerSocketFactory
----------------METHODS----------------

protected void <init>()

static java.lang.String access$000()

static java.lang.String access$002(
java.lang.String)

static javax.net.ServerSocketFactory access$102(
javax.net.ServerSocketFactory)

public static javax.net.ServerSocketFactory getDefault()

public abstract java.lang.String[] getDefaultCipherSuites()

public abstract java.lang.String[] getSupportedCipherSuites()

________________CLASS________________


 class javax.net.ssl.DefaultSSLServerSocketFactory extends javax.net.ssl.SSLServerSocketFactory

----------------FIELDS----------------

private java.lang.String errMessage
----------------METHODS----------------

 void <init>(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.net.ServerSocket createServerSocket(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.net.ServerSocket createServerSocket(
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.net.ServerSocket createServerSocket(
int
int
java.net.InetAddress)

public java.lang.String[] getDefaultCipherSuites()

public java.lang.String[] getSupportedCipherSuites()

________________CLASS________________


public abstract class javax.net.ssl.SSLSocketFactory extends javax.net.SocketFactory

----------------FIELDS----------------

private static java.lang.String defaultName

private static javax.net.SocketFactory defaultSocketFactory
----------------METHODS----------------

public void <init>()

static java.lang.String access$000()

static java.lang.String access$002(
java.lang.String)

static javax.net.SocketFactory access$102(
javax.net.SocketFactory)

public static javax.net.SocketFactory getDefault()

private static void log(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract java.net.Socket createSocket(
java.net.Socket
java.lang.String
int
boolean)

public abstract java.lang.String[] getDefaultCipherSuites()

public abstract java.lang.String[] getSupportedCipherSuites()

________________CLASS________________


 class javax.net.ssl.DefaultSSLSocketFactory extends javax.net.ssl.SSLSocketFactory

----------------FIELDS----------------

private java.lang.String errMessage
----------------METHODS----------------

 void <init>(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/net/UnknownHostException; )
public java.net.Socket createSocket(
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/net/UnknownHostException; )
public java.net.Socket createSocket(
java.lang.String
int
java.net.InetAddress
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.net.Socket createSocket(
java.net.InetAddress
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.net.Socket createSocket(
java.net.InetAddress
int
java.net.InetAddress
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.net.Socket createSocket(
java.net.Socket
java.lang.String
int
boolean)

public java.lang.String[] getDefaultCipherSuites()

public java.lang.String[] getSupportedCipherSuites()

________________CLASS________________


public class javax.net.ssl.HandshakeCompletedEvent extends java.util.EventObject implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

private transient javax.net.ssl.SSLSession session
----------------METHODS----------------

public void <init>(
javax.net.ssl.SSLSocket
javax.net.ssl.SSLSession)

public java.lang.String getCipherSuite()

public java.security.cert.Certificate[] getLocalCertificates()

public java.security.Principal getLocalPrincipal()
@dalvik.annotation.Throws (value =Ljavax/net/ssl/SSLPeerUnverifiedException; )
public javax.security.cert.X509Certificate[] getPeerCertificateChain()
@dalvik.annotation.Throws (value =Ljavax/net/ssl/SSLPeerUnverifiedException; )
public java.security.cert.Certificate[] getPeerCertificates()
@dalvik.annotation.Throws (value =Ljavax/net/ssl/SSLPeerUnverifiedException; )
public java.security.Principal getPeerPrincipal()

public javax.net.ssl.SSLSession getSession()

public javax.net.ssl.SSLSocket getSocket()

________________CLASS________________


public abstract interface class javax.net.ssl.HandshakeCompletedListener extends java.lang.Object implements java.util.EventListener

----------------FIELDS----------------
----------------METHODS----------------

public abstract void handshakeCompleted(
javax.net.ssl.HandshakeCompletedEvent)

________________CLASS________________


public abstract class javax.net.ssl.HttpsURLConnection extends java.net.HttpURLConnection

----------------FIELDS----------------

private static javax.net.ssl.HostnameVerifier defaultHostnameVerifier

private static javax.net.ssl.SSLSocketFactory defaultSSLSocketFactory

private static javax.net.ssl.SSLSocketFactory socketFactory

protected javax.net.ssl.HostnameVerifier hostnameVerifier
----------------METHODS----------------

static void <clinit>()

protected void <init>(
java.net.URL)

public static javax.net.ssl.HostnameVerifier getDefaultHostnameVerifier()

public static javax.net.ssl.SSLSocketFactory getDefaultSSLSocketFactory()

public static void setDefaultHostnameVerifier(
javax.net.ssl.HostnameVerifier)

public static void setDefaultSSLSocketFactory(
javax.net.ssl.SSLSocketFactory)

public abstract java.lang.String getCipherSuite()

public javax.net.ssl.HostnameVerifier getHostnameVerifier()

public abstract java.security.cert.Certificate[] getLocalCertificates()

public java.security.Principal getLocalPrincipal()
@dalvik.annotation.Throws (value =Ljavax/net/ssl/SSLPeerUnverifiedException; )
public java.security.Principal getPeerPrincipal()

public javax.net.ssl.SSLSocketFactory getSSLSocketFactory()
@dalvik.annotation.Throws (value =Ljavax/net/ssl/SSLPeerUnverifiedException; )
public abstract java.security.cert.Certificate[] getServerCertificates()

public void setHostnameVerifier(
javax.net.ssl.HostnameVerifier)

public void setSSLSocketFactory(
javax.net.ssl.SSLSocketFactory)

________________CLASS________________


public abstract interface class javax.net.ssl.KeyManager extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/String;>; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
final class javax.net.ssl.KeyManagerFactory$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public volatile java.lang.Object run()

public java.lang.String run()

________________CLASS________________


public class javax.net.ssl.KeyManagerFactory extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.String PROPERTY_NAME

private static final java.lang.String SERVICE

private static org.apache.harmony.security.fortress.Engine engine

private final java.lang.String algorithm

private final java.security.Provider provider

private final javax.net.ssl.KeyManagerFactorySpi spiImpl
----------------METHODS----------------

static void <clinit>()

protected void <init>(
javax.net.ssl.KeyManagerFactorySpi
java.security.Provider
java.lang.String)

public static final java.lang.String getDefaultAlgorithm()
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public static final javax.net.ssl.KeyManagerFactory getInstance(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/NoSuchProviderException; )
public static final javax.net.ssl.KeyManagerFactory getInstance(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public static final javax.net.ssl.KeyManagerFactory getInstance(
java.lang.String
java.security.Provider)

public final java.lang.String getAlgorithm()

public final javax.net.ssl.KeyManager[] getKeyManagers()

public final java.security.Provider getProvider()
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException;Ljava/security/NoSuchAlgorithmException;Ljava/security/UnrecoverableKeyException; )
public final void init(
java.security.KeyStore
char[])
@dalvik.annotation.Throws (value =Ljava/security/InvalidAlgorithmParameterException; )
public final void init(
javax.net.ssl.ManagerFactoryParameters)

________________CLASS________________


public abstract class javax.net.ssl.KeyManagerFactorySpi extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

protected abstract javax.net.ssl.KeyManager[] engineGetKeyManagers()
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException;Ljava/security/NoSuchAlgorithmException;Ljava/security/UnrecoverableKeyException; )
protected abstract void engineInit(
java.security.KeyStore
char[])
@dalvik.annotation.Throws (value =Ljava/security/InvalidAlgorithmParameterException; )
protected abstract void engineInit(
javax.net.ssl.ManagerFactoryParameters)

________________CLASS________________


public class javax.net.ssl.KeyStoreBuilderParameters extends java.lang.Object implements javax.net.ssl.ManagerFactoryParameters

----------------FIELDS----------------

private java.util.List ksbuilders
----------------METHODS----------------

public void <init>(
java.security.KeyStore$Builder)

public void <init>(
java.util.List)

public java.util.List getParameters()

________________CLASS________________


public abstract class javax.net.ssl.SSLContextSpi extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

protected abstract javax.net.ssl.SSLEngine engineCreateSSLEngine()

protected abstract javax.net.ssl.SSLEngine engineCreateSSLEngine(
java.lang.String
int)

protected abstract javax.net.ssl.SSLSessionContext engineGetClientSessionContext()

protected abstract javax.net.ssl.SSLSessionContext engineGetServerSessionContext()

protected abstract javax.net.ssl.SSLServerSocketFactory engineGetServerSocketFactory()

protected abstract javax.net.ssl.SSLSocketFactory engineGetSocketFactory()
@dalvik.annotation.Throws (value =Ljava/security/KeyManagementException; )
protected abstract void engineInit(
javax.net.ssl.KeyManager[]
javax.net.ssl.TrustManager[]
java.security.SecureRandom)

________________CLASS________________


public abstract class javax.net.ssl.SSLEngine extends java.lang.Object

----------------FIELDS----------------

private final java.lang.String host

private final int port
----------------METHODS----------------

protected void <init>()

protected void <init>(
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljavax/net/ssl/SSLException; )
public abstract void beginHandshake()
@dalvik.annotation.Throws (value =Ljavax/net/ssl/SSLException; )
public abstract void closeInbound()

public abstract void closeOutbound()

public abstract java.lang.Runnable getDelegatedTask()

public abstract boolean getEnableSessionCreation()

public abstract java.lang.String[] getEnabledCipherSuites()

public abstract java.lang.String[] getEnabledProtocols()

public abstract javax.net.ssl.SSLEngineResult$HandshakeStatus getHandshakeStatus()

public abstract boolean getNeedClientAuth()

public java.lang.String getPeerHost()

public int getPeerPort()

public abstract javax.net.ssl.SSLSession getSession()

public abstract java.lang.String[] getSupportedCipherSuites()

public abstract java.lang.String[] getSupportedProtocols()

public abstract boolean getUseClientMode()

public abstract boolean getWantClientAuth()

public abstract boolean isInboundDone()

public abstract boolean isOutboundDone()

public abstract void setEnableSessionCreation(
boolean)

public abstract void setEnabledCipherSuites(
java.lang.String[])

public abstract void setEnabledProtocols(
java.lang.String[])

public abstract void setNeedClientAuth(
boolean)

public abstract void setUseClientMode(
boolean)

public abstract void setWantClientAuth(
boolean)
@dalvik.annotation.Throws (value =Ljavax/net/ssl/SSLException; )
public javax.net.ssl.SSLEngineResult unwrap(
java.nio.ByteBuffer
java.nio.ByteBuffer)
@dalvik.annotation.Throws (value =Ljavax/net/ssl/SSLException; )
public javax.net.ssl.SSLEngineResult unwrap(
java.nio.ByteBuffer
java.nio.ByteBuffer[])
@dalvik.annotation.Throws (value =Ljavax/net/ssl/SSLException; )
public abstract javax.net.ssl.SSLEngineResult unwrap(
java.nio.ByteBuffer
java.nio.ByteBuffer[]
int
int)
@dalvik.annotation.Throws (value =Ljavax/net/ssl/SSLException; )
public javax.net.ssl.SSLEngineResult wrap(
java.nio.ByteBuffer
java.nio.ByteBuffer)
@dalvik.annotation.Throws (value =Ljavax/net/ssl/SSLException; )
public abstract javax.net.ssl.SSLEngineResult wrap(
java.nio.ByteBuffer[]
int
int
java.nio.ByteBuffer)
@dalvik.annotation.Throws (value =Ljavax/net/ssl/SSLException; )
public javax.net.ssl.SSLEngineResult wrap(
java.nio.ByteBuffer[]
java.nio.ByteBuffer)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =16409 name =HandshakeStatus )
@dalvik.annotation.EnclosingClass (value =Ljavax/net/ssl/SSLEngineResult; )
@dalvik.annotation.Signature (value =Ljava/lang/Enum<Ljavax/net/ssl/SSLEngineResult$HandshakeStatus;>; )
public final class javax.net.ssl.SSLEngineResult$HandshakeStatus extends java.lang.Enum

----------------FIELDS----------------

private static final javax.net.ssl.SSLEngineResult$HandshakeStatus[] $VALUES

public static final javax.net.ssl.SSLEngineResult$HandshakeStatus FINISHED

public static final javax.net.ssl.SSLEngineResult$HandshakeStatus NEED_TASK

public static final javax.net.ssl.SSLEngineResult$HandshakeStatus NEED_UNWRAP

public static final javax.net.ssl.SSLEngineResult$HandshakeStatus NEED_WRAP

public static final javax.net.ssl.SSLEngineResult$HandshakeStatus NOT_HANDSHAKING
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Signature (value =()V )
private void <init>(
java.lang.String
int)

public static javax.net.ssl.SSLEngineResult$HandshakeStatus valueOf(
java.lang.String)

public static javax.net.ssl.SSLEngineResult$HandshakeStatus[] values()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =16409 name =Status )
@dalvik.annotation.Signature (value =Ljava/lang/Enum<Ljavax/net/ssl/SSLEngineResult$Status;>; )
@dalvik.annotation.EnclosingClass (value =Ljavax/net/ssl/SSLEngineResult; )
public final class javax.net.ssl.SSLEngineResult$Status extends java.lang.Enum

----------------FIELDS----------------

private static final javax.net.ssl.SSLEngineResult$Status[] $VALUES

public static final javax.net.ssl.SSLEngineResult$Status BUFFER_OVERFLOW

public static final javax.net.ssl.SSLEngineResult$Status BUFFER_UNDERFLOW

public static final javax.net.ssl.SSLEngineResult$Status CLOSED

public static final javax.net.ssl.SSLEngineResult$Status OK
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Signature (value =()V )
private void <init>(
java.lang.String
int)

public static javax.net.ssl.SSLEngineResult$Status valueOf(
java.lang.String)

public static javax.net.ssl.SSLEngineResult$Status[] values()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljavax/net/ssl/SSLEngineResult$Status;Ljavax/net/ssl/SSLEngineResult$HandshakeStatus; )
public class javax.net.ssl.SSLEngineResult extends java.lang.Object

----------------FIELDS----------------

private final int bytesConsumed

private final int bytesProduced

private final javax.net.ssl.SSLEngineResult$HandshakeStatus handshakeStatus

private final javax.net.ssl.SSLEngineResult$Status status
----------------METHODS----------------

public void <init>(
javax.net.ssl.SSLEngineResult$Status
javax.net.ssl.SSLEngineResult$HandshakeStatus
int
int)

public final int bytesConsumed()

public final int bytesProduced()

public final javax.net.ssl.SSLEngineResult$HandshakeStatus getHandshakeStatus()

public final javax.net.ssl.SSLEngineResult$Status getStatus()

public java.lang.String toString()

________________CLASS________________


public class javax.net.ssl.SSLException extends java.io.IOException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.Throwable)

public void <init>(
java.lang.Throwable)

________________CLASS________________


public class javax.net.ssl.SSLHandshakeException extends javax.net.ssl.SSLException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>(
java.lang.String)

________________CLASS________________


public class javax.net.ssl.SSLKeyException extends javax.net.ssl.SSLException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>(
java.lang.String)

________________CLASS________________


public class javax.net.ssl.SSLPeerUnverifiedException extends javax.net.ssl.SSLException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>(
java.lang.String)

________________CLASS________________


public final class javax.net.ssl.SSLPermission extends java.security.BasicPermission

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.String)

________________CLASS________________


public class javax.net.ssl.SSLProtocolException extends javax.net.ssl.SSLException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>(
java.lang.String)

________________CLASS________________


public abstract class javax.net.ssl.SSLServerSocket extends java.net.ServerSocket

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void <init>(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void <init>(
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void <init>(
int
int
java.net.InetAddress)

public abstract boolean getEnableSessionCreation()

public abstract java.lang.String[] getEnabledCipherSuites()

public abstract java.lang.String[] getEnabledProtocols()

public abstract boolean getNeedClientAuth()

public abstract java.lang.String[] getSupportedCipherSuites()

public abstract java.lang.String[] getSupportedProtocols()

public abstract boolean getUseClientMode()

public abstract boolean getWantClientAuth()

public abstract void setEnableSessionCreation(
boolean)

public abstract void setEnabledCipherSuites(
java.lang.String[])

public abstract void setEnabledProtocols(
java.lang.String[])

public abstract void setNeedClientAuth(
boolean)

public abstract void setUseClientMode(
boolean)

public abstract void setWantClientAuth(
boolean)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
final class javax.net.ssl.SSLServerSocketFactory$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public java.lang.Object run()

________________CLASS________________


public abstract interface class javax.net.ssl.SSLSession extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract int getApplicationBufferSize()

public abstract java.lang.String getCipherSuite()

public abstract long getCreationTime()

public abstract byte[] getId()

public abstract long getLastAccessedTime()

public abstract java.security.cert.Certificate[] getLocalCertificates()

public abstract java.security.Principal getLocalPrincipal()

public abstract int getPacketBufferSize()
@dalvik.annotation.Throws (value =Ljavax/net/ssl/SSLPeerUnverifiedException; )
public abstract javax.security.cert.X509Certificate[] getPeerCertificateChain()
@dalvik.annotation.Throws (value =Ljavax/net/ssl/SSLPeerUnverifiedException; )
public abstract java.security.cert.Certificate[] getPeerCertificates()

public abstract java.lang.String getPeerHost()

public abstract int getPeerPort()
@dalvik.annotation.Throws (value =Ljavax/net/ssl/SSLPeerUnverifiedException; )
public abstract java.security.Principal getPeerPrincipal()

public abstract java.lang.String getProtocol()

public abstract javax.net.ssl.SSLSessionContext getSessionContext()

public abstract java.lang.Object getValue(
java.lang.String)

public abstract java.lang.String[] getValueNames()

public abstract void invalidate()

public abstract boolean isValid()

public abstract void putValue(
java.lang.String
java.lang.Object)

public abstract void removeValue(
java.lang.String)

________________CLASS________________


public class javax.net.ssl.SSLSessionBindingEvent extends java.util.EventObject implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

private java.lang.String name
----------------METHODS----------------

public void <init>(
javax.net.ssl.SSLSession
java.lang.String)

public java.lang.String getName()

public javax.net.ssl.SSLSession getSession()

________________CLASS________________


public abstract interface class javax.net.ssl.SSLSessionBindingListener extends java.lang.Object implements java.util.EventListener

----------------FIELDS----------------
----------------METHODS----------------

public abstract void valueBound(
javax.net.ssl.SSLSessionBindingEvent)

public abstract void valueUnbound(
javax.net.ssl.SSLSessionBindingEvent)

________________CLASS________________


public abstract interface class javax.net.ssl.SSLSessionContext extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.util.Enumeration getIds()

public abstract javax.net.ssl.SSLSession getSession(
byte[])

public abstract int getSessionCacheSize()

public abstract int getSessionTimeout()
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public abstract void setSessionCacheSize(
int)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public abstract void setSessionTimeout(
int)

________________CLASS________________


public abstract class javax.net.ssl.SSLSocket extends java.net.Socket

----------------FIELDS----------------
----------------METHODS----------------

protected void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/net/UnknownHostException; )
protected void <init>(
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/net/UnknownHostException; )
protected void <init>(
java.lang.String
int
java.net.InetAddress
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void <init>(
java.net.InetAddress
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void <init>(
java.net.InetAddress
int
java.net.InetAddress
int)

public abstract void addHandshakeCompletedListener(
javax.net.ssl.HandshakeCompletedListener)

public abstract boolean getEnableSessionCreation()

public abstract java.lang.String[] getEnabledCipherSuites()

public abstract java.lang.String[] getEnabledProtocols()

public abstract boolean getNeedClientAuth()

public abstract javax.net.ssl.SSLSession getSession()

public abstract java.lang.String[] getSupportedCipherSuites()

public abstract java.lang.String[] getSupportedProtocols()

public abstract boolean getUseClientMode()

public abstract boolean getWantClientAuth()

public abstract void removeHandshakeCompletedListener(
javax.net.ssl.HandshakeCompletedListener)

public abstract void setEnableSessionCreation(
boolean)

public abstract void setEnabledCipherSuites(
java.lang.String[])

public abstract void setEnabledProtocols(
java.lang.String[])

public abstract void setNeedClientAuth(
boolean)

public abstract void setUseClientMode(
boolean)

public abstract void setWantClientAuth(
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void startHandshake()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
final class javax.net.ssl.SSLSocketFactory$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public java.lang.Object run()

________________CLASS________________


public abstract interface class javax.net.ssl.TrustManager extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/String;>; )
final class javax.net.ssl.TrustManagerFactory$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public volatile java.lang.Object run()

public java.lang.String run()

________________CLASS________________


public class javax.net.ssl.TrustManagerFactory extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.String PROPERTYNAME

private static final java.lang.String SERVICE

private static org.apache.harmony.security.fortress.Engine engine

private final java.lang.String algorithm

private final java.security.Provider provider

private final javax.net.ssl.TrustManagerFactorySpi spiImpl
----------------METHODS----------------

static void <clinit>()

protected void <init>(
javax.net.ssl.TrustManagerFactorySpi
java.security.Provider
java.lang.String)

public static final java.lang.String getDefaultAlgorithm()
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public static final javax.net.ssl.TrustManagerFactory getInstance(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/NoSuchProviderException; )
public static final javax.net.ssl.TrustManagerFactory getInstance(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public static final javax.net.ssl.TrustManagerFactory getInstance(
java.lang.String
java.security.Provider)

public final java.lang.String getAlgorithm()

public final java.security.Provider getProvider()

public final javax.net.ssl.TrustManager[] getTrustManagers()
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException; )
public final void init(
java.security.KeyStore)
@dalvik.annotation.Throws (value =Ljava/security/InvalidAlgorithmParameterException; )
public final void init(
javax.net.ssl.ManagerFactoryParameters)

________________CLASS________________


public abstract class javax.net.ssl.TrustManagerFactorySpi extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

protected abstract javax.net.ssl.TrustManager[] engineGetTrustManagers()
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException; )
protected abstract void engineInit(
java.security.KeyStore)
@dalvik.annotation.Throws (value =Ljava/security/InvalidAlgorithmParameterException; )
protected abstract void engineInit(
javax.net.ssl.ManagerFactoryParameters)

________________CLASS________________


public abstract interface class javax.net.ssl.X509KeyManager extends java.lang.Object implements javax.net.ssl.KeyManager

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.lang.String chooseClientAlias(
java.lang.String[]
java.security.Principal[]
java.net.Socket)

public abstract java.lang.String chooseServerAlias(
java.lang.String
java.security.Principal[]
java.net.Socket)

public abstract java.security.cert.X509Certificate[] getCertificateChain(
java.lang.String)

public abstract java.lang.String[] getClientAliases(
java.lang.String
java.security.Principal[])

public abstract java.security.PrivateKey getPrivateKey(
java.lang.String)

public abstract java.lang.String[] getServerAliases(
java.lang.String
java.security.Principal[])

________________CLASS________________


public abstract class javax.net.ssl.X509ExtendedKeyManager extends java.lang.Object implements javax.net.ssl.X509KeyManager

----------------FIELDS----------------
----------------METHODS----------------

protected void <init>()

public java.lang.String chooseEngineClientAlias(
java.lang.String[]
java.security.Principal[]
javax.net.ssl.SSLEngine)

public java.lang.String chooseEngineServerAlias(
java.lang.String
java.security.Principal[]
javax.net.ssl.SSLEngine)

________________CLASS________________


public abstract interface class javax.net.ssl.X509TrustManager extends java.lang.Object implements javax.net.ssl.TrustManager

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException; )
public abstract void checkClientTrusted(
java.security.cert.X509Certificate[]
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException; )
public abstract void checkServerTrusted(
java.security.cert.X509Certificate[]
java.lang.String)

public abstract java.security.cert.X509Certificate[] getAcceptedIssuers()

________________CLASS________________


public final class javax.security.auth.AuthPermission extends java.security.BasicPermission

----------------FIELDS----------------

private static final java.lang.String CREATE_LOGIN_CONTEXT

private static final java.lang.String CREATE_LOGIN_CONTEXT_ANY

private static final long serialVersionUID
----------------METHODS----------------

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.String)

private static java.lang.String init(
java.lang.String)

________________CLASS________________


public class javax.security.auth.DestroyFailedException extends java.lang.Exception

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Ljavax/security/auth/PrivateCredentialPermission; )
@dalvik.annotation.InnerClass (accessFlags =26 name =CredOwner )
final class javax.security.auth.PrivateCredentialPermission$CredOwner extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

private transient boolean isClassWildcard

private transient boolean isPNameWildcard

 java.lang.String principalClass

 java.lang.String principalName
----------------METHODS----------------

 void <init>(
java.lang.String
java.lang.String)

public boolean equals(
java.lang.Object)

public int hashCode()

 boolean implies(
java.lang.Object)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljavax/security/auth/PrivateCredentialPermission$CredOwner; )
public final class javax.security.auth.PrivateCredentialPermission extends java.security.Permission

----------------FIELDS----------------

private static final java.lang.String READ

private static final long serialVersionUID

private java.lang.String credentialClass

private transient int offset

private transient javax.security.auth.PrivateCredentialPermission$CredOwner[] set
----------------METHODS----------------

public void <init>(
java.lang.String
java.lang.String)
@dalvik.annotation.Signature (value =(Ljava/lang/String;Ljava/util/Set<Ljava/security/Principal;>;)V )
 void <init>(
java.lang.String
java.util.Set)

private void initTargetName(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)

private boolean sameMembers(
java.lang.Object[]
java.lang.Object[]
int)

public boolean equals(
java.lang.Object)

public java.lang.String getActions()

public java.lang.String getCredentialClass()

public java.lang.String[][] getPrincipals()

public int hashCode()

public boolean implies(
java.security.Permission)

public java.security.PermissionCollection newPermissionCollection()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
final class javax.security.auth.Subject$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final javax.security.auth.SubjectDomainCombiner val$combiner

final java.security.AccessControlContext val$context
----------------METHODS----------------

 void <init>(
java.security.AccessControlContext
javax.security.auth.SubjectDomainCombiner)

public java.lang.Object run()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/security/AccessControlContext;>; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
final class javax.security.auth.Subject$2 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final javax.security.auth.SubjectDomainCombiner val$combiner

final java.security.AccessControlContext val$context
----------------METHODS----------------

 void <init>(
java.security.AccessControlContext
javax.security.auth.SubjectDomainCombiner)

public volatile java.lang.Object run()

public java.security.AccessControlContext run()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/security/DomainCombiner;>; )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class javax.security.auth.Subject$3 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final java.security.AccessControlContext val$context
----------------METHODS----------------

 void <init>(
java.security.AccessControlContext)

public volatile java.lang.Object run()

public java.security.DomainCombiner run()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =2 name =SecureIterator )
@dalvik.annotation.EnclosingClass (value =Ljavax/security/auth/Subject$SecureSet; )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Iterator<TSST;>; )
 class javax.security.auth.Subject$SecureSet$SecureIterator extends java.lang.Object implements java.util.Iterator

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Iterator<TSST;>; )
protected java.util.Iterator iterator

final javax.security.auth.Subject$SecureSet this$1
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/Iterator<TSST;>;)V )
protected void <init>(
javax.security.auth.Subject$SecureSet
java.util.Iterator)

public boolean hasNext()
@dalvik.annotation.Signature (value =()TSST; )
public java.lang.Object next()

public void remove()

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
 class javax.security.auth.Subject$SecureSet$1 extends javax.security.auth.Subject$SecureSet$SecureIterator

----------------FIELDS----------------

final javax.security.auth.Subject$SecureSet this$1
----------------METHODS----------------

 void <init>(
javax.security.auth.Subject$SecureSet
java.util.Iterator)
@dalvik.annotation.Signature (value =()TSST; )
public java.lang.Object next()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.Signature (value =Ljava/util/AbstractSet<TE;>; )
@dalvik.annotation.EnclosingMethod (value =null )
 class javax.security.auth.Subject$SecureSet$2 extends java.util.AbstractSet

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/LinkedList<TE;>; )
private java.util.LinkedList elements

final javax.security.auth.Subject$SecureSet this$1

final java.lang.Class val$c
----------------METHODS----------------

 void <init>(
javax.security.auth.Subject$SecureSet
java.lang.Class)
@dalvik.annotation.Signature (value =(TE;)Z )
public boolean add(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TE;>; )
public java.util.Iterator iterator()
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public boolean retainAll(
java.util.Collection)

public int size()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =18 name =SecureSet )
@dalvik.annotation.Signature (value =<SST:Ljava/lang/Object;>Ljava/util/AbstractSet<TSST;>;Ljava/io/Serializable; )
@dalvik.annotation.MemberClasses (value =Ljavax/security/auth/Subject$SecureSet$SecureIterator; )
@dalvik.annotation.EnclosingClass (value =Ljavax/security/auth/Subject; )
final class javax.security.auth.Subject$SecureSet extends java.util.AbstractSet implements java.io.Serializable

----------------FIELDS----------------

private static final int SET_Principal

private static final int SET_PrivCred

private static final int SET_PubCred

private static final long serialVersionUID
@dalvik.annotation.Signature (value =Ljava/util/LinkedList<TSST;>; )
private java.util.LinkedList elements

private transient javax.security.auth.AuthPermission permission

private int setType

final javax.security.auth.Subject this$0
----------------METHODS----------------

protected void <init>(
javax.security.auth.Subject
javax.security.auth.AuthPermission)
@dalvik.annotation.Signature (value =(Ljavax/security/auth/AuthPermission;Ljava/util/Collection<+TSST;>;)V )
protected void <init>(
javax.security.auth.Subject
javax.security.auth.AuthPermission
java.util.Collection)

static javax.security.auth.AuthPermission access$600(
javax.security.auth.Subject$SecureSet)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)

private void verifyElement(
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)
@dalvik.annotation.Signature (value =(TSST;)Z )
public boolean add(
java.lang.Object)
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>(Ljava/lang/Class<TE;>;)Ljava/util/Set<TE;>; )
protected final java.util.Set get(
java.lang.Class)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TSST;>; )
public java.util.Iterator iterator()
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public boolean retainAll(
java.util.Collection)

public int size()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Ljavax/security/auth/Subject$SecureSet; )
public final class javax.security.auth.Subject extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------

private static final javax.security.auth.AuthPermission _AS

private static final javax.security.auth.AuthPermission _AS_PRIVILEGED

private static final javax.security.auth.AuthPermission _PRINCIPALS

private static final javax.security.auth.AuthPermission _PRIVATE_CREDENTIALS

private static final javax.security.auth.AuthPermission _PUBLIC_CREDENTIALS

private static final javax.security.auth.AuthPermission _READ_ONLY

private static final javax.security.auth.AuthPermission _SUBJECT

private static final long serialVersionUID
@dalvik.annotation.Signature (value =Ljava/util/Set<Ljava/security/Principal;>; )
private final java.util.Set principals
@dalvik.annotation.Signature (value =Ljavax/security/auth/Subject$SecureSet<Ljava/lang/Object;>; )
private transient javax.security.auth.Subject$SecureSet privateCredentials
@dalvik.annotation.Signature (value =Ljavax/security/auth/Subject$SecureSet<Ljava/lang/Object;>; )
private transient javax.security.auth.Subject$SecureSet publicCredentials

private boolean readOnly
----------------METHODS----------------

static void <clinit>()

public void <init>()
@dalvik.annotation.Signature (value =(ZLjava/util/Set<+Ljava/security/Principal;>;Ljava/util/Set<*>;Ljava/util/Set<*>;)V )
public void <init>(
boolean
java.util.Set
java.util.Set
java.util.Set)

static javax.security.auth.AuthPermission access$000()

static void access$100(
javax.security.auth.Subject)

static void access$200(
java.security.Permission)

static javax.security.auth.AuthPermission access$300()

static java.util.Set access$400(
javax.security.auth.Subject)

static javax.security.auth.AuthPermission access$500()

private static void checkPermission(
java.security.Permission)

private void checkState()

public static java.lang.Object doAs(
javax.security.auth.Subject
java.security.PrivilegedAction)
@dalvik.annotation.Throws (value =Ljava/security/PrivilegedActionException; )
public static java.lang.Object doAs(
javax.security.auth.Subject
java.security.PrivilegedExceptionAction)

public static java.lang.Object doAsPrivileged(
javax.security.auth.Subject
java.security.PrivilegedAction
java.security.AccessControlContext)
@dalvik.annotation.Throws (value =Ljava/security/PrivilegedActionException; )
public static java.lang.Object doAsPrivileged(
javax.security.auth.Subject
java.security.PrivilegedExceptionAction
java.security.AccessControlContext)

private static java.lang.Object doAs_PrivilegedAction(
javax.security.auth.Subject
java.security.PrivilegedAction
java.security.AccessControlContext)
@dalvik.annotation.Throws (value =Ljava/security/PrivilegedActionException; )
private static java.lang.Object doAs_PrivilegedExceptionAction(
javax.security.auth.Subject
java.security.PrivilegedExceptionAction
java.security.AccessControlContext)

public static javax.security.auth.Subject getSubject(
java.security.AccessControlContext)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

public boolean equals(
java.lang.Object)
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/security/Principal;>; )
public java.util.Set getPrincipals()
@dalvik.annotation.Signature (value =<T::Ljava/security/Principal;>(Ljava/lang/Class<TT;>;)Ljava/util/Set<TT;>; )
public java.util.Set getPrincipals(
java.lang.Class)
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/lang/Object;>; )
public java.util.Set getPrivateCredentials()
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/lang/Class<TT;>;)Ljava/util/Set<TT;>; )
public java.util.Set getPrivateCredentials(
java.lang.Class)
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/lang/Object;>; )
public java.util.Set getPublicCredentials()
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>(Ljava/lang/Class<TT;>;)Ljava/util/Set<TT;>; )
public java.util.Set getPublicCredentials(
java.lang.Class)

public int hashCode()

public boolean isReadOnly()

public void setReadOnly()

public java.lang.String toString()

________________CLASS________________


public class javax.security.auth.SubjectDomainCombiner extends java.lang.Object implements java.security.DomainCombiner

----------------FIELDS----------------

private static final javax.security.auth.AuthPermission _GET

private javax.security.auth.Subject subject
----------------METHODS----------------

static void <clinit>()

public void <init>(
javax.security.auth.Subject)

public java.security.ProtectionDomain[] combine(
java.security.ProtectionDomain[]
java.security.ProtectionDomain[])

public javax.security.auth.Subject getSubject()

________________CLASS________________


public abstract interface class javax.security.auth.callback.Callback extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________


public abstract interface class javax.security.auth.callback.CallbackHandler extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljavax/security/auth/callback/UnsupportedCallbackException; )
public abstract void handle(
javax.security.auth.callback.Callback[])

________________CLASS________________


public class javax.security.auth.callback.PasswordCallback extends java.lang.Object implements javax.security.auth.callback.Callback, java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

 boolean echoOn

private char[] inputPassword

private java.lang.String prompt
----------------METHODS----------------

public void <init>(
java.lang.String
boolean)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
private void setPrompt(
java.lang.String)

public void clearPassword()

public char[] getPassword()

public java.lang.String getPrompt()

public boolean isEchoOn()

public void setPassword(
char[])

________________CLASS________________


public class javax.security.auth.callback.UnsupportedCallbackException extends java.lang.Exception

----------------FIELDS----------------

private static final long serialVersionUID

private javax.security.auth.callback.Callback callback
----------------METHODS----------------

public void <init>(
javax.security.auth.callback.Callback)

public void <init>(
javax.security.auth.callback.Callback
java.lang.String)

public javax.security.auth.callback.Callback getCallback()

________________CLASS________________


public class javax.security.auth.login.LoginException extends java.security.GeneralSecurityException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public final class javax.security.auth.x500.X500Principal extends java.lang.Object implements java.io.Serializable, java.security.Principal

----------------FIELDS----------------

public static final java.lang.String CANONICAL

public static final java.lang.String RFC1779

public static final java.lang.String RFC2253

private static final long serialVersionUID

private transient org.apache.harmony.security.x501.Name dn
----------------METHODS----------------

public void <init>(
java.io.InputStream)

public void <init>(
java.lang.String)

public void <init>(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

public boolean equals(
java.lang.Object)

public byte[] getEncoded()

public java.lang.String getName()

public java.lang.String getName(
java.lang.String)

public int hashCode()

public java.lang.String toString()

________________CLASS________________


public abstract class javax.security.cert.Certificate extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public boolean equals(
java.lang.Object)
@dalvik.annotation.Throws (value =Ljavax/security/cert/CertificateEncodingException; )
public abstract byte[] getEncoded()

public abstract java.security.PublicKey getPublicKey()

public int hashCode()

public abstract java.lang.String toString()
@dalvik.annotation.Throws (value =Ljavax/security/cert/CertificateException;Ljava/security/NoSuchAlgorithmException;Ljava/security/InvalidKeyException;Ljava/security/NoSuchProviderException;Ljava/security/SignatureException; )
public abstract void verify(
java.security.PublicKey)
@dalvik.annotation.Throws (value =Ljavax/security/cert/CertificateException;Ljava/security/NoSuchAlgorithmException;Ljava/security/InvalidKeyException;Ljava/security/NoSuchProviderException;Ljava/security/SignatureException; )
public abstract void verify(
java.security.PublicKey
java.lang.String)

________________CLASS________________


public class javax.security.cert.CertificateException extends java.lang.Exception

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class javax.security.cert.CertificateEncodingException extends javax.security.cert.CertificateException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class javax.security.cert.CertificateExpiredException extends javax.security.cert.CertificateException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class javax.security.cert.CertificateNotYetValidException extends javax.security.cert.CertificateException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class javax.security.cert.CertificateParsingException extends javax.security.cert.CertificateException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Ljavax/security/cert/X509Certificate; )
final class javax.security.cert.X509Certificate$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public java.lang.Object run()

________________CLASS________________


public abstract class javax.security.cert.X509Certificate extends javax.security.cert.Certificate

----------------FIELDS----------------

private static java.lang.reflect.Constructor constructor
----------------METHODS----------------

static void <clinit>()

public void <init>()
@dalvik.annotation.Throws (value =Ljavax/security/cert/CertificateException; )
public static final javax.security.cert.X509Certificate getInstance(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljavax/security/cert/CertificateException; )
public static final javax.security.cert.X509Certificate getInstance(
byte[])
@dalvik.annotation.Throws (value =Ljavax/security/cert/CertificateExpiredException;Ljavax/security/cert/CertificateNotYetValidException; )
public abstract void checkValidity()
@dalvik.annotation.Throws (value =Ljavax/security/cert/CertificateExpiredException;Ljavax/security/cert/CertificateNotYetValidException; )
public abstract void checkValidity(
java.util.Date)

public abstract java.security.Principal getIssuerDN()

public abstract java.util.Date getNotAfter()

public abstract java.util.Date getNotBefore()

public abstract java.math.BigInteger getSerialNumber()

public abstract java.lang.String getSigAlgName()

public abstract java.lang.String getSigAlgOID()

public abstract byte[] getSigAlgParams()

public abstract java.security.Principal getSubjectDN()

public abstract int getVersion()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
final class javax.security.cert.X509Certificate$2 extends javax.security.cert.X509Certificate

----------------FIELDS----------------

final java.security.cert.X509Certificate val$cert
----------------METHODS----------------

 void <init>(
java.security.cert.X509Certificate)
@dalvik.annotation.Throws (value =Ljavax/security/cert/CertificateExpiredException;Ljavax/security/cert/CertificateNotYetValidException; )
public void checkValidity()
@dalvik.annotation.Throws (value =Ljavax/security/cert/CertificateExpiredException;Ljavax/security/cert/CertificateNotYetValidException; )
public void checkValidity(
java.util.Date)
@dalvik.annotation.Throws (value =Ljavax/security/cert/CertificateEncodingException; )
public byte[] getEncoded()

public java.security.Principal getIssuerDN()

public java.util.Date getNotAfter()

public java.util.Date getNotBefore()

public java.security.PublicKey getPublicKey()

public java.math.BigInteger getSerialNumber()

public java.lang.String getSigAlgName()

public java.lang.String getSigAlgOID()

public byte[] getSigAlgParams()

public java.security.Principal getSubjectDN()

public int getVersion()

public java.lang.String toString()
@dalvik.annotation.Throws (value =Ljavax/security/cert/CertificateException;Ljava/security/NoSuchAlgorithmException;Ljava/security/InvalidKeyException;Ljava/security/NoSuchProviderException;Ljava/security/SignatureException; )
public void verify(
java.security.PublicKey)
@dalvik.annotation.Throws (value =Ljavax/security/cert/CertificateException;Ljava/security/NoSuchAlgorithmException;Ljava/security/InvalidKeyException;Ljava/security/NoSuchProviderException;Ljava/security/SignatureException; )
public void verify(
java.security.PublicKey
java.lang.String)

________________CLASS________________


public class javax.sql.ConnectionEvent extends java.util.EventObject implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID

private java.sql.SQLException theSQLException
----------------METHODS----------------

public void <init>(
javax.sql.PooledConnection)

public void <init>(
javax.sql.PooledConnection
java.sql.SQLException)

public java.sql.SQLException getSQLException()

________________CLASS________________


public abstract interface class javax.sql.ConnectionEventListener extends java.lang.Object implements java.util.EventListener

----------------FIELDS----------------
----------------METHODS----------------

public abstract void connectionClosed(
javax.sql.ConnectionEvent)

public abstract void connectionErrorOccurred(
javax.sql.ConnectionEvent)

________________CLASS________________


public abstract interface class javax.sql.ConnectionPoolDataSource extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.io.PrintWriter getLogWriter()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getLoginTimeout()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract javax.sql.PooledConnection getPooledConnection()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract javax.sql.PooledConnection getPooledConnection(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setLogWriter(
java.io.PrintWriter)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setLoginTimeout(
int)

________________CLASS________________


public abstract interface class javax.sql.DataSource extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Connection getConnection()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Connection getConnection(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.io.PrintWriter getLogWriter()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getLoginTimeout()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setLogWriter(
java.io.PrintWriter)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setLoginTimeout(
int)

________________CLASS________________


public abstract interface class javax.sql.PooledConnection extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract void addConnectionEventListener(
javax.sql.ConnectionEventListener)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void close()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Connection getConnection()

public abstract void removeConnectionEventListener(
javax.sql.ConnectionEventListener)

________________CLASS________________


public abstract interface class javax.sql.RowSet extends java.lang.Object implements java.sql.ResultSet

----------------FIELDS----------------
----------------METHODS----------------

public abstract void addRowSetListener(
javax.sql.RowSetListener)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void clearParameters()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void execute()

public abstract java.lang.String getCommand()

public abstract java.lang.String getDataSourceName()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean getEscapeProcessing()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getMaxFieldSize()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getMaxRows()

public abstract java.lang.String getPassword()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract int getQueryTimeout()

public abstract int getTransactionIsolation()
@dalvik.annotation.Signature (value =()Ljava/util/Map<Ljava/lang/String;Ljava/lang/Class<*>;>; )
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.util.Map getTypeMap()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.String getUrl()

public abstract java.lang.String getUsername()

public abstract boolean isReadOnly()

public abstract void removeRowSetListener(
javax.sql.RowSetListener)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setArray(
int
java.sql.Array)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setAsciiStream(
int
java.io.InputStream
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setBigDecimal(
int
java.math.BigDecimal)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setBinaryStream(
int
java.io.InputStream
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setBlob(
int
java.sql.Blob)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setBoolean(
int
boolean)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setByte(
int
byte)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setBytes(
int
byte[])
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setCharacterStream(
int
java.io.Reader
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setClob(
int
java.sql.Clob)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setCommand(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setConcurrency(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setDataSourceName(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setDate(
int
java.sql.Date)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setDate(
int
java.sql.Date
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setDouble(
int
double)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setEscapeProcessing(
boolean)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setFloat(
int
float)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setInt(
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setLong(
int
long)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setMaxFieldSize(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setMaxRows(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setNull(
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setNull(
int
int
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setObject(
int
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setObject(
int
java.lang.Object
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setObject(
int
java.lang.Object
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setPassword(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setQueryTimeout(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setReadOnly(
boolean)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setRef(
int
java.sql.Ref)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setShort(
int
short)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setString(
int
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setTime(
int
java.sql.Time)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setTime(
int
java.sql.Time
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setTimestamp(
int
java.sql.Timestamp)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setTimestamp(
int
java.sql.Timestamp
java.util.Calendar)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setTransactionIsolation(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setType(
int)
@dalvik.annotation.Signature (value =(Ljava/util/Map<Ljava/lang/String;Ljava/lang/Class<*>;>;)V )
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setTypeMap(
java.util.Map)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setUrl(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setUsername(
java.lang.String)

________________CLASS________________


public class javax.sql.RowSetEvent extends java.util.EventObject implements java.io.Serializable

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>(
javax.sql.RowSet)

________________CLASS________________


public abstract interface class javax.sql.RowSetInternal extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.Connection getConnection()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.ResultSet getOriginal()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.sql.ResultSet getOriginalRow()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract java.lang.Object[] getParams()
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setMetaData(
javax.sql.RowSetMetaData)

________________CLASS________________


public abstract interface class javax.sql.RowSetListener extends java.lang.Object implements java.util.EventListener

----------------FIELDS----------------
----------------METHODS----------------

public abstract void cursorMoved(
javax.sql.RowSetEvent)

public abstract void rowChanged(
javax.sql.RowSetEvent)

public abstract void rowSetChanged(
javax.sql.RowSetEvent)

________________CLASS________________


public abstract interface class javax.sql.RowSetMetaData extends java.lang.Object implements java.sql.ResultSetMetaData

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setAutoIncrement(
int
boolean)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setCaseSensitive(
int
boolean)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setCatalogName(
int
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setColumnCount(
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setColumnDisplaySize(
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setColumnLabel(
int
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setColumnName(
int
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setColumnType(
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setColumnTypeName(
int
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setCurrency(
int
boolean)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setNullable(
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setPrecision(
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setScale(
int
int)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setSchemaName(
int
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setSearchable(
int
boolean)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setSigned(
int
boolean)
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void setTableName(
int
java.lang.String)

________________CLASS________________


public abstract interface class javax.sql.RowSetReader extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract void readData(
javax.sql.RowSetInternal)

________________CLASS________________


public abstract interface class javax.sql.RowSetWriter extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/sql/SQLException; )
public abstract boolean writeData(
javax.sql.RowSetInternal)

________________CLASS________________


public class javax.xml.XMLConstants extends java.lang.Object

----------------FIELDS----------------

public static final java.lang.String DEFAULT_NS_PREFIX

public static final java.lang.String FEATURE_SECURE_PROCESSING

public static final java.lang.String NULL_NS_URI

public static final java.lang.String RELAXNG_NS_URI

public static final java.lang.String W3C_XML_SCHEMA_INSTANCE_NS_URI

public static final java.lang.String W3C_XML_SCHEMA_NS_URI

public static final java.lang.String W3C_XPATH_DATATYPE_NS_URI

public static final java.lang.String XMLNS_ATTRIBUTE

public static final java.lang.String XMLNS_ATTRIBUTE_NS_URI

public static final java.lang.String XML_DTD_NS_URI

public static final java.lang.String XML_NS_PREFIX

public static final java.lang.String XML_NS_URI
----------------METHODS----------------

public void <init>()

________________CLASS________________


public abstract class javax.xml.parsers.DocumentBuilder extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

protected void <init>()

public abstract org.w3c.dom.DOMImplementation getDOMImplementation()

public abstract boolean isNamespaceAware()

public abstract boolean isValidating()
@dalvik.annotation.Throws (value =Ljava/lang/UnsupportedOperationException; )
public boolean isXIncludeAware()

public abstract org.w3c.dom.Document newDocument()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException;Ljava/io/IOException; )
public org.w3c.dom.Document parse(
java.io.File)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException;Ljava/io/IOException; )
public org.w3c.dom.Document parse(
java.io.InputStream)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException;Ljava/io/IOException; )
public org.w3c.dom.Document parse(
java.io.InputStream
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException;Ljava/io/IOException; )
public org.w3c.dom.Document parse(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException;Ljava/io/IOException; )
public abstract org.w3c.dom.Document parse(
org.xml.sax.InputSource)

public void reset()

public abstract void setEntityResolver(
org.xml.sax.EntityResolver)

public abstract void setErrorHandler(
org.xml.sax.ErrorHandler)

________________CLASS________________


public abstract class javax.xml.parsers.DocumentBuilderFactory extends java.lang.Object

----------------FIELDS----------------

private boolean coalesce

private boolean expandEntityReferences

private boolean ignoreComments

private boolean ignoreElementContentWhitespace

private boolean namespaceAware

private boolean validate
----------------METHODS----------------

protected void <init>()
@dalvik.annotation.Throws (value =Ljavax/xml/parsers/FactoryConfigurationError; )
public static javax.xml.parsers.DocumentBuilderFactory newInstance()
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public abstract java.lang.Object getAttribute(
java.lang.String)
@dalvik.annotation.Throws (value =Ljavax/xml/parsers/ParserConfigurationException; )
public abstract boolean getFeature(
java.lang.String)

public boolean isCoalescing()

public boolean isExpandEntityReferences()

public boolean isIgnoringComments()

public boolean isIgnoringElementContentWhitespace()

public boolean isNamespaceAware()

public boolean isValidating()

public boolean isXIncludeAware()
@dalvik.annotation.Throws (value =Ljavax/xml/parsers/ParserConfigurationException; )
public abstract javax.xml.parsers.DocumentBuilder newDocumentBuilder()
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public abstract void setAttribute(
java.lang.String
java.lang.Object)

public void setCoalescing(
boolean)

public void setExpandEntityReferences(
boolean)
@dalvik.annotation.Throws (value =Ljavax/xml/parsers/ParserConfigurationException; )
public abstract void setFeature(
java.lang.String
boolean)

public void setIgnoringComments(
boolean)

public void setIgnoringElementContentWhitespace(
boolean)

public void setNamespaceAware(
boolean)

public void setValidating(
boolean)

public void setXIncludeAware(
boolean)

________________CLASS________________


public class javax.xml.parsers.FactoryConfigurationError extends java.lang.Error

----------------FIELDS----------------

private java.lang.Exception cause
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.Exception)

public void <init>(
java.lang.Exception
java.lang.String)

public void <init>(
java.lang.String)

public java.lang.Exception getException()

public java.lang.String getMessage()

________________CLASS________________


public class javax.xml.parsers.ParserConfigurationException extends java.lang.Exception

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public abstract class javax.xml.parsers.SAXParser extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

protected void <init>()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public abstract org.xml.sax.Parser getParser()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXNotRecognizedException;Lorg/xml/sax/SAXNotSupportedException; )
public abstract java.lang.Object getProperty(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public abstract org.xml.sax.XMLReader getXMLReader()

public abstract boolean isNamespaceAware()

public abstract boolean isValidating()
@dalvik.annotation.Throws (value =Ljava/lang/UnsupportedOperationException; )
public boolean isXIncludeAware()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException;Ljava/io/IOException; )
public void parse(
java.io.File
org.xml.sax.HandlerBase)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException;Ljava/io/IOException; )
public void parse(
java.io.File
org.xml.sax.helpers.DefaultHandler)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException;Ljava/io/IOException; )
public void parse(
java.io.InputStream
org.xml.sax.HandlerBase)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException;Ljava/io/IOException; )
public void parse(
java.io.InputStream
org.xml.sax.HandlerBase
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException;Ljava/io/IOException; )
public void parse(
java.io.InputStream
org.xml.sax.helpers.DefaultHandler)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException;Ljava/io/IOException; )
public void parse(
java.io.InputStream
org.xml.sax.helpers.DefaultHandler
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException;Ljava/io/IOException; )
public void parse(
java.lang.String
org.xml.sax.HandlerBase)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException;Ljava/io/IOException; )
public void parse(
java.lang.String
org.xml.sax.helpers.DefaultHandler)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException;Ljava/io/IOException; )
public void parse(
org.xml.sax.InputSource
org.xml.sax.HandlerBase)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException;Ljava/io/IOException; )
public void parse(
org.xml.sax.InputSource
org.xml.sax.helpers.DefaultHandler)

public void reset()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXNotRecognizedException;Lorg/xml/sax/SAXNotSupportedException; )
public abstract void setProperty(
java.lang.String
java.lang.Object)

________________CLASS________________


public abstract class javax.xml.parsers.SAXParserFactory extends java.lang.Object

----------------FIELDS----------------

private boolean namespaceAware

private boolean validating

private boolean xincludeAware
----------------METHODS----------------

protected void <init>()
@dalvik.annotation.Throws (value =Ljavax/xml/parsers/FactoryConfigurationError; )
public static javax.xml.parsers.SAXParserFactory newInstance()
@dalvik.annotation.Throws (value =Ljavax/xml/parsers/ParserConfigurationException;Lorg/xml/sax/SAXNotRecognizedException;Lorg/xml/sax/SAXNotSupportedException; )
public abstract boolean getFeature(
java.lang.String)

public boolean isNamespaceAware()

public boolean isValidating()

public boolean isXIncludeAware()
@dalvik.annotation.Throws (value =Ljavax/xml/parsers/ParserConfigurationException;Lorg/xml/sax/SAXException; )
public abstract javax.xml.parsers.SAXParser newSAXParser()
@dalvik.annotation.Throws (value =Ljavax/xml/parsers/ParserConfigurationException;Lorg/xml/sax/SAXNotRecognizedException;Lorg/xml/sax/SAXNotSupportedException; )
public abstract void setFeature(
java.lang.String
boolean)

public void setNamespaceAware(
boolean)

public void setValidating(
boolean)

public void setXIncludeAware(
boolean)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
 class junit.extensions.ActiveTestSuite$1 extends java.lang.Thread

----------------FIELDS----------------

final junit.extensions.ActiveTestSuite this$0

final junit.framework.TestResult val$result

final junit.framework.Test val$test
----------------METHODS----------------

 void <init>(
junit.extensions.ActiveTestSuite
junit.framework.Test
junit.framework.TestResult)

public void run()

________________CLASS________________


public abstract interface class junit.framework.Test extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract int countTestCases()

public abstract void run(
junit.framework.TestResult)

________________CLASS________________


public class junit.framework.TestSuite extends java.lang.Object implements junit.framework.Test

----------------FIELDS----------------

private java.lang.String fName

private java.util.Vector fTests
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.Class)

public void <init>(
java.lang.Class
java.lang.String)

public void <init>(
java.lang.String)

private void addTestMethod(
java.lang.reflect.Method
java.util.Vector
java.lang.Class)

public static junit.framework.Test createTest(
java.lang.Class
java.lang.String)

private static java.lang.String exceptionToString(
java.lang.Throwable)
@dalvik.annotation.Throws (value =Ljava/lang/NoSuchMethodException; )
public static java.lang.reflect.Constructor getTestConstructor(
java.lang.Class)

private boolean isPublicTestMethod(
java.lang.reflect.Method)

private boolean isTestMethod(
java.lang.reflect.Method)

private static junit.framework.Test warning(
java.lang.String)

public void addTest(
junit.framework.Test)

public void addTestSuite(
java.lang.Class)

public int countTestCases()

public java.lang.String getName()

public void run(
junit.framework.TestResult)

public void runTest(
junit.framework.Test
junit.framework.TestResult)

public void setName(
java.lang.String)

public junit.framework.Test testAt(
int)

public int testCount()

public java.util.Enumeration tests()

public java.lang.String toString()

________________CLASS________________


public class junit.extensions.ActiveTestSuite extends junit.framework.TestSuite

----------------FIELDS----------------

private volatile int fActiveTestDeathCount
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.Class)

public void <init>(
java.lang.Class
java.lang.String)

public void <init>(
java.lang.String)

public void run(
junit.framework.TestResult)

public void runFinished(
junit.framework.Test)

public void runTest(
junit.framework.Test
junit.framework.TestResult)

 void waitUntilFinished()

________________CLASS________________


public class junit.framework.Assert extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

protected void <init>()

public static void assertEquals(
byte
byte)

public static void assertEquals(
char
char)

public static void assertEquals(
double
double
double)

public static void assertEquals(
float
float
float)

public static void assertEquals(
int
int)

public static void assertEquals(
long
long)

public static void assertEquals(
java.lang.Object
java.lang.Object)

public static void assertEquals(
java.lang.String
byte
byte)

public static void assertEquals(
java.lang.String
char
char)

public static void assertEquals(
java.lang.String
double
double
double)

public static void assertEquals(
java.lang.String
float
float
float)

public static void assertEquals(
java.lang.String
int
int)

public static void assertEquals(
java.lang.String
long
long)

public static void assertEquals(
java.lang.String
java.lang.Object
java.lang.Object)

public static void assertEquals(
java.lang.String
java.lang.String)

public static void assertEquals(
java.lang.String
java.lang.String
java.lang.String)

public static void assertEquals(
java.lang.String
short
short)

public static void assertEquals(
java.lang.String
boolean
boolean)

public static void assertEquals(
short
short)

public static void assertEquals(
boolean
boolean)

public static void assertFalse(
java.lang.String
boolean)

public static void assertFalse(
boolean)

public static void assertNotNull(
java.lang.Object)

public static void assertNotNull(
java.lang.String
java.lang.Object)

public static void assertNotSame(
java.lang.Object
java.lang.Object)

public static void assertNotSame(
java.lang.String
java.lang.Object
java.lang.Object)

public static void assertNull(
java.lang.Object)

public static void assertNull(
java.lang.String
java.lang.Object)

public static void assertSame(
java.lang.Object
java.lang.Object)

public static void assertSame(
java.lang.String
java.lang.Object
java.lang.Object)

public static void assertTrue(
java.lang.String
boolean)

public static void assertTrue(
boolean)

public static void fail()

public static void fail(
java.lang.String)

private static void failNotEquals(
java.lang.String
java.lang.Object
java.lang.Object)

private static void failNotSame(
java.lang.String
java.lang.Object
java.lang.Object)

private static void failSame(
java.lang.String)

static java.lang.String format(
java.lang.String
java.lang.Object
java.lang.Object)

________________CLASS________________


public abstract class junit.framework.TestCase extends junit.framework.Assert implements junit.framework.Test

----------------FIELDS----------------

private java.lang.String fName
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

public int countTestCases()

protected junit.framework.TestResult createResult()

public java.lang.String getName()

public junit.framework.TestResult run()

public void run(
junit.framework.TestResult)
@dalvik.annotation.Throws (value =Ljava/lang/Throwable; )
public void runBare()
@dalvik.annotation.Throws (value =Ljava/lang/Throwable; )
protected void runTest()

public void setName(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/lang/Exception; )
protected void setUp()
@dalvik.annotation.Throws (value =Ljava/lang/Exception; )
protected void tearDown()

public java.lang.String toString()

________________CLASS________________


public class junit.extensions.ExceptionTestCase extends junit.framework.TestCase

----------------FIELDS----------------

 java.lang.Class fExpected
----------------METHODS----------------

public void <init>(
java.lang.String
java.lang.Class)
@dalvik.annotation.Throws (value =Ljava/lang/Throwable; )
protected void runTest()

________________CLASS________________


public class junit.extensions.TestDecorator extends junit.framework.Assert implements junit.framework.Test

----------------FIELDS----------------

protected junit.framework.Test fTest
----------------METHODS----------------

public void <init>(
junit.framework.Test)

public void basicRun(
junit.framework.TestResult)

public int countTestCases()

public junit.framework.Test getTest()

public void run(
junit.framework.TestResult)

public java.lang.String toString()

________________CLASS________________


public class junit.extensions.RepeatedTest extends junit.extensions.TestDecorator

----------------FIELDS----------------

private int fTimesRepeat
----------------METHODS----------------

public void <init>(
junit.framework.Test
int)

public int countTestCases()

public void run(
junit.framework.TestResult)

public java.lang.String toString()

________________CLASS________________


public abstract interface class junit.framework.Protectable extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/lang/Throwable; )
public abstract void protect()

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
 class junit.extensions.TestSetup$1 extends java.lang.Object implements junit.framework.Protectable

----------------FIELDS----------------

final junit.extensions.TestSetup this$0

final junit.framework.TestResult val$result
----------------METHODS----------------

 void <init>(
junit.extensions.TestSetup
junit.framework.TestResult)
@dalvik.annotation.Throws (value =Ljava/lang/Exception; )
public void protect()

________________CLASS________________


public class junit.extensions.TestSetup extends junit.extensions.TestDecorator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>(
junit.framework.Test)

public void run(
junit.framework.TestResult)
@dalvik.annotation.Throws (value =Ljava/lang/Exception; )
protected void setUp()
@dalvik.annotation.Throws (value =Ljava/lang/Exception; )
protected void tearDown()

________________CLASS________________


public class junit.framework.AssertionFailedError extends java.lang.Error

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class junit.framework.ComparisonFailure extends junit.framework.AssertionFailedError

----------------FIELDS----------------

private java.lang.String fActual

private java.lang.String fExpected
----------------METHODS----------------

public void <init>(
java.lang.String
java.lang.String
java.lang.String)

public java.lang.String getMessage()

________________CLASS________________


public class junit.framework.TestFailure extends java.lang.Object

----------------FIELDS----------------

protected junit.framework.Test fFailedTest

protected java.lang.Throwable fThrownException
----------------METHODS----------------

public void <init>(
junit.framework.Test
java.lang.Throwable)

public java.lang.String exceptionMessage()

public junit.framework.Test failedTest()

public boolean isFailure()

public java.lang.Throwable thrownException()

public java.lang.String toString()

public java.lang.String trace()

________________CLASS________________


public abstract interface class junit.framework.TestListener extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract void addError(
junit.framework.Test
java.lang.Throwable)

public abstract void addFailure(
junit.framework.Test
junit.framework.AssertionFailedError)

public abstract void endTest(
junit.framework.Test)

public abstract void startTest(
junit.framework.Test)

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
 class junit.framework.TestResult$1 extends java.lang.Object implements junit.framework.Protectable

----------------FIELDS----------------

final junit.framework.TestResult this$0

final junit.framework.TestCase val$test
----------------METHODS----------------

 void <init>(
junit.framework.TestResult
junit.framework.TestCase)
@dalvik.annotation.Throws (value =Ljava/lang/Throwable; )
public void protect()

________________CLASS________________


public class junit.framework.TestResult extends java.lang.Object

----------------FIELDS----------------

protected java.util.Vector fErrors

protected java.util.Vector fFailures

protected java.util.Vector fListeners

protected int fRunTests

private boolean fStop
----------------METHODS----------------

public void <init>()

private java.util.Vector cloneListeners()

public void addError(
junit.framework.Test
java.lang.Throwable)

public void addFailure(
junit.framework.Test
junit.framework.AssertionFailedError)

public void addListener(
junit.framework.TestListener)

public void endTest(
junit.framework.Test)

public int errorCount()

public java.util.Enumeration errors()

public int failureCount()

public java.util.Enumeration failures()

public void removeListener(
junit.framework.TestListener)

protected void run(
junit.framework.TestCase)

public int runCount()

public void runProtected(
junit.framework.Test
junit.framework.Protectable)

public boolean shouldStop()

public void startTest(
junit.framework.Test)

public void stop()

public boolean wasSuccessful()

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class junit.framework.TestSuite$1 extends junit.framework.TestCase

----------------FIELDS----------------

final java.lang.String val$message
----------------METHODS----------------

 void <init>(
java.lang.String
java.lang.String)

protected void runTest()

________________CLASS________________


public class org.apache.harmony.annotation.internal.nls.Messages extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.String sResource
----------------METHODS----------------

public void <init>()

public static java.lang.String getString(
java.lang.String)

public static java.lang.String getString(
java.lang.String
char)

public static java.lang.String getString(
java.lang.String
int)

public static java.lang.String getString(
java.lang.String
java.lang.Object)

public static java.lang.String getString(
java.lang.String
java.lang.Object
java.lang.Object)

public static java.lang.String getString(
java.lang.String
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.archive.internal.nls.Messages extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.String sResource
----------------METHODS----------------

public void <init>()

public static java.lang.String getString(
java.lang.String)

public static java.lang.String getString(
java.lang.String
char)

public static java.lang.String getString(
java.lang.String
int)

public static java.lang.String getString(
java.lang.String
java.lang.Object)

public static java.lang.String getString(
java.lang.String
java.lang.Object
java.lang.Object)

public static java.lang.String getString(
java.lang.String
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.archive.util.Util extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public static boolean ASCIIIgnoreCaseRegionMatches(
java.lang.String
int
java.lang.String
int
int)

public static java.lang.String toASCIILowerCase(
java.lang.String)

public static java.lang.String toASCIIUpperCase(
java.lang.String)

________________CLASS________________


public class org.apache.harmony.auth.internal.nls.Messages extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.String sResource
----------------METHODS----------------

public void <init>()

public static java.lang.String getString(
java.lang.String)

public static java.lang.String getString(
java.lang.String
char)

public static java.lang.String getString(
java.lang.String
int)

public static java.lang.String getString(
java.lang.String
java.lang.Object)

public static java.lang.String getString(
java.lang.String
java.lang.Object
java.lang.Object)

public static java.lang.String getString(
java.lang.String
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.crypto.internal.NullCipherSpi extends javax.crypto.CipherSpi

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljavax/crypto/ShortBufferException;Ljavax/crypto/IllegalBlockSizeException;Ljavax/crypto/BadPaddingException; )
public int engineDoFinal(
java.nio.ByteBuffer
java.nio.ByteBuffer)
@dalvik.annotation.Throws (value =Ljavax/crypto/ShortBufferException;Ljavax/crypto/IllegalBlockSizeException;Ljavax/crypto/BadPaddingException; )
public int engineDoFinal(
byte[]
int
int
byte[]
int)
@dalvik.annotation.Throws (value =Ljavax/crypto/IllegalBlockSizeException;Ljavax/crypto/BadPaddingException; )
public byte[] engineDoFinal(
byte[]
int
int)

public int engineGetBlockSize()

public byte[] engineGetIV()
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
public int engineGetKeySize(
java.security.Key)

public int engineGetOutputSize(
int)

public java.security.AlgorithmParameters engineGetParameters()
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljava/security/InvalidAlgorithmParameterException; )
public void engineInit(
int
java.security.Key
java.security.AlgorithmParameters
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
public void engineInit(
int
java.security.Key
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljava/security/InvalidAlgorithmParameterException; )
public void engineInit(
int
java.security.Key
java.security.spec.AlgorithmParameterSpec
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public void engineSetMode(
java.lang.String)
@dalvik.annotation.Throws (value =Ljavax/crypto/NoSuchPaddingException; )
public void engineSetPadding(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljava/security/NoSuchAlgorithmException; )
public java.security.Key engineUnwrap(
byte[]
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljavax/crypto/ShortBufferException; )
public int engineUpdate(
java.nio.ByteBuffer
java.nio.ByteBuffer)
@dalvik.annotation.Throws (value =Ljavax/crypto/ShortBufferException; )
public int engineUpdate(
byte[]
int
int
byte[]
int)

public byte[] engineUpdate(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljavax/crypto/IllegalBlockSizeException;Ljava/security/InvalidKeyException; )
public byte[] engineWrap(
java.security.Key)

________________CLASS________________


public class org.apache.harmony.crypto.internal.nls.Messages extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.String sResource
----------------METHODS----------------

public void <init>()

public static java.lang.String getString(
java.lang.String)

public static java.lang.String getString(
java.lang.String
char)

public static java.lang.String getString(
java.lang.String
int)

public static java.lang.String getString(
java.lang.String
java.lang.Object)

public static java.lang.String getString(
java.lang.String
java.lang.Object
java.lang.Object)

public static java.lang.String getString(
java.lang.String
java.lang.Object[])

________________CLASS________________


public final class org.apache.harmony.dalvik.NativeTestTarget extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

private void <init>()

public static void emptyInlineMethod()

public static native void emptyInternalStaticMethod()

public static native void emptyJniStaticMethod0()

public static native void emptyJniStaticMethod6(
int
int
int
int
int
int)

public static native void emptyJniStaticMethod6L(
java.lang.String
java.lang.String[]
int[][]
java.lang.Object
java.lang.Object[]
java.lang.Object[][][][])

________________CLASS________________


public class org.apache.harmony.dalvik.ddmc.Chunk extends java.lang.Object

----------------FIELDS----------------

public byte[] data

public int length

public int offset

public int type
----------------METHODS----------------

public void <init>()

public void <init>(
int
java.nio.ByteBuffer)

public void <init>(
int
byte[]
int
int)

________________CLASS________________


public abstract class org.apache.harmony.dalvik.ddmc.ChunkHandler extends java.lang.Object

----------------FIELDS----------------

public static final int CHUNK_FAIL

public static final java.nio.ByteOrder CHUNK_ORDER
----------------METHODS----------------

static void <clinit>()

public void <init>()

public static org.apache.harmony.dalvik.ddmc.Chunk createFailChunk(
int
java.lang.String)

public static java.lang.String getString(
java.nio.ByteBuffer
int)

public static java.lang.String name(
int)

public static void putString(
java.nio.ByteBuffer
java.lang.String)

public static int type(
java.lang.String)

public static java.nio.ByteBuffer wrapChunk(
org.apache.harmony.dalvik.ddmc.Chunk)

public abstract void connected()

public abstract void disconnected()

public abstract org.apache.harmony.dalvik.ddmc.Chunk handleChunk(
org.apache.harmony.dalvik.ddmc.Chunk)

________________CLASS________________


public class org.apache.harmony.dalvik.ddmc.DdmServer extends java.lang.Object

----------------FIELDS----------------

public static final int CLIENT_PROTOCOL_VERSION

private static final int CONNECTED

private static final int DISCONNECTED
@dalvik.annotation.Signature (value =Ljava/util/HashMap<Ljava/lang/Integer;Lorg/apache/harmony/dalvik/ddmc/ChunkHandler;>; )
private static java.util.HashMap mHandlerMap

private static volatile boolean mRegistrationComplete

private static boolean mRegistrationTimedOut
----------------METHODS----------------

static void <clinit>()

private void <init>()

private static void broadcast(
int)

private static org.apache.harmony.dalvik.ddmc.Chunk dispatch(
int
byte[]
int
int)

private static native void nativeSendChunk(
int
byte[]
int
int)

public static void registerHandler(
int
org.apache.harmony.dalvik.ddmc.ChunkHandler)

public static void registrationComplete()

public static void sendChunk(
org.apache.harmony.dalvik.ddmc.Chunk)

public static org.apache.harmony.dalvik.ddmc.ChunkHandler unregisterHandler(
int)

________________CLASS________________


public class org.apache.harmony.dalvik.ddmc.DdmVmInternal extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

private void <init>()

public static native void enableRecentAllocations(
boolean)

public static native boolean getRecentAllocationStatus()

public static native byte[] getRecentAllocations()

public static native java.lang.StackTraceElement[] getStackTraceById(
int)

public static native byte[] getThreadStats()

public static native boolean heapInfoNotify(
int)

public static native boolean heapSegmentNotify(
int
int
boolean)

public static native void threadNotify(
boolean)

________________CLASS________________


public final class org.apache.harmony.kernel.vm.StringUtils extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

private void <init>()

public static java.lang.String combineStrings(
java.lang.Object[])

________________CLASS________________


public final class org.apache.harmony.kernel.vm.VM extends java.lang.Object

----------------FIELDS----------------

static final int CPE_TYPE_DIRECTORY

static final int CPE_TYPE_JAR

static final int CPE_TYPE_TCP

static final int CPE_TYPE_UNKNOWN

static final int CPE_TYPE_UNUSABLE

private static final int kernelVersion
----------------METHODS----------------

public void <init>()

public static void addShutdownHook(
java.lang.Thread)

public static java.lang.ClassLoader bootCallerClassLoader()

public static java.lang.ClassLoader callerClassLoader()

public static void closeJars()

public static void deleteOnExit()

public static void dumpString(
java.lang.String)
@dalvik.annotation.Signature (value =(Ljava/lang/String;Ljava/lang/ClassLoader;)Ljava/lang/Class<*>; )
static java.lang.Class findClassOrNull(
java.lang.String
java.lang.ClassLoader)
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;)I )
static int getCPIndexImpl(
java.lang.Class)

static int getClassPathCount()

static final int getClassPathEntryType(
java.lang.Object
int)

public static int getKernelVersion()

public static final java.lang.ClassLoader getNonBootstrapClassLoader()

static byte[] getPathFromClassPath(
int)

static final java.lang.ClassLoader getStackClassLoader(
int)

public static java.lang.String[] getVMArgs()

public static final void initializeClassLoader(
java.lang.ClassLoader
boolean)

static void initializeVM()

public static final java.lang.String intern(
java.lang.String)

public static boolean removeShutdownHook(
java.lang.Thread)

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/Object;>; )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
 class org.apache.harmony.lang.annotation.AnnotationFactory$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final org.apache.harmony.lang.annotation.AnnotationFactory this$0

final org.apache.harmony.lang.annotation.AnnotationMember val$el
----------------METHODS----------------

 void <init>(
org.apache.harmony.lang.annotation.AnnotationFactory
org.apache.harmony.lang.annotation.AnnotationMember)

public java.lang.Object run()

________________CLASS________________


public final class org.apache.harmony.lang.annotation.AnnotationFactory extends java.lang.Object implements java.lang.reflect.InvocationHandler, java.io.Serializable

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Map<Ljava/lang/Class<+Ljava/lang/annotation/Annotation;>;[Lorg/apache/harmony/lang/annotation/AnnotationMember;>; )
private static final transient java.util.Map cache

private org.apache.harmony.lang.annotation.AnnotationMember[] elements
@dalvik.annotation.Signature (value =Ljava/lang/Class<+Ljava/lang/annotation/Annotation;>; )
private final java.lang.Class klazz
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Signature (value =(Ljava/lang/Class<+Ljava/lang/annotation/Annotation;>;[Lorg/apache/harmony/lang/annotation/AnnotationMember;)V )
private void <init>(
java.lang.Class
org.apache.harmony.lang.annotation.AnnotationMember[])
@dalvik.annotation.Signature (value =(Ljava/lang/Class<+Ljava/lang/annotation/Annotation;>;[Lorg/apache/harmony/lang/annotation/AnnotationMember;)Ljava/lang/annotation/Annotation; )
public static java.lang.annotation.Annotation createAnnotation(
java.lang.Class
org.apache.harmony.lang.annotation.AnnotationMember[])
@dalvik.annotation.Signature (value =(Ljava/lang/Class<+Ljava/lang/annotation/Annotation;>;)[Lorg/apache/harmony/lang/annotation/AnnotationMember; )
public static org.apache.harmony.lang.annotation.AnnotationMember[] getElementsDescription(
java.lang.Class)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)

public boolean equals(
java.lang.Object)

public int hashCode()
@dalvik.annotation.Throws (value =Ljava/lang/Throwable; )
public java.lang.Object invoke(
java.lang.Object
java.lang.reflect.Method
java.lang.Object[])

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/lang/annotation/AnnotationMember; )
@dalvik.annotation.Signature (value =Ljava/lang/Enum<Lorg/apache/harmony/lang/annotation/AnnotationMember$DefaultValues;>; )
@dalvik.annotation.InnerClass (accessFlags =16410 name =DefaultValues )
final class org.apache.harmony.lang.annotation.AnnotationMember$DefaultValues extends java.lang.Enum

----------------FIELDS----------------

private static final org.apache.harmony.lang.annotation.AnnotationMember$DefaultValues[] $VALUES

public static final org.apache.harmony.lang.annotation.AnnotationMember$DefaultValues NO_VALUE
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Signature (value =()V )
private void <init>(
java.lang.String
int)

public static org.apache.harmony.lang.annotation.AnnotationMember$DefaultValues valueOf(
java.lang.String)

public static org.apache.harmony.lang.annotation.AnnotationMember$DefaultValues[] values()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/apache/harmony/lang/annotation/AnnotationMember$DefaultValues; )
public class org.apache.harmony.lang.annotation.AnnotationMember extends java.lang.Object implements java.io.Serializable

----------------FIELDS----------------

protected static final char ARRAY

protected static final char ERROR

protected static final java.lang.Object NO_VALUE

protected static final char OTHER

protected transient java.lang.reflect.Method definingMethod
@dalvik.annotation.Signature (value =Ljava/lang/Class<*>; )
protected transient java.lang.Class elementType

protected final java.lang.String name

protected final char tag

protected final java.lang.Object value
----------------METHODS----------------

static void <clinit>()

public void <init>(
java.lang.String
java.lang.Object)

public void <init>(
java.lang.String
java.lang.Object
java.lang.Class
java.lang.reflect.Method)
@dalvik.annotation.Throws (value =Ljava/lang/Throwable; )
public java.lang.Object copyValue()

public boolean equalArrayValue(
java.lang.Object)

public boolean equals(
java.lang.Object)

public int hashCode()
@dalvik.annotation.Throws (value =Ljava/lang/Throwable; )
public void rethrowError()

protected org.apache.harmony.lang.annotation.AnnotationMember setDefinition(
org.apache.harmony.lang.annotation.AnnotationMember)

public java.lang.String toString()
@dalvik.annotation.Throws (value =Ljava/lang/Throwable; )
public java.lang.Object validateValue()

________________CLASS________________


public class org.apache.harmony.logging.internal.nls.Messages extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.String sResource
----------------METHODS----------------

public void <init>()

public static java.lang.String getString(
java.lang.String)

public static java.lang.String getString(
java.lang.String
char)

public static java.lang.String getString(
java.lang.String
int)

public static java.lang.String getString(
java.lang.String
java.lang.Object)

public static java.lang.String getString(
java.lang.String
java.lang.Object
java.lang.Object)

public static java.lang.String getString(
java.lang.String
java.lang.Object[])

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/io/InputStream;>; )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
 class org.apache.harmony.luni.internal.net.www.MimeTable$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final org.apache.harmony.luni.internal.net.www.MimeTable this$0
----------------METHODS----------------

 void <init>(
org.apache.harmony.luni.internal.net.www.MimeTable)

public java.io.InputStream run()

public volatile java.lang.Object run()

________________CLASS________________


public class org.apache.harmony.luni.internal.net.www.MimeTable extends java.lang.Object implements java.net.FileNameMap

----------------FIELDS----------------

public static final java.lang.String UNKNOWN

public static final java.util.Properties types
----------------METHODS----------------

static void <clinit>()

public void <init>()

static java.io.InputStream access$000(
org.apache.harmony.luni.internal.net.www.MimeTable)

private java.io.InputStream getContentTypes()

public java.lang.String getContentTypeFor(
java.lang.String)

________________CLASS________________


public class org.apache.harmony.luni.internal.net.www.protocol.file.FileURLConnection extends java.net.URLConnection

----------------FIELDS----------------

 java.lang.String fileName

private java.io.InputStream is

private boolean isDir

private int length

private java.io.FilePermission permission
----------------METHODS----------------

public void <init>(
java.net.URL)

private java.io.InputStream getDirectoryListing(
java.io.File)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void connect()

public int getContentLength()

public java.lang.String getContentType()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.io.InputStream getInputStream()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.security.Permission getPermission()

________________CLASS________________


public class org.apache.harmony.luni.internal.net.www.protocol.file.Handler extends java.net.URLStreamHandler

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public java.net.URLConnection openConnection(
java.net.URL)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.net.URLConnection openConnection(
java.net.URL
java.net.Proxy)

protected void parseURL(
java.net.URL
java.lang.String
int
int)

________________CLASS________________


public class org.apache.harmony.luni.internal.net.www.protocol.ftp.FtpURLConnection extends java.net.URLConnection

----------------FIELDS----------------

private static final int FTP_DATAOPEN

private static final int FTP_FILEOK

private static final int FTP_LOGGEDIN

private static final int FTP_NOTFOUND

private static final int FTP_OK

private static final int FTP_OPENDATA

private static final int FTP_PASWD

private static final int FTP_PORT

private static final int FTP_TRANSFEROK

private static final int FTP_USERREADY

private java.net.ServerSocket acceptSocket

private java.net.Socket controlSocket

private java.io.InputStream ctrlInput

private java.io.OutputStream ctrlOutput

private java.net.Proxy currentProxy

private int dataPort

private java.net.Socket dataSocket

private java.lang.String hostName

private java.io.InputStream inputStream

private java.lang.String password

private java.net.Proxy proxy

private java.lang.String replyCode

private java.net.URI uri

private java.lang.String username
----------------METHODS----------------

protected void <init>(
java.net.URL)

protected void <init>(
java.net.URL
java.net.Proxy)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void cd()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void connectInternal()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void getFile()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private int getReply()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void login()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void port()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private java.lang.String readLine()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private boolean readMultiLine()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void sendFile()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void setType()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void write(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void connect()

public java.lang.String getContentType()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.io.InputStream getInputStream()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.io.OutputStream getOutputStream()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.security.Permission getPermission()

public void setDoInput(
boolean)

public void setDoOutput(
boolean)

________________CLASS________________


 class org.apache.harmony.luni.internal.net.www.protocol.ftp.FtpURLInputStream extends java.io.InputStream

----------------FIELDS----------------

private java.net.Socket controlSocket

private java.io.InputStream is
----------------METHODS----------------

public void <init>(
java.io.InputStream
java.net.Socket)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int available()

public void close()

public void mark(
int)

public boolean markSupported()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void reset()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long skip(
long)

________________CLASS________________


public class org.apache.harmony.luni.internal.net.www.protocol.ftp.Handler extends java.net.URLStreamHandler

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

protected int getDefaultPort()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected java.net.URLConnection openConnection(
java.net.URL)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected java.net.URLConnection openConnection(
java.net.URL
java.net.Proxy)

________________CLASS________________


public class org.apache.harmony.luni.internal.net.www.protocol.http.Handler extends java.net.URLStreamHandler

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

protected int getDefaultPort()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected java.net.URLConnection openConnection(
java.net.URL)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected java.net.URLConnection openConnection(
java.net.URL
java.net.Proxy)

________________CLASS________________


public class org.apache.harmony.luni.internal.net.www.protocol.http.Header extends java.lang.Object implements java.lang.Cloneable

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/HashMap<Ljava/lang/String;Ljava/util/LinkedList<Ljava/lang/String;>;>; )
private java.util.HashMap keyTable
@dalvik.annotation.Signature (value =Ljava/util/ArrayList<Ljava/lang/String;>; )
private java.util.ArrayList props

private java.lang.String statusLine
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Signature (value =(Ljava/util/Map<Ljava/lang/String;Ljava/util/List<Ljava/lang/String;>;>;)V )
public void <init>(
java.util.Map)

public void add(
java.lang.String
java.lang.String)

public java.lang.Object clone()

public java.lang.String get(
int)

public java.lang.String get(
java.lang.String)
@dalvik.annotation.Signature (value =()Ljava/util/Map<Ljava/lang/String;Ljava/util/List<Ljava/lang/String;>;>; )
public java.util.Map getFieldMap()

public java.lang.String getKey(
int)

public java.lang.String getStatusLine()

public int length()

public void set(
java.lang.String
java.lang.String)

public void setStatusLine(
java.lang.String)

________________CLASS________________


public class org.apache.harmony.luni.internal.net.www.protocol.http.HttpConfiguration extends java.lang.Object

----------------FIELDS----------------

private java.lang.String hostName

private int hostPort

private java.net.Proxy proxy

private java.net.URI uri
----------------METHODS----------------

public void <init>(
java.net.URI)

public void <init>(
java.net.URI
java.net.Proxy)

public boolean equals(
java.lang.Object)

public java.lang.String getHostName()

public int getHostPort()

public java.net.Proxy getProxy()

public int hashCode()

public boolean usesProxy()

________________CLASS________________


public class org.apache.harmony.luni.internal.net.www.protocol.http.HttpConnection extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.Class SOCKET_TIMEOUT_CLASS

private org.apache.harmony.luni.internal.net.www.protocol.http.HttpConfiguration config

private java.io.InputStream inputStream

private java.io.OutputStream outputStream

private java.net.Socket socket

private java.io.InputStream sslInputStream

private java.io.OutputStream sslOutputStream

private javax.net.ssl.SSLSocket sslSocket

private boolean usingSecureSocket
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
org.apache.harmony.luni.internal.net.www.protocol.http.HttpConfiguration
int)

private static java.lang.Class SocketTimeoutExceptionClass()

public static boolean isSocketTimeoutException(
java.io.InterruptedIOException)

public void closeSocketAndStreams()

public org.apache.harmony.luni.internal.net.www.protocol.http.HttpConfiguration getHttpConfiguration()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.io.InputStream getInputStream()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.io.OutputStream getOutputStream()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public javax.net.ssl.SSLSocket getSecureSocket(
javax.net.ssl.SSLSocketFactory
javax.net.ssl.HostnameVerifier)

 java.net.Socket getSocket()

protected boolean isEligibleForRecycling()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected boolean isStale()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void setSoTimeout(
int)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =4104 name =null )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/luni/internal/net/www/protocol/http/HttpConnectionManager; )
 class org.apache.harmony.luni.internal.net.www.protocol.http.HttpConnectionManager$1 extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/luni/internal/net/www/protocol/http/HttpConnectionManager; )
@dalvik.annotation.InnerClass (accessFlags =10 name =ConnectionPool )
 class org.apache.harmony.luni.internal.net.www.protocol.http.HttpConnectionManager$ConnectionPool extends java.lang.Object

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Map<Lorg/apache/harmony/luni/internal/net/www/protocol/http/HttpConfiguration;Ljava/util/List<Lorg/apache/harmony/luni/internal/net/www/protocol/http/HttpConnection;>;>; )
private java.util.Map freeConnectionMap
----------------METHODS----------------

private void <init>()

 void <init>(
org.apache.harmony.luni.internal.net.www.protocol.http.HttpConnectionManager$1)

public void clear()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public org.apache.harmony.luni.internal.net.www.protocol.http.HttpConnection getHttpConnection(
org.apache.harmony.luni.internal.net.www.protocol.http.HttpConfiguration
int)

public int numFreeConnections()

public void returnConnection(
org.apache.harmony.luni.internal.net.www.protocol.http.HttpConnection)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/apache/harmony/luni/internal/net/www/protocol/http/HttpConnectionManager$1;Lorg/apache/harmony/luni/internal/net/www/protocol/http/HttpConnectionManager$ConnectionPool; )
public class org.apache.harmony.luni.internal.net.www.protocol.http.HttpConnectionManager extends java.lang.Object

----------------FIELDS----------------

private static org.apache.harmony.luni.internal.net.www.protocol.http.HttpConnectionManager defaultConnectionManager

private static boolean keepAlive

private static int maxConnections

private org.apache.harmony.luni.internal.net.www.protocol.http.HttpConnectionManager$ConnectionPool pool
----------------METHODS----------------

static void <clinit>()

public void <init>()

static boolean access$100()

static int access$200()

private void checkSystemProperties()

public static org.apache.harmony.luni.internal.net.www.protocol.http.HttpConnectionManager getDefault()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public org.apache.harmony.luni.internal.net.www.protocol.http.HttpConnection getConnection(
java.net.URI
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public org.apache.harmony.luni.internal.net.www.protocol.http.HttpConnection getConnection(
java.net.URI
java.net.Proxy
int)

public int numFreeConnections()

public void reset()

public void returnConnectionToPool(
org.apache.harmony.luni.internal.net.www.protocol.http.HttpConnection)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/net/ResponseCache;>; )
 class org.apache.harmony.luni.internal.net.www.protocol.http.HttpURLConnection$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final org.apache.harmony.luni.internal.net.www.protocol.http.HttpURLConnection this$0
----------------METHODS----------------

 void <init>(
org.apache.harmony.luni.internal.net.www.protocol.http.HttpURLConnection)

public volatile java.lang.Object run()

public java.net.ResponseCache run()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =2 name =ChunkedInputStream )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/luni/internal/net/www/protocol/http/HttpURLConnection; )
 class org.apache.harmony.luni.internal.net.www.protocol.http.HttpURLConnection$ChunkedInputStream extends java.io.InputStream

----------------FIELDS----------------

private boolean atEnd

private int bytesRemaining

final org.apache.harmony.luni.internal.net.www.protocol.http.HttpURLConnection this$0
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
org.apache.harmony.luni.internal.net.www.protocol.http.HttpURLConnection)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void readChunkSize()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int available()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long skip(
int)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =2 name =HttpOutputStream )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/luni/internal/net/www/protocol/http/HttpURLConnection; )
 class org.apache.harmony.luni.internal.net.www.protocol.http.HttpURLConnection$HttpOutputStream extends java.io.OutputStream

----------------FIELDS----------------

static final int MAX

 java.io.ByteArrayOutputStream cache

 int cacheLength

 boolean closed

 int defaultCacheSize

 int limit

final org.apache.harmony.luni.internal.net.www.protocol.http.HttpURLConnection this$0

 boolean writeToSocket
----------------METHODS----------------

public void <init>(
org.apache.harmony.luni.internal.net.www.protocol.http.HttpURLConnection)

public void <init>(
org.apache.harmony.luni.internal.net.www.protocol.http.HttpURLConnection
int)

private int calculateChunkDataLength()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void output(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void sendCache(
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void flush()

 boolean isCached()

 boolean isChunked()

 int size()

 byte[] toByteArray()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
byte[]
int
int)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =2 name =LimitedInputStream )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/luni/internal/net/www/protocol/http/HttpURLConnection; )
 class org.apache.harmony.luni.internal.net.www.protocol.http.HttpURLConnection$LimitedInputStream extends java.io.InputStream

----------------FIELDS----------------

 int bytesRemaining

final org.apache.harmony.luni.internal.net.www.protocol.http.HttpURLConnection this$0
----------------METHODS----------------

public void <init>(
org.apache.harmony.luni.internal.net.www.protocol.http.HttpURLConnection
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int available()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long skip(
int)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/luni/internal/net/www/protocol/http/HttpURLConnection; )
@dalvik.annotation.InnerClass (accessFlags =2 name =LocalCloseInputStream )
 class org.apache.harmony.luni.internal.net.www.protocol.http.HttpURLConnection$LocalCloseInputStream extends java.io.InputStream

----------------FIELDS----------------

private boolean closed

final org.apache.harmony.luni.internal.net.www.protocol.http.HttpURLConnection this$0
----------------METHODS----------------

public void <init>(
org.apache.harmony.luni.internal.net.www.protocol.http.HttpURLConnection)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void throwClosed()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int available()

public void close()

public void mark(
int)

public boolean markSupported()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void reset()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long skip(
long)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/apache/harmony/luni/internal/net/www/protocol/http/HttpURLConnection$HttpOutputStream;Lorg/apache/harmony/luni/internal/net/www/protocol/http/HttpURLConnection$ChunkedInputStream;Lorg/apache/harmony/luni/internal/net/www/protocol/http/HttpURLConnection$LimitedInputStream;Lorg/apache/harmony/luni/internal/net/www/protocol/http/HttpURLConnection$LocalCloseInputStream; )
public class org.apache.harmony.luni.internal.net.www.protocol.http.HttpURLConnection extends java.net.HttpURLConnection

----------------FIELDS----------------

private static final java.lang.String GET

private static final java.lang.String HEAD

private static final java.lang.String POST

private static final java.lang.String PUT

private static org.apache.harmony.luni.internal.net.www.protocol.http.Header defaultReqHeader

private java.io.OutputStream cacheOut

private java.net.CacheRequest cacheRequest

private java.net.CacheResponse cacheResponse

protected org.apache.harmony.luni.internal.net.www.protocol.http.HttpConnection connection

private final int defaultPort

private boolean hasTriedCache

private java.net.InetAddress hostAddress

private java.lang.String hostName

private int hostPort

private int httpVersion

private java.io.InputStream is

private org.apache.harmony.luni.internal.net.www.protocol.http.HttpURLConnection$HttpOutputStream os

private java.net.Proxy proxy

private java.lang.String proxyName

private org.apache.harmony.luni.internal.net.www.protocol.http.Header reqHeader

private org.apache.harmony.luni.internal.net.www.protocol.http.Header resHeader

private java.net.ResponseCache responseCache

 boolean sendChunked

private boolean sentRequest

private java.io.OutputStream socketOut

private java.io.InputStream uis

private java.net.URI uri
----------------METHODS----------------

static void <clinit>()

protected void <init>(
java.net.URL)

protected void <init>(
java.net.URL
int)

protected void <init>(
java.net.URL
int
java.net.Proxy)

static java.io.InputStream access$000(
org.apache.harmony.luni.internal.net.www.protocol.http.HttpURLConnection)

static void access$100(
org.apache.harmony.luni.internal.net.www.protocol.http.HttpURLConnection
boolean)

static int access$1000(
org.apache.harmony.luni.internal.net.www.protocol.http.HttpURLConnection)

static int access$1100(
org.apache.harmony.luni.internal.net.www.protocol.http.HttpURLConnection)

static java.io.OutputStream access$1200(
org.apache.harmony.luni.internal.net.www.protocol.http.HttpURLConnection)

static boolean access$200(
org.apache.harmony.luni.internal.net.www.protocol.http.HttpURLConnection)

static java.net.CacheRequest access$300(
org.apache.harmony.luni.internal.net.www.protocol.http.HttpURLConnection)

static boolean access$400(
org.apache.harmony.luni.internal.net.www.protocol.http.HttpURLConnection)

static java.io.OutputStream access$500(
org.apache.harmony.luni.internal.net.www.protocol.http.HttpURLConnection)

static boolean access$600(
org.apache.harmony.luni.internal.net.www.protocol.http.HttpURLConnection)

static boolean access$700(
org.apache.harmony.luni.internal.net.www.protocol.http.HttpURLConnection)

static boolean access$800(
org.apache.harmony.luni.internal.net.www.protocol.http.HttpURLConnection)

static boolean access$900(
org.apache.harmony.luni.internal.net.www.protocol.http.HttpURLConnection)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private byte[] createRequest()

private void disconnect(
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private java.lang.String getAuthorizationCredentials(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private java.io.InputStream getContentStream()

public static java.lang.String getDefaultRequestProperty(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private boolean getFromCache()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private java.net.InetAddress getHostAddress()

private java.lang.String getHostName()

private int getHostPort()

private java.lang.String getSystemProperty(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void putToCache()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private boolean sendRequest()

public static void setDefaultRequestProperty(
java.lang.String
java.lang.String)

private void setProxy(
java.lang.String)

public void addRequestProperty(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void connect()

public void disconnect()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void doRequest()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void doRequestInternal()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void endRequest()

public java.io.InputStream getErrorStream()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected org.apache.harmony.luni.internal.net.www.protocol.http.HttpConnection getHTTPConnection(
java.net.Proxy)

public java.lang.String getHeaderField(
int)

public java.lang.String getHeaderField(
java.lang.String)

public java.lang.String getHeaderFieldKey(
int)
@dalvik.annotation.Signature (value =()Ljava/util/Map<Ljava/lang/String;Ljava/util/List<Ljava/lang/String;>;>; )
public java.util.Map getHeaderFields()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.io.InputStream getInputStream()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.io.OutputStream getOutputStream()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.security.Permission getPermission()
@dalvik.annotation.Signature (value =()Ljava/util/Map<Ljava/lang/String;Ljava/util/List<Ljava/lang/String;>;>; )
public java.util.Map getRequestProperties()

public java.lang.String getRequestProperty(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int getResponseCode()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void readHeaders()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void readServerResponse()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 java.lang.String readln()

protected java.lang.String requestString()

public void setIfModifiedSince(
long)

public void setRequestProperty(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void setUpTransportIO(
org.apache.harmony.luni.internal.net.www.protocol.http.HttpConnection)

public boolean usingProxy()

________________CLASS________________


public class org.apache.harmony.luni.internal.net.www.protocol.https.Handler extends java.net.URLStreamHandler

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

protected int getDefaultPort()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected java.net.URLConnection openConnection(
java.net.URL)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected java.net.URLConnection openConnection(
java.net.URL
java.net.Proxy)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =2 name =HttpsEngine )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/luni/internal/net/www/protocol/https/HttpsURLConnection; )
 class org.apache.harmony.luni.internal.net.www.protocol.https.HttpsURLConnection$HttpsEngine extends org.apache.harmony.luni.internal.net.www.protocol.http.HttpURLConnection

----------------FIELDS----------------

private boolean makingSSLTunnel

final org.apache.harmony.luni.internal.net.www.protocol.https.HttpsURLConnection this$0
----------------METHODS----------------

protected void <init>(
org.apache.harmony.luni.internal.net.www.protocol.https.HttpsURLConnection
java.net.URL
int)

protected void <init>(
org.apache.harmony.luni.internal.net.www.protocol.https.HttpsURLConnection
java.net.URL
int
java.net.Proxy)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void connect()

protected java.lang.String requestString()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/apache/harmony/luni/internal/net/www/protocol/https/HttpsURLConnection$HttpsEngine; )
public class org.apache.harmony.luni.internal.net.www.protocol.https.HttpsURLConnection extends javax.net.ssl.HttpsURLConnection

----------------FIELDS----------------

private final org.apache.harmony.luni.internal.net.www.protocol.https.HttpsURLConnection$HttpsEngine httpsEngine

private javax.net.ssl.SSLSocket sslSocket
----------------METHODS----------------

protected void <init>(
java.net.URL
int)

protected void <init>(
java.net.URL
int
java.net.Proxy)

static javax.net.ssl.SSLSocket access$002(
org.apache.harmony.luni.internal.net.www.protocol.https.HttpsURLConnection
javax.net.ssl.SSLSocket)

public void addRequestProperty(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void connect()

public void disconnect()

public boolean getAllowUserInteraction()

public java.lang.String getCipherSuite()

public int getConnectTimeout()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object getContent()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object getContent(
java.lang.Class[])

public java.lang.String getContentEncoding()

public int getContentLength()

public java.lang.String getContentType()

public long getDate()

public boolean getDefaultUseCaches()

public boolean getDoInput()

public boolean getDoOutput()

public java.io.InputStream getErrorStream()

public long getExpiration()

public java.lang.String getHeaderField(
int)

public java.lang.String getHeaderField(
java.lang.String)

public long getHeaderFieldDate(
java.lang.String
long)

public int getHeaderFieldInt(
java.lang.String
int)

public java.lang.String getHeaderFieldKey(
int)
@dalvik.annotation.Signature (value =()Ljava/util/Map<Ljava/lang/String;Ljava/util/List<Ljava/lang/String;>;>; )
public java.util.Map getHeaderFields()

public long getIfModifiedSince()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.io.InputStream getInputStream()

public boolean getInstanceFollowRedirects()

public long getLastModified()

public java.security.cert.Certificate[] getLocalCertificates()

public java.security.Principal getLocalPrincipal()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.io.OutputStream getOutputStream()
@dalvik.annotation.Throws (value =Ljavax/net/ssl/SSLPeerUnverifiedException; )
public java.security.Principal getPeerPrincipal()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.security.Permission getPermission()

public int getReadTimeout()

public java.lang.String getRequestMethod()
@dalvik.annotation.Signature (value =()Ljava/util/Map<Ljava/lang/String;Ljava/util/List<Ljava/lang/String;>;>; )
public java.util.Map getRequestProperties()

public java.lang.String getRequestProperty(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int getResponseCode()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.String getResponseMessage()
@dalvik.annotation.Throws (value =Ljavax/net/ssl/SSLPeerUnverifiedException; )
public java.security.cert.Certificate[] getServerCertificates()

public java.net.URL getURL()

public boolean getUseCaches()

public void setAllowUserInteraction(
boolean)

public void setConnectTimeout(
int)

public void setDefaultUseCaches(
boolean)

public void setDoInput(
boolean)

public void setDoOutput(
boolean)

public void setIfModifiedSince(
long)

public void setInstanceFollowRedirects(
boolean)

public void setReadTimeout(
int)
@dalvik.annotation.Throws (value =Ljava/net/ProtocolException; )
public void setRequestMethod(
java.lang.String)

public void setRequestProperty(
java.lang.String
java.lang.String)

public void setUseCaches(
boolean)

public java.lang.String toString()

public boolean usingProxy()

________________CLASS________________


public class org.apache.harmony.luni.internal.net.www.protocol.jar.Handler extends java.net.URLStreamHandler

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected java.net.URLConnection openConnection(
java.net.URL)

protected void parseURL(
java.net.URL
java.lang.String
int
int)

protected java.lang.String toExternalForm(
java.net.URL)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/Integer;>; )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/luni/internal/net/www/protocol/jar/JarURLConnection; )
final class org.apache.harmony.luni.internal.net.www.protocol.jar.JarURLConnection$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public java.lang.Integer run()

public volatile java.lang.Object run()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/util/jar/JarFile;>; )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
 class org.apache.harmony.luni.internal.net.www.protocol.jar.JarURLConnection$2 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final org.apache.harmony.luni.internal.net.www.protocol.jar.JarURLConnection this$0

final java.lang.String val$externalForm
----------------METHODS----------------

 void <init>(
org.apache.harmony.luni.internal.net.www.protocol.jar.JarURLConnection
java.lang.String)

public volatile java.lang.Object run()

public java.util.jar.JarFile run()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/util/jar/JarFile;>; )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
 class org.apache.harmony.luni.internal.net.www.protocol.jar.JarURLConnection$3 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final org.apache.harmony.luni.internal.net.www.protocol.jar.JarURLConnection this$0

final java.lang.String val$externalForm

final java.io.InputStream val$is
----------------METHODS----------------

 void <init>(
org.apache.harmony.luni.internal.net.www.protocol.jar.JarURLConnection
java.io.InputStream
java.lang.String)

public volatile java.lang.Object run()

public java.util.jar.JarFile run()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =24 name =CacheEntry )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/luni/internal/net/www/protocol/jar/JarURLConnection; )
@dalvik.annotation.Signature (value =<T:Ljava/util/jar/JarFile;>Ljava/lang/ref/WeakReference<TT;>; )
final class org.apache.harmony.luni.internal.net.www.protocol.jar.JarURLConnection$CacheEntry extends java.lang.ref.WeakReference

----------------FIELDS----------------

 java.lang.Object key
----------------METHODS----------------
@dalvik.annotation.Signature (value =(TT;Ljava/lang/String;Ljava/lang/ref/ReferenceQueue<Ljava/util/jar/JarFile;>;)V )
 void <init>(
java.util.jar.JarFile
java.lang.String
java.lang.ref.ReferenceQueue)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =2 name =JarURLConnectionInputStream )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/luni/internal/net/www/protocol/jar/JarURLConnection; )
 class org.apache.harmony.luni.internal.net.www.protocol.jar.JarURLConnection$JarURLConnectionInputStream extends java.io.FilterInputStream

----------------FIELDS----------------

 java.io.InputStream inputStream

 java.util.jar.JarFile jarFile

final org.apache.harmony.luni.internal.net.www.protocol.jar.JarURLConnection this$0
----------------METHODS----------------

protected void <init>(
org.apache.harmony.luni.internal.net.www.protocol.jar.JarURLConnection
java.io.InputStream
java.util.jar.JarFile)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long skip(
long)

________________CLASS________________

@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Comparator<Lorg/apache/harmony/luni/internal/net/www/protocol/jar/JarURLConnection$LRUKey;>; )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/luni/internal/net/www/protocol/jar/JarURLConnection; )
@dalvik.annotation.InnerClass (accessFlags =24 name =LRUComparator )
final class org.apache.harmony.luni.internal.net.www.protocol.jar.JarURLConnection$LRUComparator extends java.lang.Object implements java.util.Comparator

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public volatile int compare(
java.lang.Object
java.lang.Object)

public int compare(
org.apache.harmony.luni.internal.net.www.protocol.jar.JarURLConnection$LRUKey
org.apache.harmony.luni.internal.net.www.protocol.jar.JarURLConnection$LRUKey)

public boolean equals(
java.lang.Object
java.lang.Object)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/luni/internal/net/www/protocol/jar/JarURLConnection; )
@dalvik.annotation.InnerClass (accessFlags =24 name =LRUKey )
final class org.apache.harmony.luni.internal.net.www.protocol.jar.JarURLConnection$LRUKey extends java.lang.Object

----------------FIELDS----------------

 java.util.jar.JarFile jar

 long ts
----------------METHODS----------------

 void <init>(
java.util.jar.JarFile
long)

public boolean equals(
java.lang.Object)

public int hashCode()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/apache/harmony/luni/internal/net/www/protocol/jar/JarURLConnection$JarURLConnectionInputStream;Lorg/apache/harmony/luni/internal/net/www/protocol/jar/JarURLConnection$LRUComparator;Lorg/apache/harmony/luni/internal/net/www/protocol/jar/JarURLConnection$LRUKey;Lorg/apache/harmony/luni/internal/net/www/protocol/jar/JarURLConnection$CacheEntry; )
public class org.apache.harmony.luni.internal.net.www.protocol.jar.JarURLConnection extends java.net.JarURLConnection

----------------FIELDS----------------

static int Limit
@dalvik.annotation.Signature (value =Ljava/util/Hashtable<Ljava/lang/String;Lorg/apache/harmony/luni/internal/net/www/protocol/jar/JarURLConnection$CacheEntry<+Ljava/util/jar/JarFile;>;>; )
static java.util.Hashtable jarCache
@dalvik.annotation.Signature (value =Ljava/util/TreeSet<Lorg/apache/harmony/luni/internal/net/www/protocol/jar/JarURLConnection$LRUKey;>; )
static java.util.TreeSet lru
@dalvik.annotation.Signature (value =Ljava/lang/ref/ReferenceQueue<Ljava/util/jar/JarFile;>; )
 java.lang.ref.ReferenceQueue cacheQueue

private boolean closed

private java.util.jar.JarEntry jarEntry

private java.util.jar.JarFile jarFile

 java.io.InputStream jarInput
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Throws (value =Ljava/net/MalformedURLException; )
public void <init>(
java.net.URL)

static boolean access$000(
org.apache.harmony.luni.internal.net.www.protocol.jar.JarURLConnection)

static boolean access$102(
org.apache.harmony.luni.internal.net.www.protocol.jar.JarURLConnection
boolean)

public static void closeCachedFiles()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void findJarEntry()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void findJarFile()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void connect()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object getContent()

public int getContentLength()

public java.lang.String getContentType()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.io.InputStream getInputStream()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.util.jar.JarEntry getJarEntry()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.util.jar.JarFile getJarFile()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.security.Permission getPermission()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 java.util.jar.JarFile openJarFile(
java.lang.String
java.lang.String
boolean)

________________CLASS________________


public class org.apache.harmony.luni.internal.nls.Messages extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.String sResource
----------------METHODS----------------

public void <init>()

public static java.lang.String getString(
java.lang.String)

public static java.lang.String getString(
java.lang.String
char)

public static java.lang.String getString(
java.lang.String
int)

public static java.lang.String getString(
java.lang.String
java.lang.Object)

public static java.lang.String getString(
java.lang.String
java.lang.Object
java.lang.Object)

public static java.lang.String getString(
java.lang.String
java.lang.Object[])

________________CLASS________________


 class org.apache.harmony.luni.internal.reflect.ProxyCharArrayCache extends java.lang.Object

----------------FIELDS----------------

private int elementSize

private char[][] keyTable

private int threshold

private int[] valueTable
----------------METHODS----------------

 void <init>(
int)

static boolean equals(
char[]
char[])

private int hashCodeChar(
char[])

private void rehash()

 int get(
char[])

 int put(
char[]
int)

 int size()

public java.lang.String toString()

________________CLASS________________


abstract interface class org.apache.harmony.luni.internal.reflect.ProxyConstants extends java.lang.Object

----------------FIELDS----------------

public static final int AccFinal

public static final int AccPrivate

public static final int AccProtected

public static final int AccPublic

public static final int AccStatic

public static final int AccSuper

public static final int ClassTag

public static final char[] CodeName

public static final int DoubleTag

public static final char[] ExceptionsName

public static final int FieldRefTag

public static final int FloatTag

public static final char[] Init

public static final int IntegerTag

public static final int InterfaceMethodRefTag

public static final int LongTag

public static final int MethodRefTag

public static final int NameAndTypeTag

public static final int OPC_aaload

public static final int OPC_aastore

public static final int OPC_aconst_null

public static final int OPC_aload

public static final int OPC_aload_0

public static final int OPC_aload_1

public static final int OPC_aload_2

public static final int OPC_aload_3

public static final int OPC_anewarray

public static final int OPC_areturn

public static final int OPC_arraylength

public static final int OPC_astore

public static final int OPC_astore_0

public static final int OPC_astore_1

public static final int OPC_astore_2

public static final int OPC_astore_3

public static final int OPC_athrow

public static final int OPC_baload

public static final int OPC_bastore

public static final int OPC_bipush

public static final int OPC_caload

public static final int OPC_castore

public static final int OPC_checkcast

public static final int OPC_d2f

public static final int OPC_d2i

public static final int OPC_d2l

public static final int OPC_dadd

public static final int OPC_daload

public static final int OPC_dastore

public static final int OPC_dcmpg

public static final int OPC_dcmpl

public static final int OPC_dconst_0

public static final int OPC_dconst_1

public static final int OPC_ddiv

public static final int OPC_dload

public static final int OPC_dload_0

public static final int OPC_dload_1

public static final int OPC_dload_2

public static final int OPC_dload_3

public static final int OPC_dmul

public static final int OPC_dneg

public static final int OPC_drem

public static final int OPC_dreturn

public static final int OPC_dstore

public static final int OPC_dstore_0

public static final int OPC_dstore_1

public static final int OPC_dstore_2

public static final int OPC_dstore_3

public static final int OPC_dsub

public static final int OPC_dup

public static final int OPC_dup2

public static final int OPC_dup2_x1

public static final int OPC_dup2_x2

public static final int OPC_dup_x1

public static final int OPC_dup_x2

public static final int OPC_f2d

public static final int OPC_f2i

public static final int OPC_f2l

public static final int OPC_fadd

public static final int OPC_faload

public static final int OPC_fastore

public static final int OPC_fcmpg

public static final int OPC_fcmpl

public static final int OPC_fconst_0

public static final int OPC_fconst_1

public static final int OPC_fconst_2

public static final int OPC_fdiv

public static final int OPC_fload

public static final int OPC_fload_0

public static final int OPC_fload_1

public static final int OPC_fload_2

public static final int OPC_fload_3

public static final int OPC_fmul

public static final int OPC_fneg

public static final int OPC_frem

public static final int OPC_freturn

public static final int OPC_fstore

public static final int OPC_fstore_0

public static final int OPC_fstore_1

public static final int OPC_fstore_2

public static final int OPC_fstore_3

public static final int OPC_fsub

public static final int OPC_getfield

public static final int OPC_getstatic

public static final int OPC_goto

public static final int OPC_goto_w

public static final int OPC_i2b

public static final int OPC_i2c

public static final int OPC_i2d

public static final int OPC_i2f

public static final int OPC_i2l

public static final int OPC_i2s

public static final int OPC_iadd

public static final int OPC_iaload

public static final int OPC_iand

public static final int OPC_iastore

public static final int OPC_iconst_0

public static final int OPC_iconst_1

public static final int OPC_iconst_2

public static final int OPC_iconst_3

public static final int OPC_iconst_4

public static final int OPC_iconst_5

public static final int OPC_iconst_m1

public static final int OPC_idiv

public static final int OPC_if_acmpeq

public static final int OPC_if_acmpne

public static final int OPC_if_icmpeq

public static final int OPC_if_icmpge

public static final int OPC_if_icmpgt

public static final int OPC_if_icmple

public static final int OPC_if_icmplt

public static final int OPC_if_icmpne

public static final int OPC_ifeq

public static final int OPC_ifge

public static final int OPC_ifgt

public static final int OPC_ifle

public static final int OPC_iflt

public static final int OPC_ifne

public static final int OPC_ifnonnull

public static final int OPC_ifnull

public static final int OPC_iinc

public static final int OPC_iload

public static final int OPC_iload_0

public static final int OPC_iload_1

public static final int OPC_iload_2

public static final int OPC_iload_3

public static final int OPC_imul

public static final int OPC_ineg

public static final int OPC_instanceof

public static final int OPC_invokeinterface

public static final int OPC_invokespecial

public static final int OPC_invokestatic

public static final int OPC_invokevirtual

public static final int OPC_ior

public static final int OPC_irem

public static final int OPC_ireturn

public static final int OPC_ishl

public static final int OPC_ishr

public static final int OPC_istore

public static final int OPC_istore_0

public static final int OPC_istore_1

public static final int OPC_istore_2

public static final int OPC_istore_3

public static final int OPC_isub

public static final int OPC_iushr

public static final int OPC_ixor

public static final int OPC_jsr

public static final int OPC_jsr_w

public static final int OPC_l2d

public static final int OPC_l2f

public static final int OPC_l2i

public static final int OPC_ladd

public static final int OPC_laload

public static final int OPC_land

public static final int OPC_lastore

public static final int OPC_lcmp

public static final int OPC_lconst_0

public static final int OPC_lconst_1

public static final int OPC_ldc

public static final int OPC_ldc2_w

public static final int OPC_ldc_w

public static final int OPC_ldiv

public static final int OPC_lload

public static final int OPC_lload_0

public static final int OPC_lload_1

public static final int OPC_lload_2

public static final int OPC_lload_3

public static final int OPC_lmul

public static final int OPC_lneg

public static final int OPC_lookupswitch

public static final int OPC_lor

public static final int OPC_lrem

public static final int OPC_lreturn

public static final int OPC_lshl

public static final int OPC_lshr

public static final int OPC_lstore

public static final int OPC_lstore_0

public static final int OPC_lstore_1

public static final int OPC_lstore_2

public static final int OPC_lstore_3

public static final int OPC_lsub

public static final int OPC_lushr

public static final int OPC_lxor

public static final int OPC_monitorenter

public static final int OPC_monitorexit

public static final int OPC_multianewarray

public static final int OPC_new

public static final int OPC_newarray

public static final int OPC_nop

public static final int OPC_pop

public static final int OPC_pop2

public static final int OPC_putfield

public static final int OPC_putstatic

public static final int OPC_ret

public static final int OPC_return

public static final int OPC_saload

public static final int OPC_sastore

public static final int OPC_sipush

public static final int OPC_swap

public static final int OPC_tableswitch

public static final int OPC_wide

public static final int StringTag

public static final int Utf8Tag
----------------METHODS----------------

static void <clinit>()

________________CLASS________________


public final class org.apache.harmony.luni.internal.reflect.ProxyClassFile extends java.lang.Object implements org.apache.harmony.luni.internal.reflect.ProxyConstants

----------------FIELDS----------------

private static java.lang.reflect.Method ClassForNameMethod

private static java.lang.reflect.Method ClassGetMethod

private static java.lang.reflect.Method HandlerInvokeMethod

private static final int INCREMENT_SIZE

private static final int INITIAL_CONTENTS_SIZE

private static final int INITIAL_HEADER_SIZE

private static java.lang.reflect.Method ObjectEqualsMethod

private static java.lang.reflect.Method ObjectHashCodeMethod

private static java.lang.reflect.Method ObjectToStringMethod
@dalvik.annotation.Signature (value =Ljava/lang/reflect/Constructor<*>; )
private static java.lang.reflect.Constructor ProxyConstructor

private static java.lang.reflect.Field ProxyHandlerField
@dalvik.annotation.Signature (value =Ljava/lang/reflect/Constructor<*>; )
private static java.lang.reflect.Constructor UndeclaredThrowableExceptionConstructor

private org.apache.harmony.luni.internal.reflect.ProxyConstantPool constantPool

private int constantPoolOffset

private byte[] contents

private int contentsOffset

 byte[] header

 int headerOffset

private org.apache.harmony.luni.internal.reflect.ProxyMethod[] proxyMethods
----------------METHODS----------------

 void <init>(
java.lang.String
java.lang.Class[])

private void addAttributes()

private void addFields()

private void addMethods()
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;Ljava/util/ArrayList<Lorg/apache/harmony/luni/internal/reflect/ProxyMethod;>;Ljava/util/HashSet<Ljava/lang/Class<*>;>;)V )
private void findMethods(
java.lang.Class
java.util.ArrayList
java.util.HashSet)

private void findMethods(
java.lang.Class[])

private void genCallClassForName(
java.lang.String)
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;Ljava/lang/String;[Ljava/lang/Class;)V )
private void genCallGetMethod(
java.lang.Class
java.lang.String
java.lang.Class[])
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;)V )
private void genCastReturnType(
java.lang.Class)
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;I)I )
private int genInvokeArg(
java.lang.Class
int)

private int genInvokeArgs(
java.lang.Class[])

private void genLoadArg(
int)

private void genStoreArg(
int)

public static byte[] generateBytes(
java.lang.String
java.lang.Class[])

private void generateCodeAttribute(
org.apache.harmony.luni.internal.reflect.ProxyMethod)

private byte[] getBytes()
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;)[C )
static char[] getConstantPoolName(
java.lang.Class)
@dalvik.annotation.Signature (value =(Ljava/lang/reflect/Constructor<*>;)[C )
static char[] getConstantPoolName(
java.lang.reflect.Constructor)

static char[] getConstantPoolName(
java.lang.reflect.Method)
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;)Ljava/lang/reflect/Method; )
private java.lang.reflect.Method typeAccessMethod(
java.lang.Class)
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;)Ljava/lang/reflect/Field; )
private java.lang.reflect.Field typeField(
java.lang.Class)
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;)Ljava/lang/reflect/Constructor<*>; )
private java.lang.reflect.Constructor typeInitMethod(
java.lang.Class)
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;)Ljava/lang/String; )
private java.lang.String typeWrapperName(
java.lang.Class)

private void writeIntConstant(
int)

private void writeLdc(
java.lang.String)

private void writeUnsignedByte(
int)

private void writeUnsignedShort(
int)

private void writeUnsignedWord(
int)

________________CLASS________________


 class org.apache.harmony.luni.internal.reflect.ProxyConstantPool extends java.lang.Object implements org.apache.harmony.luni.internal.reflect.ProxyConstants

----------------FIELDS----------------

public static final int CLASS_INITIAL_SIZE

public static final int CONSTANTPOOL_GROW_SIZE

public static final int CONSTANTPOOL_INITIAL_SIZE

public static final int FIELD_INITIAL_SIZE

public static final int INTERFACE_INITIAL_SIZE

public static final int METHOD_INITIAL_SIZE

public static final int NAMEANDTYPE_INITIAL_SIZE

public static final int STRING_INITIAL_SIZE

public static final int UTF8_INITIAL_SIZE

 org.apache.harmony.luni.internal.reflect.ProxyCharArrayCache UTF8Cache

 org.apache.harmony.luni.internal.reflect.ProxyCharArrayCache classNameCache

 int currentIndex

 int currentOffset

 org.apache.harmony.luni.internal.reflect.ProxyObjectCache fieldCache

 org.apache.harmony.luni.internal.reflect.ProxyObjectCache interfaceMethodCache

 org.apache.harmony.luni.internal.reflect.ProxyObjectCache methodCache

 org.apache.harmony.luni.internal.reflect.ProxyNameAndTypeCache nameAndTypeCache

 byte[] poolContent

 org.apache.harmony.luni.internal.reflect.ProxyCharArrayCache stringCache
----------------METHODS----------------

 void <init>(
org.apache.harmony.luni.internal.reflect.ProxyClassFile)

private int literalIndexForNameAndType(
int
int)

private final void writeU1(
int)

private final void writeU2(
int)

 int literalIndex(
java.lang.String)
@dalvik.annotation.Signature (value =(Ljava/lang/reflect/Constructor<*>;)I )
 int literalIndex(
java.lang.reflect.Constructor)

 int literalIndex(
java.lang.reflect.Field)

 int literalIndex(
java.lang.reflect.Method)

 int literalIndex(
char[])

 int literalIndexForLdc(
char[])

 int typeIndex(
java.lang.String)

________________CLASS________________


 class org.apache.harmony.luni.internal.reflect.ProxyMethod extends java.lang.Object

----------------FIELDS----------------

 java.lang.Class[] commonExceptions

 java.lang.reflect.Method method
----------------METHODS----------------

 void <init>(
java.lang.reflect.Method)

 java.lang.Class[] getCheckedExceptions()

 boolean matchMethod(
java.lang.reflect.Method)

________________CLASS________________


 class org.apache.harmony.luni.internal.reflect.ProxyNameAndTypeCache extends java.lang.Object

----------------FIELDS----------------

 int elementSize

 int[][] keyTable

 int threshold

 int[] valueTable
----------------METHODS----------------

 void <init>(
int)

private void rehash()

 int get(
int[])

 int hashCode(
int[])

 int put(
int[]
int)

 int size()

public java.lang.String toString()

________________CLASS________________


 class org.apache.harmony.luni.internal.reflect.ProxyObjectCache extends java.lang.Object

----------------FIELDS----------------

 int elementSize

 java.lang.Object[] keyTable

 int threshold

 int[] valueTable
----------------METHODS----------------

 void <init>(
int)

private void rehash()

 int get(
java.lang.Object)

 int hashCode(
java.lang.Object)

 int put(
java.lang.Object
int)

 int size()

public java.lang.String toString()

________________CLASS________________


public abstract class org.apache.harmony.luni.internal.util.TimezoneGetter extends java.lang.Object

----------------FIELDS----------------

private static org.apache.harmony.luni.internal.util.TimezoneGetter instance
----------------METHODS----------------

public void <init>()

public static org.apache.harmony.luni.internal.util.TimezoneGetter getInstance()

public static void setInstance(
org.apache.harmony.luni.internal.util.TimezoneGetter)

public abstract java.lang.String getId()

________________CLASS________________


public class org.apache.harmony.luni.lang.reflect.GenericSignatureParser extends java.lang.Object

----------------FIELDS----------------

 char[] buffer

private boolean eof

public org.apache.harmony.luni.lang.reflect.ListOfTypes exceptionTypes

public java.lang.reflect.Type fieldType

public java.lang.reflect.TypeVariable[] formalTypeParameters

 java.lang.reflect.GenericDeclaration genericDecl

 java.lang.String identifier

public org.apache.harmony.luni.lang.reflect.ListOfTypes interfaceTypes

public org.apache.harmony.luni.lang.reflect.ListOfTypes parameterTypes

 int pos

public java.lang.reflect.Type returnType

public java.lang.reflect.Type superclassType

 char symbol
----------------METHODS----------------

public void <init>()

 void expect(
char)

 boolean isStopSymbol(
char)

 void parseClassSignature()

 java.lang.reflect.Type parseClassTypeSignature()

 java.lang.reflect.Type parseFieldTypeSignature()

public void parseForClass(
java.lang.reflect.GenericDeclaration
java.lang.String)

public void parseForConstructor(
java.lang.reflect.GenericDeclaration
java.lang.String)

public void parseForField(
java.lang.reflect.GenericDeclaration
java.lang.String)

public void parseForMethod(
java.lang.reflect.GenericDeclaration
java.lang.String)
@dalvik.annotation.Signature (value =()Lorg/apache/harmony/luni/lang/reflect/ImplForVariable<Ljava/lang/reflect/GenericDeclaration;>; )
 org.apache.harmony.luni.lang.reflect.ImplForVariable parseFormalTypeParameter()

 void parseMethodTypeSignature(
boolean)

 void parseOptFormalTypeParameters()

 org.apache.harmony.luni.lang.reflect.ListOfTypes parseOptTypeArguments()

 java.lang.reflect.Type parseReturnType()

 java.lang.reflect.Type parseTypeArgument()

 java.lang.reflect.Type parseTypeSignature()
@dalvik.annotation.Signature (value =()Lorg/apache/harmony/luni/lang/reflect/ImplForVariable<Ljava/lang/reflect/GenericDeclaration;>; )
 org.apache.harmony.luni.lang.reflect.ImplForVariable parseTypeVariableSignature()

 void scanIdentifier()

 void scanSymbol()

 void setInput(
java.lang.reflect.GenericDeclaration
java.lang.String)

________________CLASS________________


public final class org.apache.harmony.luni.lang.reflect.ImplForArray extends java.lang.Object implements java.lang.reflect.GenericArrayType

----------------FIELDS----------------

private final java.lang.reflect.Type componentType
----------------METHODS----------------

public void <init>(
java.lang.reflect.Type)

public java.lang.reflect.Type getGenericComponentType()

public java.lang.String toString()

________________CLASS________________


public final class org.apache.harmony.luni.lang.reflect.ImplForType extends java.lang.Object implements java.lang.reflect.ParameterizedType

----------------FIELDS----------------

private final org.apache.harmony.luni.lang.reflect.ListOfTypes args

private final org.apache.harmony.luni.lang.reflect.ImplForType ownerType0

private java.lang.reflect.Type ownerTypeRes

private java.lang.Class rawType

private final java.lang.String rawTypeName
----------------METHODS----------------

public void <init>(
org.apache.harmony.luni.lang.reflect.ImplForType
java.lang.String
org.apache.harmony.luni.lang.reflect.ListOfTypes)

public java.lang.reflect.Type[] getActualTypeArguments()

public java.lang.reflect.Type getOwnerType()

public java.lang.Class getRawType()

public volatile java.lang.reflect.Type getRawType()

 java.lang.reflect.Type getResolvedType()

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.Signature (value =<D::Ljava/lang/reflect/GenericDeclaration;>Ljava/lang/Object;Ljava/lang/reflect/TypeVariable<TD;>; )
public final class org.apache.harmony.luni.lang.reflect.ImplForVariable extends java.lang.Object implements java.lang.reflect.TypeVariable

----------------FIELDS----------------

private org.apache.harmony.luni.lang.reflect.ListOfTypes bounds

private final java.lang.reflect.GenericDeclaration declOfVarUser
@dalvik.annotation.Signature (value =Lorg/apache/harmony/luni/lang/reflect/ImplForVariable<TD;>; )
private org.apache.harmony.luni.lang.reflect.ImplForVariable formalVar
@dalvik.annotation.Signature (value =TD; )
private java.lang.reflect.GenericDeclaration genericDeclaration

private final java.lang.String name
----------------METHODS----------------
@dalvik.annotation.Signature (value =(TD;Ljava/lang/String;)V )
 void <init>(
java.lang.reflect.GenericDeclaration
java.lang.String)
@dalvik.annotation.Signature (value =(TD;Ljava/lang/String;Lorg/apache/harmony/luni/lang/reflect/ListOfTypes;)V )
 void <init>(
java.lang.reflect.GenericDeclaration
java.lang.String
org.apache.harmony.luni.lang.reflect.ListOfTypes)

static java.lang.reflect.TypeVariable findFormalVar(
java.lang.reflect.GenericDeclaration
java.lang.String)

static java.lang.reflect.GenericDeclaration nextLayer(
java.lang.reflect.GenericDeclaration)

public boolean equals(
java.lang.Object)

public java.lang.reflect.Type[] getBounds()
@dalvik.annotation.Signature (value =()TD; )
public java.lang.reflect.GenericDeclaration getGenericDeclaration()

public java.lang.String getName()

public int hashCode()

 void resolve()

public java.lang.String toString()

________________CLASS________________


public final class org.apache.harmony.luni.lang.reflect.ImplForWildcard extends java.lang.Object implements java.lang.reflect.WildcardType

----------------FIELDS----------------

private final org.apache.harmony.luni.lang.reflect.ListOfTypes extendsBound

private final org.apache.harmony.luni.lang.reflect.ListOfTypes superBound
----------------METHODS----------------

public void <init>(
org.apache.harmony.luni.lang.reflect.ListOfTypes
org.apache.harmony.luni.lang.reflect.ListOfTypes)

public boolean equals(
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/lang/TypeNotPresentException;Ljava/lang/reflect/MalformedParameterizedTypeException; )
public java.lang.reflect.Type[] getLowerBounds()
@dalvik.annotation.Throws (value =Ljava/lang/TypeNotPresentException;Ljava/lang/reflect/MalformedParameterizedTypeException; )
public java.lang.reflect.Type[] getUpperBounds()

public int hashCode()

public java.lang.String toString()

________________CLASS________________


public class org.apache.harmony.luni.lang.reflect.ListOfTypes extends java.lang.Object

----------------FIELDS----------------

static final org.apache.harmony.luni.lang.reflect.ListOfTypes empty
@dalvik.annotation.Signature (value =Ljava/util/ArrayList<Ljava/lang/reflect/Type;>; )
 java.util.ArrayList list

private java.lang.reflect.Type[] resolvedTypes
----------------METHODS----------------

static void <clinit>()

 void <init>(
int)

 void <init>(
java.lang.reflect.Type[])

 void add(
java.lang.reflect.Type)

public java.lang.reflect.Type[] getResolvedTypes()

 int length()

public java.lang.String toString()

________________CLASS________________


 class org.apache.harmony.luni.lang.reflect.ListOfVariables extends java.lang.Object

----------------FIELDS----------------

public static final java.lang.reflect.TypeVariable[] empty
@dalvik.annotation.Signature (value =Ljava/util/ArrayList<Ljava/lang/reflect/TypeVariable<*>;>; )
 java.util.ArrayList array

 int n
----------------METHODS----------------

static void <clinit>()

 void <init>()
@dalvik.annotation.Signature (value =(Ljava/lang/reflect/TypeVariable<*>;)V )
 void add(
java.lang.reflect.TypeVariable)
@dalvik.annotation.Signature (value =()[Ljava/lang/reflect/TypeVariable<*>; )
 java.lang.reflect.TypeVariable[] getArray()

________________CLASS________________


public class org.apache.harmony.luni.lang.reflect.Types extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public static java.lang.reflect.Type[] getClonedTypeArray(
org.apache.harmony.luni.lang.reflect.ListOfTypes)

public static java.lang.reflect.Type getType(
java.lang.reflect.Type)

________________CLASS________________


final class org.apache.harmony.luni.net.GenericIPMreq extends java.lang.Object

----------------FIELDS----------------

private java.net.InetAddress interfaceAddr

private int interfaceIdx

private boolean isIPV6Address

private java.net.InetAddress multiaddr
----------------METHODS----------------

 void <init>(
java.net.InetAddress)

 void <init>(
java.net.InetAddress
java.net.NetworkInterface)

private void init()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/Boolean;>; )
@dalvik.annotation.InnerClass (accessFlags =26 name =Action )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/luni/net/NetUtil; )
final class org.apache.harmony.luni.net.NetUtil$Action extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

private final java.lang.String propertyName
----------------METHODS----------------

 void <init>(
java.lang.String)

public java.lang.Boolean run()

public volatile java.lang.Object run()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/apache/harmony/luni/net/NetUtil$Action; )
public class org.apache.harmony.luni.net.NetUtil extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

static int bytesToInt(
byte[]
int)
@dalvik.annotation.Signature (value =(Ljava/net/URI;)Ljava/util/List<Ljava/net/Proxy;>; )
public static java.util.List getProxyList(
java.net.URI)

static void intToBytes(
int
byte[]
int)

public static boolean preferIPv4Stack()

public static boolean preferIPv6Addresses()

public static boolean usingSocks(
java.net.Proxy)

________________CLASS________________


 class org.apache.harmony.luni.net.PlainDatagramSocketImpl extends java.net.DatagramSocketImpl

----------------FIELDS----------------

static final int FLAG_SHUTDOWN

static final int IP_MULTICAST_ADD

static final int IP_MULTICAST_DROP

static final int IP_MULTICAST_TTL

static final int MULTICAST_IF

static final int MULTICAST_TTL

static final int REUSEADDR_AND_REUSEPORT

private static final int SO_BROADCAST

static final int TCP_NODELAY

private boolean bindToDevice

private java.net.InetAddress connectedAddress

private int connectedPort

private byte[] ipaddress

private volatile boolean isNativeConnected

private org.apache.harmony.luni.platform.INetworkSystem netImpl

public int receiveTimeout

public boolean shutdownInput

public boolean streaming

private int trafficClass

private int ttl
----------------METHODS----------------

public void <init>()

public void <init>(
java.io.FileDescriptor
int)

private void updatePacketRecvAddress(
java.net.DatagramPacket)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void bind(
int
java.net.InetAddress)

public void close()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void connect(
java.net.InetAddress
int)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void create()

public void disconnect()

protected void finalize()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public java.lang.Object getOption(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public byte getTTL()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int getTimeToLive()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void join(
java.net.InetAddress)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void joinGroup(
java.net.SocketAddress
java.net.NetworkInterface)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void leave(
java.net.InetAddress)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void leaveGroup(
java.net.SocketAddress
java.net.NetworkInterface)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected int peek(
java.net.InetAddress)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int peekData(
java.net.DatagramPacket)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void receive(
java.net.DatagramPacket)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void send(
java.net.DatagramPacket)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void setOption(
int
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void setTTL(
byte)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void setTimeToLive(
int)

________________CLASS________________


 class org.apache.harmony.luni.net.PlainMulticastSocketImpl extends org.apache.harmony.luni.net.PlainDatagramSocketImpl

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void create()

________________CLASS________________


 class org.apache.harmony.luni.net.PlainSocketImpl extends java.net.SocketImpl

----------------FIELDS----------------

static final int FLAG_SHUTDOWN

static final int MULTICAST_IF

static final int MULTICAST_TTL

static final int TCP_NODELAY

private static java.lang.reflect.Field fdField

private static java.net.InetAddress lastConnectedAddress

private static int lastConnectedPort

private static java.lang.reflect.Field localportField

protected org.apache.harmony.luni.platform.INetworkSystem netImpl

 java.net.Proxy proxy

public boolean shutdownInput

public boolean streaming

private boolean tcpNoDelay

private int trafficClass
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void connect(
java.net.InetAddress
int
int)

private java.lang.reflect.Field getSocketImplField(
java.lang.String)

private void setLocalport(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void socksBind()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void socksConnect(
java.net.InetAddress
int
int)
@dalvik.annotation.Throws (value =Ljava/net/UnknownHostException; )
private java.net.InetAddress socksGetServerAddress()

private int socksGetServerPort()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private org.apache.harmony.luni.net.Socks4Message socksReadReply()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void socksRequestConnection(
java.net.InetAddress
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void socksSendRequest(
int
java.net.InetAddress
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void accept(
java.net.SocketImpl)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected int available()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void bind(
java.net.InetAddress
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void connect(
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void connect(
java.net.InetAddress
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void connect(
java.net.SocketAddress
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void create(
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void finalize()

 java.io.FileDescriptor getFD()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected java.io.InputStream getInputStream()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public java.lang.Object getOption(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected java.io.OutputStream getOutputStream()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void listen(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 int read(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void sendUrgentData(
int)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void setOption(
int
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void shutdownInput()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void shutdownOutput()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void socksAccept()

protected boolean supportsUrgentData()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 int write(
byte[]
int
int)

________________CLASS________________


 class org.apache.harmony.luni.net.PlainServerSocketImpl extends org.apache.harmony.luni.net.PlainSocketImpl

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public void <init>(
java.io.FileDescriptor)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
protected void create(
boolean)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/reflect/Field;>; )
@dalvik.annotation.EnclosingMethod (value =null )
 class org.apache.harmony.luni.net.PlainSocketImpl$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final org.apache.harmony.luni.net.PlainSocketImpl this$0

final java.lang.String val$fieldName
----------------METHODS----------------

 void <init>(
org.apache.harmony.luni.net.PlainSocketImpl
java.lang.String)

public volatile java.lang.Object run()

public java.lang.reflect.Field run()

________________CLASS________________


 class org.apache.harmony.luni.net.PlainSocketImpl2 extends org.apache.harmony.luni.net.PlainSocketImpl

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public void <init>(
java.io.FileDescriptor
int
java.net.InetAddress
int)

public void <init>(
java.net.Proxy)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void create(
boolean)

________________CLASS________________


public class org.apache.harmony.luni.net.SocketImplProvider extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public static java.net.DatagramSocketImpl getDatagramSocketImpl()

public static java.net.DatagramSocketImpl getDatagramSocketImpl(
java.io.FileDescriptor
int)

public static java.net.DatagramSocketImpl getMulticastSocketImpl()

public static java.net.SocketImpl getServerSocketImpl()

public static java.net.SocketImpl getServerSocketImpl(
java.io.FileDescriptor)

public static java.net.SocketImpl getSocketImpl()

public static java.net.SocketImpl getSocketImpl(
java.io.FileDescriptor
int
java.net.InetAddress
int)

public static java.net.SocketImpl getSocketImpl(
java.net.Proxy)

________________CLASS________________


 class org.apache.harmony.luni.net.SocketInputStream extends java.io.InputStream

----------------FIELDS----------------

private final org.apache.harmony.luni.net.PlainSocketImpl socket
----------------METHODS----------------

public void <init>(
java.net.SocketImpl)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int available()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long skip(
long)

________________CLASS________________


 class org.apache.harmony.luni.net.SocketOutputStream extends java.io.OutputStream

----------------FIELDS----------------

private org.apache.harmony.luni.net.PlainSocketImpl socket
----------------METHODS----------------

public void <init>(
java.net.SocketImpl)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
byte[]
int
int)

________________CLASS________________


 class org.apache.harmony.luni.net.Socks4Message extends java.lang.Object

----------------FIELDS----------------

private static final int BUFFER_LENGTH

static final int COMMAND_BIND

static final int COMMAND_CONNECT

private static final int INDEX_COMMAND

private static final int INDEX_IP

private static final int INDEX_PORT

private static final int INDEX_USER_ID

static final int INDEX_VERSION

private static final int MAX_USER_ID_LENGTH

static final int REPLY_LENGTH

static final int RETURN_CANNOT_CONNECT_TO_IDENTD

static final int RETURN_DIFFERENT_USER_IDS

static final int RETURN_FAILURE

static final int RETURN_SUCCESS

private static final int SOCKS_VERSION

protected byte[] buffer
----------------METHODS----------------

public void <init>()

private int getInt16(
int)

private int getInt32(
int)

private java.lang.String getString(
int
int)

private int getVersionNumber()

private void setInt16(
int
int)

private void setString(
int
int
java.lang.String)

private void setVersionNumber(
int)

public byte[] getBytes()

public int getCommandOrResult()

public java.lang.String getErrorString(
int)

public int getIP()

public int getLength()

public int getPort()

public java.lang.String getUserId()

public void setCommandOrResult(
int)

public void setIP(
byte[])

public void setPort(
int)

public void setUserId(
java.lang.String)

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/luni/platform/AbstractMemorySpy; )
@dalvik.annotation.InnerClass (accessFlags =16 name =AddressWrapper )
final class org.apache.harmony.luni.platform.AbstractMemorySpy$AddressWrapper extends java.lang.Object

----------------FIELDS----------------

volatile boolean autoFree

final org.apache.harmony.luni.platform.PlatformAddress shadow

final org.apache.harmony.luni.platform.AbstractMemorySpy this$0
@dalvik.annotation.Signature (value =Ljava/lang/ref/PhantomReference<Lorg/apache/harmony/luni/platform/PlatformAddress;>; )
final java.lang.ref.PhantomReference wrAddress
----------------METHODS----------------

 void <init>(
org.apache.harmony.luni.platform.AbstractMemorySpy
org.apache.harmony.luni.platform.PlatformAddress)

________________CLASS________________


public abstract interface class org.apache.harmony.luni.platform.IMemorySpy extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract void alloc(
org.apache.harmony.luni.platform.PlatformAddress)

public abstract void autoFree(
org.apache.harmony.luni.platform.PlatformAddress)

public abstract boolean free(
org.apache.harmony.luni.platform.PlatformAddress)
@dalvik.annotation.Throws (value =Ljava/lang/IndexOutOfBoundsException; )
public abstract void rangeCheck(
org.apache.harmony.luni.platform.PlatformAddress
int
int)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/apache/harmony/luni/platform/AbstractMemorySpy$AddressWrapper; )
abstract class org.apache.harmony.luni.platform.AbstractMemorySpy extends java.lang.Object implements org.apache.harmony.luni.platform.IMemorySpy

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Map<Lorg/apache/harmony/luni/platform/PlatformAddress;Lorg/apache/harmony/luni/platform/AbstractMemorySpy$AddressWrapper;>; )
protected java.util.Map memoryInUse
@dalvik.annotation.Signature (value =Ljava/lang/ref/ReferenceQueue<Ljava/lang/Object;>; )
protected java.lang.ref.ReferenceQueue notifyQueue
@dalvik.annotation.Signature (value =Ljava/util/Map<Ljava/lang/ref/Reference;Lorg/apache/harmony/luni/platform/PlatformAddress;>; )
protected java.util.Map refToShadow
----------------METHODS----------------

public void <init>()

public void alloc(
org.apache.harmony.luni.platform.PlatformAddress)

public void autoFree(
org.apache.harmony.luni.platform.PlatformAddress)

public boolean free(
org.apache.harmony.luni.platform.PlatformAddress)

protected void orphanedMemory(
java.lang.ref.Reference)
@dalvik.annotation.Throws (value =Ljava/lang/IndexOutOfBoundsException; )
public void rangeCheck(
org.apache.harmony.luni.platform.PlatformAddress
int
int)

________________CLASS________________


public abstract interface class org.apache.harmony.luni.platform.IAdapterManager extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.lang.Object getAdapter(
org.apache.harmony.luni.platform.IAdaptable
java.lang.Class)

public abstract boolean hasAdapter(
org.apache.harmony.luni.platform.IAdaptable
java.lang.Class)

public abstract void registerAdapters(
org.apache.harmony.luni.platform.IAdapterFactory
java.lang.Class)

public abstract void unregisterAdapters(
org.apache.harmony.luni.platform.IAdapterFactory)

public abstract void unregisterAdapters(
org.apache.harmony.luni.platform.IAdapterFactory
java.lang.Class)

________________CLASS________________


final class org.apache.harmony.luni.platform.AdapterManager extends java.lang.Object implements org.apache.harmony.luni.platform.IAdapterManager

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/HashMap<Ljava/lang/Class;Ljava/util/List<Lorg/apache/harmony/luni/platform/IAdapterFactory;>;>; )
private final java.util.HashMap factories
----------------METHODS----------------

 void <init>()

public java.lang.Object getAdapter(
org.apache.harmony.luni.platform.IAdaptable
java.lang.Class)

public boolean hasAdapter(
org.apache.harmony.luni.platform.IAdaptable
java.lang.Class)

public void registerAdapters(
org.apache.harmony.luni.platform.IAdapterFactory
java.lang.Class)

public void unregisterAdapters(
org.apache.harmony.luni.platform.IAdapterFactory)

public void unregisterAdapters(
org.apache.harmony.luni.platform.IAdapterFactory
java.lang.Class)

________________CLASS________________


public final class org.apache.harmony.luni.platform.Endianness extends java.lang.Object

----------------FIELDS----------------

public static final org.apache.harmony.luni.platform.Endianness BIG_ENDIAN

public static final org.apache.harmony.luni.platform.Endianness LITTLE_ENDIAN

private final java.lang.String displayName
----------------METHODS----------------

static void <clinit>()

private void <init>(
java.lang.String)

public java.lang.String toString()

________________CLASS________________


public abstract interface class org.apache.harmony.luni.platform.FileDescriptorHandler extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.io.FileDescriptor getFD()

________________CLASS________________


public abstract interface class org.apache.harmony.luni.platform.IAdaptable extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.lang.Object getAdapter(
java.lang.Class)

________________CLASS________________


public abstract interface class org.apache.harmony.luni.platform.IAdapterFactory extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.lang.Object getAdapter(
org.apache.harmony.luni.platform.IAdaptable
java.lang.Class)

public abstract java.lang.Class[] getAdapterList()

________________CLASS________________


public abstract interface class org.apache.harmony.luni.platform.ICommonDataTypes extends java.lang.Object

----------------FIELDS----------------

public static final int SIZEOF_BOOL

public static final int SIZEOF_BOOLEAN

public static final int SIZEOF_DOUBLE

public static final int SIZEOF_EIGHT_BYTES

public static final int SIZEOF_FLOAT

public static final int SIZEOF_IEEE754_32_BITS

public static final int SIZEOF_IEEE754_64_BITS

public static final int SIZEOF_INT16

public static final int SIZEOF_INT32

public static final int SIZEOF_JBOOLEAN

public static final int SIZEOF_JBYTE

public static final int SIZEOF_JCHAR

public static final int SIZEOF_JDOUBLE

public static final int SIZEOF_JFLOAT

public static final int SIZEOF_JINT

public static final int SIZEOF_JLONG

public static final int SIZEOF_JSHORT

public static final int SIZEOF_JSIZE

public static final int SIZEOF_LONG

public static final int SIZEOF_NO_BYTES

public static final int SIZEOF_ONE_BYTE

public static final int SIZEOF_SHORT

public static final int SIZEOF_SIGNED_16_BITS

public static final int SIZEOF_SIGNED_32_BITS

public static final int SIZEOF_SIGNED_64_BITS

public static final int SIZEOF_SIGNED_8_BITS

public static final int SIZEOF_SIGNED_CHAR

public static final int SIZEOF_SIGNED_LONG

public static final int SIZEOF_SIGNED_SHORT

public static final int SIZEOF_TWO_BYTES

public static final int SIZEOF_UINT16

public static final int SIZEOF_UINT32

public static final int SIZEOF_UNSIGNED_32_BITS

public static final int SIZEOF_UNSIGNED_64_BITS

public static final int SIZEOF_UNSIGNED_CHAR

public static final int SIZEOF_UNSIGNED_LONG

public static final int SIZEOF_UNSIGNED_SHORT

public static final int SIZEOF_VOID

public static final int SIZE_OF_FOUR_BYTES
----------------METHODS----------------

________________CLASS________________


public abstract interface class org.apache.harmony.luni.platform.ISystemComponent extends java.lang.Object implements org.apache.harmony.luni.platform.IAdaptable

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________


public abstract interface class org.apache.harmony.luni.platform.IFileSystem extends java.lang.Object implements org.apache.harmony.luni.platform.ISystemComponent

----------------FIELDS----------------

public static final int EXCLUSIVE_LOCK_TYPE

public static final int O_APPEND

public static final int O_CREAT

public static final int O_EXCL

public static final int O_NOCTTY

public static final int O_NONBLOCK

public static final int O_RDONLY

public static final int O_RDWR

public static final int O_RDWRSYNC

public static final int O_TRUNC

public static final int O_WRONLY

public static final int SEEK_CUR

public static final int SEEK_END

public static final int SEEK_SET

public static final int SHARED_LOCK_TYPE
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void close(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void fflush(
int
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int getAllocGranularity()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int ioctlAvailable(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract boolean lock(
int
long
long
int
boolean)
@dalvik.annotation.Throws (value =Ljava/io/FileNotFoundException; )
public abstract int open(
byte[]
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract long read(
int
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract long readDirect(
int
int
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract long readv(
int
int[]
int[]
int[]
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract long seek(
int
long
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract long transfer(
int
java.io.FileDescriptor
long
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void truncate(
int
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract long ttyRead(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void unlock(
int
long
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract long write(
int
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract long writeDirect(
int
int
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract long writev(
int
int[]
int[]
int[]
int)

________________CLASS________________


public abstract interface class org.apache.harmony.luni.platform.IMemorySystem extends java.lang.Object

----------------FIELDS----------------

public static final int MMAP_READ_ONLY

public static final int MMAP_READ_WRITE

public static final int MMAP_WRITE_COPY
----------------METHODS----------------

public abstract void flush(
int
long)

public abstract void free(
int)

public abstract int getAddress(
int)

public abstract byte getByte(
int)
@dalvik.annotation.Throws (value =Ljava/lang/NullPointerException;Ljava/lang/IndexOutOfBoundsException; )
public abstract void getByteArray(
int
byte[]
int
int)

public abstract double getDouble(
int)

public abstract double getDouble(
int
org.apache.harmony.luni.platform.Endianness)

public abstract float getFloat(
int)

public abstract float getFloat(
int
org.apache.harmony.luni.platform.Endianness)

public abstract int getInt(
int)

public abstract int getInt(
int
org.apache.harmony.luni.platform.Endianness)

public abstract long getLong(
int)

public abstract long getLong(
int
org.apache.harmony.luni.platform.Endianness)

public abstract int getPointerSize()

public abstract short getShort(
int)

public abstract short getShort(
int
org.apache.harmony.luni.platform.Endianness)

public abstract boolean isLittleEndian()

public abstract boolean isLoaded(
int
long)

public abstract void load(
int
long)
@dalvik.annotation.Throws (value =Ljava/lang/OutOfMemoryError; )
public abstract int malloc(
int)

public abstract void memmove(
int
int
long)

public abstract void memset(
int
byte
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int mmap(
int
long
long
int)

public abstract void setAddress(
int
int)

public abstract void setByte(
int
byte)
@dalvik.annotation.Throws (value =Ljava/lang/NullPointerException;Ljava/lang/IndexOutOfBoundsException; )
public abstract void setByteArray(
int
byte[]
int
int)

public abstract void setDouble(
int
double)

public abstract void setDouble(
int
double
org.apache.harmony.luni.platform.Endianness)

public abstract void setFloat(
int
float)

public abstract void setFloat(
int
float
org.apache.harmony.luni.platform.Endianness)

public abstract void setInt(
int
int)

public abstract void setInt(
int
int
org.apache.harmony.luni.platform.Endianness)
@dalvik.annotation.Throws (value =Ljava/lang/NullPointerException;Ljava/lang/IndexOutOfBoundsException; )
public abstract void setIntArray(
int
int[]
int
int
boolean)

public abstract void setLong(
int
long)

public abstract void setLong(
int
long
org.apache.harmony.luni.platform.Endianness)

public abstract void setShort(
int
short)

public abstract void setShort(
int
short
org.apache.harmony.luni.platform.Endianness)
@dalvik.annotation.Throws (value =Ljava/lang/NullPointerException;Ljava/lang/IndexOutOfBoundsException; )
public abstract void setShortArray(
int
short[]
int
int
boolean)

public abstract void unmap(
int
long)

________________CLASS________________


public abstract interface class org.apache.harmony.luni.platform.INetworkSystem extends java.lang.Object

----------------FIELDS----------------

public static final int SOCKET_CONNECT_STEP_CHECK

public static final int SOCKET_CONNECT_STEP_START
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void accept(
java.io.FileDescriptor
java.net.SocketImpl
java.io.FileDescriptor
int)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public abstract int availableStream(
java.io.FileDescriptor)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public abstract void bind(
java.io.FileDescriptor
int
java.net.InetAddress)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public abstract boolean bind2(
java.io.FileDescriptor
int
boolean
java.net.InetAddress)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int connect(
java.io.FileDescriptor
int
java.net.InetAddress
int)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public abstract void connectDatagram(
java.io.FileDescriptor
int
int
java.net.InetAddress)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void connectStreamWithTimeoutSocket(
java.io.FileDescriptor
int
int
int
java.net.InetAddress)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int connectWithTimeout(
java.io.FileDescriptor
int
int
java.net.InetAddress
int
int
byte[])
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public abstract void createDatagramSocket(
java.io.FileDescriptor
boolean)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public abstract void createMulticastSocket(
java.io.FileDescriptor
boolean)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public abstract void createServerStreamSocket(
java.io.FileDescriptor
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void createSocket(
java.io.FileDescriptor
boolean)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public abstract void disconnectDatagram(
java.io.FileDescriptor)
@dalvik.annotation.Throws (value =Ljava/net/UnknownHostException; )
public abstract java.net.InetAddress getHostByAddr(
byte[])
@dalvik.annotation.Throws (value =Ljava/net/UnknownHostException; )
public abstract java.net.InetAddress getHostByName(
java.lang.String
boolean)

public abstract int getSocketFlags()

public abstract java.net.InetAddress getSocketLocalAddress(
java.io.FileDescriptor
boolean)

public abstract int getSocketLocalPort(
java.io.FileDescriptor
boolean)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public abstract java.lang.Object getSocketOption(
java.io.FileDescriptor
int)

public abstract java.nio.channels.Channel inheritedChannel()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public abstract void listenStreamSocket(
java.io.FileDescriptor
int)

public abstract void oneTimeInitialization(
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int peekDatagram(
java.io.FileDescriptor
java.net.InetAddress
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int read(
java.io.FileDescriptor
byte[]
int
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int readDirect(
java.io.FileDescriptor
int
int
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int receiveDatagram(
java.io.FileDescriptor
java.net.DatagramPacket
byte[]
int
int
int
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int receiveDatagramDirect(
java.io.FileDescriptor
java.net.DatagramPacket
int
int
int
int
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int receiveStream(
java.io.FileDescriptor
byte[]
int
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int recvConnectedDatagram(
java.io.FileDescriptor
java.net.DatagramPacket
byte[]
int
int
int
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int recvConnectedDatagramDirect(
java.io.FileDescriptor
java.net.DatagramPacket
int
int
int
int
boolean)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public abstract int[] select(
java.io.FileDescriptor[]
java.io.FileDescriptor[]
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int sendConnectedDatagram(
java.io.FileDescriptor
byte[]
int
int
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int sendConnectedDatagramDirect(
java.io.FileDescriptor
int
int
int
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int sendDatagram(
java.io.FileDescriptor
byte[]
int
int
int
boolean
int
java.net.InetAddress)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int sendDatagram2(
java.io.FileDescriptor
byte[]
int
int
int
java.net.InetAddress)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int sendDatagramDirect(
java.io.FileDescriptor
int
int
int
int
boolean
int
java.net.InetAddress)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int sendStream(
java.io.FileDescriptor
byte[]
int
int)

public abstract void sendUrgentData(
java.io.FileDescriptor
byte)

public abstract void setInetAddress(
java.net.InetAddress
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void setNonBlocking(
java.io.FileDescriptor
boolean)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public abstract void setSocketOption(
java.io.FileDescriptor
int
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void shutdownInput(
java.io.FileDescriptor)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void shutdownOutput(
java.io.FileDescriptor)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void socketClose(
java.io.FileDescriptor)

public abstract boolean supportsUrgentData(
java.io.FileDescriptor)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int write(
java.io.FileDescriptor
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int writeDirect(
java.io.FileDescriptor
int
int
int)

________________CLASS________________


public class org.apache.harmony.luni.platform.PlatformAddress extends java.lang.Object implements org.apache.harmony.luni.platform.ICommonDataTypes, java.lang.Comparable

----------------FIELDS----------------

public static final org.apache.harmony.luni.platform.PlatformAddress NULL

static final int SIZEOF

static final long UNKNOWN

public static final org.apache.harmony.luni.platform.IMemorySpy memorySpy

static final org.apache.harmony.luni.platform.IMemorySystem osMemory

final int osaddr

final long size
----------------METHODS----------------

static void <clinit>()

 void <init>(
int
long)

public final void autoFree()

public final int compareTo(
java.lang.Object)

public org.apache.harmony.luni.platform.PlatformAddress duplicate()

public final boolean equals(
java.lang.Object)

public void free()

public final org.apache.harmony.luni.platform.PlatformAddress getAddress(
int)

public final byte getByte(
int)

public final void getByteArray(
int
byte[]
int
int)

public final double getDouble(
int)

public final double getDouble(
int
org.apache.harmony.luni.platform.Endianness)

public final float getFloat(
int)

public final float getFloat(
int
org.apache.harmony.luni.platform.Endianness)

public final int getInt(
int)

public final int getInt(
int
org.apache.harmony.luni.platform.Endianness)

public final long getLong(
int)

public final long getLong(
int
org.apache.harmony.luni.platform.Endianness)

public final short getShort(
int)

public final short getShort(
int
org.apache.harmony.luni.platform.Endianness)

public final long getSize()

public final int hashCode()

public final boolean isNULL()

public final void moveTo(
org.apache.harmony.luni.platform.PlatformAddress
long)

public org.apache.harmony.luni.platform.PlatformAddress offsetBytes(
int)

public final void setAddress(
int
org.apache.harmony.luni.platform.PlatformAddress)

public final void setByte(
int
byte)

public final void setByteArray(
int
byte[]
int
int)

public final void setDouble(
int
double)

public final void setDouble(
int
double
org.apache.harmony.luni.platform.Endianness)

public final void setFloat(
int
float)

public final void setFloat(
int
float
org.apache.harmony.luni.platform.Endianness)

public final void setInt(
int
int)

public final void setInt(
int
int
org.apache.harmony.luni.platform.Endianness)

public final void setIntArray(
int
int[]
int
int
boolean)

public final void setLong(
int
long)

public final void setLong(
int
long
org.apache.harmony.luni.platform.Endianness)

public final void setShort(
int
short)

public final void setShort(
int
short
org.apache.harmony.luni.platform.Endianness)

public final void setShortArray(
int
short[]
int
int
boolean)

public final int toInt()

public final long toLong()

public final java.lang.String toString()

________________CLASS________________


public class org.apache.harmony.luni.platform.MappedPlatformAddress extends org.apache.harmony.luni.platform.PlatformAddress

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
int
long)

public org.apache.harmony.luni.platform.PlatformAddress duplicate()

public final void free()

public final void mmapFlush()

public final boolean mmapIsLoaded()

public final void mmapLoad()

public final org.apache.harmony.luni.platform.PlatformAddress offsetBytes(
int)

________________CLASS________________


 class org.apache.harmony.luni.platform.OSComponent extends java.lang.Object implements org.apache.harmony.luni.platform.IAdaptable

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public java.lang.Object getAdapter(
java.lang.Class)

________________CLASS________________


 class org.apache.harmony.luni.platform.OSComponentFactory extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public static org.apache.harmony.luni.platform.IFileSystem getFileSystem()

public static org.apache.harmony.luni.platform.IMemorySystem getMemorySystem()

public static org.apache.harmony.luni.platform.INetworkSystem getNetworkSystem()

________________CLASS________________


 class org.apache.harmony.luni.platform.OSFileSystem extends org.apache.harmony.luni.platform.OSComponent implements org.apache.harmony.luni.platform.IFileSystem

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

private native int closeImpl(
int)

private native int fflushImpl(
int
boolean)

private native int lockImpl(
int
long
long
int
boolean)

private native int openImpl(
byte[]
int)

private native long readDirectImpl(
int
int
int
int)

private native long readImpl(
int
byte[]
int
int)

private native long readvImpl(
int
int[]
int[]
int[]
int)

private native long seekImpl(
int
long
int)

private native long transferImpl(
int
java.io.FileDescriptor
long
long)

private native int truncateImpl(
int
long)

private native long ttyReadImpl(
byte[]
int
int)

private native int unlockImpl(
int
long
long)

private final void validateLockArgs(
int
long
long)

private native long writeDirectImpl(
int
int
int
int)

private native long writeImpl(
int
byte[]
int
int)

private native long writevImpl(
int
int[]
int[]
int[]
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void fflush(
int
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public native int getAllocGranularity()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public native int ioctlAvailable(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public boolean lock(
int
long
long
int
boolean)
@dalvik.annotation.Throws (value =Ljava/io/FileNotFoundException; )
public int open(
byte[]
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long read(
int
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long readDirect(
int
int
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long readv(
int
int[]
int[]
int[]
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long seek(
int
long
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long transfer(
int
java.io.FileDescriptor
long
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void truncate(
int
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long ttyRead(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void unlock(
int
long
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long write(
int
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long writeDirect(
int
int
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long writev(
int
int[]
int[]
int[]
int)

________________CLASS________________


final class org.apache.harmony.luni.platform.OSMemory extends org.apache.harmony.luni.platform.OSComponent implements org.apache.harmony.luni.platform.IMemorySystem

----------------FIELDS----------------

public static final org.apache.harmony.luni.platform.Endianness NATIVE_ORDER

public static final int POINTER_SIZE

private static final org.apache.harmony.luni.platform.OSMemory singleton
----------------METHODS----------------

static void <clinit>()

 void <init>()

private native int flushImpl(
int
long)

public static org.apache.harmony.luni.platform.OSMemory getOSMemory()

private static native int getPointerSizeImpl()

private static native boolean isLittleEndianImpl()

private native boolean isLoadedImpl(
int
long)

private native int loadImpl(
int
long)

private native int mmapImpl(
int
long
long
int)

private int swap(
int)

private long swap(
long)

private short swap(
short)

private native void unmapImpl(
int
long)

public void flush(
int
long)

public native void free(
int)

public native int getAddress(
int)

public native byte getByte(
int)
@dalvik.annotation.Throws (value =Ljava/lang/NullPointerException;Ljava/lang/IndexOutOfBoundsException; )
public native void getByteArray(
int
byte[]
int
int)

public native double getDouble(
int)

public double getDouble(
int
org.apache.harmony.luni.platform.Endianness)

public native float getFloat(
int)

public float getFloat(
int
org.apache.harmony.luni.platform.Endianness)

public native int getInt(
int)

public int getInt(
int
org.apache.harmony.luni.platform.Endianness)

public native long getLong(
int)

public long getLong(
int
org.apache.harmony.luni.platform.Endianness)

public org.apache.harmony.luni.platform.Endianness getNativeOrder()

public int getPointerSize()

public native short getShort(
int)

public short getShort(
int
org.apache.harmony.luni.platform.Endianness)

public boolean isLittleEndian()

public boolean isLoaded(
int
long)

public void load(
int
long)
@dalvik.annotation.Throws (value =Ljava/lang/OutOfMemoryError; )
public native int malloc(
int)

public native void memmove(
int
int
long)

public native void memset(
int
byte
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int mmap(
int
long
long
int)

public native void setAddress(
int
int)

public native void setByte(
int
byte)
@dalvik.annotation.Throws (value =Ljava/lang/NullPointerException;Ljava/lang/IndexOutOfBoundsException; )
public native void setByteArray(
int
byte[]
int
int)

public native void setDouble(
int
double)

public void setDouble(
int
double
org.apache.harmony.luni.platform.Endianness)

public native void setFloat(
int
float)

public void setFloat(
int
float
org.apache.harmony.luni.platform.Endianness)

public native void setInt(
int
int)

public void setInt(
int
int
org.apache.harmony.luni.platform.Endianness)
@dalvik.annotation.Throws (value =Ljava/lang/NullPointerException;Ljava/lang/IndexOutOfBoundsException; )
public native void setIntArray(
int
int[]
int
int
boolean)

public native void setLong(
int
long)

public void setLong(
int
long
org.apache.harmony.luni.platform.Endianness)

public native void setShort(
int
short)

public void setShort(
int
short
org.apache.harmony.luni.platform.Endianness)
@dalvik.annotation.Throws (value =Ljava/lang/NullPointerException;Ljava/lang/IndexOutOfBoundsException; )
public native void setShortArray(
int
short[]
int
int
boolean)

public void unmap(
int
long)

________________CLASS________________


final class org.apache.harmony.luni.platform.OSNetworkSystem extends java.lang.Object implements org.apache.harmony.luni.platform.INetworkSystem

----------------FIELDS----------------

private static final int ERRORCODE_SOCKET_TIMEOUT

private static final int INETADDR_REACHABLE

private static boolean isNetworkInited

private static org.apache.harmony.luni.platform.OSNetworkSystem ref
----------------METHODS----------------

static void <clinit>()

private void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
static native void acceptSocketImpl(
java.io.FileDescriptor
java.net.SocketImpl
java.io.FileDescriptor
int)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
static native int availableStreamImpl(
java.io.FileDescriptor)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
static native void connectDatagramImpl2(
java.io.FileDescriptor
int
int
java.net.InetAddress)

static native int connectSocketImpl(
java.io.FileDescriptor
int
java.net.InetAddress
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
static native void connectStreamWithTimeoutSocketImpl(
java.io.FileDescriptor
int
int
int
java.net.InetAddress)

static native int connectWithTimeoutSocketImpl(
java.io.FileDescriptor
int
int
java.net.InetAddress
int
int
byte[])
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
static native void createDatagramSocketImpl(
java.io.FileDescriptor
boolean)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
static native void createMulticastSocketImpl(
java.io.FileDescriptor
boolean)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
static native void createServerStreamSocketImpl(
java.io.FileDescriptor
boolean)

static native void createSocketImpl(
java.io.FileDescriptor
boolean)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
static native void disconnectDatagramImpl(
java.io.FileDescriptor)
@dalvik.annotation.Throws (value =Ljava/net/UnknownHostException; )
static native java.net.InetAddress getHostByAddrImpl(
byte[])
@dalvik.annotation.Throws (value =Ljava/net/UnknownHostException; )
static native java.net.InetAddress getHostByNameImpl(
java.lang.String
boolean)

public static org.apache.harmony.luni.platform.OSNetworkSystem getOSNetworkSystem()

static native int getSocketFlagsImpl()

static native java.net.InetAddress getSocketLocalAddressImpl(
java.io.FileDescriptor
boolean)

static native int getSocketLocalPortImpl(
java.io.FileDescriptor
boolean)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
static native java.lang.Object getSocketOptionImpl(
java.io.FileDescriptor
int)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
static native void listenStreamSocketImpl(
java.io.FileDescriptor
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
static native int peekDatagramImpl(
java.io.FileDescriptor
java.net.InetAddress
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
static native int readSocketDirectImpl(
java.io.FileDescriptor
int
int
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
static native int readSocketImpl(
java.io.FileDescriptor
byte[]
int
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
static native int receiveDatagramDirectImpl(
java.io.FileDescriptor
java.net.DatagramPacket
int
int
int
int
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
static native int receiveDatagramImpl(
java.io.FileDescriptor
java.net.DatagramPacket
byte[]
int
int
int
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
static native int receiveStreamImpl(
java.io.FileDescriptor
byte[]
int
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
static native int recvConnectedDatagramDirectImpl(
java.io.FileDescriptor
java.net.DatagramPacket
int
int
int
int
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
static native int recvConnectedDatagramImpl(
java.io.FileDescriptor
java.net.DatagramPacket
byte[]
int
int
int
boolean)

static native int selectImpl(
java.io.FileDescriptor[]
java.io.FileDescriptor[]
int
int
int[]
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
static native int sendConnectedDatagramDirectImpl(
java.io.FileDescriptor
int
int
int
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
static native int sendConnectedDatagramImpl(
java.io.FileDescriptor
byte[]
int
int
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
static native int sendDatagramDirectImpl(
java.io.FileDescriptor
int
int
int
int
boolean
int
java.net.InetAddress)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
static native int sendDatagramImpl(
java.io.FileDescriptor
byte[]
int
int
int
boolean
int
java.net.InetAddress)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
static native int sendDatagramImpl2(
java.io.FileDescriptor
byte[]
int
int
int
java.net.InetAddress)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
static native int sendStreamImpl(
java.io.FileDescriptor
byte[]
int
int)

static native void sendUrgentDataImpl(
java.io.FileDescriptor
byte)

static native void setNonBlockingImpl(
java.io.FileDescriptor
boolean)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
static native void setSocketOptionImpl(
java.io.FileDescriptor
int
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private native void shutdownInputImpl(
java.io.FileDescriptor)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private native void shutdownOutputImpl(
java.io.FileDescriptor)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
static native void socketBindImpl(
java.io.FileDescriptor
int
java.net.InetAddress)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
static native boolean socketBindImpl2(
java.io.FileDescriptor
int
boolean
java.net.InetAddress)

static native void socketCloseImpl(
java.io.FileDescriptor)

static native boolean supportsUrgentDataImpl(
java.io.FileDescriptor)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
static native int writeSocketDirectImpl(
java.io.FileDescriptor
int
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
static native int writeSocketImpl(
java.io.FileDescriptor
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void accept(
java.io.FileDescriptor
java.net.SocketImpl
java.io.FileDescriptor
int)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public int availableStream(
java.io.FileDescriptor)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void bind(
java.io.FileDescriptor
int
java.net.InetAddress)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public boolean bind2(
java.io.FileDescriptor
int
boolean
java.net.InetAddress)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int connect(
java.io.FileDescriptor
int
java.net.InetAddress
int)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void connectDatagram(
java.io.FileDescriptor
int
int
java.net.InetAddress)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void connectStreamWithTimeoutSocket(
java.io.FileDescriptor
int
int
int
java.net.InetAddress)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int connectWithTimeout(
java.io.FileDescriptor
int
int
java.net.InetAddress
int
int
byte[])
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void createDatagramSocket(
java.io.FileDescriptor
boolean)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void createMulticastSocket(
java.io.FileDescriptor
boolean)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void createServerStreamSocket(
java.io.FileDescriptor
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void createSocket(
java.io.FileDescriptor
boolean)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void disconnectDatagram(
java.io.FileDescriptor)
@dalvik.annotation.Throws (value =Ljava/net/UnknownHostException; )
public java.net.InetAddress getHostByAddr(
byte[])
@dalvik.annotation.Throws (value =Ljava/net/UnknownHostException; )
public java.net.InetAddress getHostByName(
java.lang.String
boolean)

public int getSocketFlags()

public java.net.InetAddress getSocketLocalAddress(
java.io.FileDescriptor
boolean)

public int getSocketLocalPort(
java.io.FileDescriptor
boolean)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public java.lang.Object getSocketOption(
java.io.FileDescriptor
int)

public java.nio.channels.Channel inheritedChannel()

native java.nio.channels.Channel inheritedChannelImpl()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void listenStreamSocket(
java.io.FileDescriptor
int)

public void oneTimeInitialization(
boolean)

native void oneTimeInitializationImpl(
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int peekDatagram(
java.io.FileDescriptor
java.net.InetAddress
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
java.io.FileDescriptor
byte[]
int
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int readDirect(
java.io.FileDescriptor
int
int
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int receiveDatagram(
java.io.FileDescriptor
java.net.DatagramPacket
byte[]
int
int
int
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int receiveDatagramDirect(
java.io.FileDescriptor
java.net.DatagramPacket
int
int
int
int
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int receiveStream(
java.io.FileDescriptor
byte[]
int
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int recvConnectedDatagram(
java.io.FileDescriptor
java.net.DatagramPacket
byte[]
int
int
int
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int recvConnectedDatagramDirect(
java.io.FileDescriptor
java.net.DatagramPacket
int
int
int
int
boolean)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public int[] select(
java.io.FileDescriptor[]
java.io.FileDescriptor[]
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int sendConnectedDatagram(
java.io.FileDescriptor
byte[]
int
int
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int sendConnectedDatagramDirect(
java.io.FileDescriptor
int
int
int
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int sendDatagram(
java.io.FileDescriptor
byte[]
int
int
int
boolean
int
java.net.InetAddress)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int sendDatagram2(
java.io.FileDescriptor
byte[]
int
int
int
java.net.InetAddress)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int sendDatagramDirect(
java.io.FileDescriptor
int
int
int
int
boolean
int
java.net.InetAddress)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int sendStream(
java.io.FileDescriptor
byte[]
int
int)

public void sendUrgentData(
java.io.FileDescriptor
byte)

public void setInetAddress(
java.net.InetAddress
byte[])

native void setInetAddressImpl(
java.net.InetAddress
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void setNonBlocking(
java.io.FileDescriptor
boolean)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void setSocketOption(
java.io.FileDescriptor
int
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void shutdownInput(
java.io.FileDescriptor)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void shutdownOutput(
java.io.FileDescriptor)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void socketClose(
java.io.FileDescriptor)

public boolean supportsUrgentData(
java.io.FileDescriptor)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int write(
java.io.FileDescriptor
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int writeDirect(
java.io.FileDescriptor
int
int
int)

________________CLASS________________


public class org.apache.harmony.luni.platform.Platform extends java.lang.Object

----------------FIELDS----------------

static final org.apache.harmony.luni.platform.IAdapterManager ADAPTER_MANAGER

static final org.apache.harmony.luni.platform.IFileSystem FILE_SYSTEM

static final org.apache.harmony.luni.platform.IMemorySystem MEMORY_SYSTEM

static final org.apache.harmony.luni.platform.INetworkSystem NETWORK_SYSTEM
----------------METHODS----------------

static void <clinit>()

public void <init>()

private static final void accessCheck()

public static org.apache.harmony.luni.platform.IAdapterManager getAdapterManager()

public static org.apache.harmony.luni.platform.IFileSystem getFileSystem()

public static org.apache.harmony.luni.platform.IMemorySystem getMemorySystem()

public static org.apache.harmony.luni.platform.INetworkSystem getNetworkSystem()

________________CLASS________________


public class org.apache.harmony.luni.platform.PlatformAddressFactory extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public static org.apache.harmony.luni.platform.PlatformAddress alloc(
int)

public static org.apache.harmony.luni.platform.PlatformAddress alloc(
int
byte)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static org.apache.harmony.luni.platform.PlatformAddress allocMap(
int
long
long
int)

public static org.apache.harmony.luni.platform.MappedPlatformAddress mapOn(
int
long)

public static org.apache.harmony.luni.platform.PlatformAddress on(
int)

public static org.apache.harmony.luni.platform.PlatformAddress on(
int
long)

________________CLASS________________


final class org.apache.harmony.luni.platform.RuntimeMemorySpy extends org.apache.harmony.luni.platform.AbstractMemorySpy

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public void alloc(
org.apache.harmony.luni.platform.PlatformAddress)

________________CLASS________________


public class org.apache.harmony.luni.util.Base64 extends java.lang.Object

----------------FIELDS----------------

private static final byte[] map
----------------METHODS----------------

static void <clinit>()

public void <init>()

public static byte[] decode(
byte[])

public static byte[] decode(
byte[]
int)
@dalvik.annotation.Throws (value =Ljava/io/UnsupportedEncodingException; )
public static java.lang.String encode(
byte[]
java.lang.String)

________________CLASS________________


public class org.apache.harmony.luni.util.BinarySearch extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public static int binarySearch(
java.lang.String
char)

public static int binarySearchRange(
java.lang.String
char)

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Comparator<Ljava/lang/String;>; )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class org.apache.harmony.luni.util.DeleteOnExit$1 extends java.lang.Object implements java.util.Comparator

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public volatile int compare(
java.lang.Object
java.lang.Object)

public int compare(
java.lang.String
java.lang.String)

________________CLASS________________


public class org.apache.harmony.luni.util.DeleteOnExit extends java.lang.Object

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Vector<Ljava/lang/String;>; )
private static java.util.Vector deleteList
----------------METHODS----------------

static void <clinit>()

public void <init>()

public static void addFile(
java.lang.String)

public static void deleteOnExit()

________________CLASS________________


public class org.apache.harmony.luni.util.ErrorCodeException extends java.lang.Exception

----------------FIELDS----------------

private static final long serialVersionUID

private int errorCode
----------------METHODS----------------

public void <init>(
int)

public int getErrorCode()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/luni/util/FloatingPointParser; )
@dalvik.annotation.InnerClass (accessFlags =26 name =StringExponentPair )
final class org.apache.harmony.luni.util.FloatingPointParser$StringExponentPair extends java.lang.Object

----------------FIELDS----------------

 int e

 boolean negative

 java.lang.String s
----------------METHODS----------------

 void <init>(
java.lang.String
int
boolean)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/apache/harmony/luni/util/FloatingPointParser$StringExponentPair; )
public final class org.apache.harmony.luni.util.FloatingPointParser extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

private static org.apache.harmony.luni.util.FloatingPointParser$StringExponentPair initialParse(
java.lang.String
int)

private static native double parseDblImpl(
java.lang.String
int)

private static double parseDblName(
java.lang.String
int)

public static double parseDouble(
java.lang.String)

public static float parseFloat(
java.lang.String)

private static native float parseFltImpl(
java.lang.String
int)

private static float parseFltName(
java.lang.String
int)

________________CLASS________________


final class org.apache.harmony.luni.util.HexStringParser extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.String BINARY_EXPONENT

private static final int DOUBLE_EXPONENT_WIDTH

private static final int DOUBLE_MANTISSA_WIDTH

private static final int FLOAT_EXPONENT_WIDTH

private static final int FLOAT_MANTISSA_WIDTH

private static final java.lang.String FLOAT_TYPE_SUFFIX

private static final java.lang.String HEX_PATTERN

private static final int HEX_RADIX

private static final java.lang.String HEX_SIGNIFICANT

private static final int MAX_SIGNIFICANT_LENGTH

private static final java.util.regex.Pattern PATTERN

private final long EXPONENT_BASE

private final int EXPONENT_WIDTH

private final long MANTISSA_MASK

private final int MANTISSA_WIDTH

private final long MAX_EXPONENT

private final long MIN_EXPONENT

private java.lang.String abandonedNumber

private long exponent

private long mantissa

private long sign
----------------METHODS----------------

static void <clinit>()

public void <init>(
int
int)

private void checkedAddExponent(
long)

private int countBitsLength(
long)

private void discardTrailingBits(
long)

private void fitMantissaInDesiredWidth(
int)

private java.lang.String getNormalizedSignificand(
java.lang.String
java.lang.String)

private int getOffset(
java.lang.String
java.lang.String)

private static java.lang.String[] getSegmentsFromHexString(
java.lang.String)

private long parse(
java.lang.String)

public static double parseDouble(
java.lang.String)

private void parseExponent(
java.lang.String)

public static float parseFloat(
java.lang.String)

private void parseHexSign(
java.lang.String)

private void parseMantissa(
java.lang.String)

private void processNormalNumber()

private void processSubNormalNumber()

private void round()

private void setInfinite()

private void setZero()

________________CLASS________________


public class org.apache.harmony.luni.util.Inet6Util extends java.lang.Object

----------------FIELDS----------------

static java.lang.String hexCharacters
----------------METHODS----------------

static void <clinit>()

public void <init>()

public static java.lang.String addressToString(
int)

public static int bytesToInt(
byte[]
int)

public static void convertToBytes(
java.lang.String
byte[]
int)

public static byte[] createByteArrayFromIPAddressString(
java.lang.String)

public static java.lang.String createIPAddrStringFromByteArray(
byte[])

static int getIntValue(
char)

private static boolean isIPv4MappedAddress(
byte[])

static boolean isValidHexChar(
char)

public static boolean isValidIP4Word(
java.lang.String)

public static boolean isValidIP6Address(
java.lang.String)

public static boolean isValidIPV4Address(
java.lang.String)

________________CLASS________________


public class org.apache.harmony.luni.util.InvalidJarIndexException extends java.lang.RuntimeException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class org.apache.harmony.luni.util.Msg extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.String sResource
----------------METHODS----------------

public void <init>()

public static java.lang.String getString(
java.lang.String)

public static java.lang.String getString(
java.lang.String
char)

public static java.lang.String getString(
java.lang.String
int)

public static java.lang.String getString(
java.lang.String
java.lang.Object)

public static java.lang.String getString(
java.lang.String
java.lang.Object
java.lang.Object)

public static java.lang.String getString(
java.lang.String
java.lang.Object[])

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/Object;>; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
final class org.apache.harmony.luni.util.MsgHelp$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final java.lang.ClassLoader val$loader

final java.util.Locale val$locale

final java.lang.String val$resource
----------------METHODS----------------

 void <init>(
java.lang.String
java.util.Locale
java.lang.ClassLoader)

public java.lang.Object run()

________________CLASS________________


public final class org.apache.harmony.luni.util.MsgHelp extends java.lang.Object

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/HashMap<Ljava/lang/String;Ljava/lang/ref/SoftReference<Ljava/util/ResourceBundle;>;>; )
private static java.util.HashMap sRefMap
----------------METHODS----------------

static void <clinit>()

public void <init>()

public static java.lang.String format(
java.lang.String
java.lang.Object[])

public static java.lang.String getString(
java.lang.String
java.lang.String)

public static java.lang.String getString(
java.lang.String
java.lang.String
java.lang.Object[])

public static java.util.ResourceBundle loadBundle(
java.lang.String)

public static java.util.ResourceBundle setLocale(
java.util.Locale
java.lang.String)

________________CLASS________________


public class org.apache.harmony.luni.util.NotImplementedException extends java.lang.RuntimeException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.io.PrintStream)

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.Throwable)

public void <init>(
java.lang.Throwable)

________________CLASS________________


public final class org.apache.harmony.luni.util.NumberConverter extends java.lang.Object

----------------FIELDS----------------

private static final long[] TEN_TO_THE

private static final double invLogOfTenBaseTwo

private int firstK

private int getCount

private int setCount

private int[] uArray
----------------METHODS----------------

static void <clinit>()

public void <init>()

private native void bigIntDigitGeneratorInstImpl(
long
int
boolean
boolean
int)

public static java.lang.String convert(
double)

public static java.lang.String convert(
float)

private java.lang.String freeFormat()

private java.lang.String freeFormatExponential()

private static org.apache.harmony.luni.util.NumberConverter getConverter()

private void longDigitGenerator(
long
int
boolean
boolean
int)

public java.lang.String convertD(
double)

public java.lang.String convertF(
float)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =DBEntry )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/luni/util/OIDDatabase; )
 class org.apache.harmony.luni.util.OIDDatabase$DBEntry extends java.lang.Object

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/List<Lorg/apache/harmony/luni/util/OIDDatabase$DBEntry;>; )
private final java.util.List equivalents

private final java.lang.String value
----------------METHODS----------------

 void <init>(
java.lang.String)

 void addEquivalent(
org.apache.harmony.luni.util.OIDDatabase$DBEntry)
@dalvik.annotation.Signature (value =()Ljava/util/Set<Lorg/apache/harmony/luni/util/OIDDatabase$DBEntry;>; )
 java.util.Set getAllEquivalents()

 java.lang.String getValue()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/apache/harmony/luni/util/OIDDatabase$DBEntry; )
public class org.apache.harmony.luni.util.OIDDatabase extends java.lang.Object

----------------FIELDS----------------

private static org.apache.harmony.luni.util.OIDDatabase instance
@dalvik.annotation.Signature (value =Ljava/util/Set<Lorg/apache/harmony/luni/util/OIDDatabase$DBEntry;>; )
private java.util.Set algorithms
@dalvik.annotation.Signature (value =Ljava/util/Set<Lorg/apache/harmony/luni/util/OIDDatabase$DBEntry;>; )
private java.util.Set oids
----------------METHODS----------------

static void <clinit>()

private void <init>()
@dalvik.annotation.Signature (value =(Ljava/lang/String;Ljava/util/Iterator<Lorg/apache/harmony/luni/util/OIDDatabase$DBEntry;>;)Ljava/util/Set<Ljava/lang/String;>; )
private java.util.Set getAllEquivalents(
java.lang.String
java.util.Iterator)

public static org.apache.harmony.luni.util.OIDDatabase getInstance()

private void wireTogether(
org.apache.harmony.luni.util.OIDDatabase$DBEntry
org.apache.harmony.luni.util.OIDDatabase$DBEntry)
@dalvik.annotation.Signature (value =(Ljava/lang/String;)Ljava/util/Set<Ljava/lang/String;>; )
public java.util.Set getAllAlgorithmsForOID(
java.lang.String)
@dalvik.annotation.Signature (value =(Ljava/lang/String;)Ljava/util/Set<Ljava/lang/String;>; )
public java.util.Set getAllOIDsForAlgorithm(
java.lang.String)

public java.lang.String getFirstAlgorithmForOID(
java.lang.String)

public java.lang.String getFirstOIDForAlgorithm(
java.lang.String)

________________CLASS________________


public class org.apache.harmony.luni.util.PasswordProtectedInputStream extends java.io.FilterInputStream

----------------FIELDS----------------

private byte[] password

private int pwdIndex
----------------METHODS----------------

public void <init>(
java.io.InputStream
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long skip(
long)

________________CLASS________________


public class org.apache.harmony.luni.util.PositionedInputStream extends java.io.FilterInputStream

----------------FIELDS----------------

private int currentPosition
----------------METHODS----------------

public void <init>(
java.io.InputStream)

public int currentPosition()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[]
int
int)

public void resetCurrentPosition()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long skip(
long)

________________CLASS________________

@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>Ljava/lang/Object;Ljava/security/PrivilegedAction<TT;>; )
public class org.apache.harmony.luni.util.PriviAction extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

private static final int GET_SECURITY_POLICY

private static final int GET_SECURITY_PROPERTY

private static final int GET_SYSTEM_PROPERTY

private static final int SET_ACCESSIBLE

private int action

private java.lang.Object arg1

private java.lang.Object arg2
----------------METHODS----------------

public void <init>()

private void <init>(
int
java.lang.Object)

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.String)

public void <init>(
java.lang.reflect.AccessibleObject)
@dalvik.annotation.Signature (value =(Ljava/lang/String;)Ljava/security/PrivilegedAction<Ljava/lang/String;>; )
public static java.security.PrivilegedAction getSecurityProperty(
java.lang.String)
@dalvik.annotation.Signature (value =()TT; )
public java.lang.Object run()

________________CLASS________________


public class org.apache.harmony.luni.util.SHAOutputStream extends java.io.OutputStream implements java.lang.Cloneable

----------------FIELDS----------------

private static final int BlockSizeInBytes

private static final int H0

private static final int H1

private static final int H2

private static final int H3

private static final int H4

private static final int HConstantsSize

private static final int HashSizeInBytes

private static final int K0_19

private static final int K20_39

private static final int K40_59

private static final int K60_79

private static final int WArraySize

private int[] HConstants

private byte[] MArray

private int[] WArray

private long bytesProcessed

private int bytesToProcess

private byte[] oneByte
----------------METHODS----------------

public void <init>()

public void <init>(
byte[])

private void copyToInternalBuffer(
byte[]
int
int)

private void initialize()

private void padBuffer()

private void processBuffer()

private static java.lang.String toStringBlock(
byte[])

private static java.lang.String toStringBlock(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/lang/CloneNotSupportedException; )
public java.lang.Object clone()

public int[] getHash()

public byte[] getHashAsBytes()

public byte[] getHashAsBytes(
boolean)

public void reset()

public java.lang.String toString()

public void write(
int)

public void write(
byte[]
int
int)

________________CLASS________________

@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Comparator<TT;>; )
@dalvik.annotation.InnerClass (accessFlags =1545 name =Comparator )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/luni/util/Sorter; )
public abstract interface class org.apache.harmony.luni.util.Sorter$Comparator extends java.lang.Object implements java.util.Comparator

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@java.lang.Deprecated
@dalvik.annotation.MemberClasses (value =Lorg/apache/harmony/luni/util/Sorter$Comparator; )
public final class org.apache.harmony.luni.util.Sorter extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>([TT;Lorg/apache/harmony/luni/util/Sorter$Comparator<TT;>;)V )
public static void sort(
java.lang.Object[]
org.apache.harmony.luni.util.Sorter$Comparator)

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Map$Entry<Ljava/lang/String;TV;>; )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/luni/util/TwoKeyHashMap; )
@dalvik.annotation.InnerClass (accessFlags =9 name =Entry )
public class org.apache.harmony.luni.util.TwoKeyHashMap$Entry extends java.lang.Object implements java.util.Map$Entry

----------------FIELDS----------------

 int hash
@dalvik.annotation.Signature (value =TE; )
 java.lang.Object key1
@dalvik.annotation.Signature (value =TK; )
 java.lang.Object key2
@dalvik.annotation.Signature (value =Lorg/apache/harmony/luni/util/TwoKeyHashMap$Entry<TE;TK;TV;>; )
 org.apache.harmony.luni.util.TwoKeyHashMap$Entry next
@dalvik.annotation.Signature (value =TV; )
 java.lang.Object value
----------------METHODS----------------
@dalvik.annotation.Signature (value =(ITE;TK;TV;Lorg/apache/harmony/luni/util/TwoKeyHashMap$Entry<TE;TK;TV;>;)V )
public void <init>(
int
java.lang.Object
java.lang.Object
java.lang.Object
org.apache.harmony.luni.util.TwoKeyHashMap$Entry)

public boolean equals(
java.lang.Object)

public volatile java.lang.Object getKey()

public java.lang.String getKey()
@dalvik.annotation.Signature (value =()TE; )
public java.lang.Object getKey1()
@dalvik.annotation.Signature (value =()TK; )
public java.lang.Object getKey2()
@dalvik.annotation.Signature (value =()TV; )
public java.lang.Object getValue()

public int hashCode()
@dalvik.annotation.Signature (value =(TV;)TV; )
public java.lang.Object setValue(
java.lang.Object)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/luni/util/TwoKeyHashMap; )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Iterator<Ljava/util/Map$Entry<Ljava/lang/String;TV;>;>; )
@dalvik.annotation.InnerClass (accessFlags =0 name =EntryIteratorImpl )
 class org.apache.harmony.luni.util.TwoKeyHashMap$EntryIteratorImpl extends java.lang.Object implements java.util.Iterator

----------------FIELDS----------------

private int curr
@dalvik.annotation.Signature (value =Lorg/apache/harmony/luni/util/TwoKeyHashMap$Entry<TE;TK;TV;>; )
private org.apache.harmony.luni.util.TwoKeyHashMap$Entry curr_entry

private boolean found
@dalvik.annotation.Signature (value =Lorg/apache/harmony/luni/util/TwoKeyHashMap$Entry<TE;TK;TV;>; )
private org.apache.harmony.luni.util.TwoKeyHashMap$Entry returned_entry

private int returned_index

private int startModCount

final org.apache.harmony.luni.util.TwoKeyHashMap this$0
----------------METHODS----------------

 void <init>(
org.apache.harmony.luni.util.TwoKeyHashMap)

public boolean hasNext()

public volatile java.lang.Object next()
@dalvik.annotation.Signature (value =()Ljava/util/Map$Entry<Ljava/lang/String;TV;>; )
public java.util.Map$Entry next()

public void remove()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/luni/util/TwoKeyHashMap; )
@dalvik.annotation.InnerClass (accessFlags =0 name =EntrySetImpl )
@dalvik.annotation.Signature (value =Ljava/util/AbstractSet<Ljava/util/Map$Entry<Ljava/lang/String;TV;>;>; )
 class org.apache.harmony.luni.util.TwoKeyHashMap$EntrySetImpl extends java.util.AbstractSet

----------------FIELDS----------------

final org.apache.harmony.luni.util.TwoKeyHashMap this$0
----------------METHODS----------------

 void <init>(
org.apache.harmony.luni.util.TwoKeyHashMap)

public void clear()

public boolean contains(
java.lang.Object)

public boolean isEmpty()
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<Ljava/util/Map$Entry<Ljava/lang/String;TV;>;>; )
public java.util.Iterator iterator()

public boolean remove(
java.lang.Object)

public int size()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Iterator<TV;>; )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/luni/util/TwoKeyHashMap; )
@dalvik.annotation.InnerClass (accessFlags =0 name =ValueIteratorImpl )
 class org.apache.harmony.luni.util.TwoKeyHashMap$ValueIteratorImpl extends java.lang.Object implements java.util.Iterator

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Lorg/apache/harmony/luni/util/TwoKeyHashMap<TE;TK;TV;>.EntryIteratorImpl; )
private org.apache.harmony.luni.util.TwoKeyHashMap$EntryIteratorImpl itr

final org.apache.harmony.luni.util.TwoKeyHashMap this$0
----------------METHODS----------------

 void <init>(
org.apache.harmony.luni.util.TwoKeyHashMap)

public boolean hasNext()
@dalvik.annotation.Signature (value =()TV; )
public java.lang.Object next()

public void remove()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/util/AbstractCollection<TV;>; )
@dalvik.annotation.InnerClass (accessFlags =0 name =ValuesCollectionImpl )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/luni/util/TwoKeyHashMap; )
 class org.apache.harmony.luni.util.TwoKeyHashMap$ValuesCollectionImpl extends java.util.AbstractCollection

----------------FIELDS----------------

final org.apache.harmony.luni.util.TwoKeyHashMap this$0
----------------METHODS----------------

 void <init>(
org.apache.harmony.luni.util.TwoKeyHashMap)

public void clear()

public boolean contains(
java.lang.Object)

public boolean isEmpty()
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TV;>; )
public java.util.Iterator iterator()

public int size()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/apache/harmony/luni/util/TwoKeyHashMap$ValueIteratorImpl;Lorg/apache/harmony/luni/util/TwoKeyHashMap$ValuesCollectionImpl;Lorg/apache/harmony/luni/util/TwoKeyHashMap$EntryIteratorImpl;Lorg/apache/harmony/luni/util/TwoKeyHashMap$EntrySetImpl;Lorg/apache/harmony/luni/util/TwoKeyHashMap$Entry; )
@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;K:Ljava/lang/Object;V:Ljava/lang/Object;>Ljava/util/AbstractMap<Ljava/lang/String;TV;>; )
public class org.apache.harmony.luni.util.TwoKeyHashMap extends java.util.AbstractMap

----------------FIELDS----------------

static final int DEFAULT_INITIAL_SIZE

static final float DEFAULT_LOAD_FACTOR
@dalvik.annotation.Signature (value =[Lorg/apache/harmony/luni/util/TwoKeyHashMap$Entry<TE;TK;TV;>; )
private org.apache.harmony.luni.util.TwoKeyHashMap$Entry[] arr

private int arrSize
@dalvik.annotation.Signature (value =Ljava/util/Set<Ljava/util/Map$Entry<Ljava/lang/String;TV;>;>; )
private java.util.Set entrySet

private float loadFactor

private int modCount

private int size

 int threshold
@dalvik.annotation.Signature (value =Ljava/util/Collection<TV;>; )
private java.util.Collection values
----------------METHODS----------------

public void <init>()

public void <init>(
int)

public void <init>(
int
float)

static int access$000(
org.apache.harmony.luni.util.TwoKeyHashMap)

static int access$010(
org.apache.harmony.luni.util.TwoKeyHashMap)

static org.apache.harmony.luni.util.TwoKeyHashMap$Entry access$100(
org.apache.harmony.luni.util.TwoKeyHashMap
java.lang.Object
java.lang.Object)

static org.apache.harmony.luni.util.TwoKeyHashMap$Entry access$200(
org.apache.harmony.luni.util.TwoKeyHashMap
java.lang.Object
java.lang.Object)

static int access$300(
org.apache.harmony.luni.util.TwoKeyHashMap)

static int access$308(
org.apache.harmony.luni.util.TwoKeyHashMap)

static org.apache.harmony.luni.util.TwoKeyHashMap$Entry[] access$400(
org.apache.harmony.luni.util.TwoKeyHashMap)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Object;)Lorg/apache/harmony/luni/util/TwoKeyHashMap$Entry<TE;TK;TV;>; )
private final org.apache.harmony.luni.util.TwoKeyHashMap$Entry findEntry(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Object;)Lorg/apache/harmony/luni/util/TwoKeyHashMap$Entry<TE;TK;TV;>; )
private final org.apache.harmony.luni.util.TwoKeyHashMap$Entry removeEntry(
java.lang.Object
java.lang.Object)

public void clear()

public boolean containsKey(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Signature (value =(ITE;TK;TV;Lorg/apache/harmony/luni/util/TwoKeyHashMap$Entry<TE;TK;TV;>;)Lorg/apache/harmony/luni/util/TwoKeyHashMap$Entry<TE;TK;TV;>; )
 org.apache.harmony.luni.util.TwoKeyHashMap$Entry createEntry(
int
java.lang.Object
java.lang.Object
java.lang.Object
org.apache.harmony.luni.util.TwoKeyHashMap$Entry)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<Ljava/util/Map$Entry<Ljava/lang/String;TV;>;>; )
 java.util.Iterator createEntrySetIterator()
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TV;>; )
 java.util.Iterator createValueCollectionIterator()
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/util/Map$Entry<Ljava/lang/String;TV;>;>; )
public java.util.Set entrySet()
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Object;)TV; )
public java.lang.Object get(
java.lang.Object
java.lang.Object)

public boolean isEmpty()
@dalvik.annotation.Signature (value =(TE;TK;TV;)TV; )
public java.lang.Object put(
java.lang.Object
java.lang.Object
java.lang.Object)

 void rehash()
@dalvik.annotation.Signature (value =(Ljava/lang/Object;Ljava/lang/Object;)TV; )
public java.lang.Object remove(
java.lang.Object
java.lang.Object)

public int size()
@dalvik.annotation.Signature (value =()Ljava/util/Collection<TV;>; )
public java.util.Collection values()

________________CLASS________________


public final class org.apache.harmony.luni.util.URLUtil extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public static java.lang.String canonicalizePath(
java.lang.String)

________________CLASS________________


public final class org.apache.harmony.luni.util.Util extends java.lang.Object

----------------FIELDS----------------

private static java.lang.String[] MONTHS

private static java.lang.String[] WEEKDAYS

private static final java.lang.String defaultEncoding
----------------METHODS----------------

static void <clinit>()

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/UTFDataFormatException; )
public static java.lang.String convertFromUTF8(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/UTFDataFormatException; )
public static java.lang.String convertUTF8WithBuf(
byte[]
char[]
int
int)

public static java.lang.String decode(
java.lang.String
boolean)

public static byte[] getBytes(
java.lang.String)

private static int parse(
java.lang.String
java.lang.String[])

public static long parseDate(
java.lang.String)

public static java.lang.String toASCIILowerCase(
java.lang.String)

public static java.lang.String toASCIIUpperCase(
java.lang.String)

public static java.lang.String toString(
byte[])

public static java.lang.String toString(
byte[]
int
int)

________________CLASS________________


public class org.apache.harmony.math.internal.nls.Messages extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.String sResource
----------------METHODS----------------

public void <init>()

public static java.lang.String getString(
java.lang.String)

public static java.lang.String getString(
java.lang.String
char)

public static java.lang.String getString(
java.lang.String
int)

public static java.lang.String getString(
java.lang.String
java.lang.Object)

public static java.lang.String getString(
java.lang.String
java.lang.Object
java.lang.Object)

public static java.lang.String getString(
java.lang.String
java.lang.Object[])

________________CLASS________________


public final class org.apache.harmony.misc.HashCode extends java.lang.Object

----------------FIELDS----------------

public static final int EMPTY_HASH_CODE

private int hashCode
----------------METHODS----------------

public void <init>()

public static int combine(
int
double)

public static int combine(
int
float)

public static int combine(
int
int)

public static int combine(
int
long)

public static int combine(
int
java.lang.Object)

public static int combine(
int
boolean)

public final org.apache.harmony.misc.HashCode append(
double)

public final org.apache.harmony.misc.HashCode append(
float)

public final org.apache.harmony.misc.HashCode append(
int)

public final org.apache.harmony.misc.HashCode append(
long)

public final org.apache.harmony.misc.HashCode append(
java.lang.Object)

public final org.apache.harmony.misc.HashCode append(
boolean)

public final int hashCode()

________________CLASS________________


public class org.apache.harmony.misc.SystemUtils extends java.lang.Object

----------------FIELDS----------------

public static final int ARC_IA32

public static final int ARC_IA64

public static final int ARC_UNKNOWN

public static final int OS_LINUX

public static final int OS_UNKNOWN

public static final int OS_WINDOWS

private static int arc

private static int os
----------------METHODS----------------

static void <clinit>()

public void <init>()

public static int getOS()

________________CLASS________________


public class org.apache.harmony.misc.internal.nls.Messages extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.String sResource
----------------METHODS----------------

public void <init>()

public static java.lang.String getString(
java.lang.String)

public static java.lang.String getString(
java.lang.String
char)

public static java.lang.String getString(
java.lang.String
int)

public static java.lang.String getString(
java.lang.String
java.lang.Object)

public static java.lang.String getString(
java.lang.String
java.lang.Object
java.lang.Object)

public static java.lang.String getString(
java.lang.String
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.nio.AddressUtil extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public static int getChannelAddress(
java.nio.channels.Channel)

public static int getDirectBufferAddress(
java.nio.Buffer)

private static native int getFDAddress(
java.io.FileDescriptor)

________________CLASS________________


public class org.apache.harmony.nio.FileChannelFactory extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public static java.nio.channels.FileChannel getFileChannel(
java.lang.Object
int
int)

________________CLASS________________


public final class org.apache.harmony.nio.Util extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

private void <init>()

public static void assertArrayIndex(
int
int
int)

public static void assertArrayIndex(
byte[]
int
int)

public static void assertArrayIndex(
char[]
int
int)

public static void assertArrayIndex(
double[]
int
int)

public static void assertArrayIndex(
float[]
int
int)

public static void assertArrayIndex(
int[]
int
int)

public static void assertArrayIndex(
long[]
int
int)

public static void assertArrayIndex(
java.lang.Object[]
int
int)

public static void assertArrayIndex(
short[]
int
int)

public static void assertArrayIndex(
boolean[]
int
int)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/nio/internal/DatagramChannelImpl; )
@dalvik.annotation.InnerClass (accessFlags =10 name =DatagramSocketAdapter )
 class org.apache.harmony.nio.internal.DatagramChannelImpl$DatagramSocketAdapter extends java.net.DatagramSocket

----------------FIELDS----------------

private org.apache.harmony.nio.internal.DatagramChannelImpl channelImpl
----------------METHODS----------------

 void <init>(
java.net.DatagramSocketImpl
org.apache.harmony.nio.internal.DatagramChannelImpl)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void bind(
java.net.SocketAddress)

public void close()

public void disconnect()

public java.nio.channels.DatagramChannel getChannel()

public java.net.InetAddress getInetAddress()

public java.net.InetAddress getLocalAddress()

public int getPort()

public boolean isBound()

public boolean isConnected()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void receive(
java.net.DatagramPacket)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void send(
java.net.DatagramPacket)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/apache/harmony/nio/internal/DatagramChannelImpl$DatagramSocketAdapter; )
 class org.apache.harmony.nio.internal.DatagramChannelImpl extends java.nio.channels.DatagramChannel implements org.apache.harmony.luni.platform.FileDescriptorHandler

----------------FIELDS----------------

private static final int DEFAULT_TIMEOUT

private static final int ERRCODE_SOCKET_NONBLOCKING_WOULD_BLOCK

private static final org.apache.harmony.luni.platform.INetworkSystem networkSystem

private static final byte[] stubArray

 java.net.InetSocketAddress connectAddress

 boolean connected

private java.io.FileDescriptor fd

 boolean isBound

private int localPort

private final java.lang.Object readLock

private java.net.DatagramSocket socket

private int trafficClass

private final java.lang.Object writeLock
----------------METHODS----------------

static void <clinit>()

private void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void <init>(
java.nio.channels.spi.SelectorProvider)

private int calculateByteBufferArray(
java.nio.ByteBuffer[]
int
int)

private void checkNotNull(
java.nio.ByteBuffer)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void checkOpen()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void checkOpenConnected()

private void checkWritable(
java.nio.ByteBuffer)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private int readImpl(
java.nio.ByteBuffer)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private java.net.SocketAddress receiveDirectImpl(
java.nio.ByteBuffer
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private java.net.SocketAddress receiveImpl(
java.nio.ByteBuffer
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private int writeImpl(
java.nio.ByteBuffer)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.nio.channels.DatagramChannel connect(
java.net.SocketAddress)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.nio.channels.DatagramChannel disconnect()

public java.io.FileDescriptor getFD()

 java.net.InetAddress getLocalAddress()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void implCloseSelectableChannel()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void implConfigureBlocking(
boolean)

public boolean isConnected()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
java.nio.ByteBuffer)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long read(
java.nio.ByteBuffer[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.net.SocketAddress receive(
java.nio.ByteBuffer)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int send(
java.nio.ByteBuffer
java.net.SocketAddress)

public java.net.DatagramSocket socket()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int write(
java.nio.ByteBuffer)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long write(
java.nio.ByteBuffer[]
int
int)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/nio/internal/FileChannelImpl; )
@dalvik.annotation.InnerClass (accessFlags =4104 name =null )
 class org.apache.harmony.nio.internal.FileChannelImpl$1 extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =2 name =RepositioningLock )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/nio/internal/FileChannelImpl; )
 class org.apache.harmony.nio.internal.FileChannelImpl$RepositioningLock extends java.lang.Object

----------------FIELDS----------------

final org.apache.harmony.nio.internal.FileChannelImpl this$0
----------------METHODS----------------

private void <init>(
org.apache.harmony.nio.internal.FileChannelImpl)

 void <init>(
org.apache.harmony.nio.internal.FileChannelImpl
org.apache.harmony.nio.internal.FileChannelImpl$1)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/apache/harmony/nio/internal/FileChannelImpl$1;Lorg/apache/harmony/nio/internal/FileChannelImpl$RepositioningLock; )
public abstract class org.apache.harmony.nio.internal.FileChannelImpl extends java.nio.channels.FileChannel

----------------FIELDS----------------

private static final int ALLOC_GRANULARITY

private static final org.apache.harmony.luni.platform.IFileSystem fileSystem

private final int handle

private final org.apache.harmony.nio.internal.LockManager lockManager

private final java.lang.Object repositioningLock

private final java.lang.Object stream
----------------METHODS----------------

static void <clinit>()

public void <init>(
java.lang.Object
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private long kernelTransfer(
int
java.io.FileDescriptor
long
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private int writeImpl(
java.nio.ByteBuffer)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected java.nio.channels.FileLock basicLock(
long
long
boolean
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void force(
boolean)

public int getHandle()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void implCloseChannel()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final java.nio.channels.FileLock lock(
long
long
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract java.nio.MappedByteBuffer map(
java.nio.channels.FileChannel$MapMode
long
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected final java.nio.MappedByteBuffer mapImpl(
int
long
long)
@dalvik.annotation.Throws (value =Ljava/nio/channels/ClosedChannelException; )
protected final void openCheck()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long position()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.nio.channels.FileChannel position(
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
java.nio.ByteBuffer)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
java.nio.ByteBuffer
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long read(
java.nio.ByteBuffer[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void release(
java.nio.channels.FileLock)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long size()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long transferFrom(
java.nio.channels.ReadableByteChannel
long
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long transferTo(
long
long
java.nio.channels.WritableByteChannel)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.nio.channels.FileChannel truncate(
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final java.nio.channels.FileLock tryLock(
long
long
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int write(
java.nio.ByteBuffer)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int write(
java.nio.ByteBuffer
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long write(
java.nio.ByteBuffer[]
int
int)

________________CLASS________________


final class org.apache.harmony.nio.internal.FileLockImpl extends java.nio.channels.FileLock

----------------FIELDS----------------

private boolean isReleased
----------------METHODS----------------

public void <init>(
java.nio.channels.FileChannel
long
long
boolean)

public boolean isValid()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void release()

________________CLASS________________


public final class org.apache.harmony.nio.internal.IOUtil extends java.lang.Object

----------------FIELDS----------------

private static final int DEFAULT_BUFFER_SIZE
----------------METHODS----------------

private void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private static void convert(
java.lang.Object
java.nio.charset.CharsetEncoder
java.nio.ByteBuffer
java.nio.CharBuffer
java.io.OutputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private static void fillBuf(
java.io.InputStream
java.nio.ByteBuffer
java.nio.CharBuffer
java.nio.charset.CharsetDecoder)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static void flushOutputStreamWriter(
java.io.OutputStream
java.nio.ByteBuffer
java.nio.charset.CharsetEncoder
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static int readInputStreamReader(
java.io.InputStream
java.nio.ByteBuffer
java.nio.CharBuffer
java.nio.charset.CharsetDecoder
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static int readInputStreamReader(
char[]
int
int
java.io.InputStream
java.nio.ByteBuffer
java.nio.CharBuffer
java.nio.charset.CharsetDecoder
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static void writeOutputStreamWriter(
int
java.io.OutputStream
java.nio.ByteBuffer
java.nio.charset.CharsetEncoder
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static void writeOutputStreamWriter(
java.lang.String
int
int
java.io.OutputStream
java.nio.ByteBuffer
java.nio.charset.CharsetEncoder
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static void writeOutputStreamWriter(
char[]
int
int
java.io.OutputStream
java.nio.ByteBuffer
java.nio.charset.CharsetEncoder
java.lang.Object)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/nio/internal/LockManager; )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Comparator<Ljava/nio/channels/FileLock;>; )
 class org.apache.harmony.nio.internal.LockManager$1 extends java.lang.Object implements java.util.Comparator

----------------FIELDS----------------

final org.apache.harmony.nio.internal.LockManager this$0
----------------METHODS----------------

 void <init>(
org.apache.harmony.nio.internal.LockManager)

public volatile int compare(
java.lang.Object
java.lang.Object)

public int compare(
java.nio.channels.FileLock
java.nio.channels.FileLock)

________________CLASS________________


final class org.apache.harmony.nio.internal.LockManager extends java.lang.Object

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Comparator<Ljava/nio/channels/FileLock;>; )
private final java.util.Comparator lockComparator
@dalvik.annotation.Signature (value =Ljava/util/SortedSet<Ljava/nio/channels/FileLock;>; )
private final java.util.SortedSet locks
----------------METHODS----------------

protected void <init>()
@dalvik.annotation.Throws (value =Ljava/nio/channels/OverlappingFileLockException; )
 void addLock(
java.nio.channels.FileLock)

 void removeLock(
java.nio.channels.FileLock)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/nio/internal/MappedByteBufferFactory; )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/reflect/Constructor;>; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class org.apache.harmony.nio.internal.MappedByteBufferFactory$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public volatile java.lang.Object run()

public java.lang.reflect.Constructor run()

________________CLASS________________


 class org.apache.harmony.nio.internal.MappedByteBufferFactory extends java.lang.Object

----------------FIELDS----------------

static final java.lang.reflect.Constructor constructor
----------------METHODS----------------

static void <clinit>()

 void <init>()
@dalvik.annotation.Throws (value =Ljava/lang/Exception; )
static java.nio.MappedByteBuffer getBuffer(
org.apache.harmony.luni.platform.PlatformAddress
int
long
int)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/nio/internal/PipeImpl; )
@dalvik.annotation.InnerClass (accessFlags =2 name =SinkChannelImpl )
 class org.apache.harmony.nio.internal.PipeImpl$SinkChannelImpl extends java.nio.channels.Pipe$SinkChannel implements org.apache.harmony.luni.platform.FileDescriptorHandler

----------------FIELDS----------------

private org.apache.harmony.nio.internal.SocketChannelImpl sinkSocket

final org.apache.harmony.nio.internal.PipeImpl this$0
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void <init>(
org.apache.harmony.nio.internal.PipeImpl
java.nio.channels.spi.SelectorProvider)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public boolean finishConnect()

public java.io.FileDescriptor getFD()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void implCloseSelectableChannel()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void implConfigureBlocking(
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int write(
java.nio.ByteBuffer)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long write(
java.nio.ByteBuffer[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long write(
java.nio.ByteBuffer[]
int
int)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =2 name =SourceChannelImpl )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/nio/internal/PipeImpl; )
 class org.apache.harmony.nio.internal.PipeImpl$SourceChannelImpl extends java.nio.channels.Pipe$SourceChannel implements org.apache.harmony.luni.platform.FileDescriptorHandler

----------------FIELDS----------------

private java.nio.channels.ServerSocketChannel sourceServer

private org.apache.harmony.nio.internal.SocketChannelImpl sourceSocket

final org.apache.harmony.nio.internal.PipeImpl this$0
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void <init>(
org.apache.harmony.nio.internal.PipeImpl
java.nio.channels.spi.SelectorProvider)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void accept()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void closeServer()

public java.io.FileDescriptor getFD()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void implCloseSelectableChannel()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void implConfigureBlocking(
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
java.nio.ByteBuffer)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long read(
java.nio.ByteBuffer[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long read(
java.nio.ByteBuffer[]
int
int)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/apache/harmony/nio/internal/PipeImpl$SinkChannelImpl;Lorg/apache/harmony/nio/internal/PipeImpl$SourceChannelImpl; )
final class org.apache.harmony.nio.internal.PipeImpl extends java.nio.channels.Pipe

----------------FIELDS----------------

private int serverPort

private org.apache.harmony.nio.internal.PipeImpl$SinkChannelImpl sink

private org.apache.harmony.nio.internal.PipeImpl$SourceChannelImpl source
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>()

static int access$000(
org.apache.harmony.nio.internal.PipeImpl)

static int access$002(
org.apache.harmony.nio.internal.PipeImpl
int)

private void reset()

public java.nio.channels.Pipe$SinkChannel sink()

public java.nio.channels.Pipe$SourceChannel source()

________________CLASS________________


public final class org.apache.harmony.nio.internal.ReadOnlyFileChannel extends org.apache.harmony.nio.internal.FileChannelImpl

----------------FIELDS----------------
----------------METHODS----------------

public void <init>(
java.lang.Object
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected final java.nio.channels.FileLock basicLock(
long
long
boolean
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final void force(
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final java.nio.MappedByteBuffer map(
java.nio.channels.FileChannel$MapMode
long
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final long transferFrom(
java.nio.channels.ReadableByteChannel
long
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final java.nio.channels.FileChannel truncate(
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final int write(
java.nio.ByteBuffer)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final int write(
java.nio.ByteBuffer
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final long write(
java.nio.ByteBuffer[]
int
int)

________________CLASS________________


public final class org.apache.harmony.nio.internal.ReadWriteFileChannel extends org.apache.harmony.nio.internal.FileChannelImpl

----------------FIELDS----------------
----------------METHODS----------------

public void <init>(
java.lang.Object
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final java.nio.MappedByteBuffer map(
java.nio.channels.FileChannel$MapMode
long
long)

________________CLASS________________


final class org.apache.harmony.nio.internal.SelectionKeyImpl extends java.nio.channels.spi.AbstractSelectionKey

----------------FIELDS----------------

private java.nio.channels.spi.AbstractSelectableChannel channel

private int interestOps

 int oldInterestOps

private int readyOps

private org.apache.harmony.nio.internal.SelectorImpl selector
----------------METHODS----------------

public void <init>(
java.nio.channels.spi.AbstractSelectableChannel
int
java.lang.Object
org.apache.harmony.nio.internal.SelectorImpl)

private void checkValid()

public java.nio.channels.SelectableChannel channel()

public int interestOps()

public java.nio.channels.SelectionKey interestOps(
int)

public int readyOps()

public java.nio.channels.Selector selector()

 void setReadyOps(
int)

________________CLASS________________

@dalvik.annotation.Signature (value =<E:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/Set<TE;>; )
@dalvik.annotation.InnerClass (accessFlags =10 name =UnaddableSet )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/nio/internal/SelectorImpl; )
 class org.apache.harmony.nio.internal.SelectorImpl$UnaddableSet extends java.lang.Object implements java.util.Set

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Set<TE;>; )
private java.util.Set set
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/Set<TE;>;)V )
 void <init>(
java.util.Set)
@dalvik.annotation.Signature (value =(TE;)Z )
public boolean add(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<+TE;>;)Z )
public boolean addAll(
java.util.Collection)

public void clear()

public boolean contains(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public boolean containsAll(
java.util.Collection)

public boolean equals(
java.lang.Object)

public int hashCode()

public boolean isEmpty()
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<TE;>; )
public java.util.Iterator iterator()

public boolean remove(
java.lang.Object)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public boolean removeAll(
java.util.Collection)
@dalvik.annotation.Signature (value =(Ljava/util/Collection<*>;)Z )
public boolean retainAll(
java.util.Collection)

public int size()

public java.lang.Object[] toArray()
@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>([TT;)[TT; )
public java.lang.Object[] toArray(
java.lang.Object[])

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/apache/harmony/nio/internal/SelectorImpl$UnaddableSet; )
final class org.apache.harmony.nio.internal.SelectorImpl extends java.nio.channels.spi.AbstractSelector

----------------FIELDS----------------

private static final int MOCK_READBUF_SIZE

private static final int MOCK_WRITEBUF_SIZE

private static final int NA

private static final int READABLE

private static final int SELECT_BLOCK

private static final int SELECT_NOW

private static final int WRITEABLE
@dalvik.annotation.Signature (value =Ljava/util/Set<Ljava/nio/channels/SelectionKey;>; )
private final java.util.Set keys

final java.lang.Object keysLock

private java.io.FileDescriptor[] readable

private java.nio.channels.SelectionKey[] readableChannels
@dalvik.annotation.Signature (value =Ljava/util/List<Ljava/io/FileDescriptor;>; )
private java.util.List readableFDs
@dalvik.annotation.Signature (value =Ljava/util/Set<Ljava/nio/channels/SelectionKey;>; )
private final java.util.Set selectedKeys

private java.nio.channels.Pipe$SinkChannel sink

private java.nio.channels.Pipe$SourceChannel source

private java.io.FileDescriptor sourcefd
@dalvik.annotation.Signature (value =Ljava/util/Set<Ljava/nio/channels/SelectionKey;>; )
private java.util.Set unaddableSelectedKeys
@dalvik.annotation.Signature (value =Ljava/util/Set<Ljava/nio/channels/SelectionKey;>; )
private java.util.Set unmodifiableKeys

private java.io.FileDescriptor[] writable

private java.nio.channels.SelectionKey[] writableChannels
@dalvik.annotation.Signature (value =Ljava/util/List<Ljava/io/FileDescriptor;>; )
private java.util.List writableFDs
----------------METHODS----------------

public void <init>(
java.nio.channels.spi.SelectorProvider)

private void closeCheck()

private void doCancel()

private boolean isConnected(
org.apache.harmony.nio.internal.SelectionKeyImpl)

private void prepareChannels()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private int processSelectResult(
int[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private int selectInternal(
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void implCloseSelector()
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/nio/channels/SelectionKey;>; )
public java.util.Set keys()

protected java.nio.channels.SelectionKey register(
java.nio.channels.spi.AbstractSelectableChannel
int
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int select()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int select(
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int selectNow()
@dalvik.annotation.Signature (value =()Ljava/util/Set<Ljava/nio/channels/SelectionKey;>; )
public java.util.Set selectedKeys()

public java.nio.channels.Selector wakeup()

________________CLASS________________


public class org.apache.harmony.nio.internal.SelectorProviderImpl extends java.nio.channels.spi.SelectorProvider

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.nio.channels.DatagramChannel openDatagramChannel()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.nio.channels.Pipe openPipe()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.nio.channels.spi.AbstractSelector openSelector()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.nio.channels.ServerSocketChannel openServerSocketChannel()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.nio.channels.SocketChannel openSocketChannel()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/nio/internal/ServerSocketChannelImpl; )
@dalvik.annotation.InnerClass (accessFlags =4104 name =null )
 class org.apache.harmony.nio.internal.ServerSocketChannelImpl$1 extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/nio/internal/ServerSocketChannelImpl; )
@dalvik.annotation.InnerClass (accessFlags =2 name =AcceptLock )
 class org.apache.harmony.nio.internal.ServerSocketChannelImpl$AcceptLock extends java.lang.Object

----------------FIELDS----------------

final org.apache.harmony.nio.internal.ServerSocketChannelImpl this$0
----------------METHODS----------------

private void <init>(
org.apache.harmony.nio.internal.ServerSocketChannelImpl)

 void <init>(
org.apache.harmony.nio.internal.ServerSocketChannelImpl
org.apache.harmony.nio.internal.ServerSocketChannelImpl$1)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =2 name =ServerSocketAdapter )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/nio/internal/ServerSocketChannelImpl; )
 class org.apache.harmony.nio.internal.ServerSocketChannelImpl$ServerSocketAdapter extends java.net.ServerSocket

----------------FIELDS----------------

 org.apache.harmony.nio.internal.ServerSocketChannelImpl channelImpl

final org.apache.harmony.nio.internal.ServerSocketChannelImpl this$0
----------------METHODS----------------

 void <init>(
org.apache.harmony.nio.internal.ServerSocketChannelImpl
java.net.SocketImpl
org.apache.harmony.nio.internal.ServerSocketChannelImpl)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private java.net.Socket accept(
java.net.Socket
org.apache.harmony.nio.internal.SocketChannelImpl)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
static java.net.Socket access$100(
org.apache.harmony.nio.internal.ServerSocketChannelImpl$ServerSocketAdapter
java.net.Socket
org.apache.harmony.nio.internal.SocketChannelImpl)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.net.Socket accept()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void bind(
java.net.SocketAddress)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void bind(
java.net.SocketAddress
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()

public java.nio.channels.ServerSocketChannel getChannel()

public boolean isBound()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/apache/harmony/nio/internal/ServerSocketChannelImpl$1;Lorg/apache/harmony/nio/internal/ServerSocketChannelImpl$ServerSocketAdapter;Lorg/apache/harmony/nio/internal/ServerSocketChannelImpl$AcceptLock; )
public class org.apache.harmony.nio.internal.ServerSocketChannelImpl extends java.nio.channels.ServerSocketChannel implements org.apache.harmony.luni.platform.FileDescriptorHandler

----------------FIELDS----------------

private static final int SERVER_STATUS_CLOSED

private static final int SERVER_STATUS_OPEN

private static final int SERVER_STATUS_UNINIT

private final java.lang.Object acceptLock

private final java.io.FileDescriptor fd

private final java.net.SocketImpl impl

 boolean isBound

private final java.net.ServerSocket socket

 int status
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.nio.channels.spi.SelectorProvider)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.nio.channels.SocketChannel accept()

public java.io.FileDescriptor getFD()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void implCloseSelectableChannel()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void implConfigureBlocking(
boolean)

public java.net.ServerSocket socket()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =10 name =SocketAdapter )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/nio/internal/SocketChannelImpl; )
 class org.apache.harmony.nio.internal.SocketChannelImpl$SocketAdapter extends java.net.Socket

----------------FIELDS----------------

 org.apache.harmony.nio.internal.SocketChannelImpl channel

 java.net.SocketImpl socketImpl
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
 void <init>(
java.net.SocketImpl
org.apache.harmony.nio.internal.SocketChannelImpl)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
private void checkOpen()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void bind(
java.net.SocketAddress)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void connect(
java.net.SocketAddress
int)

public java.nio.channels.SocketChannel getChannel()

public java.net.SocketImpl getImpl()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.io.InputStream getInputStream()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public boolean getKeepAlive()

public java.net.InetAddress getLocalAddress()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public boolean getOOBInline()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.io.OutputStream getOutputStream()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public int getReceiveBufferSize()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public boolean getReuseAddress()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public int getSendBufferSize()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public int getSoLinger()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public int getSoTimeout()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public boolean getTcpNoDelay()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public int getTrafficClass()

public boolean isBound()

public boolean isConnected()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/nio/internal/SocketChannelImpl; )
@dalvik.annotation.InnerClass (accessFlags =10 name =SocketChannelInputStream )
 class org.apache.harmony.nio.internal.SocketChannelImpl$SocketChannelInputStream extends java.io.InputStream

----------------FIELDS----------------

 java.nio.channels.SocketChannel channel
----------------METHODS----------------

public void <init>(
java.nio.channels.SocketChannel)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[]
int
int)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =10 name =SocketChannelOutputStream )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/nio/internal/SocketChannelImpl; )
 class org.apache.harmony.nio.internal.SocketChannelImpl$SocketChannelOutputStream extends java.io.OutputStream

----------------FIELDS----------------

 java.nio.channels.SocketChannel channel
----------------METHODS----------------

public void <init>(
java.nio.channels.SocketChannel)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
byte[]
int
int)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/apache/harmony/nio/internal/SocketChannelImpl$SocketChannelInputStream;Lorg/apache/harmony/nio/internal/SocketChannelImpl$SocketChannelOutputStream;Lorg/apache/harmony/nio/internal/SocketChannelImpl$SocketAdapter; )
 class org.apache.harmony.nio.internal.SocketChannelImpl extends java.nio.channels.SocketChannel implements org.apache.harmony.luni.platform.FileDescriptorHandler

----------------FIELDS----------------

private static final int CONNECT_SUCCESS

private static final int EOF

private static final int ERRCODE_SOCKET_NONBLOCKING_WOULD_BLOCK

private static final int HY_PORT_SOCKET_STEP_CHECK

private static final int HY_SOCK_STEP_START

static final int SOCKET_STATUS_CLOSED

static final int SOCKET_STATUS_CONNECTED

static final int SOCKET_STATUS_PENDING

static final int SOCKET_STATUS_UNCONNECTED

static final int SOCKET_STATUS_UNINIT

private static final int TIMEOUT_BLOCK

private static final int TIMEOUT_NONBLOCK

static final org.apache.harmony.luni.platform.INetworkSystem networkSystem

 java.net.InetSocketAddress connectAddress

private byte[] connectContext

 java.io.FileDescriptor fd

 boolean isBound

 java.net.InetAddress localAddress

 int localPort

private final java.lang.Object readLock

private java.net.Socket socket

 int status

private int trafficClass

private final java.lang.Object writeLock
----------------METHODS----------------

static void <clinit>()

private void <init>()

 void <init>(
java.net.Socket
java.io.FileDescriptor)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.nio.channels.spi.SelectorProvider)

private int calculateByteBufferArray(
java.nio.ByteBuffer[]
int
int)
@dalvik.annotation.Throws (value =Ljava/nio/channels/ClosedChannelException; )
private void checkOpenConnected()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void checkUnconnected()

private boolean isIndexValid(
java.nio.ByteBuffer[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private int readImpl(
java.nio.ByteBuffer)

static java.net.InetSocketAddress validateAddress(
java.net.SocketAddress)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private int writeImpl(
java.nio.ByteBuffer)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public boolean connect(
java.net.SocketAddress)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public boolean finishConnect()

public java.io.FileDescriptor getFD()
@dalvik.annotation.Throws (value =Ljava/net/UnknownHostException; )
public java.net.InetAddress getLocalAddress()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void implCloseSelectableChannel()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void implConfigureBlocking(
boolean)

public boolean isConnected()

public boolean isConnectionPending()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
java.nio.ByteBuffer)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long read(
java.nio.ByteBuffer[]
int
int)

 void setConnected()

public java.net.Socket socket()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int write(
java.nio.ByteBuffer)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long write(
java.nio.ByteBuffer[]
int
int)

________________CLASS________________


public final class org.apache.harmony.nio.internal.WriteOnlyFileChannel extends org.apache.harmony.nio.internal.FileChannelImpl

----------------FIELDS----------------

private boolean append
----------------METHODS----------------

public void <init>(
java.lang.Object
int)

public void <init>(
java.lang.Object
int
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected final java.nio.channels.FileLock basicLock(
long
long
boolean
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.nio.MappedByteBuffer map(
java.nio.channels.FileChannel$MapMode
long
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long position()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
java.nio.ByteBuffer)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
java.nio.ByteBuffer
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long read(
java.nio.ByteBuffer[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long transferTo(
long
long
java.nio.channels.WritableByteChannel)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int write(
java.nio.ByteBuffer)

________________CLASS________________


public class org.apache.harmony.nio.internal.nls.Messages extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.String sResource
----------------METHODS----------------

public void <init>()

public static java.lang.String getString(
java.lang.String)

public static java.lang.String getString(
java.lang.String
char)

public static java.lang.String getString(
java.lang.String
int)

public static java.lang.String getString(
java.lang.String
java.lang.Object)

public static java.lang.String getString(
java.lang.String
java.lang.Object
java.lang.Object)

public static java.lang.String getString(
java.lang.String
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.niochar.internal.nls.Messages extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.String sResource
----------------METHODS----------------

public void <init>()

public static java.lang.String getString(
java.lang.String)

public static java.lang.String getString(
java.lang.String
char)

public static java.lang.String getString(
java.lang.String
int)

public static java.lang.String getString(
java.lang.String
java.lang.Object)

public static java.lang.String getString(
java.lang.String
java.lang.Object
java.lang.Object)

public static java.lang.String getString(
java.lang.String
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.prefs.internal.nls.Messages extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.String sResource
----------------METHODS----------------

public void <init>()

public static java.lang.String getString(
java.lang.String)

public static java.lang.String getString(
java.lang.String
char)

public static java.lang.String getString(
java.lang.String
int)

public static java.lang.String getString(
java.lang.String
java.lang.Object)

public static java.lang.String getString(
java.lang.String
java.lang.Object
java.lang.Object)

public static java.lang.String getString(
java.lang.String
java.lang.Object[])

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =GrantEntry )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/DefaultPolicyScanner; )
public class org.apache.harmony.security.DefaultPolicyScanner$GrantEntry extends java.lang.Object

----------------FIELDS----------------

public java.lang.String codebase
@dalvik.annotation.Signature (value =Ljava/util/Collection<Lorg/apache/harmony/security/DefaultPolicyScanner$PermissionEntry;>; )
public java.util.Collection permissions
@dalvik.annotation.Signature (value =Ljava/util/Collection<Lorg/apache/harmony/security/DefaultPolicyScanner$PrincipalEntry;>; )
public java.util.Collection principals

public java.lang.String signers
----------------METHODS----------------

public void <init>()

public void addPrincipal(
org.apache.harmony.security.DefaultPolicyScanner$PrincipalEntry)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/DefaultPolicyScanner; )
@dalvik.annotation.InnerClass (accessFlags =9 name =InvalidFormatException )
public class org.apache.harmony.security.DefaultPolicyScanner$InvalidFormatException extends java.lang.Exception

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>(
java.lang.String)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =KeystoreEntry )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/DefaultPolicyScanner; )
public class org.apache.harmony.security.DefaultPolicyScanner$KeystoreEntry extends java.lang.Object

----------------FIELDS----------------

public java.lang.String type

public java.lang.String url
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/DefaultPolicyScanner; )
@dalvik.annotation.InnerClass (accessFlags =9 name =PermissionEntry )
public class org.apache.harmony.security.DefaultPolicyScanner$PermissionEntry extends java.lang.Object

----------------FIELDS----------------

public java.lang.String actions

public java.lang.String klass

public java.lang.String name

public java.lang.String signers
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/DefaultPolicyScanner; )
@dalvik.annotation.InnerClass (accessFlags =9 name =PrincipalEntry )
public class org.apache.harmony.security.DefaultPolicyScanner$PrincipalEntry extends java.lang.Object

----------------FIELDS----------------

public static final java.lang.String WILDCARD

public java.lang.String klass

public java.lang.String name
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/apache/harmony/security/DefaultPolicyScanner$PermissionEntry;Lorg/apache/harmony/security/DefaultPolicyScanner$PrincipalEntry;Lorg/apache/harmony/security/DefaultPolicyScanner$GrantEntry;Lorg/apache/harmony/security/DefaultPolicyScanner$KeystoreEntry;Lorg/apache/harmony/security/DefaultPolicyScanner$InvalidFormatException; )
public class org.apache.harmony.security.DefaultPolicyScanner extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

protected java.lang.String composeStatus(
java.io.StreamTokenizer)

protected java.io.StreamTokenizer configure(
java.io.StreamTokenizer)
@dalvik.annotation.Throws (value =Lorg/apache/harmony/security/DefaultPolicyScanner$InvalidFormatException; )
protected final void handleUnexpectedToken(
java.io.StreamTokenizer)
@dalvik.annotation.Throws (value =Lorg/apache/harmony/security/DefaultPolicyScanner$InvalidFormatException; )
protected final void handleUnexpectedToken(
java.io.StreamTokenizer
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Lorg/apache/harmony/security/DefaultPolicyScanner$InvalidFormatException; )
protected org.apache.harmony.security.DefaultPolicyScanner$GrantEntry readGrantEntry(
java.io.StreamTokenizer)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Lorg/apache/harmony/security/DefaultPolicyScanner$InvalidFormatException; )
protected org.apache.harmony.security.DefaultPolicyScanner$KeystoreEntry readKeystoreEntry(
java.io.StreamTokenizer)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Lorg/apache/harmony/security/DefaultPolicyScanner$InvalidFormatException; )
@dalvik.annotation.Signature (value =(Ljava/io/StreamTokenizer;)Ljava/util/Collection<Lorg/apache/harmony/security/DefaultPolicyScanner$PermissionEntry;>; )
protected java.util.Collection readPermissionEntries(
java.io.StreamTokenizer)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Lorg/apache/harmony/security/DefaultPolicyScanner$InvalidFormatException; )
protected org.apache.harmony.security.DefaultPolicyScanner$PrincipalEntry readPrincipalEntry(
java.io.StreamTokenizer)
@dalvik.annotation.Signature (value =(Ljava/io/Reader;Ljava/util/Collection<Lorg/apache/harmony/security/DefaultPolicyScanner$GrantEntry;>;Ljava/util/List<Lorg/apache/harmony/security/DefaultPolicyScanner$KeystoreEntry;>;)V )
@dalvik.annotation.Throws (value =Ljava/io/IOException;Lorg/apache/harmony/security/DefaultPolicyScanner$InvalidFormatException; )
public void scanStream(
java.io.Reader
java.util.Collection
java.util.List)

________________CLASS________________


public class org.apache.harmony.security.PolicyEntry extends java.lang.Object

----------------FIELDS----------------

private final java.security.CodeSource cs
@dalvik.annotation.Signature (value =Ljava/util/Collection<Ljava/security/Permission;>; )
private final java.util.Collection permissions

private final java.security.Principal[] principals
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/security/CodeSource;Ljava/util/Collection<+Ljava/security/Principal;>;Ljava/util/Collection<+Ljava/security/Permission;>;)V )
public void <init>(
java.security.CodeSource
java.util.Collection
java.util.Collection)
@dalvik.annotation.Signature (value =()Ljava/util/Collection<Ljava/security/Permission;>; )
public java.util.Collection getPermissions()

public boolean impliesCodeSource(
java.security.CodeSource)

public boolean impliesPrincipals(
java.security.Principal[])

public boolean isVoid()

________________CLASS________________


public class org.apache.harmony.security.PrivateKeyImpl extends java.lang.Object implements java.security.PrivateKey

----------------FIELDS----------------

private static final long serialVersionUID

private java.lang.String algorithm

private byte[] encoding
----------------METHODS----------------

public void <init>(
java.lang.String)

public java.lang.String getAlgorithm()

public byte[] getEncoded()

public java.lang.String getFormat()

public void setAlgorithm(
java.lang.String)

public void setEncoding(
byte[])

________________CLASS________________


public class org.apache.harmony.security.PublicKeyImpl extends java.lang.Object implements java.security.PublicKey

----------------FIELDS----------------

private static final long serialVersionUID

private java.lang.String algorithm

private byte[] encoding
----------------METHODS----------------

public void <init>(
java.lang.String)

public java.lang.String getAlgorithm()

public byte[] getEncoded()

public java.lang.String getFormat()

public void setAlgorithm(
java.lang.String)

public void setEncoding(
byte[])

________________CLASS________________


public class org.apache.harmony.security.SystemScope extends java.security.IdentityScope

----------------FIELDS----------------

private static final long serialVersionUID

private java.util.Hashtable keys

private java.util.Hashtable names
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/KeyManagementException; )
public void <init>(
java.lang.String
java.security.IdentityScope)
@dalvik.annotation.Throws (value =Ljava/security/KeyManagementException; )
public void addIdentity(
java.security.Identity)

public java.security.Identity getIdentity(
java.lang.String)

public java.security.Identity getIdentity(
java.security.PublicKey)

public java.util.Enumeration identities()
@dalvik.annotation.Throws (value =Ljava/security/KeyManagementException; )
public void removeIdentity(
java.security.Identity)

public int size()

________________CLASS________________


public final class org.apache.harmony.security.UnresolvedPrincipal extends java.lang.Object implements java.security.Principal

----------------FIELDS----------------

public static final java.lang.String WILDCARD

private final java.lang.String klass

private final java.lang.String name
----------------METHODS----------------

public void <init>(
java.lang.String
java.lang.String)

public boolean equals(
java.lang.Object)

public java.lang.String getClassName()

public java.lang.String getName()

public int hashCode()

public boolean implies(
java.security.Principal)

public java.lang.String toString()

________________CLASS________________


public class org.apache.harmony.security.asn1.ASN1Any extends org.apache.harmony.security.asn1.ASN1Type

----------------FIELDS----------------

private static final org.apache.harmony.security.asn1.ASN1Any ASN1
----------------METHODS----------------

static void <clinit>()

public void <init>()

public static org.apache.harmony.security.asn1.ASN1Any getInstance()

public final boolean checkTag(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object decode(
org.apache.harmony.security.asn1.BerInputStream)

public void encodeASN(
org.apache.harmony.security.asn1.BerOutputStream)

public void encodeContent(
org.apache.harmony.security.asn1.BerOutputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

public int getEncodedLength(
org.apache.harmony.security.asn1.BerOutputStream)

public void setEncodingContent(
org.apache.harmony.security.asn1.BerOutputStream)

________________CLASS________________


public abstract class org.apache.harmony.security.asn1.ASN1StringType extends org.apache.harmony.security.asn1.ASN1Type

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1StringType BMPSTRING

public static final org.apache.harmony.security.asn1.ASN1StringType GENERALSTRING

public static final org.apache.harmony.security.asn1.ASN1StringType IA5STRING

public static final org.apache.harmony.security.asn1.ASN1StringType PRINTABLESTRING

public static final org.apache.harmony.security.asn1.ASN1StringType TELETEXSTRING

public static final org.apache.harmony.security.asn1.ASN1StringType UNIVERSALSTRING

public static final org.apache.harmony.security.asn1.ASN1StringType UTF8STRING
----------------METHODS----------------

static void <clinit>()

public void <init>(
int)

public final boolean checkTag(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object decode(
org.apache.harmony.security.asn1.BerInputStream)

public void encodeASN(
org.apache.harmony.security.asn1.BerOutputStream)

public void encodeContent(
org.apache.harmony.security.asn1.BerOutputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

public void setEncodingContent(
org.apache.harmony.security.asn1.BerOutputStream)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/apache/harmony/security/asn1/ASN1BitString$ASN1NamedBitList; )
public class org.apache.harmony.security.asn1.ASN1BitString extends org.apache.harmony.security.asn1.ASN1StringType

----------------FIELDS----------------

private static final org.apache.harmony.security.asn1.ASN1BitString ASN1
----------------METHODS----------------

static void <clinit>()

public void <init>()

public static org.apache.harmony.security.asn1.ASN1BitString getInstance()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object decode(
org.apache.harmony.security.asn1.BerInputStream)

public void encodeContent(
org.apache.harmony.security.asn1.BerOutputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

public void setEncodingContent(
org.apache.harmony.security.asn1.BerOutputStream)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/asn1/ASN1BitString; )
@dalvik.annotation.InnerClass (accessFlags =9 name =ASN1NamedBitList )
public class org.apache.harmony.security.asn1.ASN1BitString$ASN1NamedBitList extends org.apache.harmony.security.asn1.ASN1BitString

----------------FIELDS----------------

private static final int INDEFINITE_SIZE

private static final byte[] SET_MASK

private static final org.apache.harmony.security.asn1.BitString emptyString

private final int maxBits

private final int minBits
----------------METHODS----------------

static void <clinit>()

public void <init>()

public void <init>(
int)

public void <init>(
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

public void setEncodingContent(
org.apache.harmony.security.asn1.BerOutputStream)

________________CLASS________________


public abstract class org.apache.harmony.security.asn1.ASN1Primitive extends org.apache.harmony.security.asn1.ASN1Type

----------------FIELDS----------------
----------------METHODS----------------

public void <init>(
int)

public final boolean checkTag(
int)

public void encodeASN(
org.apache.harmony.security.asn1.BerOutputStream)

________________CLASS________________


public class org.apache.harmony.security.asn1.ASN1Boolean extends org.apache.harmony.security.asn1.ASN1Primitive

----------------FIELDS----------------

private static final org.apache.harmony.security.asn1.ASN1Boolean ASN1
----------------METHODS----------------

static void <clinit>()

public void <init>()

public static org.apache.harmony.security.asn1.ASN1Boolean getInstance()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object decode(
org.apache.harmony.security.asn1.BerInputStream)

public void encodeContent(
org.apache.harmony.security.asn1.BerOutputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

public void setEncodingContent(
org.apache.harmony.security.asn1.BerOutputStream)

________________CLASS________________


public abstract class org.apache.harmony.security.asn1.ASN1Choice extends org.apache.harmony.security.asn1.ASN1Type

----------------FIELDS----------------

private final int[][] identifiers

public final org.apache.harmony.security.asn1.ASN1Type[] type
----------------METHODS----------------

public void <init>(
org.apache.harmony.security.asn1.ASN1Type[])

private void addIdentifier(
java.util.TreeMap
int
int)

public final boolean checkTag(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object decode(
org.apache.harmony.security.asn1.BerInputStream)

public void encodeASN(
org.apache.harmony.security.asn1.BerOutputStream)

public final void encodeContent(
org.apache.harmony.security.asn1.BerOutputStream)

public abstract int getIndex(
java.lang.Object)

public abstract java.lang.Object getObjectToEncode(
java.lang.Object)

public final void setEncodingContent(
org.apache.harmony.security.asn1.BerOutputStream)

________________CLASS________________


public class org.apache.harmony.security.asn1.ASN1Enumerated extends org.apache.harmony.security.asn1.ASN1Primitive

----------------FIELDS----------------

private static final org.apache.harmony.security.asn1.ASN1Enumerated ASN1
----------------METHODS----------------

static void <clinit>()

public void <init>()

public static org.apache.harmony.security.asn1.ASN1Enumerated getInstance()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object decode(
org.apache.harmony.security.asn1.BerInputStream)

public void encodeContent(
org.apache.harmony.security.asn1.BerOutputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

public void setEncodingContent(
org.apache.harmony.security.asn1.BerOutputStream)

________________CLASS________________


public class org.apache.harmony.security.asn1.ASN1Exception extends java.io.IOException

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public final class org.apache.harmony.security.asn1.ASN1Explicit extends org.apache.harmony.security.asn1.ASN1Constructured

----------------FIELDS----------------

public final org.apache.harmony.security.asn1.ASN1Type type
----------------METHODS----------------

public void <init>(
int
int
org.apache.harmony.security.asn1.ASN1Type)

public void <init>(
int
org.apache.harmony.security.asn1.ASN1Type)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object decode(
org.apache.harmony.security.asn1.BerInputStream)

public void encodeContent(
org.apache.harmony.security.asn1.BerOutputStream)

public void setEncodingContent(
org.apache.harmony.security.asn1.BerOutputStream)

public java.lang.String toString()

________________CLASS________________


public abstract class org.apache.harmony.security.asn1.ASN1Time extends org.apache.harmony.security.asn1.ASN1StringType

----------------FIELDS----------------
----------------METHODS----------------

public void <init>(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

________________CLASS________________


public class org.apache.harmony.security.asn1.ASN1GeneralizedTime extends org.apache.harmony.security.asn1.ASN1Time

----------------FIELDS----------------

private static final org.apache.harmony.security.asn1.ASN1GeneralizedTime ASN1

private static final java.lang.String GEN_PATTERN
----------------METHODS----------------

static void <clinit>()

public void <init>()

public static org.apache.harmony.security.asn1.ASN1GeneralizedTime getInstance()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object decode(
org.apache.harmony.security.asn1.BerInputStream)

public void encodeContent(
org.apache.harmony.security.asn1.BerOutputStream)

public void setEncodingContent(
org.apache.harmony.security.asn1.BerOutputStream)

________________CLASS________________


public class org.apache.harmony.security.asn1.ASN1Implicit extends org.apache.harmony.security.asn1.ASN1Type

----------------FIELDS----------------

private static final int TAGGING_CONSTRUCTED

private static final int TAGGING_PRIMITIVE

private static final int TAGGING_STRING

private final int taggingType

private final org.apache.harmony.security.asn1.ASN1Type type
----------------METHODS----------------

public void <init>(
int
int
org.apache.harmony.security.asn1.ASN1Type)

public void <init>(
int
org.apache.harmony.security.asn1.ASN1Type)

public final boolean checkTag(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object decode(
org.apache.harmony.security.asn1.BerInputStream)

public void encodeASN(
org.apache.harmony.security.asn1.BerOutputStream)

public void encodeContent(
org.apache.harmony.security.asn1.BerOutputStream)

public void setEncodingContent(
org.apache.harmony.security.asn1.BerOutputStream)

________________CLASS________________


public class org.apache.harmony.security.asn1.ASN1Integer extends org.apache.harmony.security.asn1.ASN1Primitive

----------------FIELDS----------------

private static final org.apache.harmony.security.asn1.ASN1Integer ASN1
----------------METHODS----------------

static void <clinit>()

public void <init>()

public static java.lang.Object fromIntValue(
int)

public static org.apache.harmony.security.asn1.ASN1Integer getInstance()

public static java.math.BigInteger toBigIntegerValue(
java.lang.Object)

public static int toIntValue(
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object decode(
org.apache.harmony.security.asn1.BerInputStream)

public void encodeContent(
org.apache.harmony.security.asn1.BerOutputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

public void setEncodingContent(
org.apache.harmony.security.asn1.BerOutputStream)

________________CLASS________________


public class org.apache.harmony.security.asn1.ASN1OctetString extends org.apache.harmony.security.asn1.ASN1StringType

----------------FIELDS----------------

private static final org.apache.harmony.security.asn1.ASN1OctetString ASN1
----------------METHODS----------------

static void <clinit>()

public void <init>()

public static org.apache.harmony.security.asn1.ASN1OctetString getInstance()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object decode(
org.apache.harmony.security.asn1.BerInputStream)

public void encodeContent(
org.apache.harmony.security.asn1.BerOutputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

public void setEncodingContent(
org.apache.harmony.security.asn1.BerOutputStream)

________________CLASS________________


public class org.apache.harmony.security.asn1.ASN1Oid extends org.apache.harmony.security.asn1.ASN1Primitive

----------------FIELDS----------------

private static final org.apache.harmony.security.asn1.ASN1Oid ASN1

private static final org.apache.harmony.security.asn1.ASN1Oid STRING_OID
----------------METHODS----------------

static void <clinit>()

public void <init>()

public static org.apache.harmony.security.asn1.ASN1Oid getInstance()

public static org.apache.harmony.security.asn1.ASN1Oid getInstanceForString()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object decode(
org.apache.harmony.security.asn1.BerInputStream)

public void encodeContent(
org.apache.harmony.security.asn1.BerOutputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

public void setEncodingContent(
org.apache.harmony.security.asn1.BerOutputStream)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/asn1/ASN1Oid; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class org.apache.harmony.security.asn1.ASN1Oid$1 extends org.apache.harmony.security.asn1.ASN1Oid

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

public void setEncodingContent(
org.apache.harmony.security.asn1.BerOutputStream)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/asn1/ASN1OpenType; )
@dalvik.annotation.InnerClass (accessFlags =9 name =Id )
public class org.apache.harmony.security.asn1.ASN1OpenType$Id extends org.apache.harmony.security.asn1.ASN1Oid

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object decode(
org.apache.harmony.security.asn1.BerInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/apache/harmony/security/asn1/ASN1OpenType$Id; )
public class org.apache.harmony.security.asn1.ASN1OpenType extends org.apache.harmony.security.asn1.ASN1Any

----------------FIELDS----------------

private final org.apache.harmony.security.asn1.ASN1OpenType$Id key

private final org.apache.harmony.security.asn1.InformationObjectSet pool
----------------METHODS----------------

public void <init>(
org.apache.harmony.security.asn1.ASN1OpenType$Id
org.apache.harmony.security.asn1.InformationObjectSet)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object decode(
org.apache.harmony.security.asn1.BerInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

________________CLASS________________


public abstract class org.apache.harmony.security.asn1.ASN1ValueCollection extends org.apache.harmony.security.asn1.ASN1Constructured

----------------FIELDS----------------

public final org.apache.harmony.security.asn1.ASN1Type type
----------------METHODS----------------

public void <init>(
int
org.apache.harmony.security.asn1.ASN1Type)

public java.util.Collection getValues(
java.lang.Object)

________________CLASS________________


public class org.apache.harmony.security.asn1.ASN1SequenceOf extends org.apache.harmony.security.asn1.ASN1ValueCollection

----------------FIELDS----------------
----------------METHODS----------------

public void <init>(
org.apache.harmony.security.asn1.ASN1Type)

public static org.apache.harmony.security.asn1.ASN1SequenceOf asArrayOf(
org.apache.harmony.security.asn1.ASN1Type)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object decode(
org.apache.harmony.security.asn1.BerInputStream)

public final void encodeContent(
org.apache.harmony.security.asn1.BerOutputStream)

public final void setEncodingContent(
org.apache.harmony.security.asn1.BerOutputStream)

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class org.apache.harmony.security.asn1.ASN1SequenceOf$1 extends org.apache.harmony.security.asn1.ASN1SequenceOf

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

public java.util.Collection getValues(
java.lang.Object)

________________CLASS________________


public class org.apache.harmony.security.asn1.ASN1Set extends org.apache.harmony.security.asn1.ASN1TypeCollection

----------------FIELDS----------------
----------------METHODS----------------

public void <init>(
org.apache.harmony.security.asn1.ASN1Type[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object decode(
org.apache.harmony.security.asn1.BerInputStream)

public final void encodeContent(
org.apache.harmony.security.asn1.BerOutputStream)

public final void setEncodingContent(
org.apache.harmony.security.asn1.BerOutputStream)

________________CLASS________________


public class org.apache.harmony.security.asn1.ASN1SetOf extends org.apache.harmony.security.asn1.ASN1ValueCollection

----------------FIELDS----------------
----------------METHODS----------------

public void <init>(
org.apache.harmony.security.asn1.ASN1Type)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static org.apache.harmony.security.asn1.ASN1SetOf asArrayOf(
org.apache.harmony.security.asn1.ASN1Type)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object decode(
org.apache.harmony.security.asn1.BerInputStream)

public final void encodeContent(
org.apache.harmony.security.asn1.BerOutputStream)

public final void setEncodingContent(
org.apache.harmony.security.asn1.BerOutputStream)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
final class org.apache.harmony.security.asn1.ASN1SetOf$1 extends org.apache.harmony.security.asn1.ASN1SetOf

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

public java.util.Collection getValues(
java.lang.Object)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/asn1/ASN1StringType; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class org.apache.harmony.security.asn1.ASN1StringType$1 extends org.apache.harmony.security.asn1.ASN1StringType

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
int)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/asn1/ASN1StringType; )
final class org.apache.harmony.security.asn1.ASN1StringType$2 extends org.apache.harmony.security.asn1.ASN1StringType

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
int)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/asn1/ASN1StringType; )
final class org.apache.harmony.security.asn1.ASN1StringType$3 extends org.apache.harmony.security.asn1.ASN1StringType

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
int)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/asn1/ASN1StringType; )
final class org.apache.harmony.security.asn1.ASN1StringType$4 extends org.apache.harmony.security.asn1.ASN1StringType

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
int)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/asn1/ASN1StringType; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class org.apache.harmony.security.asn1.ASN1StringType$5 extends org.apache.harmony.security.asn1.ASN1StringType

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
int)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/asn1/ASN1StringType; )
final class org.apache.harmony.security.asn1.ASN1StringType$6 extends org.apache.harmony.security.asn1.ASN1StringType

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
int)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/asn1/ASN1StringType; )
final class org.apache.harmony.security.asn1.ASN1StringType$7 extends org.apache.harmony.security.asn1.ASN1StringType

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

public void setEncodingContent(
org.apache.harmony.security.asn1.BerOutputStream)

________________CLASS________________


public class org.apache.harmony.security.asn1.ASN1UTCTime extends org.apache.harmony.security.asn1.ASN1Time

----------------FIELDS----------------

private static final org.apache.harmony.security.asn1.ASN1UTCTime ASN1

public static final int UTC_HM

public static final int UTC_HMS

public static final int UTC_LOCAL_HM

public static final int UTC_LOCAL_HMS

private static final java.lang.String UTC_PATTERN
----------------METHODS----------------

static void <clinit>()

public void <init>()

public static org.apache.harmony.security.asn1.ASN1UTCTime getInstance()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object decode(
org.apache.harmony.security.asn1.BerInputStream)

public void encodeContent(
org.apache.harmony.security.asn1.BerOutputStream)

public void setEncodingContent(
org.apache.harmony.security.asn1.BerOutputStream)

________________CLASS________________


public class org.apache.harmony.security.asn1.BerInputStream extends java.lang.Object

----------------FIELDS----------------

private static final int BUF_INCREASE_SIZE

protected static final int INDEFINIT_LENGTH

protected byte[] buffer

public int choiceIndex

public java.lang.Object content

protected int contentOffset

protected java.io.InputStream in

protected boolean isIndefinedLength

protected boolean isVerify

protected int length

protected int offset

public int oidElement

private java.lang.Object[][] pool

public int tag

protected int tagOffset

public int[] times
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.io.InputStream
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private final void decodeValueCollection(
org.apache.harmony.security.asn1.ASN1ValueCollection)

public static int getLength(
byte[])
@dalvik.annotation.Throws (value =Lorg/apache/harmony/security/asn1/ASN1Exception; )
private int strToInt(
int
int)

public void compactBuffer()

public java.lang.Object get(
java.lang.Object)

public final byte[] getBuffer()

public final int getContentOffset()

public byte[] getEncoded()

public final int getEndOffset()

public final int getLength()

public final int getOffset()

public final int getTagOffset()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int next()

public void put(
java.lang.Object
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void readBitString()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void readBoolean()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void readContent()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void readEnumerated()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void readGeneralizedTime()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void readInteger()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void readOID()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void readOctetString()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void readSequence(
org.apache.harmony.security.asn1.ASN1Sequence)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void readSequenceOf(
org.apache.harmony.security.asn1.ASN1SequenceOf)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void readSet(
org.apache.harmony.security.asn1.ASN1Set)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void readSetOf(
org.apache.harmony.security.asn1.ASN1SetOf)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void readString(
org.apache.harmony.security.asn1.ASN1StringType)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void readUTCTime()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final void reset(
byte[])

public final void setVerify()

________________CLASS________________


public class org.apache.harmony.security.asn1.BerOutputStream extends java.lang.Object

----------------FIELDS----------------

public java.lang.Object content

public byte[] encoded

public int length

protected int offset
----------------METHODS----------------

public void <init>()

public void encodeANY()

public void encodeBitString()

public void encodeBoolean()

public void encodeChoice(
org.apache.harmony.security.asn1.ASN1Choice)

public void encodeExplicit(
org.apache.harmony.security.asn1.ASN1Explicit)

public void encodeGeneralizedTime()

public void encodeInteger()

public void encodeOID()

public void encodeOctetString()

public void encodeSequence(
org.apache.harmony.security.asn1.ASN1Sequence)

public void encodeSequenceOf(
org.apache.harmony.security.asn1.ASN1SequenceOf)

public void encodeSet(
org.apache.harmony.security.asn1.ASN1Set)

public void encodeSetOf(
org.apache.harmony.security.asn1.ASN1SetOf)

public void encodeString()

public final void encodeTag(
int)

public void encodeUTCTime()

public void getChoiceLength(
org.apache.harmony.security.asn1.ASN1Choice)

public void getExplicitLength(
org.apache.harmony.security.asn1.ASN1Explicit)

public void getSequenceLength(
org.apache.harmony.security.asn1.ASN1Sequence)

public void getSequenceOfLength(
org.apache.harmony.security.asn1.ASN1SequenceOf)

public void getSetLength(
org.apache.harmony.security.asn1.ASN1Set)

public void getSetOfLength(
org.apache.harmony.security.asn1.ASN1SetOf)

public int getStringLength(
java.lang.Object)

________________CLASS________________


public final class org.apache.harmony.security.asn1.BitString extends java.lang.Object

----------------FIELDS----------------

private static final byte[] RESET_MASK

private static final byte[] SET_MASK

public final byte[] bytes

public final int unusedBits
----------------METHODS----------------

static void <clinit>()

public void <init>(
byte[]
int)

public void <init>(
boolean[])

public boolean getBit(
int)

public void setBit(
int
boolean)

public boolean[] toBooleanArray()

________________CLASS________________


public final class org.apache.harmony.security.asn1.DerInputStream extends org.apache.harmony.security.asn1.BerInputStream

----------------FIELDS----------------

private static final byte[] UNUSED_BITS_MASK
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public final int next()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void readBitString()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void readBoolean()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void readGeneralizedTime()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void readOctetString()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void readSequence(
org.apache.harmony.security.asn1.ASN1Sequence)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void readSetOf(
org.apache.harmony.security.asn1.ASN1SetOf)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void readString(
org.apache.harmony.security.asn1.ASN1StringType)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void readUTCTime()

________________CLASS________________


public final class org.apache.harmony.security.asn1.DerOutputStream extends org.apache.harmony.security.asn1.BerOutputStream

----------------FIELDS----------------

private static final int initSize

private int index

private int[][] len

private java.lang.Object[][] val
----------------METHODS----------------

public void <init>(
org.apache.harmony.security.asn1.ASN1Type
java.lang.Object)

private final void encodeValueCollection(
org.apache.harmony.security.asn1.ASN1ValueCollection)

private void getValueOfLength(
org.apache.harmony.security.asn1.ASN1ValueCollection)

private void push(
int[]
java.lang.Object[])

public void encodeChoice(
org.apache.harmony.security.asn1.ASN1Choice)

public void encodeExplicit(
org.apache.harmony.security.asn1.ASN1Explicit)

public void encodeSequence(
org.apache.harmony.security.asn1.ASN1Sequence)

public void encodeSequenceOf(
org.apache.harmony.security.asn1.ASN1SequenceOf)

public void encodeSetOf(
org.apache.harmony.security.asn1.ASN1SetOf)

public void getChoiceLength(
org.apache.harmony.security.asn1.ASN1Choice)

public void getExplicitLength(
org.apache.harmony.security.asn1.ASN1Explicit)

public void getSequenceLength(
org.apache.harmony.security.asn1.ASN1Sequence)

public void getSequenceOfLength(
org.apache.harmony.security.asn1.ASN1SequenceOf)

public void getSetOfLength(
org.apache.harmony.security.asn1.ASN1SetOf)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =2 name =Entry )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/asn1/InformationObjectSet; )
 class org.apache.harmony.security.asn1.InformationObjectSet$Entry extends java.lang.Object

----------------FIELDS----------------

public java.lang.Object object

public int[] oid

final org.apache.harmony.security.asn1.InformationObjectSet this$0
----------------METHODS----------------

public void <init>(
org.apache.harmony.security.asn1.InformationObjectSet
int[]
java.lang.Object)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/apache/harmony/security/asn1/InformationObjectSet$Entry; )
public class org.apache.harmony.security.asn1.InformationObjectSet extends java.lang.Object

----------------FIELDS----------------

private final int capacity

private final org.apache.harmony.security.asn1.InformationObjectSet$Entry[][] pool
----------------METHODS----------------

public void <init>()

public void <init>(
int
int)

private int hashIntArray(
int[])

public java.lang.Object get(
int[])

public void put(
org.apache.harmony.security.x501.AttributeType)

public void put(
int[]
java.lang.Object)

________________CLASS________________


public final class org.apache.harmony.security.asn1.ObjectIdentifier extends java.lang.Object

----------------FIELDS----------------

private final int[] oid

private java.lang.String soid
----------------METHODS----------------

public void <init>(
java.lang.String)

public void <init>(
int[])

public static boolean isOID(
java.lang.String)

public static int[] toIntArray(
java.lang.String)

private static int[] toIntArray(
java.lang.String
boolean)

public static java.lang.String toString(
int[])

public static void validate(
int[])

public boolean equals(
java.lang.Object)

public int[] getOid()

public int hashCode()

public java.lang.String toString()

________________CLASS________________


public class org.apache.harmony.security.fortress.DefaultPolicy extends java.security.Policy

----------------FIELDS----------------

public static final java.lang.String JAVA_SECURITY_POLICY

public static final java.lang.String POLICY_URL_PREFIX
@dalvik.annotation.Signature (value =Ljava/util/Map<Ljava/lang/Object;Ljava/util/Collection<Ljava/security/Permission;>;>; )
private final java.util.Map cache
@dalvik.annotation.Signature (value =Ljava/util/Set<Lorg/apache/harmony/security/PolicyEntry;>; )
private final java.util.Set grants

private boolean initiailized

private final org.apache.harmony.security.fortress.DefaultPolicyParser parser
----------------METHODS----------------

public void <init>()

public void <init>(
org.apache.harmony.security.fortress.DefaultPolicyParser)

public java.security.PermissionCollection getPermissions(
java.security.CodeSource)

public java.security.PermissionCollection getPermissions(
java.security.ProtectionDomain)

public void refresh()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/fortress/PolicyUtils; )
@dalvik.annotation.InnerClass (accessFlags =1545 name =GeneralExpansionHandler )
public abstract interface class org.apache.harmony.security.fortress.PolicyUtils$GeneralExpansionHandler extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Lorg/apache/harmony/security/fortress/PolicyUtils$ExpansionFailedException; )
public abstract java.lang.String resolve(
java.lang.String
java.lang.String)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =PermissionExpander )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/fortress/DefaultPolicyParser; )
 class org.apache.harmony.security.fortress.DefaultPolicyParser$PermissionExpander extends java.lang.Object implements org.apache.harmony.security.fortress.PolicyUtils$GeneralExpansionHandler

----------------FIELDS----------------

private org.apache.harmony.security.DefaultPolicyScanner$GrantEntry ge

private java.security.KeyStore ks

final org.apache.harmony.security.fortress.DefaultPolicyParser this$0
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.fortress.DefaultPolicyParser)

private java.lang.String pc2str(
java.security.Principal)

public org.apache.harmony.security.fortress.DefaultPolicyParser$PermissionExpander configure(
org.apache.harmony.security.DefaultPolicyScanner$GrantEntry
java.security.KeyStore)
@dalvik.annotation.Throws (value =Lorg/apache/harmony/security/fortress/PolicyUtils$ExpansionFailedException; )
public java.lang.String resolve(
java.lang.String
java.lang.String)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/apache/harmony/security/fortress/DefaultPolicyParser$PermissionExpander; )
public class org.apache.harmony.security.fortress.DefaultPolicyParser extends java.lang.Object

----------------FIELDS----------------

private final org.apache.harmony.security.DefaultPolicyScanner scanner
----------------METHODS----------------

public void <init>()

public void <init>(
org.apache.harmony.security.DefaultPolicyScanner)
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException;Ljava/security/cert/CertificateException; )
protected java.security.Principal getPrincipalByAlias(
java.security.KeyStore
java.lang.String)
@dalvik.annotation.Signature (value =(Ljava/util/List<Lorg/apache/harmony/security/DefaultPolicyScanner$KeystoreEntry;>;Ljava/net/URL;Ljava/util/Properties;Z)Ljava/security/KeyStore; )
protected java.security.KeyStore initKeyStore(
java.util.List
java.net.URL
java.util.Properties
boolean)
@dalvik.annotation.Signature (value =(Ljava/net/URL;Ljava/util/Properties;)Ljava/util/Collection<Lorg/apache/harmony/security/PolicyEntry;>; )
@dalvik.annotation.Throws (value =Ljava/lang/Exception; )
public java.util.Collection parse(
java.net.URL
java.util.Properties)
@dalvik.annotation.Throws (value =Ljava/lang/Exception; )
protected org.apache.harmony.security.PolicyEntry resolveGrant(
org.apache.harmony.security.DefaultPolicyScanner$GrantEntry
java.security.KeyStore
java.util.Properties
boolean)
@dalvik.annotation.Throws (value =Ljava/lang/Exception; )
protected java.security.Permission resolvePermission(
org.apache.harmony.security.DefaultPolicyScanner$PermissionEntry
org.apache.harmony.security.DefaultPolicyScanner$GrantEntry
java.security.KeyStore
java.util.Properties
boolean)
@dalvik.annotation.Throws (value =Ljava/lang/Exception; )
protected java.security.cert.Certificate[] resolveSigners(
java.security.KeyStore
java.lang.String)

________________CLASS________________


public class org.apache.harmony.security.fortress.Engine extends java.lang.Object

----------------FIELDS----------------

public static org.apache.harmony.security.fortress.SecurityAccess door

private java.lang.String lastAlgorithm

public java.security.Provider provider

private int refreshNumber

private java.security.Provider$Service returnedService

private java.lang.String serviceName

public java.lang.Object spi
----------------METHODS----------------

public void <init>(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public void getInstance(
java.lang.String
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public void getInstance(
java.lang.String
java.security.Provider
java.lang.Object)

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedExceptionAction<Ljava/net/URL;>; )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class org.apache.harmony.security.fortress.PolicyUtils$1 extends java.lang.Object implements java.security.PrivilegedExceptionAction

----------------FIELDS----------------

final java.io.File val$f
----------------METHODS----------------

 void <init>(
java.io.File)
@dalvik.annotation.Throws (value =Ljava/lang/Exception; )
public volatile java.lang.Object run()
@dalvik.annotation.Throws (value =Ljava/lang/Exception; )
public java.net.URL run()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =ExpansionFailedException )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/fortress/PolicyUtils; )
public class org.apache.harmony.security.fortress.PolicyUtils$ExpansionFailedException extends java.lang.Exception

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.Throwable)

________________CLASS________________

@dalvik.annotation.Signature (value =<T:Ljava/lang/Object;>Ljava/lang/Object;Ljava/security/PrivilegedAction<TT;>; )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/fortress/PolicyUtils; )
@dalvik.annotation.InnerClass (accessFlags =9 name =ProviderLoader )
public class org.apache.harmony.security.fortress.PolicyUtils$ProviderLoader extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/lang/Class<TT;>; )
private java.lang.Class expectedType

private java.lang.String key
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/lang/String;Ljava/lang/Class<TT;>;)V )
public void <init>(
java.lang.String
java.lang.Class)
@dalvik.annotation.Signature (value =()TT; )
public java.lang.Object run()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/String;>; )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/fortress/PolicyUtils; )
@dalvik.annotation.InnerClass (accessFlags =9 name =SecurityPropertyAccessor )
public class org.apache.harmony.security.fortress.PolicyUtils$SecurityPropertyAccessor extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

private java.lang.String key
----------------METHODS----------------

public void <init>(
java.lang.String)
@dalvik.annotation.Signature (value =(Ljava/lang/String;)Ljava/security/PrivilegedAction<Ljava/lang/String;>; )
public java.security.PrivilegedAction key(
java.lang.String)

public volatile java.lang.Object run()

public java.lang.String run()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/util/Properties;>; )
@dalvik.annotation.InnerClass (accessFlags =9 name =SystemKit )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/fortress/PolicyUtils; )
public class org.apache.harmony.security.fortress.PolicyUtils$SystemKit extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public volatile java.lang.Object run()

public java.util.Properties run()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/String;>; )
@dalvik.annotation.InnerClass (accessFlags =9 name =SystemPropertyAccessor )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/fortress/PolicyUtils; )
public class org.apache.harmony.security.fortress.PolicyUtils$SystemPropertyAccessor extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

public java.lang.String key
----------------METHODS----------------

public void <init>(
java.lang.String)
@dalvik.annotation.Signature (value =(Ljava/lang/String;)Ljava/security/PrivilegedAction<Ljava/lang/String;>; )
public java.security.PrivilegedAction key(
java.lang.String)

public volatile java.lang.Object run()

public java.lang.String run()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/fortress/PolicyUtils; )
@dalvik.annotation.InnerClass (accessFlags =9 name =URLLoader )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedExceptionAction<Ljava/io/InputStream;>; )
public class org.apache.harmony.security.fortress.PolicyUtils$URLLoader extends java.lang.Object implements java.security.PrivilegedExceptionAction

----------------FIELDS----------------

public java.net.URL location
----------------METHODS----------------

public void <init>(
java.net.URL)
@dalvik.annotation.Throws (value =Ljava/lang/Exception; )
public java.io.InputStream run()
@dalvik.annotation.Throws (value =Ljava/lang/Exception; )
public volatile java.lang.Object run()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/apache/harmony/security/fortress/PolicyUtils$GeneralExpansionHandler;Lorg/apache/harmony/security/fortress/PolicyUtils$ExpansionFailedException;Lorg/apache/harmony/security/fortress/PolicyUtils$ProviderLoader;Lorg/apache/harmony/security/fortress/PolicyUtils$SecurityPropertyAccessor;Lorg/apache/harmony/security/fortress/PolicyUtils$SystemPropertyAccessor;Lorg/apache/harmony/security/fortress/PolicyUtils$SystemKit;Lorg/apache/harmony/security/fortress/PolicyUtils$URLLoader; )
public class org.apache.harmony.security.fortress.PolicyUtils extends java.lang.Object

----------------FIELDS----------------

public static final java.lang.String FALSE

private static final java.lang.Class[] NO_ARGS

private static final java.lang.Class[] ONE_ARGS

public static final java.lang.String POLICY_ALLOW_DYNAMIC

public static final java.lang.String POLICY_EXPAND

public static final java.lang.String TRUE

private static final java.lang.Class[] TWO_ARGS
----------------METHODS----------------

static void <clinit>()

private void <init>()

public static boolean canExpandProperties()
@dalvik.annotation.Throws (value =Lorg/apache/harmony/security/fortress/PolicyUtils$ExpansionFailedException; )
public static java.lang.String expand(
java.lang.String
java.util.Properties)
@dalvik.annotation.Throws (value =Lorg/apache/harmony/security/fortress/PolicyUtils$ExpansionFailedException; )
public static java.lang.String expandGeneral(
java.lang.String
org.apache.harmony.security.fortress.PolicyUtils$GeneralExpansionHandler)
@dalvik.annotation.Throws (value =Lorg/apache/harmony/security/fortress/PolicyUtils$ExpansionFailedException; )
public static java.lang.String expandURL(
java.lang.String
java.util.Properties)

public static java.net.URL[] getPolicyURLs(
java.util.Properties
java.lang.String
java.lang.String)
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;Ljava/lang/String;Ljava/lang/String;)Ljava/security/Permission; )
@dalvik.annotation.Throws (value =Ljava/lang/Exception; )
public static java.security.Permission instantiatePermission(
java.lang.Class
java.lang.String
java.lang.String)

public static boolean matchSubset(
java.lang.Object[]
java.lang.Object[])
@dalvik.annotation.Signature (value =(Ljava/util/Collection<Ljava/security/Permission;>;)Ljava/security/PermissionCollection; )
public static java.security.PermissionCollection toPermissionCollection(
java.util.Collection)

________________CLASS________________


public final class org.apache.harmony.security.fortress.SecurityUtils extends java.lang.Object

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/WeakHashMap<Ljava/lang/Thread;Ljava/security/AccessControlContext;>; )
private static final java.util.WeakHashMap ACC_CACHE
----------------METHODS----------------

static void <clinit>()

public void <init>()
@dalvik.annotation.Throws (value =Ljava/lang/SecurityException; )
public static java.security.AccessControlContext getContext(
java.lang.Thread)
@dalvik.annotation.Throws (value =Ljava/lang/SecurityException; )
public static void putContext(
java.lang.Thread
java.security.AccessControlContext)

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/Object;>; )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/fortress/Services; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class org.apache.harmony.security.fortress.Services$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public java.lang.Object run()

________________CLASS________________


public class org.apache.harmony.security.fortress.Services extends java.lang.Object

----------------FIELDS----------------

private static boolean needRefresh
@dalvik.annotation.Signature (value =Ljava/util/List<Ljava/security/Provider;>; )
private static final java.util.List providers
@dalvik.annotation.Signature (value =Ljava/util/Map<Ljava/lang/String;Ljava/security/Provider;>; )
private static final java.util.Map providersNames

public static int refreshNumber
@dalvik.annotation.Signature (value =Ljava/util/Map<Ljava/lang/String;Ljava/security/Provider$Service;>; )
private static final java.util.Map services
----------------METHODS----------------

static void <clinit>()

public void <init>()

static void access$000()

public static java.security.Provider getProvider(
java.lang.String)

public static java.security.Provider[] getProviders()
@dalvik.annotation.Signature (value =()Ljava/util/List<Ljava/security/Provider;>; )
public static java.util.List getProvidersList()

public static java.security.Provider$Service getService(
java.lang.String)

public static void initServiceInfo(
java.security.Provider)

public static int insertProviderAt(
java.security.Provider
int)

public static boolean isEmpty()

private static void loadProviders()

public static void printServices()

public static void refresh()

public static void removeProvider(
int)

public static void setNeedRefresh()

public static void updateServiceInfo()

________________CLASS________________


public class org.apache.harmony.security.internal.nls.Messages extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.String sResource
----------------METHODS----------------

public void <init>()

public static java.lang.String getString(
java.lang.String)

public static java.lang.String getString(
java.lang.String
char)

public static java.lang.String getString(
java.lang.String
int)

public static java.lang.String getString(
java.lang.String
java.lang.Object)

public static java.lang.String getString(
java.lang.String
java.lang.Object
java.lang.Object)

public static java.lang.String getString(
java.lang.String
java.lang.Object[])

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/pkcs10/CertificationRequest; )
final class org.apache.harmony.security.pkcs10.CertificationRequest$1 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])

public java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.security.pkcs10.CertificationRequest extends java.lang.Object

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Sequence ASN1

private org.apache.harmony.security.x509.AlgorithmIdentifier algId

private byte[] encoding

private org.apache.harmony.security.pkcs10.CertificationRequestInfo info

private byte[] signature
----------------METHODS----------------

static void <clinit>()

public void <init>(
org.apache.harmony.security.pkcs10.CertificationRequestInfo
org.apache.harmony.security.x509.AlgorithmIdentifier
byte[])

private void <init>(
org.apache.harmony.security.pkcs10.CertificationRequestInfo
org.apache.harmony.security.x509.AlgorithmIdentifier
byte[]
byte[])

 void <init>(
org.apache.harmony.security.pkcs10.CertificationRequestInfo
org.apache.harmony.security.x509.AlgorithmIdentifier
byte[]
byte[]
org.apache.harmony.security.pkcs10.CertificationRequest$1)

static org.apache.harmony.security.pkcs10.CertificationRequestInfo access$100(
org.apache.harmony.security.pkcs10.CertificationRequest)

static org.apache.harmony.security.x509.AlgorithmIdentifier access$200(
org.apache.harmony.security.pkcs10.CertificationRequest)

static byte[] access$300(
org.apache.harmony.security.pkcs10.CertificationRequest)

public org.apache.harmony.security.x509.AlgorithmIdentifier getAlgId()

public byte[] getEncoded()

public org.apache.harmony.security.pkcs10.CertificationRequestInfo getInfo()

public byte[] getSignature()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/pkcs10/CertificationRequestInfo; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class org.apache.harmony.security.pkcs10.CertificationRequestInfo$1 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])

protected java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.security.pkcs10.CertificationRequestInfo extends java.lang.Object

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Sequence ASN1

private java.util.List attributes

private byte[] encoding

private org.apache.harmony.security.x501.Name subject

private org.apache.harmony.security.x509.SubjectPublicKeyInfo subjectPublicKeyInfo

private int version
----------------METHODS----------------

static void <clinit>()

public void <init>(
int
org.apache.harmony.security.x501.Name
org.apache.harmony.security.x509.SubjectPublicKeyInfo
java.util.List)

private void <init>(
int
org.apache.harmony.security.x501.Name
org.apache.harmony.security.x509.SubjectPublicKeyInfo
java.util.List
byte[])

 void <init>(
int
org.apache.harmony.security.x501.Name
org.apache.harmony.security.x509.SubjectPublicKeyInfo
java.util.List
byte[]
org.apache.harmony.security.pkcs10.CertificationRequestInfo$1)

static int access$100(
org.apache.harmony.security.pkcs10.CertificationRequestInfo)

static org.apache.harmony.security.x501.Name access$200(
org.apache.harmony.security.pkcs10.CertificationRequestInfo)

static org.apache.harmony.security.x509.SubjectPublicKeyInfo access$300(
org.apache.harmony.security.pkcs10.CertificationRequestInfo)

static java.util.List access$400(
org.apache.harmony.security.pkcs10.CertificationRequestInfo)

public java.util.List getAttributes()

public byte[] getEncoded()

public org.apache.harmony.security.x501.Name getSubject()

public org.apache.harmony.security.x509.SubjectPublicKeyInfo getSubjectPublicKeyInfo()

public int getVersion()

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/pkcs7/AuthenticatedAttributes; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class org.apache.harmony.security.pkcs7.AuthenticatedAttributes$1 extends org.apache.harmony.security.asn1.ASN1SetOf

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type)

public java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

________________CLASS________________


 class org.apache.harmony.security.pkcs7.AuthenticatedAttributes extends java.lang.Object

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1SetOf ASN1

private java.util.List authenticatedAttributes

private byte[] encoding
----------------METHODS----------------

static void <clinit>()

public void <init>(
byte[]
java.util.List)

public java.util.List getAttributes()

public byte[] getEncoded()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/pkcs7/ContentInfo; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class org.apache.harmony.security.pkcs7.ContentInfo$1 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.security.pkcs7.ContentInfo extends java.lang.Object

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Sequence ASN1

public static final int[] DATA

public static final int[] DIGESTED_DATA

public static final int[] ENCRYPTED_DATA

public static final int[] ENVELOPED_DATA

public static final int[] SIGNED_AND_ENVELOPED_DATA

public static final int[] SIGNED_DATA

private java.lang.Object content

private byte[] encoding

private int[] oid
----------------METHODS----------------

static void <clinit>()

public void <init>(
int[]
java.lang.Object)

private void <init>(
int[]
java.lang.Object
byte[])

 void <init>(
int[]
java.lang.Object
byte[]
org.apache.harmony.security.pkcs7.ContentInfo$1)

static int[] access$000(
org.apache.harmony.security.pkcs7.ContentInfo)

static java.lang.Object access$100(
org.apache.harmony.security.pkcs7.ContentInfo)

public java.lang.Object getContent()

public int[] getContentType()

public byte[] getEncoded()

public org.apache.harmony.security.pkcs7.SignedData getSignedData()

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/pkcs7/SignedData; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class org.apache.harmony.security.pkcs7.SignedData$1 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])

protected java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.security.pkcs7.SignedData extends java.lang.Object

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Sequence ASN1

private java.util.List certificates

private org.apache.harmony.security.pkcs7.ContentInfo contentInfo

private java.util.List crls

private java.util.List digestAlgorithms

private java.util.List signerInfos

private int version
----------------METHODS----------------

static void <clinit>()

public void <init>(
int
java.util.List
org.apache.harmony.security.pkcs7.ContentInfo
java.util.List
java.util.List
java.util.List)

static int access$000(
org.apache.harmony.security.pkcs7.SignedData)

static java.util.List access$100(
org.apache.harmony.security.pkcs7.SignedData)

static org.apache.harmony.security.pkcs7.ContentInfo access$200(
org.apache.harmony.security.pkcs7.SignedData)

static java.util.List access$300(
org.apache.harmony.security.pkcs7.SignedData)

static java.util.List access$400(
org.apache.harmony.security.pkcs7.SignedData)

static java.util.List access$500(
org.apache.harmony.security.pkcs7.SignedData)

public java.util.List getCRLs()

public java.util.List getCertificates()

public org.apache.harmony.security.pkcs7.ContentInfo getContentInfo()

public java.util.List getDigestAlgorithms()

public java.util.List getSignerInfos()

public int getVersion()

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/pkcs7/SignerInfo; )
final class org.apache.harmony.security.pkcs7.SignerInfo$1 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])

public void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/pkcs7/SignerInfo; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class org.apache.harmony.security.pkcs7.SignerInfo$2 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])

protected java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.security.pkcs7.SignerInfo extends java.lang.Object

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Sequence ASN1

public static final org.apache.harmony.security.asn1.ASN1Sequence ISSUER_AND_SERIAL_NUMBER

private org.apache.harmony.security.pkcs7.AuthenticatedAttributes authenticatedAttributes

private org.apache.harmony.security.x509.AlgorithmIdentifier digestAlgorithm

private org.apache.harmony.security.x509.AlgorithmIdentifier digestEncryptionAlgorithm

private byte[] encryptedDigest

private javax.security.auth.x500.X500Principal issuer

private java.math.BigInteger serialNumber

private java.util.List unauthenticatedAttributes

private int version
----------------METHODS----------------

static void <clinit>()

public void <init>(
int
java.lang.Object[]
org.apache.harmony.security.x509.AlgorithmIdentifier
org.apache.harmony.security.pkcs7.AuthenticatedAttributes
org.apache.harmony.security.x509.AlgorithmIdentifier
byte[]
java.util.List)

static int access$000(
org.apache.harmony.security.pkcs7.SignerInfo)

static javax.security.auth.x500.X500Principal access$100(
org.apache.harmony.security.pkcs7.SignerInfo)

static java.math.BigInteger access$200(
org.apache.harmony.security.pkcs7.SignerInfo)

static org.apache.harmony.security.x509.AlgorithmIdentifier access$300(
org.apache.harmony.security.pkcs7.SignerInfo)

static org.apache.harmony.security.pkcs7.AuthenticatedAttributes access$400(
org.apache.harmony.security.pkcs7.SignerInfo)

static org.apache.harmony.security.x509.AlgorithmIdentifier access$500(
org.apache.harmony.security.pkcs7.SignerInfo)

static byte[] access$600(
org.apache.harmony.security.pkcs7.SignerInfo)

static java.util.List access$700(
org.apache.harmony.security.pkcs7.SignerInfo)

public java.util.List getAuthenticatedAttributes()

public java.lang.String getDigestAlgorithm()

public java.lang.String getDigestEncryptionAlgorithm()

public byte[] getEncodedAuthenticatedAttributes()

public byte[] getEncryptedDigest()

public javax.security.auth.x500.X500Principal getIssuer()

public java.math.BigInteger getSerialNumber()

public java.lang.String getdigestAlgorithm()

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/pkcs8/PrivateKeyInfo; )
final class org.apache.harmony.security.pkcs8.PrivateKeyInfo$1 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])

protected java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.security.pkcs8.PrivateKeyInfo extends java.lang.Object

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Sequence ASN1

private java.util.List attributes

private byte[] encoding

private byte[] privateKey

private org.apache.harmony.security.x509.AlgorithmIdentifier privateKeyAlgorithm

private int version
----------------METHODS----------------

static void <clinit>()

public void <init>(
int
org.apache.harmony.security.x509.AlgorithmIdentifier
byte[]
java.util.List)

private void <init>(
int
org.apache.harmony.security.x509.AlgorithmIdentifier
byte[]
java.util.List
byte[])

 void <init>(
int
org.apache.harmony.security.x509.AlgorithmIdentifier
byte[]
java.util.List
byte[]
org.apache.harmony.security.pkcs8.PrivateKeyInfo$1)

static int access$100(
org.apache.harmony.security.pkcs8.PrivateKeyInfo)

static org.apache.harmony.security.x509.AlgorithmIdentifier access$200(
org.apache.harmony.security.pkcs8.PrivateKeyInfo)

static byte[] access$300(
org.apache.harmony.security.pkcs8.PrivateKeyInfo)

static java.util.List access$400(
org.apache.harmony.security.pkcs8.PrivateKeyInfo)

public org.apache.harmony.security.x509.AlgorithmIdentifier getAlgorithmIdentifier()

public java.util.List getAttributes()

public byte[] getEncoded()

public byte[] getPrivateKey()

public int getVersion()

________________CLASS________________


public class org.apache.harmony.security.provider.cert.Cache extends java.lang.Object

----------------FIELDS----------------

private static final long HASH_MASK

private static final int INDEX_MASK

private static final long PREFIX_HASH_MASK

private final java.lang.Object[] cache

private boolean cache_is_full

private final int cache_size

private final byte[][] encodings

private final long[] hashes

private final long[] hashes_idx

private int last_cached

private final int prefix_size
----------------METHODS----------------

public void <init>()

public void <init>(
int)

public void <init>(
int
int)

private long getSuffHash(
byte[])

public boolean contains(
long)

public java.lang.Object get(
long
byte[])

public long getHash(
byte[])

public void put(
long
byte[]
java.lang.Object)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/Void;>; )
 class org.apache.harmony.security.provider.cert.DRLCertFactory$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final org.apache.harmony.security.provider.cert.DRLCertFactory this$0
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.provider.cert.DRLCertFactory)

public volatile java.lang.Object run()

public java.lang.Void run()

________________CLASS________________


public final class org.apache.harmony.security.provider.cert.DRLCertFactory extends java.security.Provider

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

________________CLASS________________


public class org.apache.harmony.security.provider.cert.X509CRLEntryImpl extends java.security.cert.X509CRLEntry

----------------FIELDS----------------

private byte[] encoding

private final org.apache.harmony.security.x509.Extensions extensions

private final javax.security.auth.x500.X500Principal issuer

private final org.apache.harmony.security.x509.TBSCertList$RevokedCertificate rcert
----------------METHODS----------------

public void <init>(
org.apache.harmony.security.x509.TBSCertList$RevokedCertificate
javax.security.auth.x500.X500Principal)

public javax.security.auth.x500.X500Principal getCertificateIssuer()

public java.util.Set getCriticalExtensionOIDs()
@dalvik.annotation.Throws (value =Ljava/security/cert/CRLException; )
public byte[] getEncoded()

public byte[] getExtensionValue(
java.lang.String)

public java.util.Set getNonCriticalExtensionOIDs()

public java.util.Date getRevocationDate()

public java.math.BigInteger getSerialNumber()

public boolean hasExtensions()

public boolean hasUnsupportedCriticalExtension()

public java.lang.String toString()

________________CLASS________________


public class org.apache.harmony.security.provider.cert.X509CRLImpl extends java.security.cert.X509CRL

----------------FIELDS----------------

private final org.apache.harmony.security.x509.CertificateList crl

private byte[] encoding

private java.util.ArrayList entries

private boolean entriesRetrieved

private int entriesSize

private final org.apache.harmony.security.x509.Extensions extensions

private boolean isIndirectCRL

private javax.security.auth.x500.X500Principal issuer

private int nonIndirectEntriesSize

private boolean nullSigAlgParams

private java.lang.String sigAlgName

private java.lang.String sigAlgOID

private byte[] sigAlgParams

private byte[] signature

private final org.apache.harmony.security.x509.TBSCertList tbsCertList

private byte[] tbsCertListEncoding
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/security/cert/CRLException; )
public void <init>(
java.io.InputStream)

public void <init>(
org.apache.harmony.security.x509.CertificateList)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
byte[])

private void retirieveEntries()

public java.util.Set getCriticalExtensionOIDs()
@dalvik.annotation.Throws (value =Ljava/security/cert/CRLException; )
public byte[] getEncoded()

public byte[] getExtensionValue(
java.lang.String)

public java.security.Principal getIssuerDN()

public javax.security.auth.x500.X500Principal getIssuerX500Principal()

public java.util.Date getNextUpdate()

public java.util.Set getNonCriticalExtensionOIDs()

public java.security.cert.X509CRLEntry getRevokedCertificate(
java.math.BigInteger)

public java.security.cert.X509CRLEntry getRevokedCertificate(
java.security.cert.X509Certificate)
@dalvik.annotation.Signature (value =()Ljava/util/Set<+Ljava/security/cert/X509CRLEntry;>; )
public java.util.Set getRevokedCertificates()

public java.lang.String getSigAlgName()

public java.lang.String getSigAlgOID()

public byte[] getSigAlgParams()

public byte[] getSignature()
@dalvik.annotation.Throws (value =Ljava/security/cert/CRLException; )
public byte[] getTBSCertList()

public java.util.Date getThisUpdate()

public int getVersion()

public boolean hasUnsupportedCriticalExtension()

public boolean isRevoked(
java.security.cert.Certificate)

public java.lang.String toString()
@dalvik.annotation.Throws (value =Ljava/security/cert/CRLException;Ljava/security/NoSuchAlgorithmException;Ljava/security/InvalidKeyException;Ljava/security/NoSuchProviderException;Ljava/security/SignatureException; )
public void verify(
java.security.PublicKey)
@dalvik.annotation.Throws (value =Ljava/security/cert/CRLException;Ljava/security/NoSuchAlgorithmException;Ljava/security/InvalidKeyException;Ljava/security/NoSuchProviderException;Ljava/security/SignatureException; )
public void verify(
java.security.PublicKey
java.lang.String)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/provider/cert/X509CertFactoryImpl; )
@dalvik.annotation.InnerClass (accessFlags =10 name =RestoringInputStream )
 class org.apache.harmony.security.provider.cert.X509CertFactoryImpl$RestoringInputStream extends java.io.InputStream

----------------FIELDS----------------

private static final int BUFF_SIZE

private int bar

private final int[] buff

private int end

private final java.io.InputStream inStream

private int pos
----------------METHODS----------------

public void <init>(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int available()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()

public void mark(
int)

public boolean markSupported()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void reset()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long skip(
long)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/apache/harmony/security/provider/cert/X509CertFactoryImpl$RestoringInputStream; )
public class org.apache.harmony.security.provider.cert.X509CertFactoryImpl extends java.security.cert.CertificateFactorySpi

----------------FIELDS----------------

private static byte[] CERT_BOUND_SUFFIX

private static org.apache.harmony.security.provider.cert.Cache CERT_CACHE

private static int CERT_CACHE_SEED_LENGTH

private static org.apache.harmony.security.provider.cert.Cache CRL_CACHE

private static int CRL_CACHE_SEED_LENGTH

private static byte[] FREE_BOUND_SUFFIX

private static byte[] pemBegin

private static byte[] pemClose
----------------METHODS----------------

static void <clinit>()

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private byte[] decodePEM(
java.io.InputStream
byte[])
@dalvik.annotation.Throws (value =Ljava/security/cert/CRLException;Ljava/io/IOException; )
private static java.security.cert.CRL getCRL(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/security/cert/CRLException;Ljava/io/IOException; )
private static java.security.cert.CRL getCRL(
byte[])
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException;Ljava/io/IOException; )
private static java.security.cert.Certificate getCertificate(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException;Ljava/io/IOException; )
private static java.security.cert.Certificate getCertificate(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private static byte[] readBytes(
java.io.InputStream
int)
@dalvik.annotation.Throws (value =Ljava/security/cert/CRLException; )
public java.security.cert.CRL engineGenerateCRL(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/security/cert/CRLException; )
@dalvik.annotation.Signature (value =(Ljava/io/InputStream;)Ljava/util/Collection<+Ljava/security/cert/CRL;>; )
public java.util.Collection engineGenerateCRLs(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException; )
public java.security.cert.CertPath engineGenerateCertPath(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException; )
public java.security.cert.CertPath engineGenerateCertPath(
java.io.InputStream
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException; )
public java.security.cert.CertPath engineGenerateCertPath(
java.util.List)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException; )
public java.security.cert.Certificate engineGenerateCertificate(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException; )
@dalvik.annotation.Signature (value =(Ljava/io/InputStream;)Ljava/util/Collection<+Ljava/security/cert/Certificate;>; )
public java.util.Collection engineGenerateCertificates(
java.io.InputStream)
@dalvik.annotation.Signature (value =()Ljava/util/Iterator<Ljava/lang/String;>; )
public java.util.Iterator engineGetCertPathEncodings()

________________CLASS________________


public class org.apache.harmony.security.provider.cert.X509CertImpl extends java.security.cert.X509Certificate

----------------FIELDS----------------

private static final long serialVersionUID

private final org.apache.harmony.security.x509.Certificate certificate

private byte[] encoding

private final org.apache.harmony.security.x509.Extensions extensions

private javax.security.auth.x500.X500Principal issuer

private long notAfter

private long notBefore

private boolean nullSigAlgParams

private java.security.PublicKey publicKey

private java.math.BigInteger serialNumber

private java.lang.String sigAlgName

private java.lang.String sigAlgOID

private byte[] sigAlgParams

private byte[] signature

private javax.security.auth.x500.X500Principal subject

private final org.apache.harmony.security.x509.TBSCertificate tbsCert

private byte[] tbsCertificate
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException; )
public void <init>(
java.io.InputStream)

public void <init>(
org.apache.harmony.security.x509.Certificate)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
byte[])
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
private void fastVerify(
java.security.PublicKey)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateExpiredException;Ljava/security/cert/CertificateNotYetValidException; )
public void checkValidity()
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateExpiredException;Ljava/security/cert/CertificateNotYetValidException; )
public void checkValidity(
java.util.Date)

public int getBasicConstraints()

public java.util.Set getCriticalExtensionOIDs()
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateEncodingException; )
public byte[] getEncoded()
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateParsingException; )
public java.util.List getExtendedKeyUsage()

public byte[] getExtensionValue(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateParsingException; )
public java.util.Collection getIssuerAlternativeNames()

public java.security.Principal getIssuerDN()

public boolean[] getIssuerUniqueID()

public javax.security.auth.x500.X500Principal getIssuerX500Principal()

public boolean[] getKeyUsage()

public java.util.Set getNonCriticalExtensionOIDs()

public java.util.Date getNotAfter()

public java.util.Date getNotBefore()

public java.security.PublicKey getPublicKey()

public java.math.BigInteger getSerialNumber()

public java.lang.String getSigAlgName()

public java.lang.String getSigAlgOID()

public byte[] getSigAlgParams()

public byte[] getSignature()
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateParsingException; )
public java.util.Collection getSubjectAlternativeNames()

public java.security.Principal getSubjectDN()

public boolean[] getSubjectUniqueID()

public javax.security.auth.x500.X500Principal getSubjectX500Principal()
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateEncodingException; )
public byte[] getTBSCertificate()

public int getVersion()

public boolean hasUnsupportedCriticalExtension()

public java.lang.String toString()
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException;Ljava/security/NoSuchAlgorithmException;Ljava/security/InvalidKeyException;Ljava/security/NoSuchProviderException;Ljava/security/SignatureException; )
public void verify(
java.security.PublicKey)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException;Ljava/security/NoSuchAlgorithmException;Ljava/security/InvalidKeyException;Ljava/security/NoSuchProviderException;Ljava/security/SignatureException; )
public void verify(
java.security.PublicKey
java.lang.String)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/provider/cert/X509CertPathImpl; )
final class org.apache.harmony.security.provider.cert.X509CertPathImpl$1 extends org.apache.harmony.security.asn1.ASN1SequenceOf

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

public java.util.Collection getValues(
java.lang.Object)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/provider/cert/X509CertPathImpl; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class org.apache.harmony.security.provider.cert.X509CertPathImpl$2 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------

private final byte[] PRECALCULATED_HEAD

private final byte[] SIGNERS_INFO
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object decode(
org.apache.harmony.security.asn1.BerInputStream)

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/provider/cert/X509CertPathImpl; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class org.apache.harmony.security.provider.cert.X509CertPathImpl$3 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------

private final byte[] SIGNED_DATA_OID
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object decode(
org.apache.harmony.security.asn1.BerInputStream)

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.security.provider.cert.X509CertPathImpl extends java.security.cert.CertPath

----------------FIELDS----------------

public static org.apache.harmony.security.asn1.ASN1SequenceOf ASN1

private static final org.apache.harmony.security.asn1.ASN1Sequence ASN1_SIGNED_DATA

public static final int PKCS7

private static final org.apache.harmony.security.asn1.ASN1Sequence PKCS7_SIGNED_DATA_OBJECT

public static final int PKI_PATH

static final java.util.List encodings

private static final java.lang.String[] encodingsArr

private static final long serialVersionUID

private final java.util.List certificates

private byte[] pkcs7Encoding

private byte[] pkiPathEncoding
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException; )
public void <init>(
java.util.List)

private void <init>(
java.util.List
int
byte[])

 void <init>(
java.util.List
int
byte[]
org.apache.harmony.security.provider.cert.X509CertPathImpl$1)

static java.util.List access$100(
org.apache.harmony.security.provider.cert.X509CertPathImpl)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException; )
public static org.apache.harmony.security.provider.cert.X509CertPathImpl getInstance(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException; )
public static org.apache.harmony.security.provider.cert.X509CertPathImpl getInstance(
java.io.InputStream
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException; )
public static org.apache.harmony.security.provider.cert.X509CertPathImpl getInstance(
byte[])
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException; )
public static org.apache.harmony.security.provider.cert.X509CertPathImpl getInstance(
byte[]
java.lang.String)

public java.util.List getCertificates()
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateEncodingException; )
public byte[] getEncoded()
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateEncodingException; )
public byte[] getEncoded(
java.lang.String)

public java.util.Iterator getEncodings()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/Void;>; )
@dalvik.annotation.EnclosingMethod (value =null )
 class org.apache.harmony.security.provider.crypto.CryptoProvider$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final org.apache.harmony.security.provider.crypto.CryptoProvider this$0
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.provider.crypto.CryptoProvider)

public volatile java.lang.Object run()

public java.lang.Void run()

________________CLASS________________


public final class org.apache.harmony.security.provider.crypto.CryptoProvider extends java.security.Provider

----------------FIELDS----------------

private static final long serialVersionUID
----------------METHODS----------------

public void <init>()

________________CLASS________________


public class org.apache.harmony.security.provider.crypto.DSAKeyFactoryImpl extends java.security.KeyFactorySpi

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidKeySpecException; )
protected java.security.PrivateKey engineGeneratePrivate(
java.security.spec.KeySpec)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidKeySpecException; )
protected java.security.PublicKey engineGeneratePublic(
java.security.spec.KeySpec)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidKeySpecException; )
@dalvik.annotation.Signature (value =<T::Ljava/security/spec/KeySpec;>(Ljava/security/Key;Ljava/lang/Class<TT;>;)TT; )
protected java.security.spec.KeySpec engineGetKeySpec(
java.security.Key
java.lang.Class)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
protected java.security.Key engineTranslateKey(
java.security.Key)

________________CLASS________________


public class org.apache.harmony.security.provider.crypto.DSAPrivateKeyImpl extends org.apache.harmony.security.PrivateKeyImpl implements java.security.interfaces.DSAPrivateKey

----------------FIELDS----------------

private static final long serialVersionUID

private java.security.interfaces.DSAParams params

private java.math.BigInteger x
----------------METHODS----------------

public void <init>(
java.security.spec.DSAPrivateKeySpec)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidKeySpecException; )
public void <init>(
java.security.spec.PKCS8EncodedKeySpec)

public java.security.interfaces.DSAParams getParams()

public java.math.BigInteger getX()

________________CLASS________________


public class org.apache.harmony.security.provider.crypto.DSAPublicKeyImpl extends org.apache.harmony.security.PublicKeyImpl implements java.security.interfaces.DSAPublicKey

----------------FIELDS----------------

private static final long serialVersionUID

private java.security.interfaces.DSAParams params

private java.math.BigInteger y
----------------METHODS----------------

public void <init>(
java.security.spec.DSAPublicKeySpec)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidKeySpecException; )
public void <init>(
java.security.spec.X509EncodedKeySpec)

public java.security.interfaces.DSAParams getParams()

public java.math.BigInteger getY()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/provider/crypto/RandomBitsSupplier; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class org.apache.harmony.security.provider.crypto.RandomBitsSupplier$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public java.lang.Object run()

________________CLASS________________


public abstract interface class org.apache.harmony.security.provider.crypto.SHA1_Data extends java.lang.Object

----------------FIELDS----------------

public static final int BYTES_OFFSET

public static final java.lang.String[] DEVICE_NAMES

public static final int DIGEST_LENGTH

public static final int H0

public static final int H1

public static final int H2

public static final int H3

public static final int H4

public static final int HASH_OFFSET

public static final java.lang.String LIBRARY_NAME
----------------METHODS----------------

static void <clinit>()

________________CLASS________________


public class org.apache.harmony.security.provider.crypto.RandomBitsSupplier extends java.lang.Object implements org.apache.harmony.security.provider.crypto.SHA1_Data

----------------FIELDS----------------

private static java.io.FileInputStream bis

private static java.io.File randomFile

private static boolean serviceAvailable
----------------METHODS----------------

static void <clinit>()

public void <init>()

static java.io.FileInputStream access$002(
java.io.FileInputStream)

static java.io.File access$102(
java.io.File)

private static byte[] getLinuxRandomBits(
int)

public static byte[] getRandomBits(
int)

static boolean isServiceAvailable()

________________CLASS________________


public class org.apache.harmony.security.provider.crypto.SHA1Impl extends java.lang.Object implements org.apache.harmony.security.provider.crypto.SHA1_Data

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

static void computeHash(
int[])

static void updateHash(
int[]
byte[]
int
int)

________________CLASS________________


public class org.apache.harmony.security.provider.crypto.SHA1PRNG_SecureRandomImpl extends java.security.SecureRandomSpi implements java.io.Serializable, org.apache.harmony.security.provider.crypto.SHA1_Data

----------------FIELDS----------------

private static final int COUNTER_BASE

private static final int[] END_FLAGS

private static final int EXTRAFRAME_OFFSET

private static final int FRAME_LENGTH

private static final int FRAME_OFFSET

private static final int HASHBYTES_TO_USE

private static final int HASHCOPY_OFFSET

private static final int[] LEFT

private static final int[] MASK

private static final int MAX_BYTES

private static final int NEXT_BYTES

private static final int[] RIGHT1

private static final int[] RIGHT2

private static final int SET_SEED

private static final int UNDEFINED

private static org.apache.harmony.security.provider.crypto.SHA1PRNG_SecureRandomImpl myRandom

private static final long serialVersionUID

private transient int[] copies

private transient long counter

private transient int nextBIndex

private transient byte[] nextBytes

private transient int[] seed

private transient long seedLength

private transient int state
----------------METHODS----------------

static void <clinit>()

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)

private void updateSeed(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

protected byte[] engineGenerateSeed(
int)

protected void engineNextBytes(
byte[])

protected void engineSetSeed(
byte[])

________________CLASS________________


public class org.apache.harmony.security.provider.crypto.SHA1_MessageDigestImpl extends java.security.MessageDigestSpi implements java.lang.Cloneable, org.apache.harmony.security.provider.crypto.SHA1_Data

----------------FIELDS----------------

private int[] buffer

private int messageLength

private byte[] oneByte
----------------METHODS----------------

public void <init>()

private void processDigest(
byte[]
int)
@dalvik.annotation.Throws (value =Ljava/lang/CloneNotSupportedException; )
public java.lang.Object clone()
@dalvik.annotation.Throws (value =Ljava/security/DigestException; )
protected int engineDigest(
byte[]
int
int)

protected byte[] engineDigest()

protected int engineGetDigestLength()

protected void engineReset()

protected void engineUpdate(
byte)

protected void engineUpdate(
byte[]
int
int)

________________CLASS________________


public class org.apache.harmony.security.provider.crypto.SHA1withDSA_SignatureImpl extends java.security.Signature

----------------FIELDS----------------

private java.security.interfaces.DSAKey dsaKey

private java.security.MessageDigest msgDigest
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public void <init>()
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
private boolean checkSignature(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/security/InvalidParameterException; )
protected java.lang.Object engineGetParameter(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
protected void engineInitSign(
java.security.PrivateKey)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
protected void engineInitVerify(
java.security.PublicKey)
@dalvik.annotation.Throws (value =Ljava/security/InvalidParameterException; )
protected void engineSetParameter(
java.lang.String
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
protected byte[] engineSign()
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
protected void engineUpdate(
byte)
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
protected void engineUpdate(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
protected boolean engineVerify(
byte[])
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
protected boolean engineVerify(
byte[]
int
int)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/provider/crypto/ThreeIntegerSequence; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class org.apache.harmony.security.provider.crypto.ThreeIntegerSequence$1 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])

protected java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________


 class org.apache.harmony.security.provider.crypto.ThreeIntegerSequence extends java.lang.Object

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Sequence ASN1

private byte[] encoding

 byte[] g

 byte[] p

 byte[] q
----------------METHODS----------------

static void <clinit>()

 void <init>(
byte[]
byte[]
byte[])

public byte[] getEncoded()

________________CLASS________________


public class org.apache.harmony.security.utils.AlgNameMapper extends java.lang.Object

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Map<Ljava/lang/String;Ljava/lang/String;>; )
private static final java.util.Map alg2OidMap
@dalvik.annotation.Signature (value =Ljava/util/Map<Ljava/lang/String;Ljava/lang/String;>; )
private static final java.util.Map algAliasesMap

private static final java.lang.String[][] knownAlgMappings
@dalvik.annotation.Signature (value =Ljava/util/Map<Ljava/lang/String;Ljava/lang/String;>; )
private static final java.util.Map oid2AlgMap

private static final java.lang.String[] serviceName
----------------METHODS----------------

static void <clinit>()

private void <init>()

public static java.lang.String dump()

public static java.lang.String getStandardName(
java.lang.String)

public static boolean isOID(
java.lang.String)

public static java.lang.String map2AlgName(
java.lang.String)

public static java.lang.String map2OID(
java.lang.String)

public static java.lang.String normalize(
java.lang.String)

private static void selectEntries(
java.security.Provider)

________________CLASS________________


public class org.apache.harmony.security.utils.Array extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

private void <init>()

public static java.lang.String toString(
byte[]
java.lang.String)

________________CLASS________________


public class org.apache.harmony.security.utils.JarUtils extends java.lang.Object

----------------FIELDS----------------

private static final int[] MESSAGE_DIGEST_OID
----------------METHODS----------------

static void <clinit>()

public void <init>()

private static java.security.cert.X509Certificate[] createChain(
java.security.cert.X509Certificate
java.security.cert.X509Certificate[])

private static java.security.cert.X509Certificate findCert(
java.security.Principal
java.security.cert.X509Certificate[])
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/security/GeneralSecurityException; )
public static java.security.cert.Certificate[] verifySignature(
java.io.InputStream
java.io.InputStream)

________________CLASS________________


public final class org.apache.harmony.security.utils.ObjectIdentifier extends java.lang.Object

----------------FIELDS----------------

private java.lang.Object group

private int hash

private java.lang.String name

private final int[] oid

private java.lang.String sOID

private java.lang.String soid
----------------METHODS----------------

public void <init>(
int[])

public void <init>(
int[]
java.lang.String
java.lang.Object)

public static int hashIntArray(
int[])

public static void validateOid(
int[])

public boolean equals(
java.lang.Object)

public java.lang.Object getGroup()

public java.lang.String getName()

public int[] getOid()

public int hashCode()

public java.lang.String toOIDString()

public java.lang.String toString()

________________CLASS________________


public class org.apache.harmony.security.x501.AttributeType extends java.lang.Object

----------------FIELDS----------------

public final org.apache.harmony.security.asn1.ObjectIdentifier oid

public final org.apache.harmony.security.asn1.ASN1Type type
----------------METHODS----------------

public void <init>(
org.apache.harmony.security.asn1.ObjectIdentifier
org.apache.harmony.security.asn1.ASN1Type)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x501/AttributeTypeAndValue; )
final class org.apache.harmony.security.x501.AttributeTypeAndValue$1 extends org.apache.harmony.security.asn1.ASN1Type

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
int)

public boolean checkTag(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object decode(
org.apache.harmony.security.asn1.BerInputStream)

public void encodeASN(
org.apache.harmony.security.asn1.BerOutputStream)

public void encodeContent(
org.apache.harmony.security.asn1.BerOutputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

public int getEncodedLength(
org.apache.harmony.security.asn1.BerOutputStream)

public void setEncodingContent(
org.apache.harmony.security.asn1.BerOutputStream)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x501/AttributeTypeAndValue; )
final class org.apache.harmony.security.x501.AttributeTypeAndValue$2 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.security.x501.AttributeTypeAndValue extends java.lang.Object

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Sequence ASN1

public static org.apache.harmony.security.asn1.ASN1Type AttributeValue

private static final org.apache.harmony.security.utils.ObjectIdentifier C

private static final int CAPACITY

private static final org.apache.harmony.security.utils.ObjectIdentifier CN

private static final org.apache.harmony.security.utils.ObjectIdentifier DC

private static final org.apache.harmony.security.utils.ObjectIdentifier DNQ

private static final org.apache.harmony.security.utils.ObjectIdentifier DNQUALIFIER

private static final org.apache.harmony.security.utils.ObjectIdentifier EMAILADDRESS

private static final org.apache.harmony.security.utils.ObjectIdentifier GENERATION

private static final org.apache.harmony.security.utils.ObjectIdentifier GIVENNAME

private static final org.apache.harmony.security.utils.ObjectIdentifier INITIALS

private static final java.util.HashMap KNOWN_NAMES

private static final org.apache.harmony.security.utils.ObjectIdentifier[][] KNOWN_OIDS

private static final org.apache.harmony.security.utils.ObjectIdentifier L

private static final org.apache.harmony.security.utils.ObjectIdentifier O

private static final org.apache.harmony.security.utils.ObjectIdentifier OU

private static final java.util.HashMap RFC1779_NAMES

private static final java.util.HashMap RFC2253_NAMES

private static final java.util.HashMap RFC2459_NAMES

private static final org.apache.harmony.security.utils.ObjectIdentifier SERIALNUMBER

private static final int SIZE

private static final org.apache.harmony.security.utils.ObjectIdentifier ST

private static final org.apache.harmony.security.utils.ObjectIdentifier STREET

private static final org.apache.harmony.security.utils.ObjectIdentifier SURNAME

private static final org.apache.harmony.security.utils.ObjectIdentifier T

private static final org.apache.harmony.security.utils.ObjectIdentifier UID

private final org.apache.harmony.security.utils.ObjectIdentifier oid

private org.apache.harmony.security.x501.AttributeValue value
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.lang.String
org.apache.harmony.security.x501.AttributeValue)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void <init>(
int[]
org.apache.harmony.security.x501.AttributeValue)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void <init>(
int[]
org.apache.harmony.security.x501.AttributeValue
org.apache.harmony.security.x501.AttributeTypeAndValue$1)

static org.apache.harmony.security.utils.ObjectIdentifier access$100(
org.apache.harmony.security.x501.AttributeTypeAndValue)

static org.apache.harmony.security.x501.AttributeValue access$200(
org.apache.harmony.security.x501.AttributeTypeAndValue)

private static void addOID(
org.apache.harmony.security.utils.ObjectIdentifier)

private static org.apache.harmony.security.utils.ObjectIdentifier getOID(
int[])

private static int hashIntArray(
int[])

public void appendName(
java.lang.String
java.lang.StringBuffer)

public org.apache.harmony.security.utils.ObjectIdentifier getType()

________________CLASS________________


public class org.apache.harmony.security.x501.AttributeTypeAndValueComparator extends java.lang.Object implements java.util.Comparator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

private static int compateOids(
org.apache.harmony.security.utils.ObjectIdentifier
org.apache.harmony.security.utils.ObjectIdentifier)

public int compare(
java.lang.Object
java.lang.Object)

public boolean equals(
java.lang.Object)

________________CLASS________________


public class org.apache.harmony.security.x501.AttributeValue extends java.lang.Object

----------------FIELDS----------------

public byte[] bytes

public byte[] encoded

public java.lang.String escapedString

public boolean hasQE

private java.lang.String hexString

public java.lang.String rawString

private int tag

public final boolean wasEncoded
----------------METHODS----------------

public void <init>(
java.lang.String
boolean)

public void <init>(
java.lang.String
byte[])

public void <init>(
java.lang.String
byte[]
int)

private java.lang.String makeEscaped(
java.lang.String)

public void appendQEString(
java.lang.StringBuffer)

public java.lang.String getHexString()

public int getTag()

public java.lang.String makeCanonical()

________________CLASS________________


public class org.apache.harmony.security.x501.Attributes extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public static org.apache.harmony.security.asn1.ASN1Sequence getASN1(
org.apache.harmony.security.asn1.InformationObjectSet)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x501/DirectoryString; )
final class org.apache.harmony.security.x501.DirectoryString$1 extends org.apache.harmony.security.asn1.ASN1Choice

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])

public int getIndex(
java.lang.Object)

public java.lang.Object getObjectToEncode(
java.lang.Object)

________________CLASS________________


public class org.apache.harmony.security.x501.DirectoryString extends java.lang.Object

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Choice ASN1
----------------METHODS----------------

static void <clinit>()

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x501/Name; )
final class org.apache.harmony.security.x501.Name$1 extends org.apache.harmony.security.asn1.ASN1SequenceOf

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type)

public java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

public java.util.Collection getValues(
java.lang.Object)

________________CLASS________________


public class org.apache.harmony.security.x501.Name extends java.lang.Object

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1SequenceOf ASN1

public static final org.apache.harmony.security.asn1.ASN1SetOf ASN1_RDN

private java.lang.String canonicalString

private volatile byte[] encoded

private java.util.List rdn

private java.lang.String rfc1779String

private java.lang.String rfc2253String
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.lang.String)

private void <init>(
java.util.List)

 void <init>(
java.util.List
org.apache.harmony.security.x501.Name$1)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
byte[])

static java.util.List access$100(
org.apache.harmony.security.x501.Name)

private java.lang.String getName0(
java.lang.String)

public byte[] getEncoded()

public java.lang.String getName(
java.lang.String)

public javax.security.auth.x500.X500Principal getX500Principal()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/AccessDescription; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class org.apache.harmony.security.x509.AccessDescription$1 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])

protected java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.security.x509.AccessDescription extends java.lang.Object

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Sequence ASN1

private final org.apache.harmony.security.x509.GeneralName accessLocation

private final java.lang.String accessMethod

private byte[] encoding
----------------METHODS----------------

static void <clinit>()

public void <init>(
java.lang.String
org.apache.harmony.security.x509.GeneralName)

private void <init>(
java.lang.String
org.apache.harmony.security.x509.GeneralName
byte[])

 void <init>(
java.lang.String
org.apache.harmony.security.x509.GeneralName
byte[]
org.apache.harmony.security.x509.AccessDescription$1)

static java.lang.String access$100(
org.apache.harmony.security.x509.AccessDescription)

static org.apache.harmony.security.x509.GeneralName access$200(
org.apache.harmony.security.x509.AccessDescription)

public org.apache.harmony.security.x509.GeneralName getAccessLocation()

public java.lang.String getAccessMethod()

public byte[] getEncoded()

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/AlgorithmIdentifier; )
final class org.apache.harmony.security.x509.AlgorithmIdentifier$1 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])

protected java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.security.x509.AlgorithmIdentifier extends java.lang.Object

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Sequence ASN1

private java.lang.String algorithm

private java.lang.String algorithmName

private byte[] encoding

private byte[] parameters
----------------METHODS----------------

static void <clinit>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
byte[])

private void <init>(
java.lang.String
byte[]
byte[])

public void dumpValue(
java.lang.StringBuffer)

public boolean equals(
java.lang.Object)

public java.lang.String getAlgorithm()

public java.lang.String getAlgorithmName()

public byte[] getEncoded()

public byte[] getParameters()

________________CLASS________________


public class org.apache.harmony.security.x509.ExtensionValue extends java.lang.Object

----------------FIELDS----------------

protected byte[] encoding
----------------METHODS----------------

public void <init>()

public void <init>(
byte[])

public void dumpValue(
java.lang.StringBuffer)

public void dumpValue(
java.lang.StringBuffer
java.lang.String)

public byte[] getEncoded()

________________CLASS________________


public class org.apache.harmony.security.x509.AlternativeName extends org.apache.harmony.security.x509.ExtensionValue

----------------FIELDS----------------

public static final boolean ISSUER

public static final boolean SUBJECT

private org.apache.harmony.security.x509.GeneralNames alternativeNames

private boolean which
----------------METHODS----------------

public void <init>(
boolean
org.apache.harmony.security.x509.GeneralNames)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
boolean
byte[])

public void dumpValue(
java.lang.StringBuffer
java.lang.String)

public java.util.List getAlternativeNames()

public byte[] getEncoded()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/AuthorityKeyIdentifier; )
final class org.apache.harmony.security.x509.AuthorityKeyIdentifier$1 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.security.x509.AuthorityKeyIdentifier extends org.apache.harmony.security.x509.ExtensionValue

----------------FIELDS----------------

public static org.apache.harmony.security.asn1.ASN1Type ASN1

private final org.apache.harmony.security.x509.GeneralNames authorityCertIssuer

private final java.math.BigInteger authorityCertSerialNumber

private final byte[] keyIdentifier
----------------METHODS----------------

static void <clinit>()

public void <init>(
byte[]
org.apache.harmony.security.x509.GeneralNames
java.math.BigInteger)

static byte[] access$000(
org.apache.harmony.security.x509.AuthorityKeyIdentifier)

static org.apache.harmony.security.x509.GeneralNames access$100(
org.apache.harmony.security.x509.AuthorityKeyIdentifier)

static java.math.BigInteger access$200(
org.apache.harmony.security.x509.AuthorityKeyIdentifier)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static org.apache.harmony.security.x509.AuthorityKeyIdentifier decode(
byte[])

public void dumpValue(
java.lang.StringBuffer
java.lang.String)

public byte[] getEncoded()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/BasicConstraints; )
final class org.apache.harmony.security.x509.BasicConstraints$1 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.security.x509.BasicConstraints extends org.apache.harmony.security.x509.ExtensionValue

----------------FIELDS----------------

public static org.apache.harmony.security.asn1.ASN1Type ASN1

private boolean cA

private int pathLenConstraint
----------------METHODS----------------

static void <clinit>()

public void <init>(
boolean
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
byte[])

public void dumpValue(
java.lang.StringBuffer
java.lang.String)

public boolean getCA()

public byte[] getEncoded()

public int getPathLenConstraint()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/CRLDistributionPoints; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class org.apache.harmony.security.x509.CRLDistributionPoints$1 extends org.apache.harmony.security.asn1.ASN1SequenceOf

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type)

public java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

public java.util.Collection getValues(
java.lang.Object)

________________CLASS________________


public class org.apache.harmony.security.x509.CRLDistributionPoints extends org.apache.harmony.security.x509.ExtensionValue

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Type ASN1

private java.util.List distributionPoints

private byte[] encoding
----------------METHODS----------------

static void <clinit>()

public void <init>(
java.util.List)

public void <init>(
java.util.List
byte[])

static java.util.List access$000(
org.apache.harmony.security.x509.CRLDistributionPoints)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static org.apache.harmony.security.x509.CRLDistributionPoints decode(
byte[])

public void dumpValue(
java.lang.StringBuffer
java.lang.String)

public byte[] getEncoded()

________________CLASS________________


public class org.apache.harmony.security.x509.CRLNumber extends org.apache.harmony.security.x509.ExtensionValue

----------------FIELDS----------------

public static org.apache.harmony.security.asn1.ASN1Type ASN1

private final java.math.BigInteger number
----------------METHODS----------------

static void <clinit>()

public void <init>(
java.math.BigInteger)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
byte[])

public void dumpValue(
java.lang.StringBuffer
java.lang.String)

public byte[] getEncoded()

public java.math.BigInteger getNumber()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/Certificate; )
final class org.apache.harmony.security.x509.Certificate$1 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])

protected java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.security.x509.Certificate extends java.lang.Object

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Sequence ASN1

private byte[] encoding

private final org.apache.harmony.security.x509.AlgorithmIdentifier signatureAlgorithm

private final byte[] signatureValue

private final org.apache.harmony.security.x509.TBSCertificate tbsCertificate
----------------METHODS----------------

static void <clinit>()

public void <init>(
org.apache.harmony.security.x509.TBSCertificate
org.apache.harmony.security.x509.AlgorithmIdentifier
byte[])

private void <init>(
org.apache.harmony.security.x509.TBSCertificate
org.apache.harmony.security.x509.AlgorithmIdentifier
byte[]
byte[])

 void <init>(
org.apache.harmony.security.x509.TBSCertificate
org.apache.harmony.security.x509.AlgorithmIdentifier
byte[]
byte[]
org.apache.harmony.security.x509.Certificate$1)

static org.apache.harmony.security.x509.TBSCertificate access$100(
org.apache.harmony.security.x509.Certificate)

static org.apache.harmony.security.x509.AlgorithmIdentifier access$200(
org.apache.harmony.security.x509.Certificate)

static byte[] access$300(
org.apache.harmony.security.x509.Certificate)

public byte[] getEncoded()

public org.apache.harmony.security.x509.AlgorithmIdentifier getSignatureAlgorithm()

public byte[] getSignatureValue()

public org.apache.harmony.security.x509.TBSCertificate getTbsCertificate()

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/CertificateIssuer; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class org.apache.harmony.security.x509.CertificateIssuer$1 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])

public java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.security.x509.CertificateIssuer extends org.apache.harmony.security.x509.ExtensionValue

----------------FIELDS----------------

public static org.apache.harmony.security.asn1.ASN1Type ASN1

private javax.security.auth.x500.X500Principal issuer
----------------METHODS----------------

static void <clinit>()

public void <init>(
org.apache.harmony.security.x509.GeneralName)

public void <init>(
byte[])

public void dumpValue(
java.lang.StringBuffer
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public javax.security.auth.x500.X500Principal getIssuer()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/CertificateList; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class org.apache.harmony.security.x509.CertificateList$1 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])

protected java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.security.x509.CertificateList extends java.lang.Object

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Sequence ASN1

private byte[] encoding

private final org.apache.harmony.security.x509.AlgorithmIdentifier signatureAlgorithm

private final byte[] signatureValue

private final org.apache.harmony.security.x509.TBSCertList tbsCertList
----------------METHODS----------------

static void <clinit>()

public void <init>(
org.apache.harmony.security.x509.TBSCertList
org.apache.harmony.security.x509.AlgorithmIdentifier
byte[])

private void <init>(
org.apache.harmony.security.x509.TBSCertList
org.apache.harmony.security.x509.AlgorithmIdentifier
byte[]
byte[])

 void <init>(
org.apache.harmony.security.x509.TBSCertList
org.apache.harmony.security.x509.AlgorithmIdentifier
byte[]
byte[]
org.apache.harmony.security.x509.CertificateList$1)

static org.apache.harmony.security.x509.TBSCertList access$100(
org.apache.harmony.security.x509.CertificateList)

static org.apache.harmony.security.x509.AlgorithmIdentifier access$200(
org.apache.harmony.security.x509.CertificateList)

static byte[] access$300(
org.apache.harmony.security.x509.CertificateList)

public byte[] getEncoded()

public org.apache.harmony.security.x509.AlgorithmIdentifier getSignatureAlgorithm()

public byte[] getSignatureValue()

public org.apache.harmony.security.x509.TBSCertList getTbsCertList()

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/CertificatePolicies; )
final class org.apache.harmony.security.x509.CertificatePolicies$1 extends org.apache.harmony.security.asn1.ASN1SequenceOf

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type)

public java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

public java.util.Collection getValues(
java.lang.Object)

________________CLASS________________


public class org.apache.harmony.security.x509.CertificatePolicies extends org.apache.harmony.security.x509.ExtensionValue

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Type ASN1

private byte[] encoding

private java.util.List policyInformations
----------------METHODS----------------

static void <clinit>()

public void <init>()

public void <init>(
java.util.List)

private void <init>(
java.util.List
byte[])

 void <init>(
java.util.List
byte[]
org.apache.harmony.security.x509.CertificatePolicies$1)

static java.util.List access$100(
org.apache.harmony.security.x509.CertificatePolicies)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static org.apache.harmony.security.x509.CertificatePolicies decode(
byte[])

public org.apache.harmony.security.x509.CertificatePolicies addPolicyInformation(
org.apache.harmony.security.x509.PolicyInformation)

public void dumpValue(
java.lang.StringBuffer
java.lang.String)

public byte[] getEncoded()

public java.util.List getPolicyInformations()

________________CLASS________________


public class org.apache.harmony.security.x509.DNParser extends java.lang.Object

----------------FIELDS----------------

protected int beg

protected char[] chars

protected int cur

protected byte[] encoded

protected int end

protected boolean hasQE

protected final int length

protected int pos
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private char getEscaped()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private java.lang.String hexAV()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected java.lang.String escapedAV()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected int getByte(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected char getUTF8()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected java.lang.String nextAT()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.util.List parse()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected java.lang.String quotedAV()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/DistributionPoint; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class org.apache.harmony.security.x509.DistributionPoint$1 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.security.x509.DistributionPoint extends java.lang.Object

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Sequence ASN1

private final org.apache.harmony.security.x509.GeneralNames cRLIssuer

private final org.apache.harmony.security.x509.DistributionPointName distributionPoint

private final org.apache.harmony.security.x509.ReasonFlags reasons
----------------METHODS----------------

static void <clinit>()

public void <init>()

public void <init>(
org.apache.harmony.security.x509.DistributionPointName
org.apache.harmony.security.x509.ReasonFlags
org.apache.harmony.security.x509.GeneralNames)

static org.apache.harmony.security.x509.DistributionPointName access$000(
org.apache.harmony.security.x509.DistributionPoint)

static org.apache.harmony.security.x509.ReasonFlags access$100(
org.apache.harmony.security.x509.DistributionPoint)

static org.apache.harmony.security.x509.GeneralNames access$200(
org.apache.harmony.security.x509.DistributionPoint)

public void dumpValue(
java.lang.StringBuffer
java.lang.String)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/DistributionPointName; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class org.apache.harmony.security.x509.DistributionPointName$1 extends org.apache.harmony.security.asn1.ASN1Choice

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

public int getIndex(
java.lang.Object)

public java.lang.Object getObjectToEncode(
java.lang.Object)

________________CLASS________________


public class org.apache.harmony.security.x509.DistributionPointName extends java.lang.Object

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Choice ASN1

private final org.apache.harmony.security.x509.GeneralNames fullName

private final org.apache.harmony.security.x501.Name nameRelativeToCRLIssuer
----------------METHODS----------------

static void <clinit>()

public void <init>(
org.apache.harmony.security.x501.Name)

public void <init>(
org.apache.harmony.security.x509.GeneralNames)

static org.apache.harmony.security.x509.GeneralNames access$000(
org.apache.harmony.security.x509.DistributionPointName)

static org.apache.harmony.security.x501.Name access$100(
org.apache.harmony.security.x509.DistributionPointName)

public void dumpValue(
java.lang.StringBuffer
java.lang.String)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/EDIPartyName; )
final class org.apache.harmony.security.x509.EDIPartyName$1 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])

protected java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.security.x509.EDIPartyName extends java.lang.Object

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Sequence ASN1

private byte[] encoding

private java.lang.String nameAssigner

private java.lang.String partyName
----------------METHODS----------------

static void <clinit>()

public void <init>(
java.lang.String
java.lang.String)

private void <init>(
java.lang.String
java.lang.String
byte[])

 void <init>(
java.lang.String
java.lang.String
byte[]
org.apache.harmony.security.x509.EDIPartyName$1)

static java.lang.String access$100(
org.apache.harmony.security.x509.EDIPartyName)

static java.lang.String access$200(
org.apache.harmony.security.x509.EDIPartyName)

public byte[] getEncoded()

public java.lang.String getNameAssigner()

public java.lang.String getPartyName()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/ExtendedKeyUsage; )
final class org.apache.harmony.security.x509.ExtendedKeyUsage$1 extends org.apache.harmony.security.asn1.ASN1Oid

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

________________CLASS________________


public class org.apache.harmony.security.x509.ExtendedKeyUsage extends org.apache.harmony.security.x509.ExtensionValue

----------------FIELDS----------------

public static org.apache.harmony.security.asn1.ASN1Type ASN1

private java.util.List keys
----------------METHODS----------------

static void <clinit>()

public void <init>(
java.util.List)

public void <init>(
byte[])

public void dumpValue(
java.lang.StringBuffer
java.lang.String)

public byte[] getEncoded()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.util.List getExtendedKeyUsage()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/Extension; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class org.apache.harmony.security.x509.Extension$1 extends org.apache.harmony.security.asn1.ASN1OctetString

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/Extension; )
final class org.apache.harmony.security.x509.Extension$2 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.security.x509.Extension extends java.lang.Object

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Sequence ASN1

public static final int[] AUTHORITY_INFO_ACCESS

public static final int[] AUTH_KEY_ID

public static final int[] BASIC_CONSTRAINTS

public static final int[] CERTIFICATE_ISSUER

public static final int[] CERTIFICATE_POLICIES

public static final boolean CRITICAL

public static final int[] CRL_DISTR_POINTS

public static final int[] CRL_NUMBER

public static final int[] EXTENDED_KEY_USAGE

public static final int[] FRESHEST_CRL

public static final int[] INHIBIT_ANY_POLICY

public static final int[] INVALIDITY_DATE

public static final int[] ISSUER_ALTERNATIVE_NAME

public static final int[] ISSUING_DISTR_POINT

public static final int[] ISSUING_DISTR_POINTS

public static final int[] KEY_USAGE

public static final int[] NAME_CONSTRAINTS

public static final boolean NON_CRITICAL

public static final int[] POLICY_CONSTRAINTS

public static final int[] POLICY_MAPPINGS

public static final int[] PRIVATE_KEY_USAGE_PERIOD

public static final int[] REASON_CODE

public static final int[] SUBJECT_ALT_NAME

public static final int[] SUBJECT_INFO_ACCESS

public static final int[] SUBJ_DIRECTORY_ATTRS

public static final int[] SUBJ_KEY_ID

private final boolean critical

private byte[] encoding

private final int[] extnID

private java.lang.String extnID_str

private final byte[] extnValue

protected org.apache.harmony.security.x509.ExtensionValue extnValueObject

private byte[] rawExtnValue

private boolean valueDecoded
----------------METHODS----------------

static void <clinit>()

public void <init>(
java.lang.String
boolean
org.apache.harmony.security.x509.ExtensionValue)

public void <init>(
java.lang.String
boolean
byte[])

public void <init>(
java.lang.String
byte[])

public void <init>(
int[]
boolean
byte[])

private void <init>(
int[]
boolean
byte[]
byte[]
byte[]
org.apache.harmony.security.x509.ExtensionValue)

 void <init>(
int[]
boolean
byte[]
byte[]
byte[]
org.apache.harmony.security.x509.ExtensionValue
org.apache.harmony.security.x509.Extension$1)

public void <init>(
int[]
byte[])

static boolean access$000(
int[]
int[])

static int[] access$200(
org.apache.harmony.security.x509.Extension)

static boolean access$300(
org.apache.harmony.security.x509.Extension)

static byte[] access$400(
org.apache.harmony.security.x509.Extension)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void decodeExtensionValue()

private static boolean oidEquals(
int[]
int[])

public void dumpValue(
java.lang.StringBuffer
java.lang.String)

public boolean equals(
java.lang.Object)

public org.apache.harmony.security.x509.BasicConstraints getBasicConstraintsValue()

public boolean getCritical()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public org.apache.harmony.security.x509.ExtensionValue getDecodedExtensionValue()

public byte[] getEncoded()

public java.lang.String getExtnID()

public byte[] getExtnValue()

public org.apache.harmony.security.x509.KeyUsage getKeyUsageValue()

public byte[] getRawExtnValue()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/Extensions; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class org.apache.harmony.security.x509.Extensions$1 extends org.apache.harmony.security.asn1.ASN1SequenceOf

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type)

public java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

public java.util.Collection getValues(
java.lang.Object)

________________CLASS________________


public class org.apache.harmony.security.x509.Extensions extends java.lang.Object

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Type ASN1

private static java.util.List SUPPORTED_CRITICAL

private java.util.Set critical

private byte[] encoding
@dalvik.annotation.Signature (value =Ljava/util/List<Lorg/apache/harmony/security/x509/Extension;>; )
private java.util.List extensions

private boolean hasUnsupported

private java.util.Set noncritical

private java.util.HashMap oidMap
----------------METHODS----------------

static void <clinit>()

public void <init>()

public void <init>(
java.util.List)

static java.util.List access$000(
org.apache.harmony.security.x509.Extensions)

private void makeOidsLists()

public void addExtension(
org.apache.harmony.security.x509.Extension)

public void dumpValue(
java.lang.StringBuffer
java.lang.String)

public boolean equals(
java.lang.Object)

public java.util.Set getCriticalExtensions()

public byte[] getEncoded()

public org.apache.harmony.security.x509.Extension getExtensionByOID(
java.lang.String)

public java.util.List getExtensions()

public java.util.Set getNonCriticalExtensions()

public boolean hasUnsupportedCritical()

public int size()

public int valueOfBasicConstrains()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public javax.security.auth.x500.X500Principal valueOfCertificateIssuerExtension()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.util.List valueOfExtendedKeyUsage()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.util.List valueOfIssuerAlternativeName()

public boolean[] valueOfKeyUsage()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.util.List valueOfSubjectAlternativeName()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/GeneralName; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class org.apache.harmony.security.x509.GeneralName$1 extends org.apache.harmony.security.asn1.ASN1Choice

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

public int getIndex(
java.lang.Object)

public java.lang.Object getObjectToEncode(
java.lang.Object)

________________CLASS________________


public class org.apache.harmony.security.x509.GeneralName extends java.lang.Object

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Choice ASN1

public static final int DIR_NAME

public static final int DNS_NAME

public static final int EDIP_NAME

public static final int IP_ADDR

public static final int OTHER_NAME

public static final int REG_ID

public static final int RFC822_NAME

public static final int UR_ID

public static final int X400_ADDR

private static org.apache.harmony.security.asn1.ASN1Type[] nameASN1

private byte[] encoding

private java.lang.Object name

private byte[] name_encoding

private int tag
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
int
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
int
byte[])

public void <init>(
org.apache.harmony.security.x501.Name)

public void <init>(
org.apache.harmony.security.x509.EDIPartyName)

public void <init>(
org.apache.harmony.security.x509.ORAddress)

public void <init>(
org.apache.harmony.security.x509.OtherName)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public void <init>(
byte[])

static java.lang.Object access$000(
org.apache.harmony.security.x509.GeneralName)

static int access$100(
org.apache.harmony.security.x509.GeneralName)

static byte[] access$202(
org.apache.harmony.security.x509.GeneralName
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static void checkDNS(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static void checkURI(
java.lang.String)

private java.lang.String getBytesAsString(
byte[])

public static java.lang.String ipBytesToStr(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static byte[] ipStrToBytes(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static int[] oidStrToInts(
java.lang.String)

public boolean equals(
java.lang.Object)

public java.util.List getAsList()

public byte[] getEncoded()

public byte[] getEncodedName()

public java.lang.Object getName()

public int getTag()

public boolean isAcceptable(
org.apache.harmony.security.x509.GeneralName)

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/GeneralNames; )
final class org.apache.harmony.security.x509.GeneralNames$1 extends org.apache.harmony.security.asn1.ASN1SequenceOf

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type)

public java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

public java.util.Collection getValues(
java.lang.Object)

________________CLASS________________


public class org.apache.harmony.security.x509.GeneralNames extends java.lang.Object

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Type ASN1

private byte[] encoding

private java.util.List generalNames
----------------METHODS----------------

static void <clinit>()

public void <init>()

public void <init>(
java.util.List)

private void <init>(
java.util.List
byte[])

 void <init>(
java.util.List
byte[]
org.apache.harmony.security.x509.GeneralNames$1)

static java.util.List access$100(
org.apache.harmony.security.x509.GeneralNames)

public void addName(
org.apache.harmony.security.x509.GeneralName)

public void dumpValue(
java.lang.StringBuffer
java.lang.String)

public byte[] getEncoded()

public java.util.List getNames()

public java.util.List getPairsList()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/GeneralSubtree; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class org.apache.harmony.security.x509.GeneralSubtree$1 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])

protected java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.security.x509.GeneralSubtree extends java.lang.Object

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Sequence ASN1

private final org.apache.harmony.security.x509.GeneralName base

private byte[] encoding

private final int maximum

private final int minimum
----------------METHODS----------------

static void <clinit>()

public void <init>(
org.apache.harmony.security.x509.GeneralName)

public void <init>(
org.apache.harmony.security.x509.GeneralName
int)

public void <init>(
org.apache.harmony.security.x509.GeneralName
int
int)

static org.apache.harmony.security.x509.GeneralName access$000(
org.apache.harmony.security.x509.GeneralSubtree)

static int access$100(
org.apache.harmony.security.x509.GeneralSubtree)

static int access$200(
org.apache.harmony.security.x509.GeneralSubtree)

public void dumpValue(
java.lang.StringBuffer
java.lang.String)

public org.apache.harmony.security.x509.GeneralName getBase()

public byte[] getEncoded()

public int getMaximum()

public int getMinimum()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/GeneralSubtrees; )
final class org.apache.harmony.security.x509.GeneralSubtrees$1 extends org.apache.harmony.security.asn1.ASN1SequenceOf

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type)

public java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

public java.util.Collection getValues(
java.lang.Object)

________________CLASS________________


public class org.apache.harmony.security.x509.GeneralSubtrees extends java.lang.Object

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Type ASN1

private byte[] encoding

private java.util.List generalSubtrees
----------------METHODS----------------

static void <clinit>()

public void <init>()

public void <init>(
java.util.List)

static java.util.List access$000(
org.apache.harmony.security.x509.GeneralSubtrees)

public org.apache.harmony.security.x509.GeneralSubtrees addSubtree(
org.apache.harmony.security.x509.GeneralSubtree)

public byte[] getEncoded()

public java.util.List getSubtrees()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/InfoAccessSyntax; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class org.apache.harmony.security.x509.InfoAccessSyntax$1 extends org.apache.harmony.security.asn1.ASN1SequenceOf

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

public java.util.Collection getValues(
java.lang.Object)

________________CLASS________________


public class org.apache.harmony.security.x509.InfoAccessSyntax extends org.apache.harmony.security.x509.ExtensionValue

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Type ASN1

private final java.util.List accessDescriptions
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.util.List)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void <init>(
java.util.List
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void <init>(
java.util.List
byte[]
org.apache.harmony.security.x509.InfoAccessSyntax$1)

static java.util.List access$100(
org.apache.harmony.security.x509.InfoAccessSyntax)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static org.apache.harmony.security.x509.InfoAccessSyntax decode(
byte[])

public void dumpValue(
java.lang.StringBuffer
java.lang.String)

public java.util.List getAccessDescriptions()

public byte[] getEncoded()

public java.lang.String toString()

________________CLASS________________


public class org.apache.harmony.security.x509.InhibitAnyPolicy extends org.apache.harmony.security.x509.ExtensionValue

----------------FIELDS----------------

private int skipCerts
----------------METHODS----------------

public void <init>(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
byte[])

public void dumpValue(
java.lang.StringBuffer
java.lang.String)

public byte[] getEncoded()

public int getSkipCerts()

________________CLASS________________


public class org.apache.harmony.security.x509.InvalidityDate extends org.apache.harmony.security.x509.ExtensionValue

----------------FIELDS----------------

public static org.apache.harmony.security.asn1.ASN1Type ASN1

private final java.util.Date date
----------------METHODS----------------

static void <clinit>()

public void <init>(
java.util.Date)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
byte[])

public void dumpValue(
java.lang.StringBuffer
java.lang.String)

public java.util.Date getDate()

public byte[] getEncoded()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/IssuingDistributionPoint; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class org.apache.harmony.security.x509.IssuingDistributionPoint$1 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])

protected java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.security.x509.IssuingDistributionPoint extends org.apache.harmony.security.x509.ExtensionValue

----------------FIELDS----------------

public static org.apache.harmony.security.asn1.ASN1Type ASN1

private org.apache.harmony.security.x509.DistributionPointName distributionPoint

private boolean indirectCRL

private boolean onlyContainsAttributeCerts

private boolean onlyContainsCACerts

private boolean onlyContainsUserCerts

private org.apache.harmony.security.x509.ReasonFlags onlySomeReasons
----------------METHODS----------------

static void <clinit>()

public void <init>(
org.apache.harmony.security.x509.DistributionPointName
org.apache.harmony.security.x509.ReasonFlags)

static org.apache.harmony.security.x509.DistributionPointName access$000(
org.apache.harmony.security.x509.IssuingDistributionPoint)

static boolean access$100(
org.apache.harmony.security.x509.IssuingDistributionPoint)

static boolean access$200(
org.apache.harmony.security.x509.IssuingDistributionPoint)

static org.apache.harmony.security.x509.ReasonFlags access$300(
org.apache.harmony.security.x509.IssuingDistributionPoint)

static boolean access$400(
org.apache.harmony.security.x509.IssuingDistributionPoint)

static boolean access$500(
org.apache.harmony.security.x509.IssuingDistributionPoint)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static org.apache.harmony.security.x509.IssuingDistributionPoint decode(
byte[])

public void dumpValue(
java.lang.StringBuffer
java.lang.String)

public org.apache.harmony.security.x509.DistributionPointName getDistributionPoint()

public byte[] getEncoded()

public boolean getIndirectCRL()

public boolean getOnlyContainsAttributeCerts()

public boolean getOnlyContainsCACerts()

public boolean getOnlyContainsUserCerts()

public org.apache.harmony.security.x509.ReasonFlags getOnlySomeReasons()

public void setIndirectCRL(
boolean)

public void setOnlyContainsAttributeCerts(
boolean)

public void setOnlyContainsCACerts(
boolean)

public void setOnlyContainsUserCerts(
boolean)

________________CLASS________________


public class org.apache.harmony.security.x509.KeyUsage extends org.apache.harmony.security.x509.ExtensionValue

----------------FIELDS----------------

private static final org.apache.harmony.security.asn1.ASN1Type ASN1

private static final java.lang.String[] USAGES

private final boolean[] keyUsage
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
byte[])

public void <init>(
boolean[])

public void dumpValue(
java.lang.StringBuffer
java.lang.String)

public byte[] getEncoded()

public boolean[] getKeyUsage()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/NameConstraints; )
final class org.apache.harmony.security.x509.NameConstraints$1 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])

protected java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.security.x509.NameConstraints extends org.apache.harmony.security.x509.ExtensionValue

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Sequence ASN1

private byte[] encoding

private final org.apache.harmony.security.x509.GeneralSubtrees excludedSubtrees

private java.util.ArrayList[] excluded_names

private final org.apache.harmony.security.x509.GeneralSubtrees permittedSubtrees

private java.util.ArrayList[] permitted_names
----------------METHODS----------------

static void <clinit>()

public void <init>()

public void <init>(
org.apache.harmony.security.x509.GeneralSubtrees
org.apache.harmony.security.x509.GeneralSubtrees)

private void <init>(
org.apache.harmony.security.x509.GeneralSubtrees
org.apache.harmony.security.x509.GeneralSubtrees
byte[])

 void <init>(
org.apache.harmony.security.x509.GeneralSubtrees
org.apache.harmony.security.x509.GeneralSubtrees
byte[]
org.apache.harmony.security.x509.NameConstraints$1)

static org.apache.harmony.security.x509.GeneralSubtrees access$100(
org.apache.harmony.security.x509.NameConstraints)

static org.apache.harmony.security.x509.GeneralSubtrees access$200(
org.apache.harmony.security.x509.NameConstraints)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static org.apache.harmony.security.x509.NameConstraints decode(
byte[])

private byte[] getExtensionValue(
java.security.cert.X509Certificate
java.lang.String)

private void prepareNames()

public void dumpValue(
java.lang.StringBuffer
java.lang.String)

public byte[] getEncoded()

public boolean isAcceptable(
java.security.cert.X509Certificate)

public boolean isAcceptable(
java.util.List)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/ORAddress; )
final class org.apache.harmony.security.x509.ORAddress$1 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])

protected java.lang.Object getDecodedObject(
java.lang.Object[])

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/ORAddress; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class org.apache.harmony.security.x509.ORAddress$2 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------

private final java.lang.Object foo
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])

protected java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.security.x509.ORAddress extends java.lang.Object

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Sequence ASN1

private byte[] encoding
----------------METHODS----------------

static void <clinit>()

public void <init>()

public byte[] getEncoded()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/OtherName; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class org.apache.harmony.security.x509.OtherName$1 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])

protected java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.security.x509.OtherName extends java.lang.Object

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Sequence ASN1

private byte[] encoding

private java.lang.String typeID

private byte[] value
----------------METHODS----------------

static void <clinit>()

public void <init>(
java.lang.String
byte[])

private void <init>(
java.lang.String
byte[]
byte[])

 void <init>(
java.lang.String
byte[]
byte[]
org.apache.harmony.security.x509.OtherName$1)

static java.lang.String access$100(
org.apache.harmony.security.x509.OtherName)

static byte[] access$200(
org.apache.harmony.security.x509.OtherName)

public byte[] getEncoded()

public java.lang.String getTypeID()

public byte[] getValue()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/PolicyConstraints; )
final class org.apache.harmony.security.x509.PolicyConstraints$1 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])

protected java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.security.x509.PolicyConstraints extends org.apache.harmony.security.x509.ExtensionValue

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Sequence ASN1

private byte[] encoding

private final java.math.BigInteger inhibitPolicyMapping

private final java.math.BigInteger requireExplicitPolicy
----------------METHODS----------------

static void <clinit>()

public void <init>()

public void <init>(
int
int)

public void <init>(
java.math.BigInteger
java.math.BigInteger)

private void <init>(
java.math.BigInteger
java.math.BigInteger
byte[])

 void <init>(
java.math.BigInteger
java.math.BigInteger
byte[]
org.apache.harmony.security.x509.PolicyConstraints$1)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
byte[])

static java.math.BigInteger access$100(
org.apache.harmony.security.x509.PolicyConstraints)

static java.math.BigInteger access$200(
org.apache.harmony.security.x509.PolicyConstraints)

public void dumpValue(
java.lang.StringBuffer
java.lang.String)

public byte[] getEncoded()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/PolicyInformation; )
final class org.apache.harmony.security.x509.PolicyInformation$1 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])

protected java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.security.x509.PolicyInformation extends java.lang.Object

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Sequence ASN1

private byte[] encoding

private java.lang.String policyIdentifier
----------------METHODS----------------

static void <clinit>()

public void <init>(
java.lang.String)

static java.lang.String access$000(
org.apache.harmony.security.x509.PolicyInformation)

public void dumpValue(
java.lang.StringBuffer)

public byte[] getEncoded()

public java.lang.String getPolicyIdentifier()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/PolicyQualifierInfo; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class org.apache.harmony.security.x509.PolicyQualifierInfo$1 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])

________________CLASS________________


public class org.apache.harmony.security.x509.PolicyQualifierInfo extends java.lang.Object

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Sequence ASN1
----------------METHODS----------------

static void <clinit>()

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/PrivateKeyUsagePeriod; )
final class org.apache.harmony.security.x509.PrivateKeyUsagePeriod$1 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])

protected java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.security.x509.PrivateKeyUsagePeriod extends java.lang.Object

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Sequence ASN1

private byte[] encoding

private final java.util.Date notAfterDate

private final java.util.Date notBeforeDate
----------------METHODS----------------

static void <clinit>()

public void <init>(
java.util.Date
java.util.Date)

private void <init>(
java.util.Date
java.util.Date
byte[])

 void <init>(
java.util.Date
java.util.Date
byte[]
org.apache.harmony.security.x509.PrivateKeyUsagePeriod$1)

static java.util.Date access$100(
org.apache.harmony.security.x509.PrivateKeyUsagePeriod)

static java.util.Date access$200(
org.apache.harmony.security.x509.PrivateKeyUsagePeriod)

public byte[] getEncoded()

public java.util.Date getNotAfter()

public java.util.Date getNotBefore()

________________CLASS________________


public class org.apache.harmony.security.x509.ReasonCode extends org.apache.harmony.security.x509.ExtensionValue

----------------FIELDS----------------

public static final byte AA_COMPROMISE

public static final byte AFFILIATION_CHANGED

public static org.apache.harmony.security.asn1.ASN1Type ASN1

public static final byte CA_COMPROMISE

public static final byte CERTIFICATE_HOLD

public static final byte CESSATION_OF_OPERATION

public static final byte KEY_COMPROMISE

public static final byte PRIVILEGE_WITHDRAWN

public static final byte REMOVE_FROM_CRL

public static final byte SUPERSEDED

public static final byte UNSPECIFIED

private final byte code
----------------METHODS----------------

static void <clinit>()

public void <init>(
byte)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
byte[])

public void dumpValue(
java.lang.StringBuffer
java.lang.String)

public int getCode()

public byte[] getEncoded()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/ReasonFlags; )
final class org.apache.harmony.security.x509.ReasonFlags$1 extends org.apache.harmony.security.asn1.ASN1BitString$ASN1NamedBitList

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

public void setEncodingContent(
org.apache.harmony.security.asn1.BerOutputStream)

________________CLASS________________


public class org.apache.harmony.security.x509.ReasonFlags extends java.lang.Object

----------------FIELDS----------------

public static org.apache.harmony.security.asn1.ASN1BitString ASN1

public static final java.lang.String[] REASONS

private boolean[] flags
----------------METHODS----------------

static void <clinit>()

public void <init>(
boolean[])

static boolean[] access$000(
org.apache.harmony.security.x509.ReasonFlags)

public void dumpValue(
java.lang.StringBuffer
java.lang.String)

________________CLASS________________


public class org.apache.harmony.security.x509.SubjectKeyIdentifier extends org.apache.harmony.security.x509.ExtensionValue

----------------FIELDS----------------

private final byte[] keyIdentifier
----------------METHODS----------------

public void <init>(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static org.apache.harmony.security.x509.SubjectKeyIdentifier decode(
byte[])

public void dumpValue(
java.lang.StringBuffer
java.lang.String)

public byte[] getEncoded()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/SubjectPublicKeyInfo; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class org.apache.harmony.security.x509.SubjectPublicKeyInfo$1 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])

protected java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.security.x509.SubjectPublicKeyInfo extends java.lang.Object

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Sequence ASN1

private org.apache.harmony.security.x509.AlgorithmIdentifier algorithmID

private byte[] encoding

private java.security.PublicKey publicKey

private byte[] subjectPublicKey

private int unusedBits
----------------METHODS----------------

static void <clinit>()

public void <init>(
org.apache.harmony.security.x509.AlgorithmIdentifier
byte[])

public void <init>(
org.apache.harmony.security.x509.AlgorithmIdentifier
byte[]
int)

private void <init>(
org.apache.harmony.security.x509.AlgorithmIdentifier
byte[]
int
byte[])

 void <init>(
org.apache.harmony.security.x509.AlgorithmIdentifier
byte[]
int
byte[]
org.apache.harmony.security.x509.SubjectPublicKeyInfo$1)

static org.apache.harmony.security.x509.AlgorithmIdentifier access$100(
org.apache.harmony.security.x509.SubjectPublicKeyInfo)

static byte[] access$200(
org.apache.harmony.security.x509.SubjectPublicKeyInfo)

static int access$300(
org.apache.harmony.security.x509.SubjectPublicKeyInfo)

public org.apache.harmony.security.x509.AlgorithmIdentifier getAlgorithmIdentifier()

public byte[] getEncoded()

public java.security.PublicKey getPublicKey()

public byte[] getSubjectPublicKey()

public int getUnusedBits()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/TBSCertList; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class org.apache.harmony.security.x509.TBSCertList$1 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/TBSCertList$RevokedCertificate; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class org.apache.harmony.security.x509.TBSCertList$RevokedCertificate$1 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])

protected java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/TBSCertList; )
@dalvik.annotation.InnerClass (accessFlags =9 name =RevokedCertificate )
public class org.apache.harmony.security.x509.TBSCertList$RevokedCertificate extends java.lang.Object

----------------FIELDS----------------

public static org.apache.harmony.security.asn1.ASN1Sequence ASN1

private final org.apache.harmony.security.x509.Extensions crlEntryExtensions

private byte[] encoding

private javax.security.auth.x500.X500Principal issuer

private boolean issuerRetrieved

private final java.util.Date revocationDate

private final java.math.BigInteger userCertificate
----------------METHODS----------------

static void <clinit>()

public void <init>(
java.math.BigInteger
java.util.Date
org.apache.harmony.security.x509.Extensions)

static java.math.BigInteger access$000(
org.apache.harmony.security.x509.TBSCertList$RevokedCertificate)

static java.util.Date access$100(
org.apache.harmony.security.x509.TBSCertList$RevokedCertificate)

static org.apache.harmony.security.x509.Extensions access$200(
org.apache.harmony.security.x509.TBSCertList$RevokedCertificate)

public void dumpValue(
java.lang.StringBuffer
java.lang.String)

public boolean equals(
java.lang.Object)

public org.apache.harmony.security.x509.Extensions getCrlEntryExtensions()

public byte[] getEncoded()

public javax.security.auth.x500.X500Principal getIssuer()

public java.util.Date getRevocationDate()

public java.math.BigInteger getUserCertificate()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/apache/harmony/security/x509/TBSCertList$RevokedCertificate; )
public class org.apache.harmony.security.x509.TBSCertList extends java.lang.Object

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Sequence ASN1

private final org.apache.harmony.security.x509.Extensions crlExtensions

private byte[] encoding

private final org.apache.harmony.security.x501.Name issuer

private final java.util.Date nextUpdate

private final java.util.List revokedCertificates

private final org.apache.harmony.security.x509.AlgorithmIdentifier signature

private final java.util.Date thisUpdate

private final int version
----------------METHODS----------------

static void <clinit>()

public void <init>(
int
org.apache.harmony.security.x509.AlgorithmIdentifier
org.apache.harmony.security.x501.Name
java.util.Date
java.util.Date
java.util.List
org.apache.harmony.security.x509.Extensions)

private void <init>(
int
org.apache.harmony.security.x509.AlgorithmIdentifier
org.apache.harmony.security.x501.Name
java.util.Date
java.util.Date
java.util.List
org.apache.harmony.security.x509.Extensions
byte[])

 void <init>(
int
org.apache.harmony.security.x509.AlgorithmIdentifier
org.apache.harmony.security.x501.Name
java.util.Date
java.util.Date
java.util.List
org.apache.harmony.security.x509.Extensions
byte[]
org.apache.harmony.security.x509.TBSCertList$1)

public void <init>(
org.apache.harmony.security.x509.AlgorithmIdentifier
org.apache.harmony.security.x501.Name
java.util.Date)

static org.apache.harmony.security.x509.Extensions access$1000(
org.apache.harmony.security.x509.TBSCertList)

static int access$400(
org.apache.harmony.security.x509.TBSCertList)

static org.apache.harmony.security.x509.AlgorithmIdentifier access$500(
org.apache.harmony.security.x509.TBSCertList)

static org.apache.harmony.security.x501.Name access$600(
org.apache.harmony.security.x509.TBSCertList)

static java.util.Date access$700(
org.apache.harmony.security.x509.TBSCertList)

static java.util.Date access$800(
org.apache.harmony.security.x509.TBSCertList)

static java.util.List access$900(
org.apache.harmony.security.x509.TBSCertList)

public void dumpValue(
java.lang.StringBuffer)

public boolean equals(
java.lang.Object)

public org.apache.harmony.security.x509.Extensions getCrlExtensions()

public byte[] getEncoded()

public org.apache.harmony.security.x501.Name getIssuer()

public java.util.Date getNextUpdate()

public java.util.List getRevokedCertificates()

public org.apache.harmony.security.x509.AlgorithmIdentifier getSignature()

public java.util.Date getThisUpdate()

public int getVersion()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/TBSCertificate; )
final class org.apache.harmony.security.x509.TBSCertificate$1 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])

protected java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.security.x509.TBSCertificate extends java.lang.Object

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Sequence ASN1

 byte[] encoding

private final org.apache.harmony.security.x509.Extensions extensions

private final org.apache.harmony.security.x501.Name issuer

private final boolean[] issuerUniqueID

private final java.math.BigInteger serialNumber

private final org.apache.harmony.security.x509.AlgorithmIdentifier signature

private final org.apache.harmony.security.x501.Name subject

private final org.apache.harmony.security.x509.SubjectPublicKeyInfo subjectPublicKeyInfo

private final boolean[] subjectUniqueID

private final org.apache.harmony.security.x509.Validity validity

private final int version
----------------METHODS----------------

static void <clinit>()

public void <init>(
int
java.math.BigInteger
org.apache.harmony.security.x509.AlgorithmIdentifier
org.apache.harmony.security.x501.Name
org.apache.harmony.security.x509.Validity
org.apache.harmony.security.x501.Name
org.apache.harmony.security.x509.SubjectPublicKeyInfo)

public void <init>(
int
java.math.BigInteger
org.apache.harmony.security.x509.AlgorithmIdentifier
org.apache.harmony.security.x501.Name
org.apache.harmony.security.x509.Validity
org.apache.harmony.security.x501.Name
org.apache.harmony.security.x509.SubjectPublicKeyInfo
boolean[]
boolean[]
org.apache.harmony.security.x509.Extensions)

private void <init>(
int
java.math.BigInteger
org.apache.harmony.security.x509.AlgorithmIdentifier
org.apache.harmony.security.x501.Name
org.apache.harmony.security.x509.Validity
org.apache.harmony.security.x501.Name
org.apache.harmony.security.x509.SubjectPublicKeyInfo
boolean[]
boolean[]
org.apache.harmony.security.x509.Extensions
byte[])

 void <init>(
int
java.math.BigInteger
org.apache.harmony.security.x509.AlgorithmIdentifier
org.apache.harmony.security.x501.Name
org.apache.harmony.security.x509.Validity
org.apache.harmony.security.x501.Name
org.apache.harmony.security.x509.SubjectPublicKeyInfo
boolean[]
boolean[]
org.apache.harmony.security.x509.Extensions
byte[]
org.apache.harmony.security.x509.TBSCertificate$1)

static int access$100(
org.apache.harmony.security.x509.TBSCertificate)

static org.apache.harmony.security.x509.Extensions access$1000(
org.apache.harmony.security.x509.TBSCertificate)

static java.math.BigInteger access$200(
org.apache.harmony.security.x509.TBSCertificate)

static org.apache.harmony.security.x509.AlgorithmIdentifier access$300(
org.apache.harmony.security.x509.TBSCertificate)

static org.apache.harmony.security.x501.Name access$400(
org.apache.harmony.security.x509.TBSCertificate)

static org.apache.harmony.security.x509.Validity access$500(
org.apache.harmony.security.x509.TBSCertificate)

static org.apache.harmony.security.x501.Name access$600(
org.apache.harmony.security.x509.TBSCertificate)

static org.apache.harmony.security.x509.SubjectPublicKeyInfo access$700(
org.apache.harmony.security.x509.TBSCertificate)

static boolean[] access$800(
org.apache.harmony.security.x509.TBSCertificate)

static boolean[] access$900(
org.apache.harmony.security.x509.TBSCertificate)

public void dumpValue(
java.lang.StringBuffer)

public byte[] getEncoded()

public org.apache.harmony.security.x509.Extensions getExtensions()

public org.apache.harmony.security.x501.Name getIssuer()

public boolean[] getIssuerUniqueID()

public java.math.BigInteger getSerialNumber()

public org.apache.harmony.security.x509.AlgorithmIdentifier getSignature()

public org.apache.harmony.security.x501.Name getSubject()

public org.apache.harmony.security.x509.SubjectPublicKeyInfo getSubjectPublicKeyInfo()

public boolean[] getSubjectUniqueID()

public org.apache.harmony.security.x509.Validity getValidity()

public int getVersion()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/Time; )
final class org.apache.harmony.security.x509.Time$1 extends org.apache.harmony.security.asn1.ASN1Choice

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])

public int getIndex(
java.lang.Object)

public java.lang.Object getObjectToEncode(
java.lang.Object)

________________CLASS________________


public class org.apache.harmony.security.x509.Time extends java.lang.Object

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Choice ASN1

private static final long JAN_01_2050
----------------METHODS----------------

static void <clinit>()

public void <init>()

________________CLASS________________


public class org.apache.harmony.security.x509.Utils extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public static boolean isPrintableString(
java.lang.String)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/Validity; )
final class org.apache.harmony.security.x509.Validity$1 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])

protected java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.security.x509.Validity extends java.lang.Object

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Sequence ASN1

private byte[] encoding

private final java.util.Date notAfter

private final java.util.Date notBefore
----------------METHODS----------------

static void <clinit>()

public void <init>(
java.util.Date
java.util.Date)

static java.util.Date access$000(
org.apache.harmony.security.x509.Validity)

static java.util.Date access$100(
org.apache.harmony.security.x509.Validity)

public byte[] getEncoded()

public java.util.Date getNotAfter()

public java.util.Date getNotBefore()

________________CLASS________________


public class org.apache.harmony.security.x509.X509PublicKey extends java.lang.Object implements java.security.PublicKey

----------------FIELDS----------------

private final java.lang.String algorithm

private final byte[] encoded

private final byte[] keyBytes
----------------METHODS----------------

public void <init>(
java.lang.String
byte[]
byte[])

public java.lang.String getAlgorithm()

public byte[] getEncoded()

public java.lang.String getFormat()

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/tsp/MessageImprint; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class org.apache.harmony.security.x509.tsp.MessageImprint$1 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])

protected java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.security.x509.tsp.MessageImprint extends java.lang.Object

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Sequence ASN1

private final org.apache.harmony.security.x509.AlgorithmIdentifier algId

private final byte[] hashedMessage
----------------METHODS----------------

static void <clinit>()

public void <init>(
org.apache.harmony.security.x509.AlgorithmIdentifier
byte[])

static org.apache.harmony.security.x509.AlgorithmIdentifier access$000(
org.apache.harmony.security.x509.tsp.MessageImprint)

static byte[] access$100(
org.apache.harmony.security.x509.tsp.MessageImprint)

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Enum<Lorg/apache/harmony/security/x509/tsp/PKIFailureInfo;>; )
public final class org.apache.harmony.security.x509.tsp.PKIFailureInfo extends java.lang.Enum

----------------FIELDS----------------

private static final org.apache.harmony.security.x509.tsp.PKIFailureInfo[] $VALUES

public static final org.apache.harmony.security.x509.tsp.PKIFailureInfo ADD_INFO_NOT_AVAILABLE

public static final org.apache.harmony.security.x509.tsp.PKIFailureInfo BAD_ALG

public static final org.apache.harmony.security.x509.tsp.PKIFailureInfo BAD_DATA_FORMAT

public static final org.apache.harmony.security.x509.tsp.PKIFailureInfo BAD_REQUEST

public static final org.apache.harmony.security.x509.tsp.PKIFailureInfo SYSTEM_FAILURE

public static final org.apache.harmony.security.x509.tsp.PKIFailureInfo TIME_NOT_AVAILABLE

public static final org.apache.harmony.security.x509.tsp.PKIFailureInfo UNACCEPTED_EXTENSION

public static final org.apache.harmony.security.x509.tsp.PKIFailureInfo UNACCEPTED_POLICY

private static int maxValue

private final int value
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Signature (value =(I)V )
private void <init>(
java.lang.String
int
int)

public static org.apache.harmony.security.x509.tsp.PKIFailureInfo getInstance(
int)

public static int getMaxValue()

public static org.apache.harmony.security.x509.tsp.PKIFailureInfo valueOf(
java.lang.String)

public static org.apache.harmony.security.x509.tsp.PKIFailureInfo[] values()

public int getValue()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Enum<Lorg/apache/harmony/security/x509/tsp/PKIStatus;>; )
public final class org.apache.harmony.security.x509.tsp.PKIStatus extends java.lang.Enum

----------------FIELDS----------------

private static final org.apache.harmony.security.x509.tsp.PKIStatus[] $VALUES

public static final org.apache.harmony.security.x509.tsp.PKIStatus GRANTED

public static final org.apache.harmony.security.x509.tsp.PKIStatus GRANTED_WITH_MODS

public static final org.apache.harmony.security.x509.tsp.PKIStatus REJECTION

public static final org.apache.harmony.security.x509.tsp.PKIStatus REVOCATION_NOTIFICATION

public static final org.apache.harmony.security.x509.tsp.PKIStatus REVOCATION_WARNING

public static final org.apache.harmony.security.x509.tsp.PKIStatus WAITING

private final int status
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Signature (value =(I)V )
private void <init>(
java.lang.String
int
int)

public static org.apache.harmony.security.x509.tsp.PKIStatus getInstance(
int)

public static org.apache.harmony.security.x509.tsp.PKIStatus valueOf(
java.lang.String)

public static org.apache.harmony.security.x509.tsp.PKIStatus[] values()

public int getStatus()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/tsp/PKIStatusInfo; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class org.apache.harmony.security.x509.tsp.PKIStatusInfo$1 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])

protected java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.security.x509.tsp.PKIStatusInfo extends java.lang.Object

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Sequence ASN1

private final org.apache.harmony.security.x509.tsp.PKIFailureInfo failInfo

private final org.apache.harmony.security.x509.tsp.PKIStatus status

private final java.util.List statusString
----------------METHODS----------------

static void <clinit>()

public void <init>(
org.apache.harmony.security.x509.tsp.PKIStatus
java.util.List
org.apache.harmony.security.x509.tsp.PKIFailureInfo)

static org.apache.harmony.security.x509.tsp.PKIStatus access$000(
org.apache.harmony.security.x509.tsp.PKIStatusInfo)

static java.util.List access$100(
org.apache.harmony.security.x509.tsp.PKIStatusInfo)

static org.apache.harmony.security.x509.tsp.PKIFailureInfo access$200(
org.apache.harmony.security.x509.tsp.PKIStatusInfo)

public org.apache.harmony.security.x509.tsp.PKIFailureInfo getFailInfo()

public org.apache.harmony.security.x509.tsp.PKIStatus getStatus()

public java.util.List getStatusString()

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/tsp/TSTInfo; )
final class org.apache.harmony.security.x509.tsp.TSTInfo$1 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])

protected java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/tsp/TSTInfo; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class org.apache.harmony.security.x509.tsp.TSTInfo$2 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])

protected java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.security.x509.tsp.TSTInfo extends java.lang.Object

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Sequence ACCURACY

public static final org.apache.harmony.security.asn1.ASN1Sequence ASN1

private final int[] accuracy

private final org.apache.harmony.security.x509.Extensions extensions

private final java.util.Date genTime

private final org.apache.harmony.security.x509.tsp.MessageImprint messageImprint

private final java.math.BigInteger nonce

private final java.lang.Boolean ordering

private final java.lang.String policy

private final java.math.BigInteger serialNumber

private final org.apache.harmony.security.x509.GeneralName tsa

private final int version
----------------METHODS----------------

static void <clinit>()

public void <init>(
int
java.lang.String
org.apache.harmony.security.x509.tsp.MessageImprint
java.math.BigInteger
java.util.Date
int[]
java.lang.Boolean
java.math.BigInteger
org.apache.harmony.security.x509.GeneralName
org.apache.harmony.security.x509.Extensions)

static int access$000(
org.apache.harmony.security.x509.tsp.TSTInfo)

static java.lang.String access$100(
org.apache.harmony.security.x509.tsp.TSTInfo)

static org.apache.harmony.security.x509.tsp.MessageImprint access$200(
org.apache.harmony.security.x509.tsp.TSTInfo)

static java.math.BigInteger access$300(
org.apache.harmony.security.x509.tsp.TSTInfo)

static java.util.Date access$400(
org.apache.harmony.security.x509.tsp.TSTInfo)

static int[] access$500(
org.apache.harmony.security.x509.tsp.TSTInfo)

static java.lang.Boolean access$600(
org.apache.harmony.security.x509.tsp.TSTInfo)

static java.math.BigInteger access$700(
org.apache.harmony.security.x509.tsp.TSTInfo)

static org.apache.harmony.security.x509.GeneralName access$800(
org.apache.harmony.security.x509.tsp.TSTInfo)

static org.apache.harmony.security.x509.Extensions access$900(
org.apache.harmony.security.x509.tsp.TSTInfo)

public int[] getAccuracy()

public org.apache.harmony.security.x509.Extensions getExtensions()

public java.util.Date getGenTime()

public org.apache.harmony.security.x509.tsp.MessageImprint getMessageImprint()

public java.math.BigInteger getNonce()

public java.lang.Boolean getOrdering()

public java.lang.String getPolicy()

public java.math.BigInteger getSerialNumber()

public org.apache.harmony.security.x509.GeneralName getTsa()

public int getVersion()

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/tsp/TimeStampReq; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class org.apache.harmony.security.x509.tsp.TimeStampReq$1 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])

protected java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.security.x509.tsp.TimeStampReq extends java.lang.Object

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Sequence ASN1

private final java.lang.Boolean certReq

private byte[] encoding

private final org.apache.harmony.security.x509.Extensions extensions

private final org.apache.harmony.security.x509.tsp.MessageImprint messageImprint

private final java.math.BigInteger nonce

private final java.lang.String reqPolicy

private final int version
----------------METHODS----------------

static void <clinit>()

public void <init>(
int
org.apache.harmony.security.x509.tsp.MessageImprint
java.lang.String
java.math.BigInteger
java.lang.Boolean
org.apache.harmony.security.x509.Extensions)

private void <init>(
int
org.apache.harmony.security.x509.tsp.MessageImprint
java.lang.String
java.math.BigInteger
java.lang.Boolean
org.apache.harmony.security.x509.Extensions
byte[])

 void <init>(
int
org.apache.harmony.security.x509.tsp.MessageImprint
java.lang.String
java.math.BigInteger
java.lang.Boolean
org.apache.harmony.security.x509.Extensions
byte[]
org.apache.harmony.security.x509.tsp.TimeStampReq$1)

static int access$100(
org.apache.harmony.security.x509.tsp.TimeStampReq)

static org.apache.harmony.security.x509.tsp.MessageImprint access$200(
org.apache.harmony.security.x509.tsp.TimeStampReq)

static java.lang.String access$300(
org.apache.harmony.security.x509.tsp.TimeStampReq)

static java.math.BigInteger access$400(
org.apache.harmony.security.x509.tsp.TimeStampReq)

static java.lang.Boolean access$500(
org.apache.harmony.security.x509.tsp.TimeStampReq)

static org.apache.harmony.security.x509.Extensions access$600(
org.apache.harmony.security.x509.tsp.TimeStampReq)

public java.lang.Boolean getCertReq()

public byte[] getEncoded()

public org.apache.harmony.security.x509.Extensions getExtensions()

public org.apache.harmony.security.x509.tsp.MessageImprint getMessageImprint()

public java.math.BigInteger getNonce()

public java.lang.String getReqPolicy()

public int getVersion()

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/security/x509/tsp/TimeStampResp; )
@dalvik.annotation.InnerClass (accessFlags =8 name =null )
final class org.apache.harmony.security.x509.tsp.TimeStampResp$1 extends org.apache.harmony.security.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.security.asn1.ASN1Type[])

protected java.lang.Object getDecodedObject(
org.apache.harmony.security.asn1.BerInputStream)

protected void getValues(
java.lang.Object
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.security.x509.tsp.TimeStampResp extends java.lang.Object

----------------FIELDS----------------

public static final org.apache.harmony.security.asn1.ASN1Sequence ASN1

private final org.apache.harmony.security.x509.tsp.PKIStatusInfo status

private final org.apache.harmony.security.pkcs7.ContentInfo timeStampToken
----------------METHODS----------------

static void <clinit>()

public void <init>(
org.apache.harmony.security.x509.tsp.PKIStatusInfo
org.apache.harmony.security.pkcs7.ContentInfo)

static org.apache.harmony.security.x509.tsp.PKIStatusInfo access$000(
org.apache.harmony.security.x509.tsp.TimeStampResp)

static org.apache.harmony.security.pkcs7.ContentInfo access$100(
org.apache.harmony.security.x509.tsp.TimeStampResp)

public org.apache.harmony.security.x509.tsp.PKIStatusInfo getStatus()

public org.apache.harmony.security.pkcs7.ContentInfo getTimeStampToken()

public java.lang.String toString()

________________CLASS________________


public class org.apache.harmony.sql.internal.nls.Messages extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.String sResource
----------------METHODS----------------

public void <init>()

public static java.lang.String getString(
java.lang.String)

public static java.lang.String getString(
java.lang.String
char)

public static java.lang.String getString(
java.lang.String
int)

public static java.lang.String getString(
java.lang.String
java.lang.Object)

public static java.lang.String getString(
java.lang.String
java.lang.Object
java.lang.Object)

public static java.lang.String getString(
java.lang.String
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.text.BidiRun extends java.lang.Object

----------------FIELDS----------------

private final int level

private final int limit

private final int start
----------------METHODS----------------

public void <init>(
int
int
int)

public boolean equals(
java.lang.Object)

public int getLevel()

public int getLimit()

public int getStart()

________________CLASS________________


public final class org.apache.harmony.text.BidiWrapper extends java.lang.Object

----------------FIELDS----------------

public static final int UBIDI_DEFAULT_LTR

public static final int UBIDI_DEFAULT_RTL

public static final int UBIDI_DO_MIRRORING

public static final int UBIDI_INSERT_LRM_FOR_NUMERIC

public static final int UBIDI_KEEP_BASE_COMBINING

public static final int UBIDI_LEVEL_OVERRIDE

public static final int UBIDI_MAX_EXPLICIT_LEVEL

public static final int UBIDI_OUTPUT_REVERSE

public static final int UBIDI_REMOVE_BIDI_CONTROLS

public static final int UBiDiDirection_UBIDI_LTR

public static final int UBiDiDirection_UBIDI_MIXED

public static final int UBiDiDirection_UBIDI_RTL
----------------METHODS----------------

public void <init>()

public static native void ubidi_close(
long)

public static native int ubidi_countRuns(
long)

public static native int ubidi_getDirection(
long)

public static native int ubidi_getLength(
long)

public static native byte[] ubidi_getLevels(
long)

public static native byte ubidi_getParaLevel(
long)

public static native org.apache.harmony.text.BidiRun[] ubidi_getRuns(
long)

public static native long ubidi_open()

public static native int[] ubidi_reorderVisual(
byte[]
int)

public static native long ubidi_setLine(
long
int
int)

public static native void ubidi_setPara(
long
char[]
int
byte
byte[])

________________CLASS________________


public class org.apache.harmony.text.internal.nls.Messages extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.String sResource
----------------METHODS----------------

public void <init>()

public static java.lang.String getString(
java.lang.String)

public static java.lang.String getString(
java.lang.String
char)

public static java.lang.String getString(
java.lang.String
int)

public static java.lang.String getString(
java.lang.String
java.lang.Object)

public static java.lang.String getString(
java.lang.String
java.lang.Object
java.lang.Object)

public static java.lang.String getString(
java.lang.String
java.lang.Object[])

________________CLASS________________


public abstract interface class org.xml.sax.Attributes extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract int getIndex(
java.lang.String)

public abstract int getIndex(
java.lang.String
java.lang.String)

public abstract int getLength()

public abstract java.lang.String getLocalName(
int)

public abstract java.lang.String getQName(
int)

public abstract java.lang.String getType(
int)

public abstract java.lang.String getType(
java.lang.String)

public abstract java.lang.String getType(
java.lang.String
java.lang.String)

public abstract java.lang.String getURI(
int)

public abstract java.lang.String getValue(
int)

public abstract java.lang.String getValue(
java.lang.String)

public abstract java.lang.String getValue(
java.lang.String
java.lang.String)

________________CLASS________________


abstract class org.apache.harmony.xml.ExpatAttributes extends java.lang.Object implements org.xml.sax.Attributes

----------------FIELDS----------------

private static final java.lang.String CDATA
----------------METHODS----------------

 void <init>()

static native void freeAttributes(
int)

static native int getIndex(
int
java.lang.String)

static native int getIndex(
int
java.lang.String
java.lang.String)

static native java.lang.String getLocalName(
int
int
int)

static native java.lang.String getQName(
int
int
int)

static native java.lang.String getURI(
int
int
int)

static native java.lang.String getValue(
int
int)

static native java.lang.String getValue(
int
java.lang.String)

static native java.lang.String getValue(
int
java.lang.String
java.lang.String)

public int getIndex(
java.lang.String)

public int getIndex(
java.lang.String
java.lang.String)

public abstract int getLength()

public java.lang.String getLocalName(
int)

abstract int getParserPointer()

public abstract int getPointer()

public java.lang.String getQName(
int)

public java.lang.String getType(
int)

public java.lang.String getType(
java.lang.String)

public java.lang.String getType(
java.lang.String
java.lang.String)

public java.lang.String getURI(
int)

public java.lang.String getValue(
int)

public java.lang.String getValue(
java.lang.String)

public java.lang.String getValue(
java.lang.String
java.lang.String)

________________CLASS________________


 class org.apache.harmony.xml.ExpatException extends java.lang.Exception

----------------FIELDS----------------
----------------METHODS----------------

public void <init>(
java.lang.String)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/xml/ExpatParser; )
@dalvik.annotation.InnerClass (accessFlags =4104 name =null )
 class org.apache.harmony.xml.ExpatParser$1 extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =10 name =ClonedAttributes )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/xml/ExpatParser; )
 class org.apache.harmony.xml.ExpatParser$ClonedAttributes extends org.apache.harmony.xml.ExpatAttributes

----------------FIELDS----------------

private static final org.xml.sax.Attributes EMPTY

private final int length

private final int parserPointer

private int pointer
----------------METHODS----------------

static void <clinit>()

private void <init>(
int
int
int)

 void <init>(
int
int
int
org.apache.harmony.xml.ExpatParser$1)

static org.xml.sax.Attributes access$400()
@dalvik.annotation.Throws (value =Ljava/lang/Throwable; )
protected void finalize()

public int getLength()

public int getParserPointer()

public int getPointer()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/xml/ExpatParser; )
@dalvik.annotation.InnerClass (accessFlags =2 name =CurrentAttributes )
 class org.apache.harmony.xml.ExpatParser$CurrentAttributes extends org.apache.harmony.xml.ExpatAttributes

----------------FIELDS----------------

final org.apache.harmony.xml.ExpatParser this$0
----------------METHODS----------------

private void <init>(
org.apache.harmony.xml.ExpatParser)

 void <init>(
org.apache.harmony.xml.ExpatParser
org.apache.harmony.xml.ExpatParser$1)

public int getLength()

public int getParserPointer()

public int getPointer()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/apache/harmony/xml/ExpatParser$1;Lorg/apache/harmony/xml/ExpatParser$EntityParser;Lorg/apache/harmony/xml/ExpatParser$ParseException;Lorg/apache/harmony/xml/ExpatParser$CurrentAttributes;Lorg/apache/harmony/xml/ExpatParser$ExpatLocator;Lorg/apache/harmony/xml/ExpatParser$ClonedAttributes; )
 class org.apache.harmony.xml.ExpatParser extends java.lang.Object

----------------FIELDS----------------

private static final int BUFFER_SIZE

static final java.lang.String CHARACTER_ENCODING

private static final java.lang.String DEFAULT_ENCODING

private static final java.lang.String OUTSIDE_START_ELEMENT

private static final int TIMEOUT

private int attributeCount

private int attributePointer

private final org.apache.harmony.xml.ExpatAttributes attributes

private final java.lang.String encoding

private boolean inStartElement

private final org.xml.sax.Locator locator

private int pointer

private final java.lang.String publicId

private final java.lang.String systemId

private final org.apache.harmony.xml.ExpatReader xmlReader
----------------METHODS----------------

static void <clinit>()

private void <init>(
java.lang.String
org.apache.harmony.xml.ExpatReader
int
java.lang.String
java.lang.String)

 void <init>(
java.lang.String
org.apache.harmony.xml.ExpatReader
int
java.lang.String
java.lang.String
org.apache.harmony.xml.ExpatParser$1)

 void <init>(
java.lang.String
org.apache.harmony.xml.ExpatReader
boolean
java.lang.String
java.lang.String)

static int access$1000(
org.apache.harmony.xml.ExpatParser)

static boolean access$1100(
org.apache.harmony.xml.ExpatParser)

static int access$1200(
org.apache.harmony.xml.ExpatParser)

static int access$1300(
org.apache.harmony.xml.ExpatParser)

static java.lang.String access$600(
org.apache.harmony.xml.ExpatParser)

static java.lang.String access$700(
org.apache.harmony.xml.ExpatParser)

static int access$800(
org.apache.harmony.xml.ExpatParser)

static int access$900(
org.apache.harmony.xml.ExpatParser)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException;Lorg/apache/harmony/xml/ExpatException; )
private native void append(
int
java.lang.String
boolean)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException;Lorg/apache/harmony/xml/ExpatException; )
private native void append(
int
byte[]
int
int)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException;Lorg/apache/harmony/xml/ExpatException; )
private native void append(
int
char[]
int
int)

private static native int cloneAttributes(
int
int)

private int column()

private static native int column(
int)

private static native int createEntityParser(
int
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
private void endDocument()

private native int initialize(
java.lang.String
boolean)

private int line()

private static native int line(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
static java.io.InputStream openUrl(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Lorg/xml/sax/SAXException; )
private void parseExternalEntity(
org.apache.harmony.xml.ExpatParser
org.xml.sax.InputSource)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Lorg/xml/sax/SAXException; )
private void parseFragment(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Lorg/xml/sax/SAXException; )
private void parseFragment(
java.io.Reader)

private java.lang.String pickEncoding(
org.xml.sax.InputSource)

private native void release(
int)

private static native void releaseParser(
int)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
private void startDocument()

private static native void staticInitialize(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
 void append(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
 void append(
byte[])
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
 void append(
byte[]
int
int)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
 void append(
char[]
int
int)

 org.xml.sax.Attributes cloneAttributes()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
 void comment(
char[]
int)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
 void endCdata()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
 void endDtd()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
 void endElement(
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
 void endNamespace(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/lang/Throwable; )
protected void finalize()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
 void finish()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException;Ljava/io/IOException; )
 void handleExternalEntity(
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Lorg/xml/sax/SAXException; )
 void parseDocument(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Lorg/xml/sax/SAXException; )
 void parseDocument(
java.io.Reader)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
 void processingInstruction(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
 void startCdata()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
 void startDtd(
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
 void startElement(
java.lang.String
java.lang.String
java.lang.String
int
int)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
 void startNamespace(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
 void text(
char[]
int)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =10 name =EntityParser )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/xml/ExpatParser; )
 class org.apache.harmony.xml.ExpatParser$EntityParser extends org.apache.harmony.xml.ExpatParser

----------------FIELDS----------------

private int depth
----------------METHODS----------------

private void <init>(
java.lang.String
org.apache.harmony.xml.ExpatReader
int
java.lang.String
java.lang.String)

 void <init>(
java.lang.String
org.apache.harmony.xml.ExpatReader
int
java.lang.String
java.lang.String
org.apache.harmony.xml.ExpatParser$1)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
 void endElement(
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/lang/Throwable; )
protected void finalize()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
 void startElement(
java.lang.String
java.lang.String
java.lang.String
int
int)

________________CLASS________________


public abstract interface class org.xml.sax.Locator extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract int getColumnNumber()

public abstract int getLineNumber()

public abstract java.lang.String getPublicId()

public abstract java.lang.String getSystemId()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =2 name =ExpatLocator )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/xml/ExpatParser; )
 class org.apache.harmony.xml.ExpatParser$ExpatLocator extends java.lang.Object implements org.xml.sax.Locator

----------------FIELDS----------------

final org.apache.harmony.xml.ExpatParser this$0
----------------METHODS----------------

private void <init>(
org.apache.harmony.xml.ExpatParser)

 void <init>(
org.apache.harmony.xml.ExpatParser
org.apache.harmony.xml.ExpatParser$1)

public int getColumnNumber()

public int getLineNumber()

public java.lang.String getPublicId()

public java.lang.String getSystemId()

public java.lang.String toString()

________________CLASS________________


public class org.xml.sax.SAXException extends java.lang.Exception

----------------FIELDS----------------

private java.lang.Exception exception
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.Exception)

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
java.lang.Exception)

public java.lang.Exception getException()

public java.lang.String getMessage()

public java.lang.String toString()

________________CLASS________________


public class org.xml.sax.SAXParseException extends org.xml.sax.SAXException

----------------FIELDS----------------

private int columnNumber

private int lineNumber

private java.lang.String publicId

private java.lang.String systemId
----------------METHODS----------------

public void <init>(
java.lang.String
java.lang.String
java.lang.String
int
int)

public void <init>(
java.lang.String
java.lang.String
java.lang.String
int
int
java.lang.Exception)

public void <init>(
java.lang.String
org.xml.sax.Locator)

public void <init>(
java.lang.String
org.xml.sax.Locator
java.lang.Exception)

private void init(
java.lang.String
java.lang.String
int
int)

public int getColumnNumber()

public int getLineNumber()

public java.lang.String getPublicId()

public java.lang.String getSystemId()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =10 name =ParseException )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/xml/ExpatParser; )
 class org.apache.harmony.xml.ExpatParser$ParseException extends org.xml.sax.SAXParseException

----------------FIELDS----------------
----------------METHODS----------------

private void <init>(
java.lang.String
org.xml.sax.Locator)

 void <init>(
java.lang.String
org.xml.sax.Locator
org.apache.harmony.xml.ExpatParser$1)

private static java.lang.String makeMessage(
java.lang.String
int
int)

private static java.lang.String makeMessage(
java.lang.String
org.xml.sax.Locator)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =4104 name =null )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/xml/ExpatPullParser; )
 class org.apache.harmony.xml.ExpatPullParser$1 extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/xml/ExpatPullParser; )
@dalvik.annotation.InnerClass (accessFlags =1024 name =Document )
@dalvik.annotation.MemberClasses (value =Lorg/apache/harmony/xml/ExpatPullParser$Document$SaxHandler; )
abstract class org.apache.harmony.xml.ExpatPullParser$Document extends java.lang.Object

----------------FIELDS----------------

 org.apache.harmony.xml.ExpatPullParser$Event currentEvent

final java.lang.String encoding

 boolean finished

 org.apache.harmony.xml.ExpatPullParser$Event last

 org.apache.harmony.xml.ExpatPullParser$NamespaceStack$Builder namespaceStackBuilder

final org.apache.harmony.xml.ExpatParser parser

final boolean processNamespaces

 org.apache.harmony.xml.ExpatPullParser$TextEvent textEvent

final org.apache.harmony.xml.ExpatPullParser this$0
----------------METHODS----------------

 void <init>(
org.apache.harmony.xml.ExpatPullParser
java.lang.String
boolean)

 void add(
org.apache.harmony.xml.ExpatPullParser$Event)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
abstract int buffer()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException;Ljava/io/IOException; )
 int dequeue()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
abstract void flush(
org.apache.harmony.xml.ExpatParser
int)

 int getDepth()

 java.lang.String getEncoding()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
 boolean isCurrentElementEmpty()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Lorg/xmlpull/v1/XmlPullParserException; )
 void pump()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/xml/ExpatPullParser; )
@dalvik.annotation.InnerClass (accessFlags =0 name =ByteDocument )
 class org.apache.harmony.xml.ExpatPullParser$ByteDocument extends org.apache.harmony.xml.ExpatPullParser$Document

----------------FIELDS----------------

final byte[] buffer

final java.io.InputStream in

final org.apache.harmony.xml.ExpatPullParser this$0
----------------METHODS----------------

 void <init>(
org.apache.harmony.xml.ExpatPullParser
java.io.InputStream
java.lang.String
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 int buffer()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
 void flush(
org.apache.harmony.xml.ExpatParser
int)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =CharDocument )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/xml/ExpatPullParser; )
 class org.apache.harmony.xml.ExpatPullParser$CharDocument extends org.apache.harmony.xml.ExpatPullParser$Document

----------------FIELDS----------------

final char[] buffer

final java.io.Reader in

final org.apache.harmony.xml.ExpatPullParser this$0
----------------METHODS----------------

 void <init>(
org.apache.harmony.xml.ExpatPullParser
java.io.Reader
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 int buffer()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
 void flush(
org.apache.harmony.xml.ExpatParser
int)

________________CLASS________________


public abstract interface class org.xml.sax.ContentHandler extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public abstract void characters(
char[]
int
int)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public abstract void endDocument()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public abstract void endElement(
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public abstract void endPrefixMapping(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public abstract void ignorableWhitespace(
char[]
int
int)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public abstract void processingInstruction(
java.lang.String
java.lang.String)

public abstract void setDocumentLocator(
org.xml.sax.Locator)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public abstract void skippedEntity(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public abstract void startDocument()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public abstract void startElement(
java.lang.String
java.lang.String
java.lang.String
org.xml.sax.Attributes)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public abstract void startPrefixMapping(
java.lang.String
java.lang.String)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/xml/ExpatPullParser$Document; )
@dalvik.annotation.InnerClass (accessFlags =2 name =SaxHandler )
 class org.apache.harmony.xml.ExpatPullParser$Document$SaxHandler extends java.lang.Object implements org.xml.sax.ContentHandler

----------------FIELDS----------------

 int depth

final org.apache.harmony.xml.ExpatPullParser$Document this$1
----------------METHODS----------------

private void <init>(
org.apache.harmony.xml.ExpatPullParser$Document)

 void <init>(
org.apache.harmony.xml.ExpatPullParser$Document
org.apache.harmony.xml.ExpatPullParser$1)

public void characters(
char[]
int
int)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void endDocument()

public void endElement(
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void endPrefixMapping(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void ignorableWhitespace(
char[]
int
int)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void processingInstruction(
java.lang.String
java.lang.String)

public void setDocumentLocator(
org.xml.sax.Locator)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void skippedEntity(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void startDocument()

public void startElement(
java.lang.String
java.lang.String
java.lang.String
org.xml.sax.Attributes)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void startPrefixMapping(
java.lang.String
java.lang.String)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =1032 name =Event )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/xml/ExpatPullParser; )
abstract class org.apache.harmony.xml.ExpatPullParser$Event extends java.lang.Object

----------------FIELDS----------------

final int depth

final org.apache.harmony.xml.ExpatPullParser$NamespaceStack namespaceStack

 org.apache.harmony.xml.ExpatPullParser$Event next
----------------METHODS----------------

 void <init>(
int
org.apache.harmony.xml.ExpatPullParser$NamespaceStack)

 int getAttributeCount()

 java.lang.String getAttributeName(
int)

 java.lang.String getAttributeNamespace(
int)

 java.lang.String getAttributeValue(
int)

 java.lang.String getAttributeValue(
java.lang.String
java.lang.String)

public int getDepth()

 java.lang.String getName()

 java.lang.String getNamespace()

 org.apache.harmony.xml.ExpatPullParser$Event getNext()

 java.lang.StringBuilder getText()

abstract int getType()

 void setNext(
org.apache.harmony.xml.ExpatPullParser$Event)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =EndDocumentEvent )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/xml/ExpatPullParser; )
 class org.apache.harmony.xml.ExpatPullParser$EndDocumentEvent extends org.apache.harmony.xml.ExpatPullParser$Event

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

 org.apache.harmony.xml.ExpatPullParser$Event getNext()

 int getType()

 void setNext(
org.apache.harmony.xml.ExpatPullParser$Event)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =EndTagEvent )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/xml/ExpatPullParser; )
 class org.apache.harmony.xml.ExpatPullParser$EndTagEvent extends org.apache.harmony.xml.ExpatPullParser$Event

----------------FIELDS----------------

final java.lang.String localName

final java.lang.String namespace
----------------METHODS----------------

 void <init>(
java.lang.String
java.lang.String
int
org.apache.harmony.xml.ExpatPullParser$NamespaceStack)

 java.lang.String getName()

 java.lang.String getNamespace()

 int getType()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/xml/ExpatPullParser$NamespaceStack; )
@dalvik.annotation.InnerClass (accessFlags =8 name =Builder )
 class org.apache.harmony.xml.ExpatPullParser$NamespaceStack$Builder extends java.lang.Object

----------------FIELDS----------------

 org.apache.harmony.xml.ExpatPullParser$NamespaceStack top
----------------METHODS----------------

 void <init>()

 org.apache.harmony.xml.ExpatPullParser$NamespaceStack build()

 void pop(
int)

 void push(
java.lang.String
java.lang.String
int)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/xml/ExpatPullParser; )
@dalvik.annotation.InnerClass (accessFlags =8 name =NamespaceStack )
@dalvik.annotation.MemberClasses (value =Lorg/apache/harmony/xml/ExpatPullParser$NamespaceStack$Builder; )
 class org.apache.harmony.xml.ExpatPullParser$NamespaceStack extends java.lang.Object

----------------FIELDS----------------

static final org.apache.harmony.xml.ExpatPullParser$NamespaceStack EMPTY

private final int depth

private final int index

private final org.apache.harmony.xml.ExpatPullParser$NamespaceStack parent

private final java.lang.String prefix

private final java.lang.String uri
----------------METHODS----------------

static void <clinit>()

private void <init>()

private void <init>(
org.apache.harmony.xml.ExpatPullParser$NamespaceStack
java.lang.String
java.lang.String
int)

 void <init>(
org.apache.harmony.xml.ExpatPullParser$NamespaceStack
java.lang.String
java.lang.String
int
org.apache.harmony.xml.ExpatPullParser$1)

static int access$100(
org.apache.harmony.xml.ExpatPullParser$NamespaceStack)

static org.apache.harmony.xml.ExpatPullParser$NamespaceStack access$200(
org.apache.harmony.xml.ExpatPullParser$NamespaceStack)

private org.apache.harmony.xml.ExpatPullParser$NamespaceStack nodeAt(
int)

 int countAt(
int)

 java.lang.String prefixAt(
int)

 java.lang.String uriAt(
int)

 java.lang.String uriFor(
java.lang.String)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =StartDocumentEvent )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/xml/ExpatPullParser; )
 class org.apache.harmony.xml.ExpatPullParser$StartDocumentEvent extends org.apache.harmony.xml.ExpatPullParser$Event

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

 int getType()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/xml/ExpatPullParser; )
@dalvik.annotation.InnerClass (accessFlags =8 name =StartTagEvent )
 class org.apache.harmony.xml.ExpatPullParser$StartTagEvent extends org.apache.harmony.xml.ExpatPullParser$Event

----------------FIELDS----------------

final org.xml.sax.Attributes attributes

final java.lang.String name

final java.lang.String namespace

final boolean processNamespaces
----------------METHODS----------------

 void <init>(
java.lang.String
java.lang.String
org.apache.harmony.xml.ExpatParser
int
org.apache.harmony.xml.ExpatPullParser$NamespaceStack
boolean)

 int getAttributeCount()

 java.lang.String getAttributeName(
int)

 java.lang.String getAttributeNamespace(
int)

 java.lang.String getAttributeValue(
int)

 java.lang.String getAttributeValue(
java.lang.String
java.lang.String)

 java.lang.String getName()

 java.lang.String getNamespace()

 int getType()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =TextEvent )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/xml/ExpatPullParser; )
 class org.apache.harmony.xml.ExpatPullParser$TextEvent extends org.apache.harmony.xml.ExpatPullParser$Event

----------------FIELDS----------------

final java.lang.StringBuilder builder
----------------METHODS----------------

public void <init>(
int
int
org.apache.harmony.xml.ExpatPullParser$NamespaceStack)

 void append(
char[]
int
int)

 java.lang.StringBuilder getText()

 int getType()

________________CLASS________________


public abstract interface class org.xmlpull.v1.XmlPullParser extends java.lang.Object

----------------FIELDS----------------

public static final int CDSECT

public static final int COMMENT

public static final int DOCDECL

public static final int END_DOCUMENT

public static final int END_TAG

public static final int ENTITY_REF

public static final java.lang.String FEATURE_PROCESS_DOCDECL

public static final java.lang.String FEATURE_PROCESS_NAMESPACES

public static final java.lang.String FEATURE_REPORT_NAMESPACE_ATTRIBUTES

public static final java.lang.String FEATURE_VALIDATION

public static final int IGNORABLE_WHITESPACE

public static final java.lang.String NO_NAMESPACE

public static final int PROCESSING_INSTRUCTION

public static final int START_DOCUMENT

public static final int START_TAG

public static final int TEXT

public static final java.lang.String[] TYPES
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public abstract void defineEntityReplacementText(
java.lang.String
java.lang.String)

public abstract int getAttributeCount()

public abstract java.lang.String getAttributeName(
int)

public abstract java.lang.String getAttributeNamespace(
int)

public abstract java.lang.String getAttributePrefix(
int)

public abstract java.lang.String getAttributeType(
int)

public abstract java.lang.String getAttributeValue(
int)

public abstract java.lang.String getAttributeValue(
java.lang.String
java.lang.String)

public abstract int getColumnNumber()

public abstract int getDepth()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public abstract int getEventType()

public abstract boolean getFeature(
java.lang.String)

public abstract java.lang.String getInputEncoding()

public abstract int getLineNumber()

public abstract java.lang.String getName()

public abstract java.lang.String getNamespace()

public abstract java.lang.String getNamespace(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public abstract int getNamespaceCount(
int)
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public abstract java.lang.String getNamespacePrefix(
int)
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public abstract java.lang.String getNamespaceUri(
int)

public abstract java.lang.String getPositionDescription()

public abstract java.lang.String getPrefix()

public abstract java.lang.Object getProperty(
java.lang.String)

public abstract java.lang.String getText()

public abstract char[] getTextCharacters(
int[])

public abstract boolean isAttributeDefault(
int)
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public abstract boolean isEmptyElementTag()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public abstract boolean isWhitespace()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException;Ljava/io/IOException; )
public abstract int next()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException;Ljava/io/IOException; )
public abstract int nextTag()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException;Ljava/io/IOException; )
public abstract java.lang.String nextText()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException;Ljava/io/IOException; )
public abstract int nextToken()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException;Ljava/io/IOException; )
public abstract void require(
int
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public abstract void setFeature(
java.lang.String
boolean)
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public abstract void setInput(
java.io.InputStream
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public abstract void setInput(
java.io.Reader)
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public abstract void setProperty(
java.lang.String
java.lang.Object)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/apache/harmony/xml/ExpatPullParser$1;Lorg/apache/harmony/xml/ExpatPullParser$ByteDocument;Lorg/apache/harmony/xml/ExpatPullParser$CharDocument;Lorg/apache/harmony/xml/ExpatPullParser$Document;Lorg/apache/harmony/xml/ExpatPullParser$EndDocumentEvent;Lorg/apache/harmony/xml/ExpatPullParser$TextEvent;Lorg/apache/harmony/xml/ExpatPullParser$EndTagEvent;Lorg/apache/harmony/xml/ExpatPullParser$StartTagEvent;Lorg/apache/harmony/xml/ExpatPullParser$StartDocumentEvent;Lorg/apache/harmony/xml/ExpatPullParser$Event;Lorg/apache/harmony/xml/ExpatPullParser$NamespaceStack; )
public class org.apache.harmony.xml.ExpatPullParser extends java.lang.Object implements org.xmlpull.v1.XmlPullParser

----------------FIELDS----------------

private static final int BUFFER_SIZE

public static final java.lang.String FEATURE_RELAXED

private static final java.lang.String NOT_A_START_TAG

private org.apache.harmony.xml.ExpatPullParser$Document document

private boolean processNamespaces

private boolean relaxed
----------------METHODS----------------

public void <init>()

static boolean access$400(
org.apache.harmony.xml.ExpatPullParser)
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public void defineEntityReplacementText(
java.lang.String
java.lang.String)

public int getAttributeCount()

public java.lang.String getAttributeName(
int)

public java.lang.String getAttributeNamespace(
int)

public java.lang.String getAttributePrefix(
int)

public java.lang.String getAttributeType(
int)

public java.lang.String getAttributeValue(
int)

public java.lang.String getAttributeValue(
java.lang.String
java.lang.String)

public int getColumnNumber()

public int getDepth()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public int getEventType()

public boolean getFeature(
java.lang.String)

public java.lang.String getInputEncoding()

public int getLineNumber()

public java.lang.String getName()

public java.lang.String getNamespace()

public java.lang.String getNamespace(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public int getNamespaceCount(
int)
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public java.lang.String getNamespacePrefix(
int)
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public java.lang.String getNamespaceUri(
int)

public java.lang.String getPositionDescription()

public java.lang.String getPrefix()

public java.lang.Object getProperty(
java.lang.String)

public java.lang.String getText()

public char[] getTextCharacters(
int[])

public boolean isAttributeDefault(
int)
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public boolean isEmptyElementTag()

public boolean isNamespaceProcessingEnabled()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public boolean isWhitespace()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException;Ljava/io/IOException; )
public int next()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException;Ljava/io/IOException; )
public int nextTag()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException;Ljava/io/IOException; )
public java.lang.String nextText()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException;Ljava/io/IOException; )
public int nextToken()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException;Ljava/io/IOException; )
public void require(
int
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public void setFeature(
java.lang.String
boolean)
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public void setInput(
java.io.InputStream
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public void setInput(
java.io.Reader)

public void setNamespaceProcessingEnabled(
boolean)
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public void setProperty(
java.lang.String
java.lang.Object)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/xml/ExpatReader; )
@dalvik.annotation.InnerClass (accessFlags =10 name =Feature )
 class org.apache.harmony.xml.ExpatReader$Feature extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.String BASE_URI

private static final java.lang.String NAMESPACES

private static final java.lang.String NAMESPACE_PREFIXES

private static final java.lang.String STRING_INTERNING

private static final java.lang.String VALIDATION
----------------METHODS----------------

private void <init>()

________________CLASS________________


public abstract interface class org.xml.sax.XMLReader extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract org.xml.sax.ContentHandler getContentHandler()

public abstract org.xml.sax.DTDHandler getDTDHandler()

public abstract org.xml.sax.EntityResolver getEntityResolver()

public abstract org.xml.sax.ErrorHandler getErrorHandler()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXNotRecognizedException;Lorg/xml/sax/SAXNotSupportedException; )
public abstract boolean getFeature(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXNotRecognizedException;Lorg/xml/sax/SAXNotSupportedException; )
public abstract java.lang.Object getProperty(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Lorg/xml/sax/SAXException; )
public abstract void parse(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Lorg/xml/sax/SAXException; )
public abstract void parse(
org.xml.sax.InputSource)

public abstract void setContentHandler(
org.xml.sax.ContentHandler)

public abstract void setDTDHandler(
org.xml.sax.DTDHandler)

public abstract void setEntityResolver(
org.xml.sax.EntityResolver)

public abstract void setErrorHandler(
org.xml.sax.ErrorHandler)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXNotRecognizedException;Lorg/xml/sax/SAXNotSupportedException; )
public abstract void setFeature(
java.lang.String
boolean)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXNotRecognizedException;Lorg/xml/sax/SAXNotSupportedException; )
public abstract void setProperty(
java.lang.String
java.lang.Object)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/apache/harmony/xml/ExpatReader$Feature; )
public class org.apache.harmony.xml.ExpatReader extends java.lang.Object implements org.xml.sax.XMLReader

----------------FIELDS----------------

private static final java.lang.String LEXICAL_HANDLER_PROPERTY

private static final java.util.logging.Logger logger

 org.xml.sax.ContentHandler contentHandler

 org.xml.sax.EntityResolver entityResolver

 org.xml.sax.ErrorHandler errorHandler

 org.xml.sax.ext.LexicalHandler lexicalHandler

private boolean processNamespacePrefixes

private boolean processNamespaces
----------------METHODS----------------

static void <clinit>()

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Lorg/xml/sax/SAXException; )
private void parse(
java.io.InputStream
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Lorg/xml/sax/SAXException; )
private void parse(
java.io.Reader
java.lang.String
java.lang.String)

public org.xml.sax.ContentHandler getContentHandler()

public org.xml.sax.DTDHandler getDTDHandler()

public org.xml.sax.EntityResolver getEntityResolver()

public org.xml.sax.ErrorHandler getErrorHandler()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXNotRecognizedException;Lorg/xml/sax/SAXNotSupportedException; )
public boolean getFeature(
java.lang.String)

public org.xml.sax.ext.LexicalHandler getLexicalHandler()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXNotRecognizedException;Lorg/xml/sax/SAXNotSupportedException; )
public java.lang.Object getProperty(
java.lang.String)

public boolean isNamespaceProcessingEnabled()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Lorg/xml/sax/SAXException; )
public void parse(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Lorg/xml/sax/SAXException; )
public void parse(
org.xml.sax.InputSource)

public void setContentHandler(
org.xml.sax.ContentHandler)

public void setDTDHandler(
org.xml.sax.DTDHandler)

public void setEntityResolver(
org.xml.sax.EntityResolver)

public void setErrorHandler(
org.xml.sax.ErrorHandler)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXNotRecognizedException;Lorg/xml/sax/SAXNotSupportedException; )
public void setFeature(
java.lang.String
boolean)

public void setLexicalHandler(
org.xml.sax.ext.LexicalHandler)

public void setNamespaceProcessingEnabled(
boolean)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXNotRecognizedException;Lorg/xml/sax/SAXNotSupportedException; )
public void setProperty(
java.lang.String
java.lang.Object)

________________CLASS________________


public abstract interface class org.w3c.dom.Node extends java.lang.Object

----------------FIELDS----------------

public static final short ATTRIBUTE_NODE

public static final short CDATA_SECTION_NODE

public static final short COMMENT_NODE

public static final short DOCUMENT_FRAGMENT_NODE

public static final short DOCUMENT_NODE

public static final short DOCUMENT_TYPE_NODE

public static final short ELEMENT_NODE

public static final short ENTITY_NODE

public static final short ENTITY_REFERENCE_NODE

public static final short NOTATION_NODE

public static final short PROCESSING_INSTRUCTION_NODE

public static final short TEXT_NODE
----------------METHODS----------------
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public abstract org.w3c.dom.Node appendChild(
org.w3c.dom.Node)

public abstract org.w3c.dom.Node cloneNode(
boolean)

public abstract org.w3c.dom.NamedNodeMap getAttributes()

public abstract org.w3c.dom.NodeList getChildNodes()

public abstract org.w3c.dom.Node getFirstChild()

public abstract org.w3c.dom.Node getLastChild()

public abstract java.lang.String getLocalName()

public abstract java.lang.String getNamespaceURI()

public abstract org.w3c.dom.Node getNextSibling()

public abstract java.lang.String getNodeName()

public abstract short getNodeType()
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public abstract java.lang.String getNodeValue()

public abstract org.w3c.dom.Document getOwnerDocument()

public abstract org.w3c.dom.Node getParentNode()

public abstract java.lang.String getPrefix()

public abstract org.w3c.dom.Node getPreviousSibling()

public abstract boolean hasAttributes()

public abstract boolean hasChildNodes()
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public abstract org.w3c.dom.Node insertBefore(
org.w3c.dom.Node
org.w3c.dom.Node)

public abstract boolean isSupported(
java.lang.String
java.lang.String)

public abstract void normalize()
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public abstract org.w3c.dom.Node removeChild(
org.w3c.dom.Node)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public abstract org.w3c.dom.Node replaceChild(
org.w3c.dom.Node
org.w3c.dom.Node)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public abstract void setNodeValue(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public abstract void setPrefix(
java.lang.String)

________________CLASS________________


public abstract class org.apache.harmony.xml.dom.NodeImpl extends java.lang.Object implements org.w3c.dom.Node

----------------FIELDS----------------

private static final org.w3c.dom.NodeList EMPTY_LIST

 org.apache.harmony.xml.dom.DocumentImpl document
----------------METHODS----------------

static void <clinit>()

 void <init>(
org.apache.harmony.xml.dom.DocumentImpl)

private static boolean matchesName(
java.lang.String
java.lang.String
boolean)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public org.w3c.dom.Node appendChild(
org.w3c.dom.Node)

public org.w3c.dom.Node cloneNode(
boolean)

public org.w3c.dom.NamedNodeMap getAttributes()

public org.w3c.dom.NodeList getChildNodes()

public org.w3c.dom.Node getFirstChild()

public org.w3c.dom.Node getLastChild()

public java.lang.String getLocalName()

public java.lang.String getNamespaceURI()

public org.w3c.dom.Node getNextSibling()

public java.lang.String getNodeName()

public abstract short getNodeType()
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public java.lang.String getNodeValue()

public org.w3c.dom.Document getOwnerDocument()

public org.w3c.dom.Node getParentNode()

public java.lang.String getPrefix()

public org.w3c.dom.Node getPreviousSibling()

public boolean hasAttributes()

public boolean hasChildNodes()
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public org.w3c.dom.Node insertBefore(
org.w3c.dom.Node
org.w3c.dom.Node)

public boolean isSupported(
java.lang.String
java.lang.String)

public boolean matchesName(
java.lang.String
boolean)

public boolean matchesNameNS(
java.lang.String
java.lang.String
boolean)

public void normalize()
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public org.w3c.dom.Node removeChild(
org.w3c.dom.Node)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public org.w3c.dom.Node replaceChild(
org.w3c.dom.Node
org.w3c.dom.Node)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public void setNodeValue(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public void setPrefix(
java.lang.String)

________________CLASS________________


public abstract interface class org.w3c.dom.Attr extends java.lang.Object implements org.w3c.dom.Node

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.lang.String getName()

public abstract org.w3c.dom.Element getOwnerElement()

public abstract boolean getSpecified()

public abstract java.lang.String getValue()
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public abstract void setValue(
java.lang.String)

________________CLASS________________


public class org.apache.harmony.xml.dom.AttrImpl extends org.apache.harmony.xml.dom.NodeImpl implements org.w3c.dom.Attr

----------------FIELDS----------------

private java.lang.String localName

private boolean namespaceAware

private java.lang.String namespaceURI

 org.apache.harmony.xml.dom.ElementImpl ownerElement

private java.lang.String prefix

private java.lang.String value
----------------METHODS----------------

 void <init>(
org.apache.harmony.xml.dom.DocumentImpl
java.lang.String)

 void <init>(
org.apache.harmony.xml.dom.DocumentImpl
java.lang.String
java.lang.String)

public java.lang.String getLocalName()

public java.lang.String getName()

public java.lang.String getNamespaceURI()

public java.lang.String getNodeName()

public short getNodeType()

public java.lang.String getNodeValue()

public org.w3c.dom.Element getOwnerElement()

public java.lang.String getPrefix()

public boolean getSpecified()

public java.lang.String getValue()
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public void setNodeValue(
java.lang.String)

public void setPrefix(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public void setValue(
java.lang.String)

________________CLASS________________


public abstract class org.apache.harmony.xml.dom.LeafNodeImpl extends org.apache.harmony.xml.dom.NodeImpl

----------------FIELDS----------------

 int index

 org.apache.harmony.xml.dom.InnerNodeImpl parent
----------------METHODS----------------

 void <init>(
org.apache.harmony.xml.dom.DocumentImpl)

public org.w3c.dom.Node getNextSibling()

public org.w3c.dom.Node getParentNode()

public org.w3c.dom.Node getPreviousSibling()

 boolean isParentOf(
org.w3c.dom.Node)

________________CLASS________________


public abstract interface class org.w3c.dom.CharacterData extends java.lang.Object implements org.w3c.dom.Node

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public abstract void appendData(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public abstract void deleteData(
int
int)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public abstract java.lang.String getData()

public abstract int getLength()
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public abstract void insertData(
int
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public abstract void replaceData(
int
int
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public abstract void setData(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public abstract java.lang.String substringData(
int
int)

________________CLASS________________


public abstract class org.apache.harmony.xml.dom.CharacterDataImpl extends org.apache.harmony.xml.dom.LeafNodeImpl implements org.w3c.dom.CharacterData

----------------FIELDS----------------

private java.lang.StringBuffer buffer
----------------METHODS----------------

 void <init>(
org.apache.harmony.xml.dom.DocumentImpl
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public void appendData(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public void deleteData(
int
int)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public java.lang.String getData()

public int getLength()

public java.lang.String getNodeValue()
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public void insertData(
int
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public void replaceData(
int
int
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public void setData(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public java.lang.String substringData(
int
int)

________________CLASS________________


public abstract interface class org.w3c.dom.Text extends java.lang.Object implements org.w3c.dom.CharacterData

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public abstract org.w3c.dom.Text splitText(
int)

________________CLASS________________


public class org.apache.harmony.xml.dom.TextImpl extends org.apache.harmony.xml.dom.CharacterDataImpl implements org.w3c.dom.Text

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.xml.dom.DocumentImpl
java.lang.String)

public java.lang.String getNodeName()

public short getNodeType()

public java.lang.String getNodeValue()
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public org.w3c.dom.Text splitText(
int)

________________CLASS________________


public abstract interface class org.w3c.dom.CDATASection extends java.lang.Object implements org.w3c.dom.Text

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________


public class org.apache.harmony.xml.dom.CDATASectionImpl extends org.apache.harmony.xml.dom.TextImpl implements org.w3c.dom.CDATASection

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.xml.dom.DocumentImpl
java.lang.String)

public java.lang.String getNodeName()

public short getNodeType()

________________CLASS________________


public abstract interface class org.w3c.dom.Comment extends java.lang.Object implements org.w3c.dom.CharacterData

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________


public class org.apache.harmony.xml.dom.CommentImpl extends org.apache.harmony.xml.dom.CharacterDataImpl implements org.w3c.dom.Comment

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.xml.dom.DocumentImpl
java.lang.String)

public java.lang.String getNodeName()

public short getNodeType()

________________CLASS________________


public abstract interface class org.w3c.dom.DOMImplementation extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public abstract org.w3c.dom.Document createDocument(
java.lang.String
java.lang.String
org.w3c.dom.DocumentType)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public abstract org.w3c.dom.DocumentType createDocumentType(
java.lang.String
java.lang.String
java.lang.String)

public abstract boolean hasFeature(
java.lang.String
java.lang.String)

________________CLASS________________


public class org.apache.harmony.xml.dom.DOMImplementationImpl extends java.lang.Object implements org.w3c.dom.DOMImplementation

----------------FIELDS----------------

private static org.apache.harmony.xml.dom.DOMImplementationImpl instance
----------------METHODS----------------

 void <init>()

public static org.apache.harmony.xml.dom.DOMImplementationImpl getInstance()
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public org.w3c.dom.Document createDocument(
java.lang.String
java.lang.String
org.w3c.dom.DocumentType)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public org.w3c.dom.DocumentType createDocumentType(
java.lang.String
java.lang.String
java.lang.String)

public boolean hasFeature(
java.lang.String
java.lang.String)

________________CLASS________________


public abstract class org.apache.harmony.xml.dom.InnerNodeImpl extends org.apache.harmony.xml.dom.LeafNodeImpl

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/List<Lorg/apache/harmony/xml/dom/LeafNodeImpl;>; )
 java.util.List children
----------------METHODS----------------

public void <init>(
org.apache.harmony.xml.dom.DocumentImpl)

private void refreshIndices(
int)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public org.w3c.dom.Node appendChild(
org.w3c.dom.Node)

public org.w3c.dom.NodeList getChildNodes()

public org.w3c.dom.Node getFirstChild()

public org.w3c.dom.Node getLastChild()

public org.w3c.dom.Node getNextSibling()

public boolean hasChildNodes()
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public org.w3c.dom.Node insertBefore(
org.w3c.dom.Node
org.w3c.dom.Node)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public org.w3c.dom.Node insertChildAt(
org.w3c.dom.Node
int)

public boolean isParentOf(
org.w3c.dom.Node)

public void normalize()
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public org.w3c.dom.Node removeChild(
org.w3c.dom.Node)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public org.w3c.dom.Node replaceChild(
org.w3c.dom.Node
org.w3c.dom.Node)

________________CLASS________________


public abstract interface class org.w3c.dom.DocumentFragment extends java.lang.Object implements org.w3c.dom.Node

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________


public class org.apache.harmony.xml.dom.DocumentFragmentImpl extends org.apache.harmony.xml.dom.InnerNodeImpl implements org.w3c.dom.DocumentFragment

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.apache.harmony.xml.dom.DocumentImpl)

public java.lang.String getNodeName()

public short getNodeType()

________________CLASS________________


public abstract interface class org.w3c.dom.Document extends java.lang.Object implements org.w3c.dom.Node

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public abstract org.w3c.dom.Attr createAttribute(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public abstract org.w3c.dom.Attr createAttributeNS(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public abstract org.w3c.dom.CDATASection createCDATASection(
java.lang.String)

public abstract org.w3c.dom.Comment createComment(
java.lang.String)

public abstract org.w3c.dom.DocumentFragment createDocumentFragment()
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public abstract org.w3c.dom.Element createElement(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public abstract org.w3c.dom.Element createElementNS(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public abstract org.w3c.dom.EntityReference createEntityReference(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public abstract org.w3c.dom.ProcessingInstruction createProcessingInstruction(
java.lang.String
java.lang.String)

public abstract org.w3c.dom.Text createTextNode(
java.lang.String)

public abstract org.w3c.dom.DocumentType getDoctype()

public abstract org.w3c.dom.Element getDocumentElement()

public abstract org.w3c.dom.Element getElementById(
java.lang.String)

public abstract org.w3c.dom.NodeList getElementsByTagName(
java.lang.String)

public abstract org.w3c.dom.NodeList getElementsByTagNameNS(
java.lang.String
java.lang.String)

public abstract org.w3c.dom.DOMImplementation getImplementation()
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public abstract org.w3c.dom.Node importNode(
org.w3c.dom.Node
boolean)

________________CLASS________________


public class org.apache.harmony.xml.dom.DocumentImpl extends org.apache.harmony.xml.dom.InnerNodeImpl implements org.w3c.dom.Document

----------------FIELDS----------------

private org.w3c.dom.DOMImplementation domImplementation
----------------METHODS----------------

 void <init>(
org.apache.harmony.xml.dom.DOMImplementationImpl
java.lang.String
java.lang.String
org.w3c.dom.DocumentType)

static boolean isXMLIdentifier(
java.lang.String)

private static boolean isXMLIdentifierPart(
char)

private static boolean isXMLIdentifierStart(
char)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
 org.w3c.dom.Node cloneNode(
org.w3c.dom.Node
boolean)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public org.apache.harmony.xml.dom.AttrImpl createAttribute(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public volatile org.w3c.dom.Attr createAttribute(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public org.w3c.dom.Attr createAttributeNS(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public org.w3c.dom.CDATASection createCDATASection(
java.lang.String)

public org.w3c.dom.Comment createComment(
java.lang.String)

public org.w3c.dom.DocumentFragment createDocumentFragment()
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public org.w3c.dom.Element createElement(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public org.w3c.dom.Element createElementNS(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public org.w3c.dom.EntityReference createEntityReference(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public org.w3c.dom.ProcessingInstruction createProcessingInstruction(
java.lang.String
java.lang.String)

public org.w3c.dom.Text createTextNode(
java.lang.String)

public org.w3c.dom.DocumentType getDoctype()

public org.w3c.dom.Element getDocumentElement()

public org.w3c.dom.Element getElementById(
java.lang.String)

public org.w3c.dom.NodeList getElementsByTagName(
java.lang.String)

public org.w3c.dom.NodeList getElementsByTagNameNS(
java.lang.String
java.lang.String)

public org.w3c.dom.DOMImplementation getImplementation()

public java.lang.String getNodeName()

public short getNodeType()
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public org.w3c.dom.Node importNode(
org.w3c.dom.Node
boolean)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public org.w3c.dom.Node insertChildAt(
org.w3c.dom.Node
int)

________________CLASS________________


public abstract interface class org.w3c.dom.DocumentType extends java.lang.Object implements org.w3c.dom.Node

----------------FIELDS----------------
----------------METHODS----------------

public abstract org.w3c.dom.NamedNodeMap getEntities()

public abstract java.lang.String getInternalSubset()

public abstract java.lang.String getName()

public abstract org.w3c.dom.NamedNodeMap getNotations()

public abstract java.lang.String getPublicId()

public abstract java.lang.String getSystemId()

________________CLASS________________


public class org.apache.harmony.xml.dom.DocumentTypeImpl extends org.apache.harmony.xml.dom.LeafNodeImpl implements org.w3c.dom.DocumentType

----------------FIELDS----------------

private java.lang.String publicId

private java.lang.String qualifiedName

private java.lang.String systemId
----------------METHODS----------------

 void <init>(
org.apache.harmony.xml.dom.DOMImplementationImpl
java.lang.String
java.lang.String
java.lang.String)

public org.w3c.dom.NamedNodeMap getEntities()

public java.lang.String getInternalSubset()

public java.lang.String getName()

public java.lang.String getNodeName()

public short getNodeType()

public org.w3c.dom.NamedNodeMap getNotations()

public java.lang.String getPublicId()

public java.lang.String getSystemId()

________________CLASS________________


public abstract interface class org.w3c.dom.NamedNodeMap extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract int getLength()

public abstract org.w3c.dom.Node getNamedItem(
java.lang.String)

public abstract org.w3c.dom.Node getNamedItemNS(
java.lang.String
java.lang.String)

public abstract org.w3c.dom.Node item(
int)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public abstract org.w3c.dom.Node removeNamedItem(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public abstract org.w3c.dom.Node removeNamedItemNS(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public abstract org.w3c.dom.Node setNamedItem(
org.w3c.dom.Node)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public abstract org.w3c.dom.Node setNamedItemNS(
org.w3c.dom.Node)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =1 name =ElementAttrNamedNodeMapImpl )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/xml/dom/ElementImpl; )
public class org.apache.harmony.xml.dom.ElementImpl$ElementAttrNamedNodeMapImpl extends java.lang.Object implements org.w3c.dom.NamedNodeMap

----------------FIELDS----------------

final org.apache.harmony.xml.dom.ElementImpl this$0
----------------METHODS----------------

public void <init>(
org.apache.harmony.xml.dom.ElementImpl)

private int indexOfItem(
java.lang.String)

private int indexOfItemNS(
java.lang.String
java.lang.String)

public int getLength()

public org.w3c.dom.Node getNamedItem(
java.lang.String)

public org.w3c.dom.Node getNamedItemNS(
java.lang.String
java.lang.String)

public org.w3c.dom.Node item(
int)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public org.w3c.dom.Node removeNamedItem(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public org.w3c.dom.Node removeNamedItemNS(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public org.w3c.dom.Node setNamedItem(
org.w3c.dom.Node)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public org.w3c.dom.Node setNamedItemNS(
org.w3c.dom.Node)

________________CLASS________________


public abstract interface class org.w3c.dom.Element extends java.lang.Object implements org.w3c.dom.Node

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.lang.String getAttribute(
java.lang.String)

public abstract java.lang.String getAttributeNS(
java.lang.String
java.lang.String)

public abstract org.w3c.dom.Attr getAttributeNode(
java.lang.String)

public abstract org.w3c.dom.Attr getAttributeNodeNS(
java.lang.String
java.lang.String)

public abstract org.w3c.dom.NodeList getElementsByTagName(
java.lang.String)

public abstract org.w3c.dom.NodeList getElementsByTagNameNS(
java.lang.String
java.lang.String)

public abstract java.lang.String getTagName()

public abstract boolean hasAttribute(
java.lang.String)

public abstract boolean hasAttributeNS(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public abstract void removeAttribute(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public abstract void removeAttributeNS(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public abstract org.w3c.dom.Attr removeAttributeNode(
org.w3c.dom.Attr)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public abstract void setAttribute(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public abstract void setAttributeNS(
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public abstract org.w3c.dom.Attr setAttributeNode(
org.w3c.dom.Attr)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public abstract org.w3c.dom.Attr setAttributeNodeNS(
org.w3c.dom.Attr)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/apache/harmony/xml/dom/ElementImpl$ElementAttrNamedNodeMapImpl; )
public class org.apache.harmony.xml.dom.ElementImpl extends org.apache.harmony.xml.dom.InnerNodeImpl implements org.w3c.dom.Element

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/List<Lorg/apache/harmony/xml/dom/AttrImpl;>; )
private java.util.List attributes

private java.lang.String localName

private boolean namespaceAware

private java.lang.String namespaceURI

private java.lang.String prefix
----------------METHODS----------------

 void <init>(
org.apache.harmony.xml.dom.DocumentImpl
java.lang.String)

 void <init>(
org.apache.harmony.xml.dom.DocumentImpl
java.lang.String
java.lang.String)

static java.util.List access$000(
org.apache.harmony.xml.dom.ElementImpl)

static int access$100(
org.apache.harmony.xml.dom.ElementImpl
java.lang.String)

static int access$200(
org.apache.harmony.xml.dom.ElementImpl
java.lang.String
java.lang.String)

private int indexOfAttribute(
java.lang.String)

private int indexOfAttributeNS(
java.lang.String
java.lang.String)

public java.lang.String getAttribute(
java.lang.String)

public java.lang.String getAttributeNS(
java.lang.String
java.lang.String)

public org.w3c.dom.Attr getAttributeNode(
java.lang.String)

public org.w3c.dom.Attr getAttributeNodeNS(
java.lang.String
java.lang.String)

public org.w3c.dom.NamedNodeMap getAttributes()

 org.w3c.dom.Element getElementById(
java.lang.String)

public org.w3c.dom.NodeList getElementsByTagName(
java.lang.String)

 void getElementsByTagName(
org.apache.harmony.xml.dom.NodeListImpl
java.lang.String)

public org.w3c.dom.NodeList getElementsByTagNameNS(
java.lang.String
java.lang.String)

 void getElementsByTagNameNS(
org.apache.harmony.xml.dom.NodeListImpl
java.lang.String
java.lang.String)

public java.lang.String getLocalName()

public java.lang.String getNamespaceURI()

public java.lang.String getNodeName()

public short getNodeType()

public java.lang.String getPrefix()

public java.lang.String getTagName()

public boolean hasAttribute(
java.lang.String)

public boolean hasAttributeNS(
java.lang.String
java.lang.String)

public boolean hasAttributes()
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public void removeAttribute(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public void removeAttributeNS(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public org.w3c.dom.Attr removeAttributeNode(
org.w3c.dom.Attr)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public void setAttribute(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public void setAttributeNS(
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public org.w3c.dom.Attr setAttributeNode(
org.w3c.dom.Attr)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public org.w3c.dom.Attr setAttributeNodeNS(
org.w3c.dom.Attr)

public void setPrefix(
java.lang.String)

________________CLASS________________


public abstract interface class org.w3c.dom.Entity extends java.lang.Object implements org.w3c.dom.Node

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.lang.String getNotationName()

public abstract java.lang.String getPublicId()

public abstract java.lang.String getSystemId()

________________CLASS________________


public class org.apache.harmony.xml.dom.EntityImpl extends org.apache.harmony.xml.dom.NodeImpl implements org.w3c.dom.Entity

----------------FIELDS----------------

private java.lang.String notationName

private java.lang.String publicID

private java.lang.String systemID
----------------METHODS----------------

 void <init>(
org.apache.harmony.xml.dom.DocumentImpl
java.lang.String
java.lang.String
java.lang.String)

public java.lang.String getNodeName()

public short getNodeType()

public java.lang.String getNotationName()

public java.lang.String getPublicId()

public java.lang.String getSystemId()

________________CLASS________________


public abstract interface class org.w3c.dom.EntityReference extends java.lang.Object implements org.w3c.dom.Node

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________


public class org.apache.harmony.xml.dom.EntityReferenceImpl extends org.apache.harmony.xml.dom.LeafNodeImpl implements org.w3c.dom.EntityReference

----------------FIELDS----------------

private java.lang.String name
----------------METHODS----------------

 void <init>(
org.apache.harmony.xml.dom.DocumentImpl
java.lang.String)

public java.lang.String getNodeName()

public short getNodeType()

________________CLASS________________


public class org.apache.harmony.xml.dom.NamedNodeMapImpl extends java.lang.Object implements org.w3c.dom.NamedNodeMap

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/List<Lorg/apache/harmony/xml/dom/NodeImpl;>; )
private java.util.List list
@dalvik.annotation.Signature (value =Ljava/lang/Class<*>; )
private java.lang.Class type
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/lang/Class<*>;)V )
 void <init>(
java.lang.Class)
@dalvik.annotation.Signature (value =(Ljava/util/List<Lorg/apache/harmony/xml/dom/NodeImpl;>;Ljava/lang/Class<*>;)V )
 void <init>(
java.util.List
java.lang.Class)

private int indexOfItem(
java.lang.String)

private int indexOfItemNS(
java.lang.String
java.lang.String)

public int getLength()

public org.w3c.dom.Node getNamedItem(
java.lang.String)

public org.w3c.dom.Node getNamedItemNS(
java.lang.String
java.lang.String)

public org.w3c.dom.Node item(
int)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public org.w3c.dom.Node removeNamedItem(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public org.w3c.dom.Node removeNamedItemNS(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public org.w3c.dom.Node setNamedItem(
org.w3c.dom.Node)
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public org.w3c.dom.Node setNamedItemNS(
org.w3c.dom.Node)

________________CLASS________________


public class org.apache.harmony.xml.dom.NodeListImpl extends java.lang.Object implements org.w3c.dom.NodeList

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/List<Lorg/apache/harmony/xml/dom/NodeImpl;>; )
private java.util.List children
----------------METHODS----------------

 void <init>()
@dalvik.annotation.Signature (value =(Ljava/util/List<Lorg/apache/harmony/xml/dom/NodeImpl;>;)V )
 void <init>(
java.util.List)

 void add(
org.apache.harmony.xml.dom.NodeImpl)

public int getLength()

public org.w3c.dom.Node item(
int)

________________CLASS________________


public abstract interface class org.w3c.dom.Notation extends java.lang.Object implements org.w3c.dom.Node

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.lang.String getPublicId()

public abstract java.lang.String getSystemId()

________________CLASS________________


public class org.apache.harmony.xml.dom.NotationImpl extends org.apache.harmony.xml.dom.LeafNodeImpl implements org.w3c.dom.Notation

----------------FIELDS----------------

private java.lang.String notationName

private java.lang.String publicID

private java.lang.String systemID
----------------METHODS----------------

 void <init>(
org.apache.harmony.xml.dom.DocumentImpl
java.lang.String
java.lang.String
java.lang.String)

public java.lang.String getNodeName()

public short getNodeType()

public java.lang.String getPublicId()

public java.lang.String getSystemId()

________________CLASS________________


public abstract interface class org.w3c.dom.ProcessingInstruction extends java.lang.Object implements org.w3c.dom.Node

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.lang.String getData()

public abstract java.lang.String getTarget()
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public abstract void setData(
java.lang.String)

________________CLASS________________


public class org.apache.harmony.xml.dom.ProcessingInstructionImpl extends org.apache.harmony.xml.dom.LeafNodeImpl implements org.w3c.dom.ProcessingInstruction

----------------FIELDS----------------

private java.lang.String data

private java.lang.String target
----------------METHODS----------------

 void <init>(
org.apache.harmony.xml.dom.DocumentImpl
java.lang.String
java.lang.String)

public java.lang.String getData()

public java.lang.String getNodeName()

public short getNodeType()

public java.lang.String getNodeValue()

public java.lang.String getTarget()
@dalvik.annotation.Throws (value =Lorg/w3c/dom/DOMException; )
public void setData(
java.lang.String)

________________CLASS________________


public class org.apache.harmony.xml.parsers.DocumentBuilderFactoryImpl extends javax.xml.parsers.DocumentBuilderFactory

----------------FIELDS----------------

private static final java.lang.String NAMESPACES

private static final java.lang.String VALIDATION
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public java.lang.Object getAttribute(
java.lang.String)
@dalvik.annotation.Throws (value =Ljavax/xml/parsers/ParserConfigurationException; )
public boolean getFeature(
java.lang.String)
@dalvik.annotation.Throws (value =Ljavax/xml/parsers/ParserConfigurationException; )
public javax.xml.parsers.DocumentBuilder newDocumentBuilder()
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public void setAttribute(
java.lang.String
java.lang.Object)
@dalvik.annotation.Throws (value =Ljavax/xml/parsers/ParserConfigurationException; )
public void setFeature(
java.lang.String
boolean)

________________CLASS________________


 class org.apache.harmony.xml.parsers.DocumentBuilderImpl extends javax.xml.parsers.DocumentBuilder

----------------FIELDS----------------

private static org.w3c.dom.DOMImplementation dom

private org.xml.sax.EntityResolver entityResolver

private org.xml.sax.ErrorHandler errorHandler

private boolean ignoreComments

private boolean ignoreElementContentWhitespace

private boolean namespaceAware
----------------METHODS----------------

static void <clinit>()

 void <init>()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException;Ljava/io/IOException; )
private void parse(
org.xmlpull.v1.XmlPullParser
org.w3c.dom.Document
org.w3c.dom.Node
int)

private java.lang.String resolveStandardEntity(
java.lang.String)

public org.w3c.dom.DOMImplementation getDOMImplementation()

public boolean isIgnoringComments()

public boolean isIgnoringElementContentWhitespace()

public boolean isNamespaceAware()

public boolean isValidating()

public org.w3c.dom.Document newDocument()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException;Ljava/io/IOException; )
public org.w3c.dom.Document parse(
org.xml.sax.InputSource)

public void setEntityResolver(
org.xml.sax.EntityResolver)

public void setErrorHandler(
org.xml.sax.ErrorHandler)

public void setIgnoreComments(
boolean)

public void setIgnoreElementContentWhitespace(
boolean)

public void setNamespaceAware(
boolean)

________________CLASS________________


public class org.apache.harmony.xml.parsers.SAXParserFactoryImpl extends javax.xml.parsers.SAXParserFactory

----------------FIELDS----------------

private static final java.lang.String NAMESPACES

private static final java.lang.String VALIDATION
@dalvik.annotation.Signature (value =Ljava/util/Map<Ljava/lang/String;Ljava/lang/Boolean;>; )
private java.util.Map features
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXNotRecognizedException; )
public boolean getFeature(
java.lang.String)

public boolean isNamespaceAware()

public boolean isValidating()
@dalvik.annotation.Throws (value =Ljavax/xml/parsers/ParserConfigurationException; )
public javax.xml.parsers.SAXParser newSAXParser()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXNotRecognizedException; )
public void setFeature(
java.lang.String
boolean)

public void setNamespaceAware(
boolean)

public void setValidating(
boolean)

________________CLASS________________


 class org.apache.harmony.xml.parsers.SAXParserImpl extends javax.xml.parsers.SAXParser

----------------FIELDS----------------

private org.xml.sax.Parser parser

private org.xml.sax.XMLReader reader
----------------METHODS----------------
@dalvik.annotation.Signature (value =(Ljava/util/Map<Ljava/lang/String;Ljava/lang/Boolean;>;)V )
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXNotRecognizedException;Lorg/xml/sax/SAXNotSupportedException; )
 void <init>(
java.util.Map)

public org.xml.sax.Parser getParser()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXNotRecognizedException;Lorg/xml/sax/SAXNotSupportedException; )
public java.lang.Object getProperty(
java.lang.String)

public org.xml.sax.XMLReader getXMLReader()

public boolean isNamespaceAware()

public boolean isValidating()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXNotRecognizedException;Lorg/xml/sax/SAXNotSupportedException; )
public void setProperty(
java.lang.String
java.lang.Object)

________________CLASS________________


public class org.apache.harmony.xnet.internal.nls.Messages extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.String sResource
----------------METHODS----------------

public void <init>()

public static java.lang.String getString(
java.lang.String)

public static java.lang.String getString(
java.lang.String
char)

public static java.lang.String getString(
java.lang.String
int)

public static java.lang.String getString(
java.lang.String
java.lang.Object)

public static java.lang.String getString(
java.lang.String
java.lang.Object
java.lang.Object)

public static java.lang.String getString(
java.lang.String
java.lang.Object[])

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.AlertException extends java.lang.RuntimeException

----------------FIELDS----------------

private final byte description

private final javax.net.ssl.SSLException reason
----------------METHODS----------------

protected void <init>(
byte
javax.net.ssl.SSLException)

protected byte getDescriptionCode()

protected javax.net.ssl.SSLException getReason()

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.AlertProtocol extends java.lang.Object

----------------FIELDS----------------

protected static final byte ACCESS_DENIED

protected static final byte BAD_CERTIFICATE

protected static final byte BAD_RECORD_MAC

protected static final byte CERTIFICATE_EXPIRED

protected static final byte CERTIFICATE_REVOKED

protected static final byte CERTIFICATE_UNKNOWN

protected static final byte CLOSE_NOTIFY

protected static final byte DECODE_ERROR

protected static final byte DECOMPRESSION_FAILURE

protected static final byte DECRYPTION_FAILED

protected static final byte DECRYPT_ERROR

protected static final byte EXPORT_RESTRICTION

protected static final byte FATAL

protected static final byte HANDSHAKE_FAILURE

protected static final byte ILLEGAL_PARAMETER

protected static final byte INSUFFICIENT_SECURITY

protected static final byte INTERNAL_ERROR

protected static final byte NO_RENEGOTIATION

protected static final byte PROTOCOL_VERSION

protected static final byte RECORD_OVERFLOW

protected static final byte UNEXPECTED_MESSAGE

protected static final byte UNKNOWN_CA

protected static final byte UNSUPPORTED_CERTIFICATE

protected static final byte USER_CANCELED

protected static final byte WARNING

private final byte[] alert

private org.apache.harmony.xnet.provider.jsse.Logger$Stream logger

private org.apache.harmony.xnet.provider.jsse.SSLRecordProtocol recordProtocol
----------------METHODS----------------

protected void <init>()

protected void alert(
byte
byte)

protected java.lang.String getAlertDescription()

protected byte getDescriptionCode()

protected boolean hasAlert()

protected boolean isFatalAlert()

protected void setProcessed()

protected void setRecordProtocol(
org.apache.harmony.xnet.provider.jsse.SSLRecordProtocol)

protected void shutdown()

protected byte[] wrap()

________________CLASS________________


public abstract interface class org.apache.harmony.xnet.provider.jsse.Appendable extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract void append(
byte[])

________________CLASS________________


public abstract class org.apache.harmony.xnet.provider.jsse.Message extends java.lang.Object

----------------FIELDS----------------

protected int length
----------------METHODS----------------

public void <init>()

protected void fatalAlert(
byte
java.lang.String)

protected void fatalAlert(
byte
java.lang.String
java.lang.Throwable)

abstract int getType()

public int length()

abstract void send(
org.apache.harmony.xnet.provider.jsse.HandshakeIODataStream)

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.CertificateMessage extends org.apache.harmony.xnet.provider.jsse.Message

----------------FIELDS----------------

 java.security.cert.X509Certificate[] certs

 byte[][] encoded_certs
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
org.apache.harmony.xnet.provider.jsse.HandshakeIODataStream
int)

public void <init>(
java.security.cert.X509Certificate[])

public int getType()

public void send(
org.apache.harmony.xnet.provider.jsse.HandshakeIODataStream)

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.CertificateRequest extends org.apache.harmony.xnet.provider.jsse.Message

----------------FIELDS----------------

public static final byte DSS_FIXED_DH

public static final byte DSS_SIGN

public static final byte RSA_FIXED_DH

public static final byte RSA_SIGN

 javax.security.auth.x500.X500Principal[] certificate_authorities

final byte[] certificate_types

private byte[][] encoded_principals

private java.lang.String[] types
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
org.apache.harmony.xnet.provider.jsse.HandshakeIODataStream
int)

public void <init>(
byte[]
java.security.cert.X509Certificate[])

public int getType()

public java.lang.String[] getTypesAsString()

public void send(
org.apache.harmony.xnet.provider.jsse.HandshakeIODataStream)

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.CertificateVerify extends org.apache.harmony.xnet.provider.jsse.Message

----------------FIELDS----------------

 byte[] signedHash
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
org.apache.harmony.xnet.provider.jsse.HandshakeIODataStream
int)

public void <init>(
byte[])

public int getType()

public void send(
org.apache.harmony.xnet.provider.jsse.HandshakeIODataStream)

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.CipherSuite extends java.lang.Object

----------------FIELDS----------------

static int KeyExchange_DHE_DSS

static int KeyExchange_DHE_DSS_EXPORT

static int KeyExchange_DHE_RSA

static int KeyExchange_DHE_RSA_EXPORT

static int KeyExchange_DH_DSS

static int KeyExchange_DH_DSS_EXPORT

static int KeyExchange_DH_RSA

static int KeyExchange_DH_RSA_EXPORT

static int KeyExchange_DH_anon

static int KeyExchange_DH_anon_EXPORT

static int KeyExchange_RSA

static int KeyExchange_RSA_EXPORT

static org.apache.harmony.xnet.provider.jsse.CipherSuite TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA

static org.apache.harmony.xnet.provider.jsse.CipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA

static org.apache.harmony.xnet.provider.jsse.CipherSuite TLS_DHE_DSS_WITH_DES_CBC_SHA

static org.apache.harmony.xnet.provider.jsse.CipherSuite TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA

static org.apache.harmony.xnet.provider.jsse.CipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA

static org.apache.harmony.xnet.provider.jsse.CipherSuite TLS_DHE_RSA_WITH_DES_CBC_SHA

static org.apache.harmony.xnet.provider.jsse.CipherSuite TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA

static org.apache.harmony.xnet.provider.jsse.CipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA

static org.apache.harmony.xnet.provider.jsse.CipherSuite TLS_DH_DSS_WITH_DES_CBC_SHA

static org.apache.harmony.xnet.provider.jsse.CipherSuite TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA

static org.apache.harmony.xnet.provider.jsse.CipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA

static org.apache.harmony.xnet.provider.jsse.CipherSuite TLS_DH_RSA_WITH_DES_CBC_SHA

static org.apache.harmony.xnet.provider.jsse.CipherSuite TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA

static org.apache.harmony.xnet.provider.jsse.CipherSuite TLS_DH_anon_EXPORT_WITH_RC4_40_MD5

static org.apache.harmony.xnet.provider.jsse.CipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA

static org.apache.harmony.xnet.provider.jsse.CipherSuite TLS_DH_anon_WITH_DES_CBC_SHA

static org.apache.harmony.xnet.provider.jsse.CipherSuite TLS_DH_anon_WITH_RC4_128_MD5

static org.apache.harmony.xnet.provider.jsse.CipherSuite TLS_NULL_WITH_NULL_NULL

static org.apache.harmony.xnet.provider.jsse.CipherSuite TLS_RSA_EXPORT_WITH_DES40_CBC_SHA

static org.apache.harmony.xnet.provider.jsse.CipherSuite TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5

static org.apache.harmony.xnet.provider.jsse.CipherSuite TLS_RSA_EXPORT_WITH_RC4_40_MD5

static org.apache.harmony.xnet.provider.jsse.CipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA

static org.apache.harmony.xnet.provider.jsse.CipherSuite TLS_RSA_WITH_DES_CBC_SHA

static org.apache.harmony.xnet.provider.jsse.CipherSuite TLS_RSA_WITH_IDEA_CBC_SHA

static org.apache.harmony.xnet.provider.jsse.CipherSuite TLS_RSA_WITH_NULL_MD5

static org.apache.harmony.xnet.provider.jsse.CipherSuite TLS_RSA_WITH_NULL_SHA

static org.apache.harmony.xnet.provider.jsse.CipherSuite TLS_RSA_WITH_RC4_128_MD5

static org.apache.harmony.xnet.provider.jsse.CipherSuite TLS_RSA_WITH_RC4_128_SHA

static byte[] code_TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA

static byte[] code_TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA

static byte[] code_TLS_DHE_DSS_WITH_DES_CBC_SHA

static byte[] code_TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA

static byte[] code_TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA

static byte[] code_TLS_DHE_RSA_WITH_DES_CBC_SHA

static byte[] code_TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA

static byte[] code_TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA

static byte[] code_TLS_DH_DSS_WITH_DES_CBC_SHA

static byte[] code_TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA

static byte[] code_TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA

static byte[] code_TLS_DH_RSA_WITH_DES_CBC_SHA

static byte[] code_TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA

static byte[] code_TLS_DH_anon_EXPORT_WITH_RC4_40_MD5

static byte[] code_TLS_DH_anon_WITH_3DES_EDE_CBC_SHA

static byte[] code_TLS_DH_anon_WITH_DES_CBC_SHA

static byte[] code_TLS_DH_anon_WITH_RC4_128_MD5

static byte[] code_TLS_NULL_WITH_NULL_NULL

static byte[] code_TLS_RSA_EXPORT_WITH_DES40_CBC_SHA

static byte[] code_TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5

static byte[] code_TLS_RSA_EXPORT_WITH_RC4_40_MD5

static byte[] code_TLS_RSA_WITH_3DES_EDE_CBC_SHA

static byte[] code_TLS_RSA_WITH_DES_CBC_SHA

static byte[] code_TLS_RSA_WITH_IDEA_CBC_SHA

static byte[] code_TLS_RSA_WITH_NULL_MD5

static byte[] code_TLS_RSA_WITH_NULL_SHA

static byte[] code_TLS_RSA_WITH_RC4_128_MD5

static byte[] code_TLS_RSA_WITH_RC4_128_SHA

private static org.apache.harmony.xnet.provider.jsse.CipherSuite[] cuitesByCode

private static java.util.Hashtable cuitesByName

static org.apache.harmony.xnet.provider.jsse.CipherSuite[] defaultCipherSuites

static java.lang.String[] supportedCipherSuiteNames

static org.apache.harmony.xnet.provider.jsse.CipherSuite[] supportedCipherSuites

final int IVSize

private final int blockSize

final java.lang.String cipherName

private final byte[] cipherSuiteCode

final int effectiveKeyBytes

final int expandedKeyMaterial

private final java.lang.String hashName

private final int hashSize

private final java.lang.String hmacName

private final boolean isExportable

final int keyExchange

final int keyMaterial

private final java.lang.String name

 boolean supported
----------------METHODS----------------

static void <clinit>()

public void <init>(
java.lang.String
boolean
int
java.lang.String
java.lang.String
byte[])

public static org.apache.harmony.xnet.provider.jsse.CipherSuite getByCode(
byte
byte)

public static org.apache.harmony.xnet.provider.jsse.CipherSuite getByCode(
byte
byte
byte)

public static org.apache.harmony.xnet.provider.jsse.CipherSuite getByName(
java.lang.String)

public static org.apache.harmony.xnet.provider.jsse.CipherSuite[] getSupported()

public static java.lang.String[] getSupportedCipherSuiteNames()

public boolean equals(
java.lang.Object)

public int getBlockSize()

public java.lang.String getBulkEncryptionAlgorithm()

public java.lang.String getHashName()

public java.lang.String getHmacName()

public int getMACLength()

public java.lang.String getName()

public boolean isAnonymous()

public boolean isExportable()

public byte[] toBytes()

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
 class org.apache.harmony.xnet.provider.jsse.ClientHandshakeImpl$1 extends java.lang.Object implements java.security.PrivilegedExceptionAction

----------------FIELDS----------------

final org.apache.harmony.xnet.provider.jsse.ClientHandshakeImpl this$0
----------------METHODS----------------

 void <init>(
org.apache.harmony.xnet.provider.jsse.ClientHandshakeImpl)
@dalvik.annotation.Throws (value =Ljava/lang/Exception; )
public java.lang.Object run()

________________CLASS________________


public abstract class org.apache.harmony.xnet.provider.jsse.HandshakeProtocol extends java.lang.Object

----------------FIELDS----------------

public static final int FINISHED

public static final int NEED_TASK

public static final int NEED_UNWRAP

public static final int NOT_HANDSHAKING

protected org.apache.harmony.xnet.provider.jsse.CertificateRequest certificateRequest

protected org.apache.harmony.xnet.provider.jsse.CertificateVerify certificateVerify

protected boolean changeCipherSpecReceived

protected org.apache.harmony.xnet.provider.jsse.CertificateMessage clientCert

protected org.apache.harmony.xnet.provider.jsse.Finished clientFinished

protected org.apache.harmony.xnet.provider.jsse.ClientHello clientHello

protected org.apache.harmony.xnet.provider.jsse.ClientKeyExchange clientKeyExchange

protected java.lang.Exception delegatedTaskErr

protected java.util.Vector delegatedTasks

public org.apache.harmony.xnet.provider.jsse.SSLEngineImpl engineOwner

protected org.apache.harmony.xnet.provider.jsse.HandshakeIODataStream io_stream

protected boolean isResuming

private byte[] master_secret_bytes

private boolean needSendCCSpec

protected boolean needSendHelloRequest

protected boolean nonBlocking

protected org.apache.harmony.xnet.provider.jsse.SSLParameters parameters

protected byte[] preMasterSecret

protected org.apache.harmony.xnet.provider.jsse.SSLRecordProtocol recordProtocol

protected org.apache.harmony.xnet.provider.jsse.CertificateMessage serverCert

protected org.apache.harmony.xnet.provider.jsse.Finished serverFinished

protected org.apache.harmony.xnet.provider.jsse.ServerHello serverHello

protected org.apache.harmony.xnet.provider.jsse.ServerHelloDone serverHelloDone

protected org.apache.harmony.xnet.provider.jsse.ServerKeyExchange serverKeyExchange

protected org.apache.harmony.xnet.provider.jsse.SSLSessionImpl session

protected int status

private byte[] verify_data
----------------METHODS----------------

protected void <init>(
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/spec/InvalidKeySpecException; )
protected static int getRSAKeyLength(
java.security.PublicKey)

protected void clearMessages()

public void computerMasterSecret()

protected void computerReferenceVerifyDataSSLv3(
byte[])

protected void computerReferenceVerifyDataTLS(
java.lang.String)

protected void computerVerifyDataSSLv3(
byte[]
byte[])

protected void computerVerifyDataTLS(
java.lang.String
byte[])

protected void fatalAlert(
byte
java.lang.String)

protected void fatalAlert(
byte
java.lang.String
java.lang.Exception)

protected void fatalAlert(
byte
javax.net.ssl.SSLException)

public org.apache.harmony.xnet.provider.jsse.SSLSessionImpl getSession()

public javax.net.ssl.SSLEngineResult$HandshakeStatus getStatus()

public java.lang.Runnable getTask()

abstract void makeFinished()

abstract void receiveChangeCipherSpec()

public void send(
org.apache.harmony.xnet.provider.jsse.Message)

protected void sendChangeCipherSpec()

protected void sendHelloRequest()

protected void sendWarningAlert(
byte)

public void setRecordProtocol(
org.apache.harmony.xnet.provider.jsse.SSLRecordProtocol)

protected void shutdown()

public abstract void start()

protected void stop()

protected void unexpectedMessage()

public abstract void unwrap(
byte[])

public abstract void unwrapSSLv2(
byte[])

protected void verifyFinished(
byte[])

public byte[] wrap()

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.ClientHandshakeImpl extends org.apache.harmony.xnet.provider.jsse.HandshakeProtocol

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
java.lang.Object)

private org.apache.harmony.xnet.provider.jsse.SSLSessionImpl findSessionToResume()

private void renegotiateNewSession()

private void startSession()

private void verifyServerCert()

protected void makeFinished()

 void processServerHelloDone()

public void receiveChangeCipherSpec()

public void start()

public void unwrap(
byte[])

public void unwrapSSLv2(
byte[])

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.ClientHello extends org.apache.harmony.xnet.provider.jsse.Message

----------------FIELDS----------------

final org.apache.harmony.xnet.provider.jsse.CipherSuite[] cipher_suites

final byte[] client_version

final byte[] compression_methods

final byte[] random

final byte[] session_id
----------------METHODS----------------

public void <init>(
java.security.SecureRandom
byte[]
byte[]
org.apache.harmony.xnet.provider.jsse.CipherSuite[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
org.apache.harmony.xnet.provider.jsse.HandshakeIODataStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
org.apache.harmony.xnet.provider.jsse.HandshakeIODataStream
int)

public byte[] getRandom()

public int getType()

public void send(
org.apache.harmony.xnet.provider.jsse.HandshakeIODataStream)

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.ClientKeyExchange extends org.apache.harmony.xnet.provider.jsse.Message

----------------FIELDS----------------

final byte[] exchange_keys

final boolean isRSA

 boolean isTLS
----------------METHODS----------------

public void <init>()

public void <init>(
java.math.BigInteger)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
org.apache.harmony.xnet.provider.jsse.HandshakeIODataStream
int
boolean
boolean)

public void <init>(
byte[]
boolean)

public int getType()

public boolean isEmpty()

public void send(
org.apache.harmony.xnet.provider.jsse.HandshakeIODataStream)

________________CLASS________________


public abstract class org.apache.harmony.xnet.provider.jsse.ConnectionState extends java.lang.Object

----------------FIELDS----------------

protected javax.crypto.Cipher decCipher

protected javax.crypto.Cipher encCipher

protected int hash_size

protected boolean is_block_cipher

protected org.apache.harmony.xnet.provider.jsse.Logger$Stream logger

protected final byte[] read_seq_num

protected final byte[] write_seq_num
----------------METHODS----------------

public void <init>()

protected static void incSequenceNumber(
byte[])

protected byte[] decrypt(
byte
byte[])

protected abstract byte[] decrypt(
byte
byte[]
int
int)

protected byte[] encrypt(
byte
byte[])

protected abstract byte[] encrypt(
byte
byte[]
int
int)

protected int getContentSize(
int)

protected int getFragmentSize(
int)

protected int getMinFragmentSize()

protected void shutdown()

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.ConnectionStateSSLv3 extends org.apache.harmony.xnet.provider.jsse.ConnectionState

----------------FIELDS----------------

private final byte[] mac_material_part

private final byte[] mac_read_secret

private final byte[] mac_write_secret

private final java.security.MessageDigest messageDigest

private final byte[] pad_1

private final byte[] pad_2
----------------METHODS----------------

protected void <init>(
org.apache.harmony.xnet.provider.jsse.SSLSessionImpl)

protected byte[] decrypt(
byte
byte[]
int
int)

protected byte[] encrypt(
byte
byte[]
int
int)

protected void shutdown()

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.ConnectionStateTLS extends org.apache.harmony.xnet.provider.jsse.ConnectionState

----------------FIELDS----------------

private static byte[] CLIENT_WRITE_KEY_LABEL

private static byte[] IV_BLOCK_LABEL

private static byte[] KEY_EXPANSION_LABEL

private static byte[] SERVER_WRITE_KEY_LABEL

private final javax.crypto.Mac decMac

private final javax.crypto.Mac encMac

private final byte[] mac_material_header
----------------METHODS----------------

static void <clinit>()

protected void <init>(
org.apache.harmony.xnet.provider.jsse.SSLSessionImpl)

protected byte[] decrypt(
byte
byte[]
int
int)

protected byte[] encrypt(
byte
byte[]
int
int)

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.ContentType extends java.lang.Object

----------------FIELDS----------------

protected static final byte ALERT

protected static final byte APPLICATION_DATA

protected static final byte CHANGE_CIPHER_SPEC

protected static final byte HANDSHAKE
----------------METHODS----------------

public void <init>()

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.DHParameters extends java.lang.Object

----------------FIELDS----------------

private static byte[] prime

private static byte[] prime512

private static byte[] primeGroup1

private static byte[] primeGroup2
----------------METHODS----------------

static void <clinit>()

public void <init>()

public static byte[] getPrime()

________________CLASS________________


public abstract interface class org.apache.harmony.xnet.provider.jsse.DataStream extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract byte[] getData(
int)

public abstract boolean hasData()

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.DelegatedTask extends java.lang.Object implements java.lang.Runnable

----------------FIELDS----------------

private final java.security.PrivilegedExceptionAction action

private final java.security.AccessControlContext context

private final org.apache.harmony.xnet.provider.jsse.HandshakeProtocol handshaker
----------------METHODS----------------

public void <init>(
java.security.PrivilegedExceptionAction
org.apache.harmony.xnet.provider.jsse.HandshakeProtocol
java.security.AccessControlContext)

public void run()

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.DigitalSignature extends java.lang.Object

----------------FIELDS----------------

private javax.crypto.Cipher cipher

private java.security.MessageDigest md5

private byte[] md5_hash

private java.security.MessageDigest sha

private byte[] sha_hash

private java.security.Signature signature
----------------METHODS----------------

public void <init>(
int)

public void init(
java.security.PrivateKey)

public void init(
java.security.cert.Certificate)

public void setMD5(
byte[])

public void setSHA(
byte[])

public byte[] sign()

public void update(
byte[])

public boolean verifySignature(
byte[])

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.EndOfBufferException extends java.io.IOException

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.EndOfSourceException extends java.io.IOException

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.Finished extends org.apache.harmony.xnet.provider.jsse.Message

----------------FIELDS----------------

private byte[] data
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
org.apache.harmony.xnet.provider.jsse.HandshakeIODataStream
int)

public void <init>(
byte[])

public byte[] getData()

public int getType()

public void send(
org.apache.harmony.xnet.provider.jsse.HandshakeIODataStream)

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.Handshake extends java.lang.Object

----------------FIELDS----------------

public static final byte CERTIFICATE

public static final byte CERTIFICATE_REQUEST

public static final byte CERTIFICATE_VERIFY

public static final byte CLIENT_HELLO

public static final byte CLIENT_KEY_EXCHANGE

public static final byte FINISHED

public static final byte HELLO_REQUEST

public static final byte SERVER_HELLO

public static final byte SERVER_HELLO_DONE

public static final byte SERVER_KEY_EXCHANGE
----------------METHODS----------------

public void <init>()

________________CLASS________________


public abstract class org.apache.harmony.xnet.provider.jsse.SSLInputStream extends java.io.InputStream

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int available()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public byte[] read(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int readUint16()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int readUint24()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long readUint32()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long readUint64()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int readUint8()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public long skip(
long)

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.HandshakeIODataStream extends org.apache.harmony.xnet.provider.jsse.SSLInputStream implements org.apache.harmony.xnet.provider.jsse.Appendable, org.apache.harmony.xnet.provider.jsse.DataStream

----------------FIELDS----------------

private static final java.security.MessageDigest md5

private static final java.security.MessageDigest sha

private int buff_size

private byte[] buffer

private int inc_buff_size

private int marked_pos

private int read_pos

private int read_pos_end

private int write_pos

private int write_pos_beg
----------------METHODS----------------

static void <clinit>()

public void <init>()

private void append(
byte[]
int
int)

private void check(
int)

private void enlargeBuffer(
int)

public void append(
byte[])

public int available()

protected void clearBuffer()

public byte[] getData(
int)

protected byte[] getDigestMD5()

protected byte[] getDigestMD5withoutLast()

protected byte[] getDigestSHA()

protected byte[] getDigestSHAwithoutLast()

protected byte[] getMessages()

public boolean hasData()

public void mark()

public void mark(
int)

public boolean markSupported()

protected void printContent(
java.io.PrintStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public byte[] read(
int)

protected void removeFromMarkedPosition()

public void reset()

public void write(
byte)

public void write(
byte[])

public void writeUint16(
long)

public void writeUint24(
long)

public void writeUint32(
long)

public void writeUint64(
long)

public void writeUint8(
long)

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.HelloRequest extends org.apache.harmony.xnet.provider.jsse.Message

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
org.apache.harmony.xnet.provider.jsse.HandshakeIODataStream
int)

public int getType()

public int length()

public void send(
org.apache.harmony.xnet.provider.jsse.HandshakeIODataStream)

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/Void;>; )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
 class org.apache.harmony.xnet.provider.jsse.JSSEProvider$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final org.apache.harmony.xnet.provider.jsse.JSSEProvider this$0
----------------METHODS----------------

 void <init>(
org.apache.harmony.xnet.provider.jsse.JSSEProvider)

public volatile java.lang.Object run()

public java.lang.Void run()

________________CLASS________________


public final class org.apache.harmony.xnet.provider.jsse.JSSEProvider extends java.security.Provider

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/String;>; )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
 class org.apache.harmony.xnet.provider.jsse.KeyManagerFactoryImpl$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final org.apache.harmony.xnet.provider.jsse.KeyManagerFactoryImpl this$0
----------------METHODS----------------

 void <init>(
org.apache.harmony.xnet.provider.jsse.KeyManagerFactoryImpl)

public volatile java.lang.Object run()

public java.lang.String run()

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/String;>; )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
 class org.apache.harmony.xnet.provider.jsse.KeyManagerFactoryImpl$2 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final org.apache.harmony.xnet.provider.jsse.KeyManagerFactoryImpl this$0
----------------METHODS----------------

 void <init>(
org.apache.harmony.xnet.provider.jsse.KeyManagerFactoryImpl)

public volatile java.lang.Object run()

public java.lang.String run()

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.KeyManagerFactoryImpl extends javax.net.ssl.KeyManagerFactorySpi

----------------FIELDS----------------

private java.security.KeyStore keyStore

private char[] pwd
----------------METHODS----------------

public void <init>()

public javax.net.ssl.KeyManager[] engineGetKeyManagers()
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException;Ljava/security/NoSuchAlgorithmException;Ljava/security/UnrecoverableKeyException; )
public void engineInit(
java.security.KeyStore
char[])
@dalvik.annotation.Throws (value =Ljava/security/InvalidAlgorithmParameterException; )
public void engineInit(
javax.net.ssl.ManagerFactoryParameters)

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.KeyManagerImpl extends javax.net.ssl.X509ExtendedKeyManager

----------------FIELDS----------------

private final java.util.Hashtable hash
----------------METHODS----------------

public void <init>(
java.security.KeyStore
char[])

private java.lang.String[] chooseAlias(
java.lang.String[]
java.security.Principal[])

public java.lang.String chooseClientAlias(
java.lang.String[]
java.security.Principal[]
java.net.Socket)

public java.lang.String chooseEngineClientAlias(
java.lang.String[]
java.security.Principal[]
javax.net.ssl.SSLEngine)

public java.lang.String chooseEngineServerAlias(
java.lang.String
java.security.Principal[]
javax.net.ssl.SSLEngine)

public java.lang.String chooseServerAlias(
java.lang.String
java.security.Principal[]
java.net.Socket)

public java.security.cert.X509Certificate[] getCertificateChain(
java.lang.String)

public java.lang.String[] getClientAliases(
java.lang.String
java.security.Principal[])

public java.security.PrivateKey getPrivateKey(
java.lang.String)

public java.lang.String[] getServerAliases(
java.lang.String
java.security.Principal[])

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =8 name =null )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/xnet/provider/jsse/Logger; )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<[Ljava/lang/String;>; )
final class org.apache.harmony.xnet.provider.jsse.Logger$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

public volatile java.lang.Object run()

public java.lang.String[] run()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =Stream )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/xnet/provider/jsse/Logger; )
public class org.apache.harmony.xnet.provider.jsse.Logger$Stream extends java.io.PrintStream

----------------FIELDS----------------

private static int indent

private final java.lang.String prefix
----------------METHODS----------------

static void <clinit>()

public void <init>(
java.lang.String)

public void endIndent()

public void newIndent()

public void print(
java.lang.String)

public void print(
byte[])

public void print(
byte[]
int
int)

public void printAsHex(
int
java.lang.String
java.lang.String
byte[])

public void printAsHex(
int
java.lang.String
java.lang.String
byte[]
int
int)

public void println(
java.lang.String)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/apache/harmony/xnet/provider/jsse/Logger$Stream; )
public class org.apache.harmony.xnet.provider.jsse.Logger extends java.lang.Object

----------------FIELDS----------------

private static java.lang.String[] names
----------------METHODS----------------

static void <clinit>()

public void <init>()

public static org.apache.harmony.xnet.provider.jsse.Logger$Stream getStream(
java.lang.String)

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.NativeCrypto extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

static void <clinit>()

public void <init>()

public static native int EVP_DigestBlockSize(
int)

public static native int EVP_DigestFinal(
int
byte[]
int)

public static native void EVP_DigestInit(
int
java.lang.String)

public static native int EVP_DigestSize(
int)

public static native void EVP_DigestUpdate(
int
byte[]
int
int)

public static native void EVP_PKEY_free(
int)

public static native int EVP_PKEY_new_DSA(
byte[]
byte[]
byte[]
byte[]
byte[])

public static native int EVP_PKEY_new_RSA(
byte[]
byte[]
byte[]
byte[]
byte[])

public static native int EVP_VerifyFinal(
int
byte[]
int
int
int)

public static native void EVP_VerifyInit(
int
java.lang.String)

public static native void EVP_VerifyUpdate(
int
byte[]
int
int)

public static native void EVP_free(
int)

public static native int EVP_new()

________________CLASS________________


public abstract interface class org.bouncycastle.crypto.Digest extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract int doFinal(
byte[]
int)

public abstract java.lang.String getAlgorithmName()

public abstract int getDigestSize()

public abstract void reset()

public abstract void update(
byte)

public abstract void update(
byte[]
int
int)

________________CLASS________________


public abstract interface class org.bouncycastle.crypto.ExtendedDigest extends java.lang.Object implements org.bouncycastle.crypto.Digest

----------------FIELDS----------------
----------------METHODS----------------

public abstract int getByteLength()

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.OpenSSLMessageDigest extends java.lang.Object implements org.bouncycastle.crypto.ExtendedDigest

----------------FIELDS----------------

private java.lang.String algorithm

private int ctx

private byte[] singleByte
----------------METHODS----------------

private void <init>(
java.lang.String)

public static org.apache.harmony.xnet.provider.jsse.OpenSSLMessageDigest getInstance(
java.lang.String)

public int doFinal(
byte[]
int)
@dalvik.annotation.Throws (value =Ljava/lang/Throwable; )
protected void finalize()

public java.lang.String getAlgorithmName()

public int getByteLength()

public int getDigestSize()

public void reset()

public void update(
byte)

public void update(
byte[]
int
int)

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.OpenSSLMessageDigestJDK extends java.security.MessageDigest

----------------FIELDS----------------

private int ctx

private byte[] singleByte
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
private void <init>(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public static org.apache.harmony.xnet.provider.jsse.OpenSSLMessageDigestJDK getInstance(
java.lang.String)

protected byte[] engineDigest()

protected void engineReset()

protected void engineUpdate(
byte)

protected void engineUpdate(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/lang/Throwable; )
protected void finalize()

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.OpenSSLServerSocketFactoryImpl extends javax.net.ssl.SSLServerSocketFactory

----------------FIELDS----------------

private java.io.IOException instantiationException

private org.apache.harmony.xnet.provider.jsse.SSLParameters sslParameters
----------------METHODS----------------

public void <init>()

public void <init>(
org.apache.harmony.xnet.provider.jsse.SSLParameters)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.net.ServerSocket createServerSocket()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.net.ServerSocket createServerSocket(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.net.ServerSocket createServerSocket(
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.net.ServerSocket createServerSocket(
int
int
java.net.InetAddress)

public java.lang.String[] getDefaultCipherSuites()

public java.lang.String[] getSupportedCipherSuites()

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.OpenSSLServerSocketImpl extends javax.net.ssl.SSLServerSocket

----------------FIELDS----------------

private static long SSL_OP_NO_SSLv3

private static long SSL_OP_NO_TLSv1

private static int SSL_VERIFY_CLIENT_ONCE

private static int SSL_VERIFY_FAIL_IF_NO_PEER_CERT

private static int SSL_VERIFY_NONE

private static int SSL_VERIFY_PEER

private static final java.lang.String[] supportedProtocols

private boolean client_mode

private org.apache.harmony.xnet.provider.jsse.SSLParameters sslParameters

private int ssl_ctx

private long ssl_op_no
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void <init>(
int
int
java.net.InetAddress
org.apache.harmony.xnet.provider.jsse.SSLParameters)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void <init>(
int
int
org.apache.harmony.xnet.provider.jsse.SSLParameters)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void <init>(
int
org.apache.harmony.xnet.provider.jsse.SSLParameters)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void <init>(
org.apache.harmony.xnet.provider.jsse.SSLParameters)

private boolean findSuite(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void init()

private native void nativefree()

private native java.lang.String[] nativegetenabledciphersuites()

static native java.lang.String[] nativegetsupportedciphersuites()

private native void nativeinit(
java.lang.String
java.lang.String
byte[])

private static native void nativeinitstatic()

private native void nativesetclientauth(
int)

private native void nativesetenabledciphersuites(
java.lang.String)

private native void nativesetenabledprotocols(
long)

private void setClientAuth()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.net.Socket accept()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/lang/Throwable; )
protected void finalize()

public boolean getEnableSessionCreation()

public java.lang.String[] getEnabledCipherSuites()

public java.lang.String[] getEnabledProtocols()

public boolean getNeedClientAuth()

public java.lang.String[] getSupportedCipherSuites()

public java.lang.String[] getSupportedProtocols()

public boolean getUseClientMode()

public boolean getWantClientAuth()

public void setEnableSessionCreation(
boolean)

public void setEnabledCipherSuites(
java.lang.String[])

public void setEnabledProtocols(
java.lang.String[])

public void setNeedClientAuth(
boolean)

public void setUseClientMode(
boolean)

public void setWantClientAuth(
boolean)

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.OpenSSLSessionImpl extends java.lang.Object implements javax.net.ssl.SSLSession

----------------FIELDS----------------

private boolean isValid

 long lastAccessedTime

 java.security.cert.X509Certificate[] localCertificates

private javax.security.cert.X509Certificate[] peerCertificateChain

 java.security.cert.X509Certificate[] peerCertificates

private java.lang.String peerHost

private int peerPort

protected int session

private org.apache.harmony.xnet.provider.jsse.SSLParameters sslParameters

private org.apache.harmony.luni.util.TwoKeyHashMap values
----------------METHODS----------------

protected void <init>(
int
org.apache.harmony.xnet.provider.jsse.SSLParameters
java.lang.String
int)

private native void nativefree(
int)

private native java.lang.String nativegetciphersuite()

private native long nativegetcreationtime()

private native byte[] nativegetid()

private native byte[][] nativegetpeercertificates()

private native java.lang.String nativegetpeerhost()

private native java.lang.String nativegetpeerport()

private native java.lang.String nativegetprotocol()

protected void finalize()

public int getApplicationBufferSize()

public java.lang.String getCipherSuite()

public long getCreationTime()

public byte[] getId()

public long getLastAccessedTime()

public java.security.cert.Certificate[] getLocalCertificates()

public java.security.Principal getLocalPrincipal()

public int getPacketBufferSize()
@dalvik.annotation.Throws (value =Ljavax/net/ssl/SSLPeerUnverifiedException; )
public javax.security.cert.X509Certificate[] getPeerCertificateChain()
@dalvik.annotation.Throws (value =Ljavax/net/ssl/SSLPeerUnverifiedException; )
public java.security.cert.Certificate[] getPeerCertificates()

public java.lang.String getPeerHost()

public int getPeerPort()
@dalvik.annotation.Throws (value =Ljavax/net/ssl/SSLPeerUnverifiedException; )
public java.security.Principal getPeerPrincipal()

public java.lang.String getProtocol()

public javax.net.ssl.SSLSessionContext getSessionContext()

public java.lang.Object getValue(
java.lang.String)

public java.lang.String[] getValueNames()

public void invalidate()

public boolean isValid()

public void putValue(
java.lang.String
java.lang.Object)

public void removeValue(
java.lang.String)

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.OpenSSLSignature extends java.security.Signature

----------------FIELDS----------------

private int ctx

private int dsa

private java.lang.String evpAlgorithm

private int rsa

private byte[] singleByte
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
private void <init>(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
public static org.apache.harmony.xnet.provider.jsse.OpenSSLSignature getInstance(
java.lang.String)

private static void log(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/InvalidParameterException; )
protected java.lang.Object engineGetParameter(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
protected void engineInitSign(
java.security.PrivateKey)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
protected void engineInitVerify(
java.security.PublicKey)
@dalvik.annotation.Throws (value =Ljava/security/InvalidParameterException; )
protected void engineSetParameter(
java.lang.String
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
protected byte[] engineSign()

protected void engineUpdate(
byte)

protected void engineUpdate(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
protected boolean engineVerify(
byte[])
@dalvik.annotation.Throws (value =Ljava/lang/Throwable; )
protected void finalize()

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.OpenSSLSocketFactoryImpl extends javax.net.ssl.SSLSocketFactory

----------------FIELDS----------------

private java.io.IOException instantiationException

private org.apache.harmony.xnet.provider.jsse.SSLParameters sslParameters
----------------METHODS----------------

public void <init>()

public void <init>(
org.apache.harmony.xnet.provider.jsse.SSLParameters)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.net.Socket createSocket()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/net/UnknownHostException; )
public java.net.Socket createSocket(
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/net/UnknownHostException; )
public java.net.Socket createSocket(
java.lang.String
int
java.net.InetAddress
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.net.Socket createSocket(
java.net.InetAddress
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.net.Socket createSocket(
java.net.InetAddress
int
java.net.InetAddress
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.net.Socket createSocket(
java.net.Socket
java.lang.String
int
boolean)

public java.lang.String[] getDefaultCipherSuites()

public java.lang.String[] getSupportedCipherSuites()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/xnet/provider/jsse/OpenSSLSocketImpl; )
@dalvik.annotation.InnerClass (accessFlags =4104 name =null )
 class org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl$1 extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =2 name =Finalizer )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/xnet/provider/jsse/OpenSSLSocketImpl; )
 class org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl$Finalizer extends java.lang.Thread

----------------FIELDS----------------

final org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl this$0
----------------METHODS----------------

private void <init>(
org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl)

 void <init>(
org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl
org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl$1)

public void run()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/xnet/provider/jsse/OpenSSLSocketImpl; )
@dalvik.annotation.InnerClass (accessFlags =2 name =SSLInputStream )
 class org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl$SSLInputStream extends java.io.InputStream

----------------FIELDS----------------

final org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl this$0
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void <init>(
org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[]
int
int)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =2 name =SSLOutputStream )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/xnet/provider/jsse/OpenSSLSocketImpl; )
 class org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl$SSLOutputStream extends java.io.OutputStream

----------------FIELDS----------------

final org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl this$0
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void <init>(
org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
byte[]
int
int)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/apache/harmony/xnet/provider/jsse/OpenSSLSocketImpl$1;Lorg/apache/harmony/xnet/provider/jsse/OpenSSLSocketImpl$Finalizer;Lorg/apache/harmony/xnet/provider/jsse/OpenSSLSocketImpl$SSLOutputStream;Lorg/apache/harmony/xnet/provider/jsse/OpenSSLSocketImpl$SSLInputStream; )
public class org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl extends javax.net.ssl.SSLSocket

----------------FIELDS----------------

private static long SSL_OP_NO_SSLv3

private static long SSL_OP_NO_TLSv1

private static int instanceCount

private static final java.lang.String[] supportedProtocols

private java.net.InetSocketAddress address

private boolean autoClose

private java.lang.Object handshakeLock

private boolean handshakeStarted

private java.io.InputStream is

private java.util.ArrayList listeners

private java.io.OutputStream os

private java.lang.Object readLock

private java.net.Socket socket

private int ssl

private org.apache.harmony.xnet.provider.jsse.SSLParameters sslParameters

private org.apache.harmony.xnet.provider.jsse.OpenSSLSessionImpl sslSession

private int ssl_ctx

private long ssl_op_no

private int timeout

private java.lang.Object writeLock
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void <init>(
java.lang.String
int
java.net.InetAddress
int
org.apache.harmony.xnet.provider.jsse.SSLParameters)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void <init>(
java.lang.String
int
org.apache.harmony.xnet.provider.jsse.SSLParameters)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void <init>(
java.net.InetAddress
int
java.net.InetAddress
int
org.apache.harmony.xnet.provider.jsse.SSLParameters)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void <init>(
java.net.InetAddress
int
org.apache.harmony.xnet.provider.jsse.SSLParameters)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void <init>(
java.net.Socket
java.lang.String
int
boolean
org.apache.harmony.xnet.provider.jsse.SSLParameters)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void <init>(
org.apache.harmony.xnet.provider.jsse.SSLParameters)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void <init>(
org.apache.harmony.xnet.provider.jsse.SSLParameters
long)

static java.lang.Object access$000(
org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl)

static int access$100(
org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
static int access$200(
org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
static int access$300(
org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl
byte[]
int
int
int)

static java.lang.Object access$400(
org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
static void access$500(
org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
static void access$600(
org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl
byte[]
int
int)

static java.net.Socket access$800(
org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl)

private boolean findSuite(
java.lang.String)

public static int getInstanceCount()

private org.apache.harmony.xnet.provider.jsse.OpenSSLSessionImpl getOpenSSLSessionImpl()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void init()

private native java.lang.String nativecipherauthenticationmethod()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private native void nativeclose()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private native boolean nativeconnect(
int
java.net.Socket
boolean
int)

private native void nativefree()

private native java.lang.String[] nativegetenabledciphersuites()

private native int nativegetsslsession(
int)

static native java.lang.String[] nativegetsupportedciphersuites()

private native void nativeinit(
java.lang.String
java.lang.String
byte[])

private static native void nativeinitstatic()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private native void nativeinterrupt()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private native int nativeread(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private native int nativeread(
byte[]
int
int
int)

private native void nativesetenabledciphersuites(
java.lang.String)

private native void nativesetenabledprotocols(
long)

private static native int nativeverifysignature(
byte[]
byte[]
java.lang.String
byte[]
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private native void nativewrite(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private native void nativewrite(
byte[]
int
int)

private static void updateInstanceCount(
int)

public static boolean verifySignature(
byte[]
byte[]
java.lang.String
java.security.interfaces.RSAPublicKey)

private int verify_callback(
byte[][])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void accept(
int
boolean)

public void addHandshakeCompletedListener(
javax.net.ssl.HandshakeCompletedListener)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void close()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void finalize()

public boolean getEnableSessionCreation()

public java.lang.String[] getEnabledCipherSuites()

public java.lang.String[] getEnabledProtocols()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.io.InputStream getInputStream()

public boolean getNeedClientAuth()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public java.io.OutputStream getOutputStream()

public javax.net.ssl.SSLSession getSession()

public java.lang.String[] getSupportedCipherSuites()

public java.lang.String[] getSupportedProtocols()

public boolean getUseClientMode()

public boolean getWantClientAuth()

synchronized native void nativeaccept(
java.net.Socket
int
boolean)

public void removeHandshakeCompletedListener(
javax.net.ssl.HandshakeCompletedListener)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void sendUrgentData(
int)

public void setEnableSessionCreation(
boolean)

public void setEnabledCipherSuites(
java.lang.String[])

public void setEnabledProtocols(
java.lang.String[])

public void setNeedClientAuth(
boolean)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void setOOBInline(
boolean)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void setSoTimeout(
int)

public void setUseClientMode(
boolean)

public void setWantClientAuth(
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void shutdownInput()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void shutdownOutput()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void startHandshake()

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImplWrapper extends org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl

----------------FIELDS----------------

private java.net.Socket socket
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void <init>(
java.net.Socket
java.lang.String
int
boolean
org.apache.harmony.xnet.provider.jsse.SSLParameters)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void bind(
java.net.SocketAddress)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void connect(
java.net.SocketAddress)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void connect(
java.net.SocketAddress
int)

public java.net.InetAddress getInetAddress()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public boolean getKeepAlive()

public java.net.InetAddress getLocalAddress()

public int getLocalPort()

public java.net.SocketAddress getLocalSocketAddress()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public boolean getOOBInline()

public int getPort()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public int getReceiveBufferSize()

public java.net.SocketAddress getRemoteSocketAddress()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public boolean getReuseAddress()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public int getSendBufferSize()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public int getSoLinger()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public int getSoTimeout()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public boolean getTcpNoDelay()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public int getTrafficClass()

public boolean isBound()

public boolean isClosed()

public boolean isConnected()

public boolean isInputShutdown()

public boolean isOutputShutdown()
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void setKeepAlive(
boolean)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void setReceiveBufferSize(
int)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void setReuseAddress(
boolean)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void setSendBufferSize(
int)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void setSoLinger(
boolean
int)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void setSoTimeout(
int)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void setTcpNoDelay(
boolean)
@dalvik.annotation.Throws (value =Ljava/net/SocketException; )
public void setTrafficClass(
int)

public java.lang.String toString()

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.PRF extends java.lang.Object

----------------FIELDS----------------

private static org.apache.harmony.xnet.provider.jsse.Logger$Stream logger

protected static java.security.MessageDigest md5

private static javax.crypto.Mac md5_mac

private static int md5_mac_length

protected static java.security.MessageDigest sha

private static javax.crypto.Mac sha_mac

private static int sha_mac_length
----------------METHODS----------------

static void <clinit>()

public void <init>()
@dalvik.annotation.Throws (value =Ljava/security/GeneralSecurityException; )
static void computePRF(
byte[]
byte[]
byte[]
byte[])

static void computePRF_SSLv3(
byte[]
byte[]
byte[])

private static void init()

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.ProtocolVersion extends java.lang.Object

----------------FIELDS----------------

public static org.apache.harmony.xnet.provider.jsse.ProtocolVersion SSLv3

public static org.apache.harmony.xnet.provider.jsse.ProtocolVersion TLSv1

private static java.util.Hashtable protocolsByName

public static final java.lang.String[] supportedProtocols

public final java.lang.String name

public final byte[] version
----------------METHODS----------------

static void <clinit>()

private void <init>(
java.lang.String
byte[])

public static org.apache.harmony.xnet.provider.jsse.ProtocolVersion getByName(
java.lang.String)

public static org.apache.harmony.xnet.provider.jsse.ProtocolVersion getByVersion(
byte[])

public static org.apache.harmony.xnet.provider.jsse.ProtocolVersion getLatestVersion(
java.lang.String[])

public static boolean isSupported(
java.lang.String)

public static boolean isSupported(
byte[])

public boolean equals(
java.lang.Object)

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.SSLBufferedInput extends org.apache.harmony.xnet.provider.jsse.SSLInputStream

----------------FIELDS----------------

private int bytik

private int consumed

private java.nio.ByteBuffer in
----------------METHODS----------------

protected void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int available()

protected int consumed()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()

protected void setSourceBuffer(
java.nio.ByteBuffer)

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.SSLContextImpl extends javax.net.ssl.SSLContextSpi

----------------FIELDS----------------

private org.apache.harmony.xnet.provider.jsse.SSLSessionContextImpl clientSessionContext

private org.apache.harmony.xnet.provider.jsse.SSLSessionContextImpl serverSessionContext

protected org.apache.harmony.xnet.provider.jsse.SSLParameters sslParameters
----------------METHODS----------------

public void <init>()

public javax.net.ssl.SSLEngine engineCreateSSLEngine()

public javax.net.ssl.SSLEngine engineCreateSSLEngine(
java.lang.String
int)

public javax.net.ssl.SSLSessionContext engineGetClientSessionContext()

public javax.net.ssl.SSLSessionContext engineGetServerSessionContext()

public javax.net.ssl.SSLServerSocketFactory engineGetServerSocketFactory()

public javax.net.ssl.SSLSocketFactory engineGetSocketFactory()
@dalvik.annotation.Throws (value =Ljava/security/KeyManagementException; )
public void engineInit(
javax.net.ssl.KeyManager[]
javax.net.ssl.TrustManager[]
java.security.SecureRandom)

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.SSLEngineAppData extends java.lang.Object implements org.apache.harmony.xnet.provider.jsse.Appendable

----------------FIELDS----------------

 byte[] buffer
----------------METHODS----------------

protected void <init>()

public void append(
byte[])

protected int placeTo(
java.nio.ByteBuffer[]
int
int)

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.SSLEngineDataStream extends java.lang.Object implements org.apache.harmony.xnet.provider.jsse.DataStream

----------------FIELDS----------------

private int available

private int consumed

private int limit

private int offset

private java.nio.ByteBuffer[] srcs
----------------METHODS----------------

protected void <init>()

public int available()

protected int consumed()

public byte[] getData(
int)

public boolean hasData()

protected void setSourceBuffers(
java.nio.ByteBuffer[]
int
int)

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.SSLEngineImpl extends javax.net.ssl.SSLEngine

----------------FIELDS----------------

private org.apache.harmony.xnet.provider.jsse.AlertProtocol alertProtocol

private org.apache.harmony.xnet.provider.jsse.SSLEngineAppData appData

private boolean close_notify_was_received

private boolean close_notify_was_sent

private org.apache.harmony.xnet.provider.jsse.SSLEngineDataStream dataStream

private boolean engine_was_closed

private boolean engine_was_shutteddown

private org.apache.harmony.xnet.provider.jsse.HandshakeProtocol handshakeProtocol

private boolean handshake_started

private boolean isInboundDone

private boolean isOutboundDone

private org.apache.harmony.xnet.provider.jsse.Logger$Stream logger

private boolean peer_mode_was_set

private org.apache.harmony.xnet.provider.jsse.SSLBufferedInput recProtIS

protected org.apache.harmony.xnet.provider.jsse.SSLRecordProtocol recordProtocol

private byte[] remaining_hsh_data

private byte[] remaining_wrapped_data

private org.apache.harmony.xnet.provider.jsse.SSLSessionImpl session

protected org.apache.harmony.xnet.provider.jsse.SSLParameters sslParameters
----------------METHODS----------------

protected void <init>(
java.lang.String
int
org.apache.harmony.xnet.provider.jsse.SSLParameters)

protected void <init>(
org.apache.harmony.xnet.provider.jsse.SSLParameters)

private javax.net.ssl.SSLEngineResult$Status getEngineStatus()

private void shutdown()
@dalvik.annotation.Throws (value =Ljavax/net/ssl/SSLException; )
public void beginHandshake()
@dalvik.annotation.Throws (value =Ljavax/net/ssl/SSLException; )
public void closeInbound()

public void closeOutbound()

public java.lang.Runnable getDelegatedTask()

public boolean getEnableSessionCreation()

public java.lang.String[] getEnabledCipherSuites()

public java.lang.String[] getEnabledProtocols()

public javax.net.ssl.SSLEngineResult$HandshakeStatus getHandshakeStatus()

public boolean getNeedClientAuth()

public javax.net.ssl.SSLSession getSession()

public java.lang.String[] getSupportedCipherSuites()

public java.lang.String[] getSupportedProtocols()

public boolean getUseClientMode()

public boolean getWantClientAuth()

public boolean isInboundDone()

public boolean isOutboundDone()

public void setEnableSessionCreation(
boolean)

public void setEnabledCipherSuites(
java.lang.String[])

public void setEnabledProtocols(
java.lang.String[])

public void setNeedClientAuth(
boolean)

public void setUseClientMode(
boolean)

public void setWantClientAuth(
boolean)
@dalvik.annotation.Throws (value =Ljavax/net/ssl/SSLException; )
public javax.net.ssl.SSLEngineResult unwrap(
java.nio.ByteBuffer
java.nio.ByteBuffer[]
int
int)
@dalvik.annotation.Throws (value =Ljavax/net/ssl/SSLException; )
public javax.net.ssl.SSLEngineResult wrap(
java.nio.ByteBuffer[]
int
int
java.nio.ByteBuffer)

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.SSLParameters extends java.lang.Object

----------------FIELDS----------------

private static javax.net.ssl.X509KeyManager defaultKeyManager

private static org.apache.harmony.xnet.provider.jsse.SSLParameters defaultParameters

private static java.security.SecureRandom defaultSecureRandom

private static javax.net.ssl.X509TrustManager defaultTrustManager

private org.apache.harmony.xnet.provider.jsse.SSLSessionContextImpl clientSessionContext

private boolean client_mode

private boolean enable_session_creation

private java.lang.String[] enabledCipherSuiteNames

private org.apache.harmony.xnet.provider.jsse.CipherSuite[] enabledCipherSuites

private java.lang.String[] enabledProtocols

private javax.net.ssl.X509KeyManager keyManager

private boolean need_client_auth

private java.security.SecureRandom secureRandom

private org.apache.harmony.xnet.provider.jsse.SSLSessionContextImpl serverSessionContext

private int ssl_ctx

private javax.net.ssl.X509TrustManager trustManager

private boolean want_client_auth
----------------METHODS----------------

private void <init>()
@dalvik.annotation.Throws (value =Ljava/security/KeyManagementException; )
protected void <init>(
javax.net.ssl.KeyManager[]
javax.net.ssl.TrustManager[]
java.security.SecureRandom
org.apache.harmony.xnet.provider.jsse.SSLSessionContextImpl
org.apache.harmony.xnet.provider.jsse.SSLSessionContextImpl)
@dalvik.annotation.Throws (value =Ljava/security/KeyManagementException; )
protected static org.apache.harmony.xnet.provider.jsse.SSLParameters getDefault()

private native int nativeinitsslctx()

protected java.lang.Object clone()

protected org.apache.harmony.xnet.provider.jsse.SSLSessionContextImpl getClientSessionContext()

protected boolean getEnableSessionCreation()

protected java.lang.String[] getEnabledCipherSuites()

protected org.apache.harmony.xnet.provider.jsse.CipherSuite[] getEnabledCipherSuitesMember()

protected java.lang.String[] getEnabledProtocols()

protected javax.net.ssl.X509KeyManager getKeyManager()

protected boolean getNeedClientAuth()

protected int getSSLCTX()

protected java.security.SecureRandom getSecureRandom()

protected java.security.SecureRandom getSecureRandomMember()

protected org.apache.harmony.xnet.provider.jsse.SSLSessionContextImpl getServerSessionContext()

protected javax.net.ssl.X509TrustManager getTrustManager()

protected boolean getUseClientMode()

protected boolean getWantClientAuth()

protected void setEnableSessionCreation(
boolean)

protected void setEnabledCipherSuites(
java.lang.String[])

protected void setEnabledProtocols(
java.lang.String[])

protected void setNeedClientAuth(
boolean)

protected void setUseClientMode(
boolean)

protected void setWantClientAuth(
boolean)

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.SSLRecordProtocol extends java.lang.Object

----------------FIELDS----------------

protected static int MAX_CIPHERED_DATA_LENGTH

protected static int MAX_COMPRESSED_DATA_LENGTH

protected static int MAX_DATA_LENGTH

protected static int MAX_SSL_PACKET_SIZE

private static final byte[] change_cipher_spec_byte

private org.apache.harmony.xnet.provider.jsse.ConnectionState activeReadState

private org.apache.harmony.xnet.provider.jsse.ConnectionState activeWriteState

private org.apache.harmony.xnet.provider.jsse.AlertProtocol alertProtocol

private org.apache.harmony.xnet.provider.jsse.Appendable appData

private org.apache.harmony.xnet.provider.jsse.HandshakeProtocol handshakeProtocol

private org.apache.harmony.xnet.provider.jsse.SSLInputStream in

private org.apache.harmony.xnet.provider.jsse.Logger$Stream logger

private org.apache.harmony.xnet.provider.jsse.ConnectionState pendingConnectionState

private org.apache.harmony.xnet.provider.jsse.SSLSessionImpl session

private boolean sessionWasChanged

private byte[] version
----------------METHODS----------------

static void <clinit>()

protected void <init>(
org.apache.harmony.xnet.provider.jsse.HandshakeProtocol
org.apache.harmony.xnet.provider.jsse.AlertProtocol
org.apache.harmony.xnet.provider.jsse.SSLInputStream
org.apache.harmony.xnet.provider.jsse.Appendable)

private byte[] packetize(
byte
byte[]
byte[])

private void setSession(
org.apache.harmony.xnet.provider.jsse.SSLSessionImpl)

protected void alert(
byte
byte)

protected byte[] getChangeCipherSpecMesage(
org.apache.harmony.xnet.provider.jsse.SSLSessionImpl)

protected int getDataSize(
int)

protected int getMinRecordSize()

protected int getRecordSize(
int)

protected org.apache.harmony.xnet.provider.jsse.SSLSessionImpl getSession()

protected void setVersion(
byte[])

protected void shutdown()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected int unwrap()

protected byte[] wrap(
byte
org.apache.harmony.xnet.provider.jsse.DataStream)

protected byte[] wrap(
byte
byte[]
int
int)

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/util/LinkedHashMap<[BLjavax/net/ssl/SSLSession;>; )
@dalvik.annotation.EnclosingClass (value =Lorg/apache/harmony/xnet/provider/jsse/SSLSessionContextImpl; )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
 class org.apache.harmony.xnet.provider.jsse.SSLSessionContextImpl$1 extends java.util.LinkedHashMap

----------------FIELDS----------------

final org.apache.harmony.xnet.provider.jsse.SSLSessionContextImpl this$0
----------------METHODS----------------

 void <init>(
org.apache.harmony.xnet.provider.jsse.SSLSessionContextImpl
int
float
boolean)

public boolean removeEldestEntry(
java.util.Map$Entry)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/util/Enumeration<[B>; )
@dalvik.annotation.EnclosingMethod (value =null )
 class org.apache.harmony.xnet.provider.jsse.SSLSessionContextImpl$2 extends java.lang.Object implements java.util.Enumeration

----------------FIELDS----------------
@dalvik.annotation.Signature (value =Ljava/util/Iterator<[B>; )
 java.util.Iterator iterator

final org.apache.harmony.xnet.provider.jsse.SSLSessionContextImpl this$0
----------------METHODS----------------

 void <init>(
org.apache.harmony.xnet.provider.jsse.SSLSessionContextImpl)

public boolean hasMoreElements()

public volatile java.lang.Object nextElement()

public byte[] nextElement()

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.SSLSessionContextImpl extends java.lang.Object implements javax.net.ssl.SSLSessionContext

----------------FIELDS----------------

private int cacheSize
@dalvik.annotation.Signature (value =Ljava/util/LinkedHashMap<[BLjavax/net/ssl/SSLSession;>; )
private volatile java.util.LinkedHashMap clone
@dalvik.annotation.Signature (value =Ljava/util/LinkedHashMap<[BLjavax/net/ssl/SSLSession;>; )
private final java.util.LinkedHashMap sessions

private long timeout
----------------METHODS----------------

public void <init>()

static int access$000(
org.apache.harmony.xnet.provider.jsse.SSLSessionContextImpl)

static java.util.LinkedHashMap access$100(
org.apache.harmony.xnet.provider.jsse.SSLSessionContextImpl)
@dalvik.annotation.Signature (value =()Ljava/util/Enumeration<[B>; )
public java.util.Enumeration getIds()

public javax.net.ssl.SSLSession getSession(
byte[])

public int getSessionCacheSize()

public int getSessionTimeout()

 void putSession(
javax.net.ssl.SSLSession)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public void setSessionCacheSize(
int)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public void setSessionTimeout(
int)

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.SSLSessionImpl extends java.lang.Object implements javax.net.ssl.SSLSession

----------------FIELDS----------------

public static final org.apache.harmony.xnet.provider.jsse.SSLSessionImpl NULL_SESSION

 org.apache.harmony.xnet.provider.jsse.CipherSuite cipherSuite

 byte[] clientRandom

 org.apache.harmony.xnet.provider.jsse.SSLSessionContextImpl context

private long creationTime

 byte[] id

 boolean isServer

private boolean isValid

 long lastAccessedTime

 java.security.cert.X509Certificate[] localCertificates

 byte[] master_secret

 java.security.cert.X509Certificate[] peerCertificates

 java.lang.String peerHost

 int peerPort

 org.apache.harmony.xnet.provider.jsse.ProtocolVersion protocol

 byte[] serverRandom

private org.apache.harmony.luni.util.TwoKeyHashMap values
----------------METHODS----------------

static void <clinit>()

private void <init>()

public void <init>(
java.security.SecureRandom)

public void <init>(
org.apache.harmony.xnet.provider.jsse.CipherSuite
java.security.SecureRandom)

public java.lang.Object clone()

public int getApplicationBufferSize()

public java.lang.String getCipherSuite()

public long getCreationTime()

public byte[] getId()

public long getLastAccessedTime()

public java.security.cert.Certificate[] getLocalCertificates()

public java.security.Principal getLocalPrincipal()

public int getPacketBufferSize()
@dalvik.annotation.Throws (value =Ljavax/net/ssl/SSLPeerUnverifiedException; )
public javax.security.cert.X509Certificate[] getPeerCertificateChain()
@dalvik.annotation.Throws (value =Ljavax/net/ssl/SSLPeerUnverifiedException; )
public java.security.cert.Certificate[] getPeerCertificates()

public java.lang.String getPeerHost()

public int getPeerPort()
@dalvik.annotation.Throws (value =Ljavax/net/ssl/SSLPeerUnverifiedException; )
public java.security.Principal getPeerPrincipal()

public java.lang.String getProtocol()

public javax.net.ssl.SSLSessionContext getSessionContext()

public java.lang.Object getValue(
java.lang.String)

public java.lang.String[] getValueNames()

public void invalidate()

public boolean isValid()

public void putValue(
java.lang.String
java.lang.Object)

public void removeValue(
java.lang.String)

 void setPeer(
java.lang.String
int)

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.SSLStreamedInput extends org.apache.harmony.xnet.provider.jsse.SSLInputStream

----------------FIELDS----------------

private java.io.InputStream in
----------------METHODS----------------

public void <init>(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int available()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.SSLv3Constants extends java.lang.Object

----------------FIELDS----------------

static final byte[] MD5pad1

static final byte[] MD5pad2

static final byte[] SHApad1

static final byte[] SHApad2

static final byte[] client

static final byte[] server
----------------METHODS----------------

static void <clinit>()

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
 class org.apache.harmony.xnet.provider.jsse.ServerHandshakeImpl$1 extends java.lang.Object implements java.security.PrivilegedExceptionAction

----------------FIELDS----------------

final org.apache.harmony.xnet.provider.jsse.ServerHandshakeImpl this$0
----------------METHODS----------------

 void <init>(
org.apache.harmony.xnet.provider.jsse.ServerHandshakeImpl)
@dalvik.annotation.Throws (value =Ljava/lang/Exception; )
public java.lang.Object run()

________________CLASS________________

@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
 class org.apache.harmony.xnet.provider.jsse.ServerHandshakeImpl$2 extends java.lang.Object implements java.security.PrivilegedExceptionAction

----------------FIELDS----------------

final org.apache.harmony.xnet.provider.jsse.ServerHandshakeImpl this$0
----------------METHODS----------------

 void <init>(
org.apache.harmony.xnet.provider.jsse.ServerHandshakeImpl)
@dalvik.annotation.Throws (value =Ljava/lang/Exception; )
public java.lang.Object run()

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.ServerHandshakeImpl extends org.apache.harmony.xnet.provider.jsse.HandshakeProtocol

----------------FIELDS----------------

private java.security.PrivateKey privKey
----------------METHODS----------------

public void <init>(
java.lang.Object)

private org.apache.harmony.xnet.provider.jsse.SSLSessionImpl findSessionToResume(
byte[])

private org.apache.harmony.xnet.provider.jsse.CipherSuite selectSuite(
org.apache.harmony.xnet.provider.jsse.CipherSuite[])

protected void makeFinished()

 void processClientHello()

public void receiveChangeCipherSpec()

public void start()

public void unwrap(
byte[])

public void unwrapSSLv2(
byte[])

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.ServerHello extends org.apache.harmony.xnet.provider.jsse.Message

----------------FIELDS----------------

 org.apache.harmony.xnet.provider.jsse.CipherSuite cipher_suite

 byte compression_method

 byte[] random

 byte[] server_version

 byte[] session_id
----------------METHODS----------------

public void <init>(
java.security.SecureRandom
byte[]
byte[]
org.apache.harmony.xnet.provider.jsse.CipherSuite
byte)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
org.apache.harmony.xnet.provider.jsse.HandshakeIODataStream
int)

public byte[] getRandom()

public int getType()

public void send(
org.apache.harmony.xnet.provider.jsse.HandshakeIODataStream)

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.ServerHelloDone extends org.apache.harmony.xnet.provider.jsse.Message

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
org.apache.harmony.xnet.provider.jsse.HandshakeIODataStream
int)

public int getType()

public int length()

public void send(
org.apache.harmony.xnet.provider.jsse.HandshakeIODataStream)

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.ServerKeyExchange extends org.apache.harmony.xnet.provider.jsse.Message

----------------FIELDS----------------

final byte[] bytes1

final byte[] bytes2

final byte[] bytes3

final byte[] hash

private java.security.interfaces.RSAPublicKey key

final java.math.BigInteger par1

final java.math.BigInteger par2

final java.math.BigInteger par3
----------------METHODS----------------

public void <init>(
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
org.apache.harmony.xnet.provider.jsse.HandshakeIODataStream
int
int)

public java.security.interfaces.RSAPublicKey getRSAPublicKey()

public int getType()

public void send(
org.apache.harmony.xnet.provider.jsse.HandshakeIODataStream)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/String;>; )
 class org.apache.harmony.xnet.provider.jsse.TrustManagerFactoryImpl$1 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final org.apache.harmony.xnet.provider.jsse.TrustManagerFactoryImpl this$0
----------------METHODS----------------

 void <init>(
org.apache.harmony.xnet.provider.jsse.TrustManagerFactoryImpl)

public volatile java.lang.Object run()

public java.lang.String run()

________________CLASS________________

@dalvik.annotation.Signature (value =Ljava/lang/Object;Ljava/security/PrivilegedAction<Ljava/lang/String;>; )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingMethod (value =null )
 class org.apache.harmony.xnet.provider.jsse.TrustManagerFactoryImpl$2 extends java.lang.Object implements java.security.PrivilegedAction

----------------FIELDS----------------

final org.apache.harmony.xnet.provider.jsse.TrustManagerFactoryImpl this$0
----------------METHODS----------------

 void <init>(
org.apache.harmony.xnet.provider.jsse.TrustManagerFactoryImpl)

public volatile java.lang.Object run()

public java.lang.String run()

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.TrustManagerFactoryImpl extends javax.net.ssl.TrustManagerFactorySpi

----------------FIELDS----------------

private java.security.KeyStore keyStore
----------------METHODS----------------

public void <init>()

public javax.net.ssl.TrustManager[] engineGetTrustManagers()
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException; )
public void engineInit(
java.security.KeyStore)
@dalvik.annotation.Throws (value =Ljava/security/InvalidAlgorithmParameterException; )
public void engineInit(
javax.net.ssl.ManagerFactoryParameters)

________________CLASS________________


public class org.apache.harmony.xnet.provider.jsse.TrustManagerImpl extends java.lang.Object implements javax.net.ssl.X509TrustManager

----------------FIELDS----------------

private java.lang.Exception err

private java.security.cert.CertificateFactory factory

private java.security.cert.PKIXParameters params

private java.security.cert.CertPathValidator validator
----------------METHODS----------------

public void <init>(
java.security.KeyStore)

private boolean isDirectlyTrustedCert(
java.security.cert.X509Certificate[])
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException; )
public void checkClientTrusted(
java.security.cert.X509Certificate[]
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException; )
public void checkServerTrusted(
java.security.cert.X509Certificate[]
java.lang.String)

public java.security.cert.X509Certificate[] getAcceptedIssuers()

________________CLASS________________


public abstract interface class org.bouncycastle.asn1.ASN1Choice extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/asn1/ASN1Collection; )
@dalvik.annotation.InnerClass (accessFlags =4104 name =null )
 class org.bouncycastle.asn1.ASN1Collection$1 extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =2 name =ASN1CollectionEnumeration )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/asn1/ASN1Collection; )
 class org.bouncycastle.asn1.ASN1Collection$ASN1CollectionEnumeration extends java.lang.Object implements java.util.Enumeration

----------------FIELDS----------------

private int at

private final int origSize

final org.bouncycastle.asn1.ASN1Collection this$0
----------------METHODS----------------

private void <init>(
org.bouncycastle.asn1.ASN1Collection)

 void <init>(
org.bouncycastle.asn1.ASN1Collection
org.bouncycastle.asn1.ASN1Collection$1)

public boolean hasMoreElements()

public java.lang.Object nextElement()

________________CLASS________________


public abstract interface class org.bouncycastle.asn1.DEREncodable extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract org.bouncycastle.asn1.DERObject getDERObject()

________________CLASS________________


public abstract class org.bouncycastle.asn1.ASN1Encodable extends java.lang.Object implements org.bouncycastle.asn1.DEREncodable

----------------FIELDS----------------

public static final java.lang.String BER

public static final java.lang.String DER
----------------METHODS----------------

public void <init>()

public boolean equals(
java.lang.Object)

public byte[] getDEREncoded()

public org.bouncycastle.asn1.DERObject getDERObject()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public byte[] getEncoded()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public byte[] getEncoded(
java.lang.String)

public int hashCode()

public abstract org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public abstract interface class org.bouncycastle.asn1.DERTags extends java.lang.Object

----------------FIELDS----------------

public static final int APPLICATION

public static final int BIT_STRING

public static final int BMP_STRING

public static final int BOOLEAN

public static final int CONSTRUCTED

public static final int ENUMERATED

public static final int EXTERNAL

public static final int GENERALIZED_TIME

public static final int GENERAL_STRING

public static final int GRAPHIC_STRING

public static final int IA5_STRING

public static final int INTEGER

public static final int NULL

public static final int NUMERIC_STRING

public static final int OBJECT_IDENTIFIER

public static final int OCTET_STRING

public static final int PRINTABLE_STRING

public static final int SEQUENCE

public static final int SEQUENCE_OF

public static final int SET

public static final int SET_OF

public static final int T61_STRING

public static final int TAGGED

public static final int UNIVERSAL_STRING

public static final int UTC_TIME

public static final int UTF8_STRING

public static final int VIDEOTEX_STRING

public static final int VISIBLE_STRING
----------------METHODS----------------

________________CLASS________________


public abstract class org.bouncycastle.asn1.DERObject extends org.bouncycastle.asn1.ASN1Encodable implements org.bouncycastle.asn1.DERTags

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
abstract void encode(
org.bouncycastle.asn1.DEROutputStream)

public abstract boolean equals(
java.lang.Object)

public abstract int hashCode()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/bouncycastle/asn1/ASN1Collection$1;Lorg/bouncycastle/asn1/ASN1Collection$ASN1CollectionEnumeration; )
public abstract class org.bouncycastle.asn1.ASN1Collection extends org.bouncycastle.asn1.DERObject

----------------FIELDS----------------

private org.bouncycastle.asn1.DEREncodable obj0

private org.bouncycastle.asn1.DEREncodable obj1

private org.bouncycastle.asn1.DEREncodable obj2

private org.bouncycastle.asn1.DEREncodable obj3

private org.bouncycastle.asn1.DEREncodable[] rest

private int size
----------------METHODS----------------

public void <init>()

static int access$100(
org.bouncycastle.asn1.ASN1Collection)

static org.bouncycastle.asn1.DEREncodable access$200(
org.bouncycastle.asn1.ASN1Collection)

static org.bouncycastle.asn1.DEREncodable access$300(
org.bouncycastle.asn1.ASN1Collection)

static org.bouncycastle.asn1.DEREncodable access$400(
org.bouncycastle.asn1.ASN1Collection)

static org.bouncycastle.asn1.DEREncodable access$500(
org.bouncycastle.asn1.ASN1Collection)

static org.bouncycastle.asn1.DEREncodable[] access$600(
org.bouncycastle.asn1.ASN1Collection)

private static byte[] getEncoded(
org.bouncycastle.asn1.DEREncodable)

private static boolean lessThanOrEqual(
byte[]
byte[])

private void setObjectAt(
org.bouncycastle.asn1.DEREncodable
int)

protected void addObject(
org.bouncycastle.asn1.DEREncodable)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
abstract void encode(
org.bouncycastle.asn1.DEROutputStream)

public final org.bouncycastle.asn1.DEREncodable getObjectAt(
int)

public final java.util.Enumeration getObjects()

public final int hashCode()

public final int size()

protected void sort()

public final java.lang.String toString()

________________CLASS________________


public class org.bouncycastle.asn1.DEREncodableVector extends java.lang.Object

----------------FIELDS----------------

private java.util.Vector v
----------------METHODS----------------

public void <init>()

public void add(
org.bouncycastle.asn1.DEREncodable)

public org.bouncycastle.asn1.DEREncodable get(
int)

public int size()

________________CLASS________________


public class org.bouncycastle.asn1.ASN1EncodableVector extends org.bouncycastle.asn1.DEREncodableVector

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =0 name =null )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/asn1/ASN1InputStream; )
 class org.bouncycastle.asn1.ASN1InputStream$1 extends org.bouncycastle.asn1.DERObject

----------------FIELDS----------------

final org.bouncycastle.asn1.ASN1InputStream this$0
----------------METHODS----------------

 void <init>(
org.bouncycastle.asn1.ASN1InputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void encode(
org.bouncycastle.asn1.DEROutputStream)

public boolean equals(
java.lang.Object)

public int hashCode()

________________CLASS________________


public class org.bouncycastle.asn1.ASN1InputStream extends java.io.FilterInputStream implements org.bouncycastle.asn1.DERTags

----------------FIELDS----------------

private org.bouncycastle.asn1.DERObject END_OF_STREAM

 boolean eofFound

 int limit
----------------METHODS----------------

public void <init>(
java.io.InputStream)

public void <init>(
java.io.InputStream
int)

public void <init>(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private org.bouncycastle.asn1.BERConstructedOctetString buildConstructedOctetString()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private org.bouncycastle.asn1.BERConstructedOctetString buildDerConstructedOctetString(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private byte[] readIndefiniteLengthFully()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private int readTagNumber(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected org.bouncycastle.asn1.DERObject buildObject(
int
int
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void readFully(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected int readLength()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public org.bouncycastle.asn1.DERObject readObject()

________________CLASS________________


public abstract class org.bouncycastle.asn1.ASN1Null extends org.bouncycastle.asn1.DERObject

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
abstract void encode(
org.bouncycastle.asn1.DEROutputStream)

public boolean equals(
java.lang.Object)

public int hashCode()

public java.lang.String toString()

________________CLASS________________


public abstract class org.bouncycastle.asn1.ASN1OctetString extends org.bouncycastle.asn1.DERObject

----------------FIELDS----------------

 byte[] string
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.DEREncodable)

public void <init>(
byte[])

public static org.bouncycastle.asn1.ASN1OctetString getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.ASN1OctetString getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
abstract void encode(
org.bouncycastle.asn1.DEROutputStream)

public boolean equals(
java.lang.Object)

public byte[] getOctets()

public int hashCode()

public java.lang.String toString()

________________CLASS________________


public class org.bouncycastle.asn1.DEROutputStream extends java.io.FilterOutputStream implements org.bouncycastle.asn1.DERTags

----------------FIELDS----------------
----------------METHODS----------------

public void <init>(
java.io.OutputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeLength(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void writeEncoded(
int
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void writeNull()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void writeObject(
java.lang.Object)

________________CLASS________________


public class org.bouncycastle.asn1.ASN1OutputStream extends org.bouncycastle.asn1.DEROutputStream

----------------FIELDS----------------
----------------METHODS----------------

public void <init>(
java.io.OutputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void writeObject(
java.lang.Object)

________________CLASS________________


public abstract class org.bouncycastle.asn1.ASN1Sequence extends org.bouncycastle.asn1.ASN1Collection

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public static org.bouncycastle.asn1.ASN1Sequence getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.ASN1Sequence getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public boolean equals(
java.lang.Object)

________________CLASS________________


public abstract class org.bouncycastle.asn1.ASN1Set extends org.bouncycastle.asn1.ASN1Collection

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public static org.bouncycastle.asn1.ASN1Set getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.ASN1Set getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public boolean equals(
java.lang.Object)

________________CLASS________________


public abstract class org.bouncycastle.asn1.ASN1TaggedObject extends org.bouncycastle.asn1.DERObject

----------------FIELDS----------------

 boolean empty

 boolean explicit

 org.bouncycastle.asn1.DEREncodable obj

 int tagNo
----------------METHODS----------------

public void <init>(
int
org.bouncycastle.asn1.DEREncodable)

public void <init>(
boolean
int
org.bouncycastle.asn1.DEREncodable)

public static org.bouncycastle.asn1.ASN1TaggedObject getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.ASN1TaggedObject getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
abstract void encode(
org.bouncycastle.asn1.DEROutputStream)

public boolean equals(
java.lang.Object)

public org.bouncycastle.asn1.DERObject getObject()

public int getTagNo()

public int hashCode()

public boolean isEmpty()

public boolean isExplicit()

public java.lang.String toString()

________________CLASS________________


public class org.bouncycastle.asn1.DEROctetString extends org.bouncycastle.asn1.ASN1OctetString

----------------FIELDS----------------
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.DEREncodable)

public void <init>(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void encode(
org.bouncycastle.asn1.DEROutputStream)

________________CLASS________________


public class org.bouncycastle.asn1.BERConstructedOctetString extends org.bouncycastle.asn1.DEROctetString

----------------FIELDS----------------

private java.util.Vector octs
----------------METHODS----------------

public void <init>(
java.util.Vector)

public void <init>(
org.bouncycastle.asn1.DEREncodable)

public void <init>(
org.bouncycastle.asn1.DERObject)

public void <init>(
byte[])

private java.util.Vector generateOcts()

private static byte[] toBytes(
java.util.Vector)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void encode(
org.bouncycastle.asn1.DEROutputStream)

public java.util.Enumeration getObjects()

public byte[] getOctets()

________________CLASS________________


public class org.bouncycastle.asn1.DERConstructedSequence extends org.bouncycastle.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public void addObject(
org.bouncycastle.asn1.DEREncodable)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void encode(
org.bouncycastle.asn1.DEROutputStream)

public int getSize()

________________CLASS________________


public class org.bouncycastle.asn1.BERConstructedSequence extends org.bouncycastle.asn1.DERConstructedSequence

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void encode(
org.bouncycastle.asn1.DEROutputStream)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/asn1/BERInputStream; )
@dalvik.annotation.InnerClass (accessFlags =0 name =null )
 class org.bouncycastle.asn1.BERInputStream$1 extends org.bouncycastle.asn1.DERObject

----------------FIELDS----------------

final org.bouncycastle.asn1.BERInputStream this$0
----------------METHODS----------------

 void <init>(
org.bouncycastle.asn1.BERInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void encode(
org.bouncycastle.asn1.DEROutputStream)

public boolean equals(
java.lang.Object)

public int hashCode()

________________CLASS________________


public class org.bouncycastle.asn1.DERInputStream extends java.io.FilterInputStream implements org.bouncycastle.asn1.DERTags

----------------FIELDS----------------
----------------METHODS----------------

public void <init>(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected org.bouncycastle.asn1.DERObject buildObject(
int
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void readFully(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected int readLength()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public org.bouncycastle.asn1.DERObject readObject()

________________CLASS________________


public class org.bouncycastle.asn1.BERInputStream extends org.bouncycastle.asn1.DERInputStream

----------------FIELDS----------------

private org.bouncycastle.asn1.DERObject END_OF_STREAM
----------------METHODS----------------

public void <init>(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private org.bouncycastle.asn1.BERConstructedOctetString buildConstructedOctetString()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private byte[] readIndefiniteLengthFully()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public org.bouncycastle.asn1.DERObject readObject()

________________CLASS________________


public class org.bouncycastle.asn1.DERNull extends org.bouncycastle.asn1.ASN1Null

----------------FIELDS----------------

public static final org.bouncycastle.asn1.DERNull THE_ONE

private static final byte[] zeroBytes
----------------METHODS----------------

static void <clinit>()

 void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void encode(
org.bouncycastle.asn1.DEROutputStream)

public boolean equals(
java.lang.Object)

public int hashCode()

________________CLASS________________


public class org.bouncycastle.asn1.BERNull extends org.bouncycastle.asn1.DERNull

----------------FIELDS----------------

public static final org.bouncycastle.asn1.BERNull THE_ONE
----------------METHODS----------------

static void <clinit>()

private void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void encode(
org.bouncycastle.asn1.DEROutputStream)

________________CLASS________________


public class org.bouncycastle.asn1.BEROutputStream extends org.bouncycastle.asn1.DEROutputStream

----------------FIELDS----------------
----------------METHODS----------------

public void <init>(
java.io.OutputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void writeObject(
java.lang.Object)

________________CLASS________________


public class org.bouncycastle.asn1.DERSequence extends org.bouncycastle.asn1.ASN1Sequence

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public void <init>(
org.bouncycastle.asn1.DEREncodable)

public void <init>(
org.bouncycastle.asn1.DEREncodableVector)

public void <init>(
org.bouncycastle.asn1.ASN1Encodable[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void encode(
org.bouncycastle.asn1.DEROutputStream)

________________CLASS________________


public class org.bouncycastle.asn1.BERSequence extends org.bouncycastle.asn1.DERSequence

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public void <init>(
org.bouncycastle.asn1.DEREncodable)

public void <init>(
org.bouncycastle.asn1.DEREncodableVector)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void encode(
org.bouncycastle.asn1.DEROutputStream)

________________CLASS________________


public class org.bouncycastle.asn1.DERSet extends org.bouncycastle.asn1.ASN1Set

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public void <init>(
org.bouncycastle.asn1.DEREncodable)

public void <init>(
org.bouncycastle.asn1.DEREncodableVector)

 void <init>(
org.bouncycastle.asn1.DEREncodableVector
boolean)

public void <init>(
org.bouncycastle.asn1.ASN1Encodable[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void encode(
org.bouncycastle.asn1.DEROutputStream)

________________CLASS________________


public class org.bouncycastle.asn1.BERSet extends org.bouncycastle.asn1.DERSet

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public void <init>(
org.bouncycastle.asn1.DEREncodable)

public void <init>(
org.bouncycastle.asn1.DEREncodableVector)

 void <init>(
org.bouncycastle.asn1.DEREncodableVector
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void encode(
org.bouncycastle.asn1.DEROutputStream)

________________CLASS________________


public class org.bouncycastle.asn1.DERTaggedObject extends org.bouncycastle.asn1.ASN1TaggedObject

----------------FIELDS----------------
----------------METHODS----------------

public void <init>(
int)

public void <init>(
int
org.bouncycastle.asn1.DEREncodable)

public void <init>(
boolean
int
org.bouncycastle.asn1.DEREncodable)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void encode(
org.bouncycastle.asn1.DEROutputStream)

________________CLASS________________


public class org.bouncycastle.asn1.BERTaggedObject extends org.bouncycastle.asn1.DERTaggedObject

----------------FIELDS----------------
----------------METHODS----------------

public void <init>(
int)

public void <init>(
int
org.bouncycastle.asn1.DEREncodable)

public void <init>(
boolean
int
org.bouncycastle.asn1.DEREncodable)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void encode(
org.bouncycastle.asn1.DEROutputStream)

________________CLASS________________


public class org.bouncycastle.asn1.DERApplicationSpecific extends org.bouncycastle.asn1.DERObject

----------------FIELDS----------------

private byte[] octets

private int tag
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
int
org.bouncycastle.asn1.DEREncodable)

public void <init>(
int
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void encode(
org.bouncycastle.asn1.DEROutputStream)

public boolean equals(
java.lang.Object)

public int getApplicationTag()

public byte[] getContents()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public org.bouncycastle.asn1.DERObject getObject()

public int hashCode()

public boolean isConstructed()

________________CLASS________________


public abstract interface class org.bouncycastle.asn1.DERString extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.lang.String getString()

________________CLASS________________


public class org.bouncycastle.asn1.DERBMPString extends org.bouncycastle.asn1.DERObject implements org.bouncycastle.asn1.DERString

----------------FIELDS----------------

 java.lang.String string
----------------METHODS----------------

public void <init>(
java.lang.String)

public void <init>(
byte[])

public static org.bouncycastle.asn1.DERBMPString getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.DERBMPString getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void encode(
org.bouncycastle.asn1.DEROutputStream)

public boolean equals(
java.lang.Object)

public java.lang.String getString()

public int hashCode()

________________CLASS________________


public class org.bouncycastle.asn1.DERBitString extends org.bouncycastle.asn1.DERObject implements org.bouncycastle.asn1.DERString

----------------FIELDS----------------

private static final char[] table

protected byte[] data

protected int padBits
----------------METHODS----------------

static void <clinit>()

protected void <init>(
byte
int)

public void <init>(
org.bouncycastle.asn1.DEREncodable)

public void <init>(
byte[])

public void <init>(
byte[]
int)

protected static byte[] getBytes(
int)

public static org.bouncycastle.asn1.DERBitString getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.DERBitString getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

protected static int getPadBits(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void encode(
org.bouncycastle.asn1.DEROutputStream)

public boolean equals(
java.lang.Object)

public byte[] getBytes()

public int getPadBits()

public java.lang.String getString()

public int hashCode()

public int intValue()

public java.lang.String toString()

________________CLASS________________


public class org.bouncycastle.asn1.DERBoolean extends org.bouncycastle.asn1.DERObject

----------------FIELDS----------------

public static final org.bouncycastle.asn1.DERBoolean FALSE

public static final org.bouncycastle.asn1.DERBoolean TRUE

private final byte value
----------------METHODS----------------

static void <clinit>()

private void <init>(
boolean)

public static org.bouncycastle.asn1.DERBoolean getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.DERBoolean getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public static org.bouncycastle.asn1.DERBoolean getInstance(
boolean)

public static org.bouncycastle.asn1.DERBoolean getInstance(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void encode(
org.bouncycastle.asn1.DEROutputStream)

public boolean equals(
java.lang.Object)

public int hashCode()

public boolean isTrue()

public java.lang.String toString()

________________CLASS________________


public class org.bouncycastle.asn1.DERConstructedSet extends org.bouncycastle.asn1.ASN1Set

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public void <init>(
org.bouncycastle.asn1.DEREncodable)

public void <init>(
org.bouncycastle.asn1.DEREncodableVector)

public void addObject(
org.bouncycastle.asn1.DEREncodable)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void encode(
org.bouncycastle.asn1.DEROutputStream)

public int getSize()

________________CLASS________________


public class org.bouncycastle.asn1.DEREnumerated extends org.bouncycastle.asn1.DERObject

----------------FIELDS----------------

 byte[] bytes
----------------METHODS----------------

public void <init>(
int)

public void <init>(
java.math.BigInteger)

public void <init>(
byte[])

public static org.bouncycastle.asn1.DEREnumerated getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.DEREnumerated getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void encode(
org.bouncycastle.asn1.DEROutputStream)

public boolean equals(
java.lang.Object)

public java.math.BigInteger getValue()

public int hashCode()

________________CLASS________________


public class org.bouncycastle.asn1.DERGeneralString extends org.bouncycastle.asn1.DERObject implements org.bouncycastle.asn1.DERString

----------------FIELDS----------------

private java.lang.String string
----------------METHODS----------------

public void <init>(
java.lang.String)

public void <init>(
byte[])

public static org.bouncycastle.asn1.DERGeneralString getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.DERGeneralString getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void encode(
org.bouncycastle.asn1.DEROutputStream)

public boolean equals(
java.lang.Object)

public byte[] getOctets()

public java.lang.String getString()

public int hashCode()

________________CLASS________________


public class org.bouncycastle.asn1.DERGeneralizedTime extends org.bouncycastle.asn1.DERObject

----------------FIELDS----------------

 java.lang.String time
----------------METHODS----------------

public void <init>(
java.lang.String)

public void <init>(
java.util.Date)

 void <init>(
byte[])

public static org.bouncycastle.asn1.DERGeneralizedTime getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.DERGeneralizedTime getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

private byte[] getOctets()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void encode(
org.bouncycastle.asn1.DEROutputStream)

public boolean equals(
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/text/ParseException; )
public java.util.Date getDate()

public java.lang.String getTime()

public int hashCode()

________________CLASS________________


public class org.bouncycastle.asn1.DERIA5String extends org.bouncycastle.asn1.DERObject implements org.bouncycastle.asn1.DERString

----------------FIELDS----------------

 java.lang.String string
----------------METHODS----------------

public void <init>(
java.lang.String)

public void <init>(
byte[])

public static org.bouncycastle.asn1.DERIA5String getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.DERIA5String getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void encode(
org.bouncycastle.asn1.DEROutputStream)

public boolean equals(
java.lang.Object)

public byte[] getOctets()

public java.lang.String getString()

public int hashCode()

________________CLASS________________


public class org.bouncycastle.asn1.DERInteger extends org.bouncycastle.asn1.DERObject

----------------FIELDS----------------

 byte[] bytes
----------------METHODS----------------

public void <init>(
int)

public void <init>(
java.math.BigInteger)

public void <init>(
byte[])

public static org.bouncycastle.asn1.DERInteger getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.DERInteger getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void encode(
org.bouncycastle.asn1.DEROutputStream)

public boolean equals(
java.lang.Object)

public java.math.BigInteger getPositiveValue()

public java.math.BigInteger getValue()

public int hashCode()

public java.lang.String toString()

________________CLASS________________


public class org.bouncycastle.asn1.DERNumericString extends org.bouncycastle.asn1.DERObject implements org.bouncycastle.asn1.DERString

----------------FIELDS----------------

 java.lang.String string
----------------METHODS----------------

public void <init>(
java.lang.String)

public void <init>(
byte[])

public static org.bouncycastle.asn1.DERNumericString getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.DERNumericString getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void encode(
org.bouncycastle.asn1.DEROutputStream)

public boolean equals(
java.lang.Object)

public byte[] getOctets()

public java.lang.String getString()

public int hashCode()

________________CLASS________________


public class org.bouncycastle.asn1.DERObjectIdentifier extends org.bouncycastle.asn1.DERObject

----------------FIELDS----------------

 java.lang.String identifier
----------------METHODS----------------

public void <init>(
java.lang.String)

 void <init>(
byte[])

public static org.bouncycastle.asn1.DERObjectIdentifier getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.DERObjectIdentifier getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

private static boolean isValidIdentifier(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeField(
java.io.OutputStream
long)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeField(
java.io.OutputStream
java.math.BigInteger)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void encode(
org.bouncycastle.asn1.DEROutputStream)

public boolean equals(
java.lang.Object)

public java.lang.String getId()

public int hashCode()

public java.lang.String toString()

________________CLASS________________


public class org.bouncycastle.asn1.DERPrintableString extends org.bouncycastle.asn1.DERObject implements org.bouncycastle.asn1.DERString

----------------FIELDS----------------

private final java.lang.String string
----------------METHODS----------------

public void <init>(
java.lang.String)

public void <init>(
byte[])

public static org.bouncycastle.asn1.DERPrintableString getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.DERPrintableString getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void encode(
org.bouncycastle.asn1.DEROutputStream)

public boolean equals(
java.lang.Object)

public byte[] getOctets()

public java.lang.String getString()

public int hashCode()

public java.lang.String toString()

________________CLASS________________


public class org.bouncycastle.asn1.DERT61String extends org.bouncycastle.asn1.DERObject implements org.bouncycastle.asn1.DERString

----------------FIELDS----------------

 java.lang.String string
----------------METHODS----------------

public void <init>(
java.lang.String)

public void <init>(
byte[])

public static org.bouncycastle.asn1.DERT61String getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.DERT61String getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void encode(
org.bouncycastle.asn1.DEROutputStream)

public boolean equals(
java.lang.Object)

public byte[] getOctets()

public java.lang.String getString()

public int hashCode()

________________CLASS________________


public class org.bouncycastle.asn1.DERUTCTime extends org.bouncycastle.asn1.DERObject

----------------FIELDS----------------

 java.lang.String time
----------------METHODS----------------

public void <init>(
java.lang.String)

public void <init>(
java.util.Date)

 void <init>(
byte[])

public static org.bouncycastle.asn1.DERUTCTime getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.DERUTCTime getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

private byte[] getOctets()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void encode(
org.bouncycastle.asn1.DEROutputStream)

public boolean equals(
java.lang.Object)

public java.lang.String getAdjustedTime()

public java.lang.String getTime()

public int hashCode()

public java.lang.String toString()

________________CLASS________________


public class org.bouncycastle.asn1.DERUTF8String extends org.bouncycastle.asn1.DERObject implements org.bouncycastle.asn1.DERString

----------------FIELDS----------------

 java.lang.String string
----------------METHODS----------------

public void <init>(
java.lang.String)

 void <init>(
byte[])

public static org.bouncycastle.asn1.DERUTF8String getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.DERUTF8String getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void encode(
org.bouncycastle.asn1.DEROutputStream)

public boolean equals(
java.lang.Object)

public java.lang.String getString()

public int hashCode()

________________CLASS________________


public class org.bouncycastle.asn1.DERUniversalString extends org.bouncycastle.asn1.DERObject implements org.bouncycastle.asn1.DERString

----------------FIELDS----------------

private static final char[] table

private byte[] string
----------------METHODS----------------

static void <clinit>()

public void <init>(
byte[])

public static org.bouncycastle.asn1.DERUniversalString getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.DERUniversalString getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void encode(
org.bouncycastle.asn1.DEROutputStream)

public boolean equals(
java.lang.Object)

public byte[] getOctets()

public java.lang.String getString()

public int hashCode()

________________CLASS________________


public class org.bouncycastle.asn1.DERUnknownTag extends org.bouncycastle.asn1.DERObject

----------------FIELDS----------------

 byte[] data

 int tag
----------------METHODS----------------

public void <init>(
int
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void encode(
org.bouncycastle.asn1.DEROutputStream)

public boolean equals(
java.lang.Object)

public byte[] getData()

public int getTag()

public int hashCode()

________________CLASS________________


public class org.bouncycastle.asn1.DERVisibleString extends org.bouncycastle.asn1.DERObject implements org.bouncycastle.asn1.DERString

----------------FIELDS----------------

 java.lang.String string
----------------METHODS----------------

public void <init>(
java.lang.String)

public void <init>(
byte[])

public static org.bouncycastle.asn1.DERVisibleString getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.DERVisibleString getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void encode(
org.bouncycastle.asn1.DEROutputStream)

public boolean equals(
java.lang.Object)

public byte[] getOctets()

public java.lang.String getString()

public int hashCode()

________________CLASS________________


public class org.bouncycastle.asn1.OIDTokenizer extends java.lang.Object

----------------FIELDS----------------

private int index

private java.lang.String oid
----------------METHODS----------------

public void <init>(
java.lang.String)

public boolean hasMoreTokens()

public java.lang.String nextToken()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =4104 name =null )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/asn1/OrderedTable; )
 class org.bouncycastle.asn1.OrderedTable$1 extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/asn1/OrderedTable; )
@dalvik.annotation.InnerClass (accessFlags =2 name =KeyEnumeration )
 class org.bouncycastle.asn1.OrderedTable$KeyEnumeration extends java.lang.Object implements java.util.Enumeration

----------------FIELDS----------------

private int at

private final int origSize

final org.bouncycastle.asn1.OrderedTable this$0
----------------METHODS----------------

private void <init>(
org.bouncycastle.asn1.OrderedTable)

 void <init>(
org.bouncycastle.asn1.OrderedTable
org.bouncycastle.asn1.OrderedTable$1)

public boolean hasMoreElements()

public java.lang.Object nextElement()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/bouncycastle/asn1/OrderedTable$1;Lorg/bouncycastle/asn1/OrderedTable$KeyEnumeration; )
public final class org.bouncycastle.asn1.OrderedTable extends java.lang.Object

----------------FIELDS----------------

private org.bouncycastle.asn1.DERObjectIdentifier key0

private org.bouncycastle.asn1.DERObjectIdentifier key1

private org.bouncycastle.asn1.DERObjectIdentifier key2

private org.bouncycastle.asn1.DERObjectIdentifier key3

private java.lang.Object[] rest

private int size

private java.lang.Object value0

private java.lang.Object value1

private java.lang.Object value2

private java.lang.Object value3
----------------METHODS----------------

public void <init>()

static int access$100(
org.bouncycastle.asn1.OrderedTable)

public void add(
org.bouncycastle.asn1.DERObjectIdentifier
java.lang.Object)

public java.lang.Object get(
org.bouncycastle.asn1.DERObjectIdentifier)

public org.bouncycastle.asn1.DERObjectIdentifier getKey(
int)

public java.util.Enumeration getKeys()

public java.lang.Object getValue(
int)

public int size()

________________CLASS________________


public class org.bouncycastle.asn1.cmp.PKIFailureInfo extends org.bouncycastle.asn1.DERBitString

----------------FIELDS----------------

public static final int ADD_INFO_NOT_AVAILABLE

public static final int BAD_ALG

public static final int BAD_CERT_ID

public static final int BAD_DATA_FORMAT

public static final int BAD_MESSAGE_CHECK

public static final int BAD_POP

public static final int BAD_REQUEST

public static final int BAD_TIME

public static final int INCORRECT_DATA

public static final int MISSING_TIME_STAMP

public static final int SYSTEM_FAILURE

public static final int TIME_NOT_AVAILABLE

public static final int UNACCEPTED_EXTENSION

public static final int UNACCEPTED_POLICY

public static final int WRONG_AUTHORITY

public static final int addInfoNotAvailable

public static final int badAlg

public static final int badCertId

public static final int badDataFormat

public static final int badMessageCheck

public static final int badPOP

public static final int badRequest

public static final int badTime

public static final int incorrectData

public static final int missingTimeStamp

public static final int systemFailure

public static final int timeNotAvailable

public static final int unacceptedExtension

public static final int unacceptedPolicy

public static final int wrongAuthority
----------------METHODS----------------

public void <init>(
int)

public void <init>(
org.bouncycastle.asn1.DERBitString)

public java.lang.String toString()

________________CLASS________________


public class org.bouncycastle.asn1.cmp.PKIFreeText extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.ASN1Sequence strings
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.DERUTF8String)

public static org.bouncycastle.asn1.cmp.PKIFreeText getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.cmp.PKIFreeText getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.DERUTF8String getStringAt(
int)

public int size()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public abstract interface class org.bouncycastle.asn1.cmp.PKIStatus extends java.lang.Object

----------------FIELDS----------------

public static final int GRANTED

public static final int GRANTED_WITH_MODS

public static final int REJECTION

public static final int REVOCATION_NOTIFICATION

public static final int REVOCATION_WARNING

public static final int WAITING
----------------METHODS----------------

________________CLASS________________


public class org.bouncycastle.asn1.cmp.PKIStatusInfo extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.DERBitString failInfo

 org.bouncycastle.asn1.DERInteger status

 org.bouncycastle.asn1.cmp.PKIFreeText statusString
----------------METHODS----------------

public void <init>(
int)

public void <init>(
int
org.bouncycastle.asn1.cmp.PKIFreeText)

public void <init>(
int
org.bouncycastle.asn1.cmp.PKIFreeText
org.bouncycastle.asn1.cmp.PKIFailureInfo)

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public static org.bouncycastle.asn1.cmp.PKIStatusInfo getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.cmp.PKIStatusInfo getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.DERBitString getFailInfo()

public java.math.BigInteger getStatus()

public org.bouncycastle.asn1.cmp.PKIFreeText getStatusString()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.cms.Attribute extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.DERObjectIdentifier attrType

private org.bouncycastle.asn1.ASN1Set attrValues
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.DERObjectIdentifier
org.bouncycastle.asn1.ASN1Set)

public static org.bouncycastle.asn1.cms.Attribute getInstance(
java.lang.Object)

public org.bouncycastle.asn1.DERObjectIdentifier getAttrType()

public org.bouncycastle.asn1.ASN1Set getAttrValues()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.cms.AttributeTable extends java.lang.Object

----------------FIELDS----------------

private java.util.Hashtable attributes
----------------METHODS----------------

public void <init>(
java.util.Hashtable)

public void <init>(
org.bouncycastle.asn1.ASN1Set)

public void <init>(
org.bouncycastle.asn1.DEREncodableVector)

private void addAttribute(
org.bouncycastle.asn1.DERObjectIdentifier
org.bouncycastle.asn1.cms.Attribute)

private java.util.Hashtable copyTable(
java.util.Hashtable)

public org.bouncycastle.asn1.cms.Attribute get(
org.bouncycastle.asn1.DERObjectIdentifier)

public org.bouncycastle.asn1.ASN1EncodableVector getAll(
org.bouncycastle.asn1.DERObjectIdentifier)

public org.bouncycastle.asn1.ASN1EncodableVector toASN1EncodableVector()

public java.util.Hashtable toHashtable()

________________CLASS________________


public abstract interface class org.bouncycastle.asn1.cms.CMSAttributes extends java.lang.Object

----------------FIELDS----------------

public static final org.bouncycastle.asn1.DERObjectIdentifier contentType

public static final org.bouncycastle.asn1.DERObjectIdentifier counterSignature

public static final org.bouncycastle.asn1.DERObjectIdentifier messageDigest

public static final org.bouncycastle.asn1.DERObjectIdentifier signingTime
----------------METHODS----------------

static void <clinit>()

________________CLASS________________


public abstract interface class org.bouncycastle.asn1.cms.CMSObjectIdentifiers extends java.lang.Object

----------------FIELDS----------------

public static final org.bouncycastle.asn1.DERObjectIdentifier compressedData

public static final org.bouncycastle.asn1.DERObjectIdentifier data

public static final org.bouncycastle.asn1.DERObjectIdentifier digestedData

public static final org.bouncycastle.asn1.DERObjectIdentifier encryptedData

public static final org.bouncycastle.asn1.DERObjectIdentifier envelopedData

public static final org.bouncycastle.asn1.DERObjectIdentifier signedAndEnvelopedData

public static final org.bouncycastle.asn1.DERObjectIdentifier signedData
----------------METHODS----------------

static void <clinit>()

________________CLASS________________


public class org.bouncycastle.asn1.cms.CompressedData extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.x509.AlgorithmIdentifier compressionAlgorithm

private org.bouncycastle.asn1.cms.ContentInfo encapContentInfo

private org.bouncycastle.asn1.DERInteger version
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.x509.AlgorithmIdentifier
org.bouncycastle.asn1.cms.ContentInfo)

public static org.bouncycastle.asn1.cms.CompressedData getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.cms.CompressedData getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.x509.AlgorithmIdentifier getCompressionAlgorithmIdentifier()

public org.bouncycastle.asn1.cms.ContentInfo getEncapContentInfo()

public org.bouncycastle.asn1.DERInteger getVersion()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.cms.ContentInfo extends org.bouncycastle.asn1.ASN1Encodable implements org.bouncycastle.asn1.cms.CMSObjectIdentifiers

----------------FIELDS----------------

private org.bouncycastle.asn1.DEREncodable content

private org.bouncycastle.asn1.DERObjectIdentifier contentType
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.DERObjectIdentifier
org.bouncycastle.asn1.DEREncodable)

public static org.bouncycastle.asn1.cms.ContentInfo getInstance(
java.lang.Object)

public org.bouncycastle.asn1.DEREncodable getContent()

public org.bouncycastle.asn1.DERObjectIdentifier getContentType()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.cms.EncryptedContentInfo extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.x509.AlgorithmIdentifier contentEncryptionAlgorithm

private org.bouncycastle.asn1.DERObjectIdentifier contentType

private org.bouncycastle.asn1.ASN1OctetString encryptedContent
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.DERObjectIdentifier
org.bouncycastle.asn1.x509.AlgorithmIdentifier
org.bouncycastle.asn1.ASN1OctetString)

public static org.bouncycastle.asn1.cms.EncryptedContentInfo getInstance(
java.lang.Object)

public org.bouncycastle.asn1.x509.AlgorithmIdentifier getContentEncryptionAlgorithm()

public org.bouncycastle.asn1.DERObjectIdentifier getContentType()

public org.bouncycastle.asn1.ASN1OctetString getEncryptedContent()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.cms.EnvelopedData extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.cms.EncryptedContentInfo encryptedContentInfo

private org.bouncycastle.asn1.cms.OriginatorInfo originatorInfo

private org.bouncycastle.asn1.ASN1Set recipientInfos

private org.bouncycastle.asn1.ASN1Set unprotectedAttrs

private org.bouncycastle.asn1.DERInteger version
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.cms.OriginatorInfo
org.bouncycastle.asn1.ASN1Set
org.bouncycastle.asn1.cms.EncryptedContentInfo
org.bouncycastle.asn1.ASN1Set)

public static org.bouncycastle.asn1.cms.EnvelopedData getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.cms.EnvelopedData getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.cms.EncryptedContentInfo getEncryptedContentInfo()

public org.bouncycastle.asn1.cms.OriginatorInfo getOriginatorInfo()

public org.bouncycastle.asn1.ASN1Set getRecipientInfos()

public org.bouncycastle.asn1.ASN1Set getUnprotectedAttrs()

public org.bouncycastle.asn1.DERInteger getVersion()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.cms.IssuerAndSerialNumber extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.x509.X509Name name

 org.bouncycastle.asn1.DERInteger serialNumber
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.x509.X509Name
java.math.BigInteger)

public void <init>(
org.bouncycastle.asn1.x509.X509Name
org.bouncycastle.asn1.DERInteger)

public static org.bouncycastle.asn1.cms.IssuerAndSerialNumber getInstance(
java.lang.Object)

public org.bouncycastle.asn1.x509.X509Name getName()

public org.bouncycastle.asn1.DERInteger getSerialNumber()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.cms.KEKIdentifier extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.DERGeneralizedTime date

private org.bouncycastle.asn1.ASN1OctetString keyIdentifier

private org.bouncycastle.asn1.cms.OtherKeyAttribute other
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
byte[]
org.bouncycastle.asn1.DERGeneralizedTime
org.bouncycastle.asn1.cms.OtherKeyAttribute)

public static org.bouncycastle.asn1.cms.KEKIdentifier getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.cms.KEKIdentifier getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.DERGeneralizedTime getDate()

public org.bouncycastle.asn1.ASN1OctetString getKeyIdentifier()

public org.bouncycastle.asn1.cms.OtherKeyAttribute getOther()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.cms.KEKRecipientInfo extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.ASN1OctetString encryptedKey

private org.bouncycastle.asn1.cms.KEKIdentifier kekid

private org.bouncycastle.asn1.x509.AlgorithmIdentifier keyEncryptionAlgorithm

private org.bouncycastle.asn1.DERInteger version
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.cms.KEKIdentifier
org.bouncycastle.asn1.x509.AlgorithmIdentifier
org.bouncycastle.asn1.ASN1OctetString)

public static org.bouncycastle.asn1.cms.KEKRecipientInfo getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.cms.KEKRecipientInfo getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.ASN1OctetString getEncryptedKey()

public org.bouncycastle.asn1.cms.KEKIdentifier getKekid()

public org.bouncycastle.asn1.x509.AlgorithmIdentifier getKeyEncryptionAlgorithm()

public org.bouncycastle.asn1.DERInteger getVersion()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.cms.KeyAgreeRecipientInfo extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.x509.AlgorithmIdentifier keyEncryptionAlgorithm

private org.bouncycastle.asn1.cms.OriginatorIdentifierOrKey originator

private org.bouncycastle.asn1.ASN1Sequence recipientEncryptedKeys

private org.bouncycastle.asn1.ASN1OctetString ukm

private org.bouncycastle.asn1.DERInteger version
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.cms.OriginatorIdentifierOrKey
org.bouncycastle.asn1.ASN1OctetString
org.bouncycastle.asn1.x509.AlgorithmIdentifier
org.bouncycastle.asn1.ASN1Sequence)

public static org.bouncycastle.asn1.cms.KeyAgreeRecipientInfo getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.cms.KeyAgreeRecipientInfo getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.x509.AlgorithmIdentifier getKeyEncryptionAlgorithm()

public org.bouncycastle.asn1.cms.OriginatorIdentifierOrKey getOriginator()

public org.bouncycastle.asn1.ASN1Sequence getRecipientEncryptedKeys()

public org.bouncycastle.asn1.ASN1OctetString getUserKeyingMaterial()

public org.bouncycastle.asn1.DERInteger getVersion()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.cms.KeyTransRecipientInfo extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.ASN1OctetString encryptedKey

private org.bouncycastle.asn1.x509.AlgorithmIdentifier keyEncryptionAlgorithm

private org.bouncycastle.asn1.cms.RecipientIdentifier rid

private org.bouncycastle.asn1.DERInteger version
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.cms.RecipientIdentifier
org.bouncycastle.asn1.x509.AlgorithmIdentifier
org.bouncycastle.asn1.ASN1OctetString)

public static org.bouncycastle.asn1.cms.KeyTransRecipientInfo getInstance(
java.lang.Object)

public org.bouncycastle.asn1.ASN1OctetString getEncryptedKey()

public org.bouncycastle.asn1.x509.AlgorithmIdentifier getKeyEncryptionAlgorithm()

public org.bouncycastle.asn1.cms.RecipientIdentifier getRecipientIdentifier()

public org.bouncycastle.asn1.DERInteger getVersion()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.cms.OriginatorIdentifierOrKey extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.DEREncodable id
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1OctetString)

public void <init>(
org.bouncycastle.asn1.DERObject)

public void <init>(
org.bouncycastle.asn1.cms.IssuerAndSerialNumber)

public void <init>(
org.bouncycastle.asn1.cms.OriginatorPublicKey)

public static org.bouncycastle.asn1.cms.OriginatorIdentifierOrKey getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.cms.OriginatorIdentifierOrKey getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.DEREncodable getId()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.cms.OriginatorInfo extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.ASN1Set certs

private org.bouncycastle.asn1.ASN1Set crls
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.ASN1Set
org.bouncycastle.asn1.ASN1Set)

public static org.bouncycastle.asn1.cms.OriginatorInfo getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.cms.OriginatorInfo getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.ASN1Set getCRLs()

public org.bouncycastle.asn1.ASN1Set getCertificates()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.cms.OriginatorPublicKey extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.x509.AlgorithmIdentifier algorithm

private org.bouncycastle.asn1.DERBitString publicKey
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.x509.AlgorithmIdentifier
byte[])

public static org.bouncycastle.asn1.cms.OriginatorPublicKey getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.cms.OriginatorPublicKey getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.x509.AlgorithmIdentifier getAlgorithm()

public org.bouncycastle.asn1.DERBitString getPublicKey()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.cms.OtherKeyAttribute extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.DEREncodable keyAttr

private org.bouncycastle.asn1.DERObjectIdentifier keyAttrId
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.DERObjectIdentifier
org.bouncycastle.asn1.DEREncodable)

public static org.bouncycastle.asn1.cms.OtherKeyAttribute getInstance(
java.lang.Object)

public org.bouncycastle.asn1.DEREncodable getKeyAttr()

public org.bouncycastle.asn1.DERObjectIdentifier getKeyAttrId()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.cms.OtherRecipientInfo extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.DERObjectIdentifier oriType

private org.bouncycastle.asn1.DEREncodable oriValue
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.DERObjectIdentifier
org.bouncycastle.asn1.DEREncodable)

public static org.bouncycastle.asn1.cms.OtherRecipientInfo getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.cms.OtherRecipientInfo getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.DERObjectIdentifier getType()

public org.bouncycastle.asn1.DEREncodable getValue()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.cms.PasswordRecipientInfo extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.ASN1OctetString encryptedKey

private org.bouncycastle.asn1.x509.AlgorithmIdentifier keyDerivationAlgorithm

private org.bouncycastle.asn1.x509.AlgorithmIdentifier keyEncryptionAlgorithm

private org.bouncycastle.asn1.DERInteger version
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.x509.AlgorithmIdentifier
org.bouncycastle.asn1.ASN1OctetString)

public void <init>(
org.bouncycastle.asn1.x509.AlgorithmIdentifier
org.bouncycastle.asn1.x509.AlgorithmIdentifier
org.bouncycastle.asn1.ASN1OctetString)

public static org.bouncycastle.asn1.cms.PasswordRecipientInfo getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.cms.PasswordRecipientInfo getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.ASN1OctetString getEncryptedKey()

public org.bouncycastle.asn1.x509.AlgorithmIdentifier getKeyDerivationAlgorithm()

public org.bouncycastle.asn1.x509.AlgorithmIdentifier getKeyEncryptionAlgorithm()

public org.bouncycastle.asn1.DERInteger getVersion()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.cms.RecipientIdentifier extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.DEREncodable id
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1OctetString)

public void <init>(
org.bouncycastle.asn1.DERObject)

public void <init>(
org.bouncycastle.asn1.cms.IssuerAndSerialNumber)

public static org.bouncycastle.asn1.cms.RecipientIdentifier getInstance(
java.lang.Object)

public org.bouncycastle.asn1.DEREncodable getId()

public boolean isTagged()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.cms.RecipientInfo extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.DEREncodable info
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.DERObject)

public void <init>(
org.bouncycastle.asn1.cms.KEKRecipientInfo)

public void <init>(
org.bouncycastle.asn1.cms.KeyAgreeRecipientInfo)

public void <init>(
org.bouncycastle.asn1.cms.KeyTransRecipientInfo)

public void <init>(
org.bouncycastle.asn1.cms.OtherRecipientInfo)

public void <init>(
org.bouncycastle.asn1.cms.PasswordRecipientInfo)

public static org.bouncycastle.asn1.cms.RecipientInfo getInstance(
java.lang.Object)

public org.bouncycastle.asn1.DEREncodable getInfo()

public org.bouncycastle.asn1.DERInteger getVersion()

public boolean isTagged()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.cms.RecipientKeyIdentifier extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.DERGeneralizedTime date

private org.bouncycastle.asn1.cms.OtherKeyAttribute other

private org.bouncycastle.asn1.ASN1OctetString subjectKeyIdentifier
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1OctetString
org.bouncycastle.asn1.DERGeneralizedTime
org.bouncycastle.asn1.cms.OtherKeyAttribute)

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public static org.bouncycastle.asn1.cms.RecipientKeyIdentifier getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.cms.RecipientKeyIdentifier getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.DERGeneralizedTime getDate()

public org.bouncycastle.asn1.cms.OtherKeyAttribute getOtherKeyAttribute()

public org.bouncycastle.asn1.ASN1OctetString getSubjectKeyIdentifier()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.cms.SignedData extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private boolean certBer

private org.bouncycastle.asn1.ASN1Set certificates

private org.bouncycastle.asn1.cms.ContentInfo contentInfo

private org.bouncycastle.asn1.ASN1Set crls

private boolean crlsBer

private org.bouncycastle.asn1.ASN1Set digestAlgorithms

private org.bouncycastle.asn1.ASN1Set signerInfos

private org.bouncycastle.asn1.DERInteger version
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.ASN1Set
org.bouncycastle.asn1.cms.ContentInfo
org.bouncycastle.asn1.ASN1Set
org.bouncycastle.asn1.ASN1Set
org.bouncycastle.asn1.ASN1Set)

public static org.bouncycastle.asn1.cms.SignedData getInstance(
java.lang.Object)

public org.bouncycastle.asn1.ASN1Set getCRLs()

public org.bouncycastle.asn1.ASN1Set getCertificates()

public org.bouncycastle.asn1.ASN1Set getDigestAlgorithms()

public org.bouncycastle.asn1.cms.ContentInfo getEncapContentInfo()

public org.bouncycastle.asn1.ASN1Set getSignerInfos()

public org.bouncycastle.asn1.DERInteger getVersion()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.cms.SignerIdentifier extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.DEREncodable id
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1OctetString)

public void <init>(
org.bouncycastle.asn1.DERObject)

public void <init>(
org.bouncycastle.asn1.cms.IssuerAndSerialNumber)

public static org.bouncycastle.asn1.cms.SignerIdentifier getInstance(
java.lang.Object)

public org.bouncycastle.asn1.DEREncodable getId()

public boolean isTagged()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.cms.SignerInfo extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.ASN1Set authenticatedAttributes

private org.bouncycastle.asn1.x509.AlgorithmIdentifier digAlgorithm

private org.bouncycastle.asn1.x509.AlgorithmIdentifier digEncryptionAlgorithm

private org.bouncycastle.asn1.ASN1OctetString encryptedDigest

private org.bouncycastle.asn1.cms.SignerIdentifier sid

private org.bouncycastle.asn1.ASN1Set unauthenticatedAttributes

private org.bouncycastle.asn1.DERInteger version
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.cms.SignerIdentifier
org.bouncycastle.asn1.x509.AlgorithmIdentifier
org.bouncycastle.asn1.ASN1Set
org.bouncycastle.asn1.x509.AlgorithmIdentifier
org.bouncycastle.asn1.ASN1OctetString
org.bouncycastle.asn1.ASN1Set)

public static org.bouncycastle.asn1.cms.SignerInfo getInstance(
java.lang.Object)

public org.bouncycastle.asn1.ASN1Set getAuthenticatedAttributes()

public org.bouncycastle.asn1.x509.AlgorithmIdentifier getDigestAlgorithm()

public org.bouncycastle.asn1.x509.AlgorithmIdentifier getDigestEncryptionAlgorithm()

public org.bouncycastle.asn1.ASN1OctetString getEncryptedDigest()

public org.bouncycastle.asn1.cms.SignerIdentifier getSID()

public org.bouncycastle.asn1.ASN1Set getUnauthenticatedAttributes()

public org.bouncycastle.asn1.DERInteger getVersion()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.cms.Time extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.DERObject time
----------------METHODS----------------

public void <init>(
java.util.Date)

public void <init>(
org.bouncycastle.asn1.DERObject)

public static org.bouncycastle.asn1.cms.Time getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.cms.Time getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public java.util.Date getDate()

public java.lang.String getTime()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public abstract interface class org.bouncycastle.asn1.cryptopro.CryptoProObjectIdentifiers extends java.lang.Object

----------------FIELDS----------------

public static final java.lang.String GOST_id

public static final org.bouncycastle.asn1.DERObjectIdentifier gostR28147_cbc

public static final org.bouncycastle.asn1.DERObjectIdentifier gostR3410_2001

public static final org.bouncycastle.asn1.DERObjectIdentifier gostR3410_2001_CryptoPro_A

public static final org.bouncycastle.asn1.DERObjectIdentifier gostR3410_2001_CryptoPro_B

public static final org.bouncycastle.asn1.DERObjectIdentifier gostR3410_2001_CryptoPro_C

public static final org.bouncycastle.asn1.DERObjectIdentifier gostR3410_2001_CryptoPro_XchA

public static final org.bouncycastle.asn1.DERObjectIdentifier gostR3410_2001_CryptoPro_XchB

public static final org.bouncycastle.asn1.DERObjectIdentifier gostR3410_94

public static final org.bouncycastle.asn1.DERObjectIdentifier gostR3410_94_CryptoPro_A

public static final org.bouncycastle.asn1.DERObjectIdentifier gostR3410_94_CryptoPro_B

public static final org.bouncycastle.asn1.DERObjectIdentifier gostR3410_94_CryptoPro_C

public static final org.bouncycastle.asn1.DERObjectIdentifier gostR3410_94_CryptoPro_D

public static final org.bouncycastle.asn1.DERObjectIdentifier gostR3410_94_CryptoPro_XchA

public static final org.bouncycastle.asn1.DERObjectIdentifier gostR3410_94_CryptoPro_XchB

public static final org.bouncycastle.asn1.DERObjectIdentifier gostR3410_94_CryptoPro_XchC

public static final org.bouncycastle.asn1.DERObjectIdentifier gostR3411

public static final org.bouncycastle.asn1.DERObjectIdentifier gostR3411_94_CryptoProParamSet

public static final org.bouncycastle.asn1.DERObjectIdentifier gostR3411_94_with_gostR3410_2001

public static final org.bouncycastle.asn1.DERObjectIdentifier gostR3411_94_with_gostR3410_94

public static final org.bouncycastle.asn1.DERObjectIdentifier gost_ElSgDH3410_1

public static final org.bouncycastle.asn1.DERObjectIdentifier gost_ElSgDH3410_default
----------------METHODS----------------

static void <clinit>()

________________CLASS________________


public abstract interface class org.bouncycastle.asn1.esf.CommitmentTypeIdentifier extends java.lang.Object

----------------FIELDS----------------

public static final org.bouncycastle.asn1.DERObjectIdentifier proofOfApproval

public static final org.bouncycastle.asn1.DERObjectIdentifier proofOfCreation

public static final org.bouncycastle.asn1.DERObjectIdentifier proofOfDelivery

public static final org.bouncycastle.asn1.DERObjectIdentifier proofOfOrigin

public static final org.bouncycastle.asn1.DERObjectIdentifier proofOfReceipt

public static final org.bouncycastle.asn1.DERObjectIdentifier proofOfSender
----------------METHODS----------------

static void <clinit>()

________________CLASS________________


public class org.bouncycastle.asn1.esf.CommitmentTypeIndication extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.DERObjectIdentifier commitmentTypeId

private org.bouncycastle.asn1.ASN1Sequence commitmentTypeQualifier
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.DERObjectIdentifier)

public void <init>(
org.bouncycastle.asn1.DERObjectIdentifier
org.bouncycastle.asn1.ASN1Sequence)

public static org.bouncycastle.asn1.esf.CommitmentTypeIndication getInstance(
java.lang.Object)

public org.bouncycastle.asn1.DERObjectIdentifier getCommitmentTypeId()

public org.bouncycastle.asn1.ASN1Sequence getCommitmentTypeQualifier()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.esf.CommitmentTypeQualifier extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.DERObjectIdentifier commitmentTypeIdentifier

private org.bouncycastle.asn1.DEREncodable qualifier
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.DERObjectIdentifier)

public void <init>(
org.bouncycastle.asn1.DERObjectIdentifier
org.bouncycastle.asn1.DEREncodable)

public static org.bouncycastle.asn1.esf.CommitmentTypeQualifier getInstance(
java.lang.Object)

public org.bouncycastle.asn1.DERObjectIdentifier getCommitmentTypeIdentifier()

public org.bouncycastle.asn1.DEREncodable getQualifier()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public abstract interface class org.bouncycastle.asn1.esf.ESFAttributes extends java.lang.Object

----------------FIELDS----------------

public static final org.bouncycastle.asn1.DERObjectIdentifier commitmentType

public static final org.bouncycastle.asn1.DERObjectIdentifier sigPolicyId

public static final org.bouncycastle.asn1.DERObjectIdentifier signerLocation
----------------METHODS----------------

static void <clinit>()

________________CLASS________________


public class org.bouncycastle.asn1.esf.SignerLocation extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.DERUTF8String countryName

private org.bouncycastle.asn1.DERUTF8String localityName

private org.bouncycastle.asn1.ASN1Sequence postalAddress
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.DERUTF8String
org.bouncycastle.asn1.DERUTF8String
org.bouncycastle.asn1.ASN1Sequence)

public static org.bouncycastle.asn1.esf.SignerLocation getInstance(
java.lang.Object)

public org.bouncycastle.asn1.DERUTF8String getCountryName()

public org.bouncycastle.asn1.DERUTF8String getLocalityName()

public org.bouncycastle.asn1.ASN1Sequence getPostalAddress()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.ess.ContentIdentifier extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.ASN1OctetString value
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1OctetString)

public void <init>(
byte[])

public static org.bouncycastle.asn1.ess.ContentIdentifier getInstance(
java.lang.Object)

public org.bouncycastle.asn1.ASN1OctetString getValue()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.ess.ESSCertID extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.ASN1OctetString certHash

private org.bouncycastle.asn1.x509.IssuerSerial issuerSerial
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
byte[])

public void <init>(
byte[]
org.bouncycastle.asn1.x509.IssuerSerial)

public static org.bouncycastle.asn1.ess.ESSCertID getInstance(
java.lang.Object)

public byte[] getCertHash()

public org.bouncycastle.asn1.x509.IssuerSerial getIssuerSerial()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.ess.OtherCertID extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.x509.IssuerSerial issuerSerial

private org.bouncycastle.asn1.ASN1Encodable otherCertHash
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.x509.AlgorithmIdentifier
byte[])

public void <init>(
org.bouncycastle.asn1.x509.AlgorithmIdentifier
byte[]
org.bouncycastle.asn1.x509.IssuerSerial)

public static org.bouncycastle.asn1.ess.OtherCertID getInstance(
java.lang.Object)

public org.bouncycastle.asn1.x509.AlgorithmIdentifier getAlgorithmHash()

public byte[] getCertHash()

public org.bouncycastle.asn1.x509.IssuerSerial getIssuerSerial()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.ess.OtherSigningCertificate extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.ASN1Sequence certs

 org.bouncycastle.asn1.ASN1Sequence policies
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.ess.OtherCertID)

public static org.bouncycastle.asn1.ess.OtherSigningCertificate getInstance(
java.lang.Object)

public org.bouncycastle.asn1.ess.OtherCertID[] getCerts()

public org.bouncycastle.asn1.x509.PolicyInformation[] getPolicies()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.ess.SigningCertificate extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.ASN1Sequence certs

 org.bouncycastle.asn1.ASN1Sequence policies
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.ess.ESSCertID)

public static org.bouncycastle.asn1.ess.SigningCertificate getInstance(
java.lang.Object)

public org.bouncycastle.asn1.ess.ESSCertID[] getCerts()

public org.bouncycastle.asn1.x509.PolicyInformation[] getPolicies()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public abstract interface class org.bouncycastle.asn1.gnu.GNUObjectIdentifiers extends java.lang.Object

----------------FIELDS----------------

public static final org.bouncycastle.asn1.DERObjectIdentifier CRC

public static final org.bouncycastle.asn1.DERObjectIdentifier CRC32

public static final org.bouncycastle.asn1.DERObjectIdentifier GNU

public static final org.bouncycastle.asn1.DERObjectIdentifier GnuPG

public static final org.bouncycastle.asn1.DERObjectIdentifier GnuRadar

public static final org.bouncycastle.asn1.DERObjectIdentifier Serpent

public static final org.bouncycastle.asn1.DERObjectIdentifier Serpent_128_CBC

public static final org.bouncycastle.asn1.DERObjectIdentifier Serpent_128_CFB

public static final org.bouncycastle.asn1.DERObjectIdentifier Serpent_128_ECB

public static final org.bouncycastle.asn1.DERObjectIdentifier Serpent_128_OFB

public static final org.bouncycastle.asn1.DERObjectIdentifier Serpent_192_CBC

public static final org.bouncycastle.asn1.DERObjectIdentifier Serpent_192_CFB

public static final org.bouncycastle.asn1.DERObjectIdentifier Serpent_192_ECB

public static final org.bouncycastle.asn1.DERObjectIdentifier Serpent_192_OFB

public static final org.bouncycastle.asn1.DERObjectIdentifier Serpent_256_CBC

public static final org.bouncycastle.asn1.DERObjectIdentifier Serpent_256_CFB

public static final org.bouncycastle.asn1.DERObjectIdentifier Serpent_256_ECB

public static final org.bouncycastle.asn1.DERObjectIdentifier Serpent_256_OFB

public static final org.bouncycastle.asn1.DERObjectIdentifier Tiger_192

public static final org.bouncycastle.asn1.DERObjectIdentifier digestAlgorithm

public static final org.bouncycastle.asn1.DERObjectIdentifier encryptionAlgorithm

public static final org.bouncycastle.asn1.DERObjectIdentifier notation

public static final org.bouncycastle.asn1.DERObjectIdentifier pkaAddress
----------------METHODS----------------

static void <clinit>()

________________CLASS________________


public abstract interface class org.bouncycastle.asn1.iana.IANAObjectIdentifiers extends java.lang.Object

----------------FIELDS----------------

public static final org.bouncycastle.asn1.DERObjectIdentifier hmacMD5

public static final org.bouncycastle.asn1.DERObjectIdentifier hmacRIPEMD160

public static final org.bouncycastle.asn1.DERObjectIdentifier hmacSHA1

public static final org.bouncycastle.asn1.DERObjectIdentifier hmacTIGER

public static final org.bouncycastle.asn1.DERObjectIdentifier isakmpOakley
----------------METHODS----------------

static void <clinit>()

________________CLASS________________


public class org.bouncycastle.asn1.icao.DataGroupHash extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.ASN1OctetString dataGroupHashValue

 org.bouncycastle.asn1.DERInteger dataGroupNumber
----------------METHODS----------------

public void <init>(
int
org.bouncycastle.asn1.ASN1OctetString)

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public static org.bouncycastle.asn1.icao.DataGroupHash getInstance(
java.lang.Object)

public org.bouncycastle.asn1.ASN1OctetString getDataGroupHashValue()

public int getDataGroupNumber()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public abstract interface class org.bouncycastle.asn1.icao.ICAOObjectIdentifiers extends java.lang.Object

----------------FIELDS----------------

public static final java.lang.String id_icao

public static final org.bouncycastle.asn1.DERObjectIdentifier id_icao_ldsSecurityObject

public static final org.bouncycastle.asn1.DERObjectIdentifier id_icao_mrtd

public static final org.bouncycastle.asn1.DERObjectIdentifier id_icao_mrtd_security
----------------METHODS----------------

static void <clinit>()

________________CLASS________________


public class org.bouncycastle.asn1.icao.LDSSecurityObject extends org.bouncycastle.asn1.ASN1Encodable implements org.bouncycastle.asn1.icao.ICAOObjectIdentifiers

----------------FIELDS----------------

public static final int ub_DataGroups

 org.bouncycastle.asn1.icao.DataGroupHash[] datagroupHash

 org.bouncycastle.asn1.x509.AlgorithmIdentifier digestAlgorithmIdentifier

 org.bouncycastle.asn1.DERInteger version
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.x509.AlgorithmIdentifier
org.bouncycastle.asn1.icao.DataGroupHash[])

private void checkDatagroupHashSeqSize(
int)

public static org.bouncycastle.asn1.icao.LDSSecurityObject getInstance(
java.lang.Object)

public org.bouncycastle.asn1.icao.DataGroupHash[] getDatagroupHash()

public org.bouncycastle.asn1.x509.AlgorithmIdentifier getDigestAlgorithmIdentifier()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.misc.IDEACBCPar extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.ASN1OctetString iv
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
byte[])

public static org.bouncycastle.asn1.misc.IDEACBCPar getInstance(
java.lang.Object)

public byte[] getIV()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public abstract interface class org.bouncycastle.asn1.misc.MiscObjectIdentifiers extends java.lang.Object

----------------FIELDS----------------

public static final java.lang.String netscape

public static final org.bouncycastle.asn1.DERObjectIdentifier netscapeBaseURL

public static final org.bouncycastle.asn1.DERObjectIdentifier netscapeCARevocationURL

public static final org.bouncycastle.asn1.DERObjectIdentifier netscapeCApolicyURL

public static final org.bouncycastle.asn1.DERObjectIdentifier netscapeCertComment

public static final org.bouncycastle.asn1.DERObjectIdentifier netscapeCertType

public static final org.bouncycastle.asn1.DERObjectIdentifier netscapeRenewalURL

public static final org.bouncycastle.asn1.DERObjectIdentifier netscapeRevocationURL

public static final org.bouncycastle.asn1.DERObjectIdentifier netscapeSSLServerName

public static final java.lang.String verisign

public static final org.bouncycastle.asn1.DERObjectIdentifier verisignCzagExtension
----------------METHODS----------------

static void <clinit>()

________________CLASS________________


public class org.bouncycastle.asn1.misc.NetscapeCertType extends org.bouncycastle.asn1.DERBitString

----------------FIELDS----------------

public static final int objectSigning

public static final int objectSigningCA

public static final int reserved

public static final int smime

public static final int smimeCA

public static final int sslCA

public static final int sslClient

public static final int sslServer
----------------METHODS----------------

public void <init>(
int)

public void <init>(
org.bouncycastle.asn1.DERBitString)

public java.lang.String toString()

________________CLASS________________


public class org.bouncycastle.asn1.misc.NetscapeRevocationURL extends org.bouncycastle.asn1.DERIA5String

----------------FIELDS----------------
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.DERIA5String)

public java.lang.String toString()

________________CLASS________________


public class org.bouncycastle.asn1.misc.VerisignCzagExtension extends org.bouncycastle.asn1.DERIA5String

----------------FIELDS----------------
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.DERIA5String)

public java.lang.String toString()

________________CLASS________________


public class org.bouncycastle.asn1.mozilla.PublicKeyAndChallenge extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.DERIA5String challenge

private org.bouncycastle.asn1.ASN1Sequence pkacSeq

private org.bouncycastle.asn1.x509.SubjectPublicKeyInfo spki
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public static org.bouncycastle.asn1.mozilla.PublicKeyAndChallenge getInstance(
java.lang.Object)

public org.bouncycastle.asn1.DERIA5String getChallenge()

public org.bouncycastle.asn1.x509.SubjectPublicKeyInfo getSubjectPublicKeyInfo()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public abstract interface class org.bouncycastle.asn1.nist.NISTObjectIdentifiers extends java.lang.Object

----------------FIELDS----------------

public static final java.lang.String aes

public static final org.bouncycastle.asn1.DERObjectIdentifier dsa_with_sha224

public static final org.bouncycastle.asn1.DERObjectIdentifier dsa_with_sha256

public static final org.bouncycastle.asn1.DERObjectIdentifier id_aes128_CBC

public static final org.bouncycastle.asn1.DERObjectIdentifier id_aes128_CFB

public static final org.bouncycastle.asn1.DERObjectIdentifier id_aes128_ECB

public static final org.bouncycastle.asn1.DERObjectIdentifier id_aes128_OFB

public static final org.bouncycastle.asn1.DERObjectIdentifier id_aes128_wrap

public static final org.bouncycastle.asn1.DERObjectIdentifier id_aes192_CBC

public static final org.bouncycastle.asn1.DERObjectIdentifier id_aes192_CFB

public static final org.bouncycastle.asn1.DERObjectIdentifier id_aes192_ECB

public static final org.bouncycastle.asn1.DERObjectIdentifier id_aes192_OFB

public static final org.bouncycastle.asn1.DERObjectIdentifier id_aes192_wrap

public static final org.bouncycastle.asn1.DERObjectIdentifier id_aes256_CBC

public static final org.bouncycastle.asn1.DERObjectIdentifier id_aes256_CFB

public static final org.bouncycastle.asn1.DERObjectIdentifier id_aes256_ECB

public static final org.bouncycastle.asn1.DERObjectIdentifier id_aes256_OFB

public static final org.bouncycastle.asn1.DERObjectIdentifier id_aes256_wrap

public static final org.bouncycastle.asn1.DERObjectIdentifier id_dsa_with_sha2

public static final org.bouncycastle.asn1.DERObjectIdentifier id_sha224

public static final org.bouncycastle.asn1.DERObjectIdentifier id_sha256

public static final org.bouncycastle.asn1.DERObjectIdentifier id_sha384

public static final org.bouncycastle.asn1.DERObjectIdentifier id_sha512

public static final java.lang.String nistAlgorithm
----------------METHODS----------------

static void <clinit>()

________________CLASS________________


public class org.bouncycastle.asn1.ocsp.BasicOCSPResponse extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.ASN1Sequence certs

private org.bouncycastle.asn1.DERBitString signature

private org.bouncycastle.asn1.x509.AlgorithmIdentifier signatureAlgorithm

private org.bouncycastle.asn1.ocsp.ResponseData tbsResponseData
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.ocsp.ResponseData
org.bouncycastle.asn1.x509.AlgorithmIdentifier
org.bouncycastle.asn1.DERBitString
org.bouncycastle.asn1.ASN1Sequence)

public static org.bouncycastle.asn1.ocsp.BasicOCSPResponse getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.ocsp.BasicOCSPResponse getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.ASN1Sequence getCerts()

public org.bouncycastle.asn1.DERBitString getSignature()

public org.bouncycastle.asn1.x509.AlgorithmIdentifier getSignatureAlgorithm()

public org.bouncycastle.asn1.ocsp.ResponseData getTbsResponseData()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.ocsp.CertID extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.x509.AlgorithmIdentifier hashAlgorithm

 org.bouncycastle.asn1.ASN1OctetString issuerKeyHash

 org.bouncycastle.asn1.ASN1OctetString issuerNameHash

 org.bouncycastle.asn1.DERInteger serialNumber
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.x509.AlgorithmIdentifier
org.bouncycastle.asn1.ASN1OctetString
org.bouncycastle.asn1.ASN1OctetString
org.bouncycastle.asn1.DERInteger)

public static org.bouncycastle.asn1.ocsp.CertID getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.ocsp.CertID getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.x509.AlgorithmIdentifier getHashAlgorithm()

public org.bouncycastle.asn1.ASN1OctetString getIssuerKeyHash()

public org.bouncycastle.asn1.ASN1OctetString getIssuerNameHash()

public org.bouncycastle.asn1.DERInteger getSerialNumber()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.ocsp.CertStatus extends org.bouncycastle.asn1.ASN1Encodable implements org.bouncycastle.asn1.ASN1Choice

----------------FIELDS----------------

private int tagNo

private org.bouncycastle.asn1.DEREncodable value
----------------METHODS----------------

public void <init>()

public void <init>(
int
org.bouncycastle.asn1.DEREncodable)

public void <init>(
org.bouncycastle.asn1.ASN1TaggedObject)

public void <init>(
org.bouncycastle.asn1.ocsp.RevokedInfo)

public static org.bouncycastle.asn1.ocsp.CertStatus getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.ocsp.CertStatus getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.DEREncodable getStatus()

public int getTagNo()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.ocsp.CrlID extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.DERInteger crlNum

 org.bouncycastle.asn1.DERGeneralizedTime crlTime

 org.bouncycastle.asn1.DERIA5String crlUrl
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public org.bouncycastle.asn1.DERInteger getCrlNum()

public org.bouncycastle.asn1.DERGeneralizedTime getCrlTime()

public org.bouncycastle.asn1.DERIA5String getCrlUrl()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public abstract interface class org.bouncycastle.asn1.ocsp.OCSPObjectIdentifiers extends java.lang.Object

----------------FIELDS----------------

public static final org.bouncycastle.asn1.DERObjectIdentifier id_pkix_ocsp

public static final org.bouncycastle.asn1.DERObjectIdentifier id_pkix_ocsp_archive_cutoff

public static final org.bouncycastle.asn1.DERObjectIdentifier id_pkix_ocsp_basic

public static final org.bouncycastle.asn1.DERObjectIdentifier id_pkix_ocsp_crl

public static final org.bouncycastle.asn1.DERObjectIdentifier id_pkix_ocsp_nocheck

public static final org.bouncycastle.asn1.DERObjectIdentifier id_pkix_ocsp_nonce

public static final org.bouncycastle.asn1.DERObjectIdentifier id_pkix_ocsp_response

public static final org.bouncycastle.asn1.DERObjectIdentifier id_pkix_ocsp_service_locator

public static final java.lang.String pkix_ocsp
----------------METHODS----------------

static void <clinit>()

________________CLASS________________


public class org.bouncycastle.asn1.ocsp.OCSPRequest extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.ocsp.Signature optionalSignature

 org.bouncycastle.asn1.ocsp.TBSRequest tbsRequest
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.ocsp.TBSRequest
org.bouncycastle.asn1.ocsp.Signature)

public static org.bouncycastle.asn1.ocsp.OCSPRequest getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.ocsp.OCSPRequest getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.ocsp.Signature getOptionalSignature()

public org.bouncycastle.asn1.ocsp.TBSRequest getTbsRequest()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.ocsp.OCSPResponse extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.ocsp.ResponseBytes responseBytes

 org.bouncycastle.asn1.ocsp.OCSPResponseStatus responseStatus
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.ocsp.OCSPResponseStatus
org.bouncycastle.asn1.ocsp.ResponseBytes)

public static org.bouncycastle.asn1.ocsp.OCSPResponse getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.ocsp.OCSPResponse getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.ocsp.ResponseBytes getResponseBytes()

public org.bouncycastle.asn1.ocsp.OCSPResponseStatus getResponseStatus()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.ocsp.OCSPResponseStatus extends org.bouncycastle.asn1.DEREnumerated

----------------FIELDS----------------

public static final int INTERNAL_ERROR

public static final int MALFORMED_REQUEST

public static final int SIG_REQUIRED

public static final int SUCCESSFUL

public static final int TRY_LATER

public static final int UNAUTHORIZED
----------------METHODS----------------

public void <init>(
int)

public void <init>(
org.bouncycastle.asn1.DEREnumerated)

________________CLASS________________


public class org.bouncycastle.asn1.ocsp.Request extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.ocsp.CertID reqCert

 org.bouncycastle.asn1.x509.X509Extensions singleRequestExtensions
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.ocsp.CertID
org.bouncycastle.asn1.x509.X509Extensions)

public static org.bouncycastle.asn1.ocsp.Request getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.ocsp.Request getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.ocsp.CertID getReqCert()

public org.bouncycastle.asn1.x509.X509Extensions getSingleRequestExtensions()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.ocsp.ResponderID extends org.bouncycastle.asn1.ASN1Encodable implements org.bouncycastle.asn1.ASN1Choice

----------------FIELDS----------------

private org.bouncycastle.asn1.DEREncodable value
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1OctetString)

public void <init>(
org.bouncycastle.asn1.x509.X509Name)

public static org.bouncycastle.asn1.ocsp.ResponderID getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.ocsp.ResponderID getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.ocsp.ResponseBytes extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.ASN1OctetString response

 org.bouncycastle.asn1.DERObjectIdentifier responseType
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.DERObjectIdentifier
org.bouncycastle.asn1.ASN1OctetString)

public static org.bouncycastle.asn1.ocsp.ResponseBytes getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.ocsp.ResponseBytes getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.ASN1OctetString getResponse()

public org.bouncycastle.asn1.DERObjectIdentifier getResponseType()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.ocsp.ResponseData extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private static final org.bouncycastle.asn1.DERInteger V1

private org.bouncycastle.asn1.DERGeneralizedTime producedAt

private org.bouncycastle.asn1.ocsp.ResponderID responderID

private org.bouncycastle.asn1.x509.X509Extensions responseExtensions

private org.bouncycastle.asn1.ASN1Sequence responses

private org.bouncycastle.asn1.DERInteger version

private boolean versionPresent
----------------METHODS----------------

static void <clinit>()

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.DERInteger
org.bouncycastle.asn1.ocsp.ResponderID
org.bouncycastle.asn1.DERGeneralizedTime
org.bouncycastle.asn1.ASN1Sequence
org.bouncycastle.asn1.x509.X509Extensions)

public void <init>(
org.bouncycastle.asn1.ocsp.ResponderID
org.bouncycastle.asn1.DERGeneralizedTime
org.bouncycastle.asn1.ASN1Sequence
org.bouncycastle.asn1.x509.X509Extensions)

public static org.bouncycastle.asn1.ocsp.ResponseData getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.ocsp.ResponseData getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.DERGeneralizedTime getProducedAt()

public org.bouncycastle.asn1.ocsp.ResponderID getResponderID()

public org.bouncycastle.asn1.x509.X509Extensions getResponseExtensions()

public org.bouncycastle.asn1.ASN1Sequence getResponses()

public org.bouncycastle.asn1.DERInteger getVersion()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.ocsp.RevokedInfo extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.x509.CRLReason revocationReason

private org.bouncycastle.asn1.DERGeneralizedTime revocationTime
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.DERGeneralizedTime
org.bouncycastle.asn1.x509.CRLReason)

public static org.bouncycastle.asn1.ocsp.RevokedInfo getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.ocsp.RevokedInfo getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.x509.CRLReason getRevocationReason()

public org.bouncycastle.asn1.DERGeneralizedTime getRevocationTime()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.ocsp.ServiceLocator extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.x509.X509Name issuer

 org.bouncycastle.asn1.DERObject locator
----------------METHODS----------------

public void <init>()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.ocsp.Signature extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.ASN1Sequence certs

 org.bouncycastle.asn1.DERBitString signature

 org.bouncycastle.asn1.x509.AlgorithmIdentifier signatureAlgorithm
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.x509.AlgorithmIdentifier
org.bouncycastle.asn1.DERBitString)

public void <init>(
org.bouncycastle.asn1.x509.AlgorithmIdentifier
org.bouncycastle.asn1.DERBitString
org.bouncycastle.asn1.ASN1Sequence)

public static org.bouncycastle.asn1.ocsp.Signature getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.ocsp.Signature getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.ASN1Sequence getCerts()

public org.bouncycastle.asn1.DERBitString getSignature()

public org.bouncycastle.asn1.x509.AlgorithmIdentifier getSignatureAlgorithm()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.ocsp.SingleResponse extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.ocsp.CertID certID

private org.bouncycastle.asn1.ocsp.CertStatus certStatus

private org.bouncycastle.asn1.DERGeneralizedTime nextUpdate

private org.bouncycastle.asn1.x509.X509Extensions singleExtensions

private org.bouncycastle.asn1.DERGeneralizedTime thisUpdate
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.ocsp.CertID
org.bouncycastle.asn1.ocsp.CertStatus
org.bouncycastle.asn1.DERGeneralizedTime
org.bouncycastle.asn1.DERGeneralizedTime
org.bouncycastle.asn1.x509.X509Extensions)

public static org.bouncycastle.asn1.ocsp.SingleResponse getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.ocsp.SingleResponse getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.ocsp.CertID getCertID()

public org.bouncycastle.asn1.ocsp.CertStatus getCertStatus()

public org.bouncycastle.asn1.DERGeneralizedTime getNextUpdate()

public org.bouncycastle.asn1.x509.X509Extensions getSingleExtensions()

public org.bouncycastle.asn1.DERGeneralizedTime getThisUpdate()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.ocsp.TBSRequest extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private static final org.bouncycastle.asn1.DERInteger V1

 org.bouncycastle.asn1.x509.X509Extensions requestExtensions

 org.bouncycastle.asn1.ASN1Sequence requestList

 org.bouncycastle.asn1.x509.GeneralName requestorName

 org.bouncycastle.asn1.DERInteger version
----------------METHODS----------------

static void <clinit>()

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.x509.GeneralName
org.bouncycastle.asn1.ASN1Sequence
org.bouncycastle.asn1.x509.X509Extensions)

public static org.bouncycastle.asn1.ocsp.TBSRequest getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.ocsp.TBSRequest getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.x509.X509Extensions getRequestExtensions()

public org.bouncycastle.asn1.ASN1Sequence getRequestList()

public org.bouncycastle.asn1.x509.GeneralName getRequestorName()

public org.bouncycastle.asn1.DERInteger getVersion()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public abstract interface class org.bouncycastle.asn1.oiw.OIWObjectIdentifiers extends java.lang.Object

----------------FIELDS----------------

public static final org.bouncycastle.asn1.DERObjectIdentifier desCBC

public static final org.bouncycastle.asn1.DERObjectIdentifier dsaWithSHA1

public static final org.bouncycastle.asn1.DERObjectIdentifier elGamalAlgorithm

public static final org.bouncycastle.asn1.DERObjectIdentifier idSHA1

public static final org.bouncycastle.asn1.DERObjectIdentifier md4WithRSA

public static final org.bouncycastle.asn1.DERObjectIdentifier md4WithRSAEncryption

public static final org.bouncycastle.asn1.DERObjectIdentifier md5WithRSA

public static final org.bouncycastle.asn1.DERObjectIdentifier sha1WithRSA
----------------METHODS----------------

static void <clinit>()

________________CLASS________________


public class org.bouncycastle.asn1.pkcs.Attribute extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.DERObjectIdentifier attrType

private org.bouncycastle.asn1.ASN1Set attrValues
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.DERObjectIdentifier
org.bouncycastle.asn1.ASN1Set)

public static org.bouncycastle.asn1.pkcs.Attribute getInstance(
java.lang.Object)

public org.bouncycastle.asn1.DERObjectIdentifier getAttrType()

public org.bouncycastle.asn1.ASN1Set getAttrValues()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.pkcs.AuthenticatedSafe extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.pkcs.ContentInfo[] info
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.pkcs.ContentInfo[])

public org.bouncycastle.asn1.pkcs.ContentInfo[] getContentInfo()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.pkcs.CertBag extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.DERObjectIdentifier certId

 org.bouncycastle.asn1.DERObject certValue

 org.bouncycastle.asn1.ASN1Sequence seq
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.DERObjectIdentifier
org.bouncycastle.asn1.DERObject)

public org.bouncycastle.asn1.DERObjectIdentifier getCertId()

public org.bouncycastle.asn1.DERObject getCertValue()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.pkcs.CertificationRequest extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

protected org.bouncycastle.asn1.pkcs.CertificationRequestInfo reqInfo

protected org.bouncycastle.asn1.x509.AlgorithmIdentifier sigAlgId

protected org.bouncycastle.asn1.DERBitString sigBits
----------------METHODS----------------

protected void <init>()

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.pkcs.CertificationRequestInfo
org.bouncycastle.asn1.x509.AlgorithmIdentifier
org.bouncycastle.asn1.DERBitString)

public org.bouncycastle.asn1.pkcs.CertificationRequestInfo getCertificationRequestInfo()

public org.bouncycastle.asn1.DERBitString getSignature()

public org.bouncycastle.asn1.x509.AlgorithmIdentifier getSignatureAlgorithm()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.pkcs.CertificationRequestInfo extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.ASN1Set attributes

 org.bouncycastle.asn1.x509.X509Name subject

 org.bouncycastle.asn1.x509.SubjectPublicKeyInfo subjectPKInfo

 org.bouncycastle.asn1.DERInteger version
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.x509.X509Name
org.bouncycastle.asn1.x509.SubjectPublicKeyInfo
org.bouncycastle.asn1.ASN1Set)

public static org.bouncycastle.asn1.pkcs.CertificationRequestInfo getInstance(
java.lang.Object)

public org.bouncycastle.asn1.ASN1Set getAttributes()

public org.bouncycastle.asn1.x509.X509Name getSubject()

public org.bouncycastle.asn1.x509.SubjectPublicKeyInfo getSubjectPublicKeyInfo()

public org.bouncycastle.asn1.DERInteger getVersion()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public abstract interface class org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers extends java.lang.Object

----------------FIELDS----------------

public static final org.bouncycastle.asn1.DERObjectIdentifier RC2_CBC

public static final java.lang.String bagtypes

public static final org.bouncycastle.asn1.DERObjectIdentifier canNotDecryptAny

public static final org.bouncycastle.asn1.DERObjectIdentifier certBag

public static final org.bouncycastle.asn1.DERObjectIdentifier crlBag

public static final org.bouncycastle.asn1.DERObjectIdentifier data

public static final org.bouncycastle.asn1.DERObjectIdentifier des_EDE3_CBC

public static final org.bouncycastle.asn1.DERObjectIdentifier dhKeyAgreement

public static final java.lang.String digestAlgorithm

public static final org.bouncycastle.asn1.DERObjectIdentifier digestedData

public static final org.bouncycastle.asn1.DERObjectIdentifier encryptedData

public static final java.lang.String encryptionAlgorithm

public static final org.bouncycastle.asn1.DERObjectIdentifier envelopedData

public static final org.bouncycastle.asn1.DERObjectIdentifier id_PBES2

public static final org.bouncycastle.asn1.DERObjectIdentifier id_PBKDF2

public static final org.bouncycastle.asn1.DERObjectIdentifier id_RSAES_OAEP

public static final org.bouncycastle.asn1.DERObjectIdentifier id_RSASSA_PSS

public static final java.lang.String id_aa

public static final org.bouncycastle.asn1.DERObjectIdentifier id_aa_commitmentType

public static final org.bouncycastle.asn1.DERObjectIdentifier id_aa_contentIdentifier

public static final org.bouncycastle.asn1.DERObjectIdentifier id_aa_encrypKeyPref

public static final org.bouncycastle.asn1.DERObjectIdentifier id_aa_otherSigCert

public static final org.bouncycastle.asn1.DERObjectIdentifier id_aa_receiptRequest

public static final org.bouncycastle.asn1.DERObjectIdentifier id_aa_sigPolicyId

public static final org.bouncycastle.asn1.DERObjectIdentifier id_aa_signatureTimeStampToken

public static final org.bouncycastle.asn1.DERObjectIdentifier id_aa_signerLocation

public static final org.bouncycastle.asn1.DERObjectIdentifier id_aa_signingCertificate

public static final org.bouncycastle.asn1.DERObjectIdentifier id_alg_PWRI_KEK

public static final java.lang.String id_ct

public static final org.bouncycastle.asn1.DERObjectIdentifier id_ct_TSTInfo

public static final org.bouncycastle.asn1.DERObjectIdentifier id_ct_compressedData

public static final java.lang.String id_cti

public static final org.bouncycastle.asn1.DERObjectIdentifier id_cti_ets_proofOfApproval

public static final org.bouncycastle.asn1.DERObjectIdentifier id_cti_ets_proofOfCreation

public static final org.bouncycastle.asn1.DERObjectIdentifier id_cti_ets_proofOfDelivery

public static final org.bouncycastle.asn1.DERObjectIdentifier id_cti_ets_proofOfOrigin

public static final org.bouncycastle.asn1.DERObjectIdentifier id_cti_ets_proofOfReceipt

public static final org.bouncycastle.asn1.DERObjectIdentifier id_cti_ets_proofOfSender

public static final org.bouncycastle.asn1.DERObjectIdentifier id_hmacWithSHA1

public static final org.bouncycastle.asn1.DERObjectIdentifier id_hmacWithSHA224

public static final org.bouncycastle.asn1.DERObjectIdentifier id_hmacWithSHA256

public static final org.bouncycastle.asn1.DERObjectIdentifier id_hmacWithSHA384

public static final org.bouncycastle.asn1.DERObjectIdentifier id_hmacWithSHA512

public static final org.bouncycastle.asn1.DERObjectIdentifier id_mgf1

public static final org.bouncycastle.asn1.DERObjectIdentifier id_pSpecified

public static final org.bouncycastle.asn1.DERObjectIdentifier keyBag

public static final org.bouncycastle.asn1.DERObjectIdentifier md2

public static final org.bouncycastle.asn1.DERObjectIdentifier md2WithRSAEncryption

public static final org.bouncycastle.asn1.DERObjectIdentifier md4

public static final org.bouncycastle.asn1.DERObjectIdentifier md4WithRSAEncryption

public static final org.bouncycastle.asn1.DERObjectIdentifier md5

public static final org.bouncycastle.asn1.DERObjectIdentifier md5WithRSAEncryption

public static final org.bouncycastle.asn1.DERObjectIdentifier pbeWithMD2AndDES_CBC

public static final org.bouncycastle.asn1.DERObjectIdentifier pbeWithMD2AndRC2_CBC

public static final org.bouncycastle.asn1.DERObjectIdentifier pbeWithMD5AndDES_CBC

public static final org.bouncycastle.asn1.DERObjectIdentifier pbeWithMD5AndRC2_CBC

public static final org.bouncycastle.asn1.DERObjectIdentifier pbeWithSHA1AndDES_CBC

public static final org.bouncycastle.asn1.DERObjectIdentifier pbeWithSHA1AndRC2_CBC

public static final org.bouncycastle.asn1.DERObjectIdentifier pbeWithSHAAnd128BitRC2_CBC

public static final org.bouncycastle.asn1.DERObjectIdentifier pbeWithSHAAnd128BitRC4

public static final org.bouncycastle.asn1.DERObjectIdentifier pbeWithSHAAnd2_KeyTripleDES_CBC

public static final org.bouncycastle.asn1.DERObjectIdentifier pbeWithSHAAnd3_KeyTripleDES_CBC

public static final org.bouncycastle.asn1.DERObjectIdentifier pbeWithSHAAnd40BitRC4

public static final org.bouncycastle.asn1.DERObjectIdentifier pbewithSHAAnd40BitRC2_CBC

public static final org.bouncycastle.asn1.DERObjectIdentifier pkcs8ShroudedKeyBag

public static final java.lang.String pkcs_1

public static final java.lang.String pkcs_12

public static final java.lang.String pkcs_12PbeIds

public static final java.lang.String pkcs_3

public static final java.lang.String pkcs_5

public static final java.lang.String pkcs_7

public static final java.lang.String pkcs_9

public static final org.bouncycastle.asn1.DERObjectIdentifier pkcs_9_at_challengePassword

public static final org.bouncycastle.asn1.DERObjectIdentifier pkcs_9_at_contentType

public static final org.bouncycastle.asn1.DERObjectIdentifier pkcs_9_at_counterSignature

public static final org.bouncycastle.asn1.DERObjectIdentifier pkcs_9_at_emailAddress

public static final org.bouncycastle.asn1.DERObjectIdentifier pkcs_9_at_extendedCertificateAttributes

public static final org.bouncycastle.asn1.DERObjectIdentifier pkcs_9_at_extensionRequest

public static final org.bouncycastle.asn1.DERObjectIdentifier pkcs_9_at_friendlyName

public static final org.bouncycastle.asn1.DERObjectIdentifier pkcs_9_at_localKeyId

public static final org.bouncycastle.asn1.DERObjectIdentifier pkcs_9_at_messageDigest

public static final org.bouncycastle.asn1.DERObjectIdentifier pkcs_9_at_signingDescription

public static final org.bouncycastle.asn1.DERObjectIdentifier pkcs_9_at_signingTime

public static final org.bouncycastle.asn1.DERObjectIdentifier pkcs_9_at_smimeCapabilities

public static final org.bouncycastle.asn1.DERObjectIdentifier pkcs_9_at_unstructuredAddress

public static final org.bouncycastle.asn1.DERObjectIdentifier pkcs_9_at_unstructuredName

public static final org.bouncycastle.asn1.DERObjectIdentifier preferSignedData

public static final org.bouncycastle.asn1.DERObjectIdentifier rsaEncryption

public static final org.bouncycastle.asn1.DERObjectIdentifier sMIMECapabilitiesVersions

public static final org.bouncycastle.asn1.DERObjectIdentifier safeContentsBag

public static final org.bouncycastle.asn1.DERObjectIdentifier secretBag

public static final org.bouncycastle.asn1.DERObjectIdentifier sha1WithRSAEncryption

public static final org.bouncycastle.asn1.DERObjectIdentifier sha224WithRSAEncryption

public static final org.bouncycastle.asn1.DERObjectIdentifier sha256WithRSAEncryption

public static final org.bouncycastle.asn1.DERObjectIdentifier sha384WithRSAEncryption

public static final org.bouncycastle.asn1.DERObjectIdentifier sha512WithRSAEncryption

public static final org.bouncycastle.asn1.DERObjectIdentifier signedAndEnvelopedData

public static final org.bouncycastle.asn1.DERObjectIdentifier signedData

public static final org.bouncycastle.asn1.DERObjectIdentifier srsaOAEPEncryptionSET

public static final org.bouncycastle.asn1.DERObjectIdentifier x509certType
----------------METHODS----------------

static void <clinit>()

________________CLASS________________


public class org.bouncycastle.asn1.pkcs.ContentInfo extends org.bouncycastle.asn1.ASN1Encodable implements org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers

----------------FIELDS----------------

private org.bouncycastle.asn1.DEREncodable content

private org.bouncycastle.asn1.DERObjectIdentifier contentType
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.DERObjectIdentifier
org.bouncycastle.asn1.DEREncodable)

public static org.bouncycastle.asn1.pkcs.ContentInfo getInstance(
java.lang.Object)

public org.bouncycastle.asn1.DEREncodable getContent()

public org.bouncycastle.asn1.DERObjectIdentifier getContentType()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.pkcs.DHParameter extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.DERInteger g

 org.bouncycastle.asn1.DERInteger l

 org.bouncycastle.asn1.DERInteger p
----------------METHODS----------------

public void <init>(
java.math.BigInteger
java.math.BigInteger
int)

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public java.math.BigInteger getG()

public java.math.BigInteger getL()

public java.math.BigInteger getP()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.pkcs.EncryptedData extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.DERObjectIdentifier bagId

 org.bouncycastle.asn1.DERObject bagValue

 org.bouncycastle.asn1.ASN1Sequence data
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.DERObjectIdentifier
org.bouncycastle.asn1.x509.AlgorithmIdentifier
org.bouncycastle.asn1.DEREncodable)

public static org.bouncycastle.asn1.pkcs.EncryptedData getInstance(
java.lang.Object)

public org.bouncycastle.asn1.ASN1OctetString getContent()

public org.bouncycastle.asn1.DERObjectIdentifier getContentType()

public org.bouncycastle.asn1.x509.AlgorithmIdentifier getEncryptionAlgorithm()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.pkcs.EncryptedPrivateKeyInfo extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.x509.AlgorithmIdentifier algId

private org.bouncycastle.asn1.ASN1OctetString data
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.x509.AlgorithmIdentifier
byte[])

public static org.bouncycastle.asn1.pkcs.EncryptedPrivateKeyInfo getInstance(
java.lang.Object)

public byte[] getEncryptedData()

public org.bouncycastle.asn1.x509.AlgorithmIdentifier getEncryptionAlgorithm()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.x509.AlgorithmIdentifier extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.DERObjectIdentifier objectId

private org.bouncycastle.asn1.DEREncodable parameters

private boolean parametersDefined
----------------METHODS----------------

public void <init>(
java.lang.String)

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.DERObjectIdentifier)

public void <init>(
org.bouncycastle.asn1.DERObjectIdentifier
org.bouncycastle.asn1.DEREncodable)

public static org.bouncycastle.asn1.x509.AlgorithmIdentifier getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.x509.AlgorithmIdentifier getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.DERObjectIdentifier getObjectId()

public org.bouncycastle.asn1.DEREncodable getParameters()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.pkcs.EncryptionScheme extends org.bouncycastle.asn1.x509.AlgorithmIdentifier

----------------FIELDS----------------

 org.bouncycastle.asn1.DERObject obj

 org.bouncycastle.asn1.DERObject objectId
----------------METHODS----------------

 void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public org.bouncycastle.asn1.DERObject getDERObject()

public org.bouncycastle.asn1.DERObject getObject()

________________CLASS________________


public class org.bouncycastle.asn1.pkcs.IssuerAndSerialNumber extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.DERInteger certSerialNumber

 org.bouncycastle.asn1.x509.X509Name name
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.x509.X509Name
java.math.BigInteger)

public void <init>(
org.bouncycastle.asn1.x509.X509Name
org.bouncycastle.asn1.DERInteger)

public static org.bouncycastle.asn1.pkcs.IssuerAndSerialNumber getInstance(
java.lang.Object)

public org.bouncycastle.asn1.DERInteger getCertificateSerialNumber()

public org.bouncycastle.asn1.x509.X509Name getName()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.pkcs.KeyDerivationFunc extends org.bouncycastle.asn1.x509.AlgorithmIdentifier

----------------FIELDS----------------
----------------METHODS----------------

 void <init>(
org.bouncycastle.asn1.ASN1Sequence)

 void <init>(
org.bouncycastle.asn1.DERObjectIdentifier
org.bouncycastle.asn1.ASN1Encodable)

________________CLASS________________


public class org.bouncycastle.asn1.pkcs.MacData extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.x509.DigestInfo digInfo

 java.math.BigInteger iterationCount

 byte[] salt
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.x509.DigestInfo
byte[]
int)

public static org.bouncycastle.asn1.pkcs.MacData getInstance(
java.lang.Object)

public java.math.BigInteger getIterationCount()

public org.bouncycastle.asn1.x509.DigestInfo getMac()

public byte[] getSalt()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.pkcs.PBES2Algorithms extends org.bouncycastle.asn1.x509.AlgorithmIdentifier implements org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers

----------------FIELDS----------------

private org.bouncycastle.asn1.pkcs.KeyDerivationFunc func

private org.bouncycastle.asn1.DERObjectIdentifier objectId

private org.bouncycastle.asn1.pkcs.EncryptionScheme scheme
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public org.bouncycastle.asn1.DERObject getDERObject()

public org.bouncycastle.asn1.pkcs.EncryptionScheme getEncryptionScheme()

public org.bouncycastle.asn1.pkcs.KeyDerivationFunc getKeyDerivationFunc()

public org.bouncycastle.asn1.DERObjectIdentifier getObjectId()

________________CLASS________________


public class org.bouncycastle.asn1.pkcs.PBES2Parameters extends org.bouncycastle.asn1.ASN1Encodable implements org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers

----------------FIELDS----------------

private org.bouncycastle.asn1.pkcs.KeyDerivationFunc func

private org.bouncycastle.asn1.pkcs.EncryptionScheme scheme
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public org.bouncycastle.asn1.pkcs.EncryptionScheme getEncryptionScheme()

public org.bouncycastle.asn1.pkcs.KeyDerivationFunc getKeyDerivationFunc()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.pkcs.PBKDF2Params extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.DERInteger iterationCount

 org.bouncycastle.asn1.DERInteger keyLength

 org.bouncycastle.asn1.ASN1OctetString octStr
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
byte[]
int)

public static org.bouncycastle.asn1.pkcs.PBKDF2Params getInstance(
java.lang.Object)

public java.math.BigInteger getIterationCount()

public java.math.BigInteger getKeyLength()

public byte[] getSalt()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.pkcs.PKCS12PBEParams extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.DERInteger iterations

 org.bouncycastle.asn1.ASN1OctetString iv
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
byte[]
int)

public static org.bouncycastle.asn1.pkcs.PKCS12PBEParams getInstance(
java.lang.Object)

public byte[] getIV()

public java.math.BigInteger getIterations()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.pkcs.Pfx extends org.bouncycastle.asn1.ASN1Encodable implements org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers

----------------FIELDS----------------

private org.bouncycastle.asn1.pkcs.ContentInfo contentInfo

private org.bouncycastle.asn1.pkcs.MacData macData
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.pkcs.ContentInfo
org.bouncycastle.asn1.pkcs.MacData)

public org.bouncycastle.asn1.pkcs.ContentInfo getAuthSafe()

public org.bouncycastle.asn1.pkcs.MacData getMacData()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.pkcs.PrivateKeyInfo extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.x509.AlgorithmIdentifier algId

private org.bouncycastle.asn1.ASN1Set attributes

private org.bouncycastle.asn1.DERObject privKey
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.x509.AlgorithmIdentifier
org.bouncycastle.asn1.DERObject)

public static org.bouncycastle.asn1.pkcs.PrivateKeyInfo getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.pkcs.PrivateKeyInfo getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.x509.AlgorithmIdentifier getAlgorithmId()

public org.bouncycastle.asn1.ASN1Set getAttributes()

public org.bouncycastle.asn1.DERObject getPrivateKey()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.pkcs.RC2CBCParameter extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.ASN1OctetString iv

 org.bouncycastle.asn1.DERInteger version
----------------METHODS----------------

public void <init>(
int
byte[])

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
byte[])

public static org.bouncycastle.asn1.pkcs.RC2CBCParameter getInstance(
java.lang.Object)

public byte[] getIV()

public java.math.BigInteger getRC2ParameterVersion()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.pkcs.RSAESOAEPparams extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

public static final org.bouncycastle.asn1.x509.AlgorithmIdentifier DEFAULT_HASH_ALGORITHM

public static final org.bouncycastle.asn1.x509.AlgorithmIdentifier DEFAULT_MASK_GEN_FUNCTION

public static final org.bouncycastle.asn1.x509.AlgorithmIdentifier DEFAULT_P_SOURCE_ALGORITHM

private org.bouncycastle.asn1.x509.AlgorithmIdentifier hashAlgorithm

private org.bouncycastle.asn1.x509.AlgorithmIdentifier maskGenAlgorithm

private org.bouncycastle.asn1.x509.AlgorithmIdentifier pSourceAlgorithm
----------------METHODS----------------

static void <clinit>()

public void <init>()

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.x509.AlgorithmIdentifier
org.bouncycastle.asn1.x509.AlgorithmIdentifier
org.bouncycastle.asn1.x509.AlgorithmIdentifier)

public static org.bouncycastle.asn1.pkcs.RSAESOAEPparams getInstance(
java.lang.Object)

public org.bouncycastle.asn1.x509.AlgorithmIdentifier getHashAlgorithm()

public org.bouncycastle.asn1.x509.AlgorithmIdentifier getMaskGenAlgorithm()

public org.bouncycastle.asn1.x509.AlgorithmIdentifier getPSourceAlgorithm()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.pkcs.RSAPrivateKeyStructure extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private java.math.BigInteger coefficient

private java.math.BigInteger exponent1

private java.math.BigInteger exponent2

private java.math.BigInteger modulus

private org.bouncycastle.asn1.ASN1Sequence otherPrimeInfos

private java.math.BigInteger prime1

private java.math.BigInteger prime2

private java.math.BigInteger privateExponent

private java.math.BigInteger publicExponent

private int version
----------------METHODS----------------

public void <init>(
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger)

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public static org.bouncycastle.asn1.pkcs.RSAPrivateKeyStructure getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.pkcs.RSAPrivateKeyStructure getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public java.math.BigInteger getCoefficient()

public java.math.BigInteger getExponent1()

public java.math.BigInteger getExponent2()

public java.math.BigInteger getModulus()

public java.math.BigInteger getPrime1()

public java.math.BigInteger getPrime2()

public java.math.BigInteger getPrivateExponent()

public java.math.BigInteger getPublicExponent()

public int getVersion()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.pkcs.RSASSAPSSparams extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

public static final org.bouncycastle.asn1.x509.AlgorithmIdentifier DEFAULT_HASH_ALGORITHM

public static final org.bouncycastle.asn1.x509.AlgorithmIdentifier DEFAULT_MASK_GEN_FUNCTION

public static final org.bouncycastle.asn1.DERInteger DEFAULT_SALT_LENGTH

public static final org.bouncycastle.asn1.DERInteger DEFAULT_TRAILER_FIELD

private org.bouncycastle.asn1.x509.AlgorithmIdentifier hashAlgorithm

private org.bouncycastle.asn1.x509.AlgorithmIdentifier maskGenAlgorithm

private org.bouncycastle.asn1.DERInteger saltLength

private org.bouncycastle.asn1.DERInteger trailerField
----------------METHODS----------------

static void <clinit>()

public void <init>()

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.x509.AlgorithmIdentifier
org.bouncycastle.asn1.x509.AlgorithmIdentifier
org.bouncycastle.asn1.DERInteger
org.bouncycastle.asn1.DERInteger)

public static org.bouncycastle.asn1.pkcs.RSASSAPSSparams getInstance(
java.lang.Object)

public org.bouncycastle.asn1.x509.AlgorithmIdentifier getHashAlgorithm()

public org.bouncycastle.asn1.x509.AlgorithmIdentifier getMaskGenAlgorithm()

public org.bouncycastle.asn1.DERInteger getSaltLength()

public org.bouncycastle.asn1.DERInteger getTrailerField()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.pkcs.SafeBag extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.ASN1Set bagAttributes

 org.bouncycastle.asn1.DERObjectIdentifier bagId

 org.bouncycastle.asn1.DERObject bagValue
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.DERObjectIdentifier
org.bouncycastle.asn1.DERObject)

public void <init>(
org.bouncycastle.asn1.DERObjectIdentifier
org.bouncycastle.asn1.DERObject
org.bouncycastle.asn1.ASN1Set)

public org.bouncycastle.asn1.ASN1Set getBagAttributes()

public org.bouncycastle.asn1.DERObjectIdentifier getBagId()

public org.bouncycastle.asn1.DERObject getBagValue()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.pkcs.SignedData extends org.bouncycastle.asn1.ASN1Encodable implements org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers

----------------FIELDS----------------

private org.bouncycastle.asn1.ASN1Set certificates

private org.bouncycastle.asn1.pkcs.ContentInfo contentInfo

private org.bouncycastle.asn1.ASN1Set crls

private org.bouncycastle.asn1.ASN1Set digestAlgorithms

private org.bouncycastle.asn1.ASN1Set signerInfos

private org.bouncycastle.asn1.DERInteger version
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.DERInteger
org.bouncycastle.asn1.ASN1Set
org.bouncycastle.asn1.pkcs.ContentInfo
org.bouncycastle.asn1.ASN1Set
org.bouncycastle.asn1.ASN1Set
org.bouncycastle.asn1.ASN1Set)

public static org.bouncycastle.asn1.pkcs.SignedData getInstance(
java.lang.Object)

public org.bouncycastle.asn1.ASN1Set getCRLs()

public org.bouncycastle.asn1.ASN1Set getCertificates()

public org.bouncycastle.asn1.pkcs.ContentInfo getContentInfo()

public org.bouncycastle.asn1.ASN1Set getDigestAlgorithms()

public org.bouncycastle.asn1.ASN1Set getSignerInfos()

public org.bouncycastle.asn1.DERInteger getVersion()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.pkcs.SignerInfo extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.ASN1Set authenticatedAttributes

private org.bouncycastle.asn1.x509.AlgorithmIdentifier digAlgorithm

private org.bouncycastle.asn1.x509.AlgorithmIdentifier digEncryptionAlgorithm

private org.bouncycastle.asn1.ASN1OctetString encryptedDigest

private org.bouncycastle.asn1.pkcs.IssuerAndSerialNumber issuerAndSerialNumber

private org.bouncycastle.asn1.ASN1Set unauthenticatedAttributes

private org.bouncycastle.asn1.DERInteger version
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.DERInteger
org.bouncycastle.asn1.pkcs.IssuerAndSerialNumber
org.bouncycastle.asn1.x509.AlgorithmIdentifier
org.bouncycastle.asn1.ASN1Set
org.bouncycastle.asn1.x509.AlgorithmIdentifier
org.bouncycastle.asn1.ASN1OctetString
org.bouncycastle.asn1.ASN1Set)

public static org.bouncycastle.asn1.pkcs.SignerInfo getInstance(
java.lang.Object)

public org.bouncycastle.asn1.ASN1Set getAuthenticatedAttributes()

public org.bouncycastle.asn1.x509.AlgorithmIdentifier getDigestAlgorithm()

public org.bouncycastle.asn1.x509.AlgorithmIdentifier getDigestEncryptionAlgorithm()

public org.bouncycastle.asn1.ASN1OctetString getEncryptedDigest()

public org.bouncycastle.asn1.pkcs.IssuerAndSerialNumber getIssuerAndSerialNumber()

public org.bouncycastle.asn1.ASN1Set getUnauthenticatedAttributes()

public org.bouncycastle.asn1.DERInteger getVersion()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public abstract interface class org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers extends java.lang.Object

----------------FIELDS----------------

public static final org.bouncycastle.asn1.DERObjectIdentifier ripemd128

public static final org.bouncycastle.asn1.DERObjectIdentifier ripemd160

public static final org.bouncycastle.asn1.DERObjectIdentifier ripemd256

public static final org.bouncycastle.asn1.DERObjectIdentifier rsaSignatureWithripemd128

public static final org.bouncycastle.asn1.DERObjectIdentifier rsaSignatureWithripemd160

public static final org.bouncycastle.asn1.DERObjectIdentifier rsaSignatureWithripemd256

public static final java.lang.String teleTrusTAlgorithm

public static final java.lang.String teleTrusTRSAsignatureAlgorithm
----------------METHODS----------------

static void <clinit>()

________________CLASS________________


public class org.bouncycastle.asn1.tsp.Accuracy extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

protected static final int MAX_MICROS

protected static final int MAX_MILLIS

protected static final int MIN_MICROS

protected static final int MIN_MILLIS

 org.bouncycastle.asn1.DERInteger micros

 org.bouncycastle.asn1.DERInteger millis

 org.bouncycastle.asn1.DERInteger seconds
----------------METHODS----------------

protected void <init>()

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.DERInteger
org.bouncycastle.asn1.DERInteger
org.bouncycastle.asn1.DERInteger)

public static org.bouncycastle.asn1.tsp.Accuracy getInstance(
java.lang.Object)

public org.bouncycastle.asn1.DERInteger getMicros()

public org.bouncycastle.asn1.DERInteger getMillis()

public org.bouncycastle.asn1.DERInteger getSeconds()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.tsp.MessageImprint extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.x509.AlgorithmIdentifier hashAlgorithm

 byte[] hashedMessage
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.x509.AlgorithmIdentifier
byte[])

public static org.bouncycastle.asn1.tsp.MessageImprint getInstance(
java.lang.Object)

public org.bouncycastle.asn1.x509.AlgorithmIdentifier getHashAlgorithm()

public byte[] getHashedMessage()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.tsp.TSTInfo extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.tsp.Accuracy accuracy

 org.bouncycastle.asn1.x509.X509Extensions extensions

 org.bouncycastle.asn1.DERGeneralizedTime genTime

 org.bouncycastle.asn1.tsp.MessageImprint messageImprint

 org.bouncycastle.asn1.DERInteger nonce

 org.bouncycastle.asn1.DERBoolean ordering

 org.bouncycastle.asn1.DERInteger serialNumber

 org.bouncycastle.asn1.x509.GeneralName tsa

 org.bouncycastle.asn1.DERObjectIdentifier tsaPolicyId

 org.bouncycastle.asn1.DERInteger version
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.DERObjectIdentifier
org.bouncycastle.asn1.tsp.MessageImprint
org.bouncycastle.asn1.DERInteger
org.bouncycastle.asn1.DERGeneralizedTime
org.bouncycastle.asn1.tsp.Accuracy
org.bouncycastle.asn1.DERBoolean
org.bouncycastle.asn1.DERInteger
org.bouncycastle.asn1.x509.GeneralName
org.bouncycastle.asn1.x509.X509Extensions)

public static org.bouncycastle.asn1.tsp.TSTInfo getInstance(
java.lang.Object)

public org.bouncycastle.asn1.tsp.Accuracy getAccuracy()

public org.bouncycastle.asn1.x509.X509Extensions getExtensions()

public org.bouncycastle.asn1.DERGeneralizedTime getGenTime()

public org.bouncycastle.asn1.tsp.MessageImprint getMessageImprint()

public org.bouncycastle.asn1.DERInteger getNonce()

public org.bouncycastle.asn1.DERBoolean getOrdering()

public org.bouncycastle.asn1.DERObjectIdentifier getPolicy()

public org.bouncycastle.asn1.DERInteger getSerialNumber()

public org.bouncycastle.asn1.x509.GeneralName getTsa()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.tsp.TimeStampReq extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.DERBoolean certReq

 org.bouncycastle.asn1.x509.X509Extensions extensions

 org.bouncycastle.asn1.tsp.MessageImprint messageImprint

 org.bouncycastle.asn1.DERInteger nonce

 org.bouncycastle.asn1.DERObjectIdentifier tsaPolicy

 org.bouncycastle.asn1.DERInteger version
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.tsp.MessageImprint
org.bouncycastle.asn1.DERObjectIdentifier
org.bouncycastle.asn1.DERInteger
org.bouncycastle.asn1.DERBoolean
org.bouncycastle.asn1.x509.X509Extensions)

public static org.bouncycastle.asn1.tsp.TimeStampReq getInstance(
java.lang.Object)

public org.bouncycastle.asn1.DERBoolean getCertReq()

public org.bouncycastle.asn1.x509.X509Extensions getExtensions()

public org.bouncycastle.asn1.tsp.MessageImprint getMessageImprint()

public org.bouncycastle.asn1.DERInteger getNonce()

public org.bouncycastle.asn1.DERObjectIdentifier getReqPolicy()

public org.bouncycastle.asn1.DERInteger getVersion()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.tsp.TimeStampResp extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.cmp.PKIStatusInfo pkiStatusInfo

 org.bouncycastle.asn1.cms.ContentInfo timeStampToken
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.cmp.PKIStatusInfo
org.bouncycastle.asn1.cms.ContentInfo)

public static org.bouncycastle.asn1.tsp.TimeStampResp getInstance(
java.lang.Object)

public org.bouncycastle.asn1.cmp.PKIStatusInfo getStatus()

public org.bouncycastle.asn1.cms.ContentInfo getTimeStampToken()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.util.ASN1Dump extends java.lang.Object

----------------FIELDS----------------

private static java.lang.String TAB
----------------METHODS----------------

static void <clinit>()

public void <init>()

static java.lang.String _dumpAsString(
java.lang.String
org.bouncycastle.asn1.DERObject)

public static java.lang.String dumpAsString(
java.lang.Object)

________________CLASS________________


public class org.bouncycastle.asn1.util.DERDump extends org.bouncycastle.asn1.util.ASN1Dump

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public static java.lang.String dumpAsString(
org.bouncycastle.asn1.DEREncodable)

public static java.lang.String dumpAsString(
org.bouncycastle.asn1.DERObject)

________________CLASS________________


public class org.bouncycastle.asn1.util.Dump extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/lang/Exception; )
public static void main(
java.lang.String[])

________________CLASS________________


public class org.bouncycastle.asn1.x509.AccessDescription extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

public static final org.bouncycastle.asn1.DERObjectIdentifier id_ad_caIssuers

public static final org.bouncycastle.asn1.DERObjectIdentifier id_ad_ocsp

 org.bouncycastle.asn1.x509.GeneralName accessLocation

 org.bouncycastle.asn1.DERObjectIdentifier accessMethod
----------------METHODS----------------

static void <clinit>()

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.DERObjectIdentifier
org.bouncycastle.asn1.x509.GeneralName)

public static org.bouncycastle.asn1.x509.AccessDescription getInstance(
java.lang.Object)

public org.bouncycastle.asn1.x509.GeneralName getAccessLocation()

public org.bouncycastle.asn1.DERObjectIdentifier getAccessMethod()

public org.bouncycastle.asn1.DERObject toASN1Object()

public java.lang.String toString()

________________CLASS________________


public class org.bouncycastle.asn1.x509.AttCertIssuer extends org.bouncycastle.asn1.ASN1Encodable implements org.bouncycastle.asn1.ASN1Choice

----------------FIELDS----------------

 org.bouncycastle.asn1.DERObject choiceObj

 org.bouncycastle.asn1.ASN1Encodable obj
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.x509.GeneralNames)

public void <init>(
org.bouncycastle.asn1.x509.V2Form)

public static org.bouncycastle.asn1.x509.AttCertIssuer getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.x509.AttCertIssuer getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.ASN1Encodable getIssuer()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.x509.AttCertValidityPeriod extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.DERGeneralizedTime notAfterTime

 org.bouncycastle.asn1.DERGeneralizedTime notBeforeTime
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.DERGeneralizedTime
org.bouncycastle.asn1.DERGeneralizedTime)

public static org.bouncycastle.asn1.x509.AttCertValidityPeriod getInstance(
java.lang.Object)

public org.bouncycastle.asn1.DERGeneralizedTime getNotAfterTime()

public org.bouncycastle.asn1.DERGeneralizedTime getNotBeforeTime()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.x509.Attribute extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.DERObjectIdentifier attrType

private org.bouncycastle.asn1.ASN1Set attrValues
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.DERObjectIdentifier
org.bouncycastle.asn1.ASN1Set)

public static org.bouncycastle.asn1.x509.Attribute getInstance(
java.lang.Object)

public org.bouncycastle.asn1.DERObjectIdentifier getAttrType()

public org.bouncycastle.asn1.ASN1Set getAttrValues()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.x509.AttributeCertificate extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.x509.AttributeCertificateInfo acinfo

 org.bouncycastle.asn1.x509.AlgorithmIdentifier signatureAlgorithm

 org.bouncycastle.asn1.DERBitString signatureValue
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.x509.AttributeCertificateInfo
org.bouncycastle.asn1.x509.AlgorithmIdentifier
org.bouncycastle.asn1.DERBitString)

public static org.bouncycastle.asn1.x509.AttributeCertificate getInstance(
java.lang.Object)

public org.bouncycastle.asn1.x509.AttributeCertificateInfo getAcinfo()

public org.bouncycastle.asn1.x509.AlgorithmIdentifier getSignatureAlgorithm()

public org.bouncycastle.asn1.DERBitString getSignatureValue()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.x509.AttributeCertificateInfo extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.x509.AttCertValidityPeriod attrCertValidityPeriod

private org.bouncycastle.asn1.ASN1Sequence attributes

private org.bouncycastle.asn1.x509.X509Extensions extensions

private org.bouncycastle.asn1.x509.Holder holder

private org.bouncycastle.asn1.x509.AttCertIssuer issuer

private org.bouncycastle.asn1.DERBitString issuerUniqueID

private org.bouncycastle.asn1.DERInteger serialNumber

private org.bouncycastle.asn1.x509.AlgorithmIdentifier signature

private org.bouncycastle.asn1.DERInteger version
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public static org.bouncycastle.asn1.x509.AttributeCertificateInfo getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.x509.AttributeCertificateInfo getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.x509.AttCertValidityPeriod getAttrCertValidityPeriod()

public org.bouncycastle.asn1.ASN1Sequence getAttributes()

public org.bouncycastle.asn1.x509.X509Extensions getExtensions()

public org.bouncycastle.asn1.x509.Holder getHolder()

public org.bouncycastle.asn1.x509.AttCertIssuer getIssuer()

public org.bouncycastle.asn1.DERBitString getIssuerUniqueID()

public org.bouncycastle.asn1.DERInteger getSerialNumber()

public org.bouncycastle.asn1.x509.AlgorithmIdentifier getSignature()

public org.bouncycastle.asn1.DERInteger getVersion()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.x509.AuthorityInformationAccess extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.x509.AccessDescription[] descriptions
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.DERObjectIdentifier
org.bouncycastle.asn1.x509.GeneralName)

public static org.bouncycastle.asn1.x509.AuthorityInformationAccess getInstance(
java.lang.Object)

public org.bouncycastle.asn1.x509.AccessDescription[] getAccessDescriptions()

public org.bouncycastle.asn1.DERObject toASN1Object()

public java.lang.String toString()

________________CLASS________________


public class org.bouncycastle.asn1.x509.AuthorityKeyIdentifier extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.x509.GeneralNames certissuer

 org.bouncycastle.asn1.DERInteger certserno

 org.bouncycastle.asn1.ASN1OctetString keyidentifier
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.x509.GeneralNames
java.math.BigInteger)

public void <init>(
org.bouncycastle.asn1.x509.SubjectPublicKeyInfo)

public void <init>(
org.bouncycastle.asn1.x509.SubjectPublicKeyInfo
org.bouncycastle.asn1.x509.GeneralNames
java.math.BigInteger)

public void <init>(
byte[]
org.bouncycastle.asn1.x509.GeneralNames
java.math.BigInteger)

public static org.bouncycastle.asn1.x509.AuthorityKeyIdentifier getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.x509.AuthorityKeyIdentifier getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.x509.GeneralNames getAuthorityCertIssuer()

public java.math.BigInteger getAuthorityCertSerialNumber()

public byte[] getKeyIdentifier()

public org.bouncycastle.asn1.DERObject toASN1Object()

public java.lang.String toString()

________________CLASS________________


public class org.bouncycastle.asn1.x509.BasicConstraints extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.DERBoolean cA

 org.bouncycastle.asn1.DERInteger pathLenConstraint
----------------METHODS----------------

public void <init>(
int)

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
boolean)

public void <init>(
boolean
int)

public static org.bouncycastle.asn1.x509.BasicConstraints getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.x509.BasicConstraints getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public java.math.BigInteger getPathLenConstraint()

public boolean isCA()

public org.bouncycastle.asn1.DERObject toASN1Object()

public java.lang.String toString()

________________CLASS________________


public class org.bouncycastle.asn1.x509.CRLDistPoint extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.ASN1Sequence seq
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.x509.DistributionPoint[])

public static org.bouncycastle.asn1.x509.CRLDistPoint getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.x509.CRLDistPoint getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.x509.DistributionPoint[] getDistributionPoints()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.x509.CRLNumber extends org.bouncycastle.asn1.DERInteger

----------------FIELDS----------------
----------------METHODS----------------

public void <init>(
java.math.BigInteger)

public java.math.BigInteger getCRLNumber()

________________CLASS________________


public class org.bouncycastle.asn1.x509.CRLReason extends org.bouncycastle.asn1.DEREnumerated

----------------FIELDS----------------

public static final int AA_COMPROMISE

public static final int AFFILIATION_CHANGED

public static final int CA_COMPROMISE

public static final int CERTIFICATE_HOLD

public static final int CESSATION_OF_OPERATION

public static final int KEY_COMPROMISE

public static final int PRIVILEGE_WITHDRAWN

public static final int REMOVE_FROM_CRL

public static final int SUPERSEDED

public static final int UNSPECIFIED

public static final int aACompromise

public static final int affiliationChanged

public static final int cACompromise

public static final int certificateHold

public static final int cessationOfOperation

public static final int keyCompromise

public static final int privilegeWithdrawn

public static final int removeFromCRL

public static final int superseded

public static final int unspecified
----------------METHODS----------------

public void <init>(
int)

public void <init>(
org.bouncycastle.asn1.DEREnumerated)

________________CLASS________________


public class org.bouncycastle.asn1.x509.CertPolicyId extends org.bouncycastle.asn1.DERObjectIdentifier

----------------FIELDS----------------
----------------METHODS----------------

public void <init>(
java.lang.String)

________________CLASS________________


public class org.bouncycastle.asn1.x509.CertificateList extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.DERBitString sig

 org.bouncycastle.asn1.x509.AlgorithmIdentifier sigAlgId

 org.bouncycastle.asn1.x509.TBSCertList tbsCertList
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public static org.bouncycastle.asn1.x509.CertificateList getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.x509.CertificateList getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.x509.X509Name getIssuer()

public org.bouncycastle.asn1.x509.Time getNextUpdate()

public org.bouncycastle.asn1.x509.TBSCertList$CRLEntry[] getRevokedCertificates()

public org.bouncycastle.asn1.DERBitString getSignature()

public org.bouncycastle.asn1.x509.AlgorithmIdentifier getSignatureAlgorithm()

public org.bouncycastle.asn1.x509.TBSCertList getTBSCertList()

public org.bouncycastle.asn1.x509.Time getThisUpdate()

public int getVersion()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.x509.CertificatePolicies extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

static final org.bouncycastle.asn1.DERObjectIdentifier anyPolicy

 java.util.Vector policies
----------------METHODS----------------

static void <clinit>()

public void <init>(
java.lang.String)

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.DERObjectIdentifier)

public static org.bouncycastle.asn1.x509.CertificatePolicies getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.x509.CertificatePolicies getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public void addPolicy(
java.lang.String)

public java.lang.String getPolicy(
int)

public org.bouncycastle.asn1.DERObject toASN1Object()

public java.lang.String toString()

________________CLASS________________


public class org.bouncycastle.asn1.x509.DSAParameter extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.DERInteger g

 org.bouncycastle.asn1.DERInteger p

 org.bouncycastle.asn1.DERInteger q
----------------METHODS----------------

public void <init>(
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger)

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public static org.bouncycastle.asn1.x509.DSAParameter getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.x509.DSAParameter getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public java.math.BigInteger getG()

public java.math.BigInteger getP()

public java.math.BigInteger getQ()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.x509.DigestInfo extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.x509.AlgorithmIdentifier algId

private byte[] digest
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.x509.AlgorithmIdentifier
byte[])

public static org.bouncycastle.asn1.x509.DigestInfo getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.x509.DigestInfo getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.x509.AlgorithmIdentifier getAlgorithmId()

public byte[] getDigest()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.x509.DisplayText extends org.bouncycastle.asn1.ASN1Encodable implements org.bouncycastle.asn1.ASN1Choice

----------------FIELDS----------------

public static final int CONTENT_TYPE_BMPSTRING

public static final int CONTENT_TYPE_IA5STRING

public static final int CONTENT_TYPE_UTF8STRING

public static final int CONTENT_TYPE_VISIBLESTRING

public static final int DISPLAY_TEXT_MAXIMUM_SIZE

 int contentType

 org.bouncycastle.asn1.DERString contents
----------------METHODS----------------

public void <init>(
int
java.lang.String)

public void <init>(
java.lang.String)

public void <init>(
org.bouncycastle.asn1.DERString)

public static org.bouncycastle.asn1.x509.DisplayText getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.x509.DisplayText getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public java.lang.String getString()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.x509.DistributionPoint extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.x509.GeneralNames cRLIssuer

 org.bouncycastle.asn1.x509.DistributionPointName distributionPoint

 org.bouncycastle.asn1.x509.ReasonFlags reasons
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.x509.DistributionPointName
org.bouncycastle.asn1.x509.ReasonFlags
org.bouncycastle.asn1.x509.GeneralNames)

public static org.bouncycastle.asn1.x509.DistributionPoint getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.x509.DistributionPoint getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.x509.GeneralNames getCRLIssuer()

public org.bouncycastle.asn1.x509.DistributionPointName getDistributionPoint()

public org.bouncycastle.asn1.x509.ReasonFlags getReasons()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.x509.DistributionPointName extends org.bouncycastle.asn1.ASN1Encodable implements org.bouncycastle.asn1.ASN1Choice

----------------FIELDS----------------

public static final int FULL_NAME

public static final int NAME_RELATIVE_TO_CRL_ISSUER

 org.bouncycastle.asn1.DEREncodable name

 int type
----------------METHODS----------------

public void <init>(
int
org.bouncycastle.asn1.ASN1Encodable)

public void <init>(
int
org.bouncycastle.asn1.DEREncodable)

public void <init>(
org.bouncycastle.asn1.ASN1TaggedObject)

public static org.bouncycastle.asn1.x509.DistributionPointName getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.x509.DistributionPointName getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.ASN1Encodable getName()

public int getType()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.x509.ExtendedKeyUsage extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.ASN1Sequence seq

 java.util.Hashtable usageTable
----------------METHODS----------------

public void <init>(
java.util.Vector)

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.x509.KeyPurposeId)

public static org.bouncycastle.asn1.x509.ExtendedKeyUsage getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.x509.ExtendedKeyUsage getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public boolean hasKeyPurposeId(
org.bouncycastle.asn1.x509.KeyPurposeId)

public int size()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.x509.GeneralName extends org.bouncycastle.asn1.ASN1Encodable implements org.bouncycastle.asn1.ASN1Choice

----------------FIELDS----------------

public static final int dNSName

public static final int directoryName

public static final int ediPartyName

public static final int iPAddress

public static final int otherName

public static final int registeredID

public static final int rfc822Name

public static final int uniformResourceIdentifier

public static final int x400Address

 org.bouncycastle.asn1.DEREncodable obj

 int tag
----------------METHODS----------------

public void <init>(
int
java.lang.String)

public void <init>(
int
org.bouncycastle.asn1.ASN1Encodable)

public void <init>(
org.bouncycastle.asn1.DERObject
int)

public void <init>(
org.bouncycastle.asn1.x509.X509Name)

public static org.bouncycastle.asn1.x509.GeneralName getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.x509.GeneralName getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.DEREncodable getName()

public int getTagNo()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.x509.GeneralNames extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.ASN1Sequence seq
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.x509.GeneralName)

public static org.bouncycastle.asn1.x509.GeneralNames getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.x509.GeneralNames getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.x509.GeneralName[] getNames()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.x509.GeneralSubtree extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private static final java.math.BigInteger ZERO

private org.bouncycastle.asn1.x509.GeneralName base

private org.bouncycastle.asn1.DERInteger maximum

private org.bouncycastle.asn1.DERInteger minimum
----------------METHODS----------------

static void <clinit>()

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.x509.GeneralName
java.math.BigInteger
java.math.BigInteger)

public static org.bouncycastle.asn1.x509.GeneralSubtree getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.x509.GeneralSubtree getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.x509.GeneralName getBase()

public java.math.BigInteger getMaximum()

public java.math.BigInteger getMinimum()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.x509.Holder extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.x509.IssuerSerial baseCertificateID

 org.bouncycastle.asn1.x509.GeneralNames entityName

 org.bouncycastle.asn1.x509.ObjectDigestInfo objectDigestInfo
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.x509.GeneralNames)

public void <init>(
org.bouncycastle.asn1.x509.IssuerSerial)

public static org.bouncycastle.asn1.x509.Holder getInstance(
java.lang.Object)

public org.bouncycastle.asn1.x509.IssuerSerial getBaseCertificateID()

public org.bouncycastle.asn1.x509.GeneralNames getEntityName()

public org.bouncycastle.asn1.x509.ObjectDigestInfo getObjectDigestInfo()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.x509.IetfAttrSyntax extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

public static final int VALUE_OCTETS

public static final int VALUE_OID

public static final int VALUE_UTF8

 org.bouncycastle.asn1.x509.GeneralNames policyAuthority

 int valueChoice

 java.util.Vector values
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public org.bouncycastle.asn1.x509.GeneralNames getPolicyAuthority()

public int getValueType()

public java.lang.Object[] getValues()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.x509.IssuerSerial extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.x509.GeneralNames issuer

 org.bouncycastle.asn1.DERBitString issuerUID

 org.bouncycastle.asn1.DERInteger serial
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.x509.GeneralNames
org.bouncycastle.asn1.DERInteger)

public static org.bouncycastle.asn1.x509.IssuerSerial getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.x509.IssuerSerial getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.x509.GeneralNames getIssuer()

public org.bouncycastle.asn1.DERBitString getIssuerUID()

public org.bouncycastle.asn1.DERInteger getSerial()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.x509.IssuingDistributionPoint extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private boolean indirectCRL

private boolean onlyContainsAttributeCerts

private boolean onlyContainsCACerts

private boolean onlyContainsUserCerts

private org.bouncycastle.asn1.ASN1Sequence seq
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public static org.bouncycastle.asn1.x509.IssuingDistributionPoint getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.x509.IssuingDistributionPoint getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public boolean isIndirectCRL()

public boolean onlyContainsAttributeCerts()

public boolean onlyContainsCACerts()

public boolean onlyContainsUserCerts()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.x509.KeyPurposeId extends org.bouncycastle.asn1.DERObjectIdentifier

----------------FIELDS----------------

public static final org.bouncycastle.asn1.x509.KeyPurposeId anyExtendedKeyUsage

private static final java.lang.String id_kp

public static final org.bouncycastle.asn1.x509.KeyPurposeId id_kp_OCSPSigning

public static final org.bouncycastle.asn1.x509.KeyPurposeId id_kp_clientAuth

public static final org.bouncycastle.asn1.x509.KeyPurposeId id_kp_codeSigning

public static final org.bouncycastle.asn1.x509.KeyPurposeId id_kp_emailProtection

public static final org.bouncycastle.asn1.x509.KeyPurposeId id_kp_ipsecEndSystem

public static final org.bouncycastle.asn1.x509.KeyPurposeId id_kp_ipsecTunnel

public static final org.bouncycastle.asn1.x509.KeyPurposeId id_kp_ipsecUser

public static final org.bouncycastle.asn1.x509.KeyPurposeId id_kp_serverAuth

public static final org.bouncycastle.asn1.x509.KeyPurposeId id_kp_smartcardlogon

public static final org.bouncycastle.asn1.x509.KeyPurposeId id_kp_timeStamping
----------------METHODS----------------

static void <clinit>()

private void <init>(
java.lang.String)

________________CLASS________________


public class org.bouncycastle.asn1.x509.KeyUsage extends org.bouncycastle.asn1.DERBitString

----------------FIELDS----------------

public static final int cRLSign

public static final int dataEncipherment

public static final int decipherOnly

public static final int digitalSignature

public static final int encipherOnly

public static final int keyAgreement

public static final int keyCertSign

public static final int keyEncipherment

public static final int nonRepudiation
----------------METHODS----------------

public void <init>(
int)

public void <init>(
org.bouncycastle.asn1.DERBitString)

public java.lang.String toString()

________________CLASS________________


public class org.bouncycastle.asn1.x509.NameConstraints extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.ASN1Sequence excluded

private org.bouncycastle.asn1.ASN1Sequence permitted
----------------METHODS----------------

public void <init>(
java.util.Vector
java.util.Vector)

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

private org.bouncycastle.asn1.DERSequence createSequence(
java.util.Vector)

public org.bouncycastle.asn1.ASN1Sequence getExcludedSubtrees()

public org.bouncycastle.asn1.ASN1Sequence getPermittedSubtrees()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.x509.NoticeReference extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.ASN1Sequence noticeNumbers

private org.bouncycastle.asn1.x509.DisplayText organization
----------------METHODS----------------

public void <init>(
int
java.lang.String
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
java.lang.String
java.util.Vector)

public void <init>(
java.lang.String
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public static org.bouncycastle.asn1.x509.NoticeReference getInstance(
java.lang.Object)

public org.bouncycastle.asn1.ASN1Sequence getNoticeNumbers()

public org.bouncycastle.asn1.x509.DisplayText getOrganization()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.x509.ObjectDigestInfo extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.x509.AlgorithmIdentifier digestAlgorithm

 org.bouncycastle.asn1.DEREnumerated digestedObjectType

 org.bouncycastle.asn1.DERBitString objectDigest

 org.bouncycastle.asn1.DERObjectIdentifier otherObjectTypeID
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public static org.bouncycastle.asn1.x509.ObjectDigestInfo getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.x509.ObjectDigestInfo getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.x509.AlgorithmIdentifier getDigestAlgorithm()

public org.bouncycastle.asn1.DEREnumerated getDigestedObjectType()

public org.bouncycastle.asn1.DERBitString getObjectDigest()

public org.bouncycastle.asn1.DERObjectIdentifier getOtherObjectTypeID()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.x509.PolicyInformation extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.DERObjectIdentifier policyIdentifier

private org.bouncycastle.asn1.ASN1Sequence policyQualifiers
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.DERObjectIdentifier)

public void <init>(
org.bouncycastle.asn1.DERObjectIdentifier
org.bouncycastle.asn1.ASN1Sequence)

public static org.bouncycastle.asn1.x509.PolicyInformation getInstance(
java.lang.Object)

public org.bouncycastle.asn1.DERObjectIdentifier getPolicyIdentifier()

public org.bouncycastle.asn1.ASN1Sequence getPolicyQualifiers()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.x509.PolicyMappings extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.ASN1Sequence seq
----------------METHODS----------------

public void <init>(
java.util.Hashtable)

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.x509.PolicyQualifierId extends org.bouncycastle.asn1.DERObjectIdentifier

----------------FIELDS----------------

private static final java.lang.String id_qt

public static final org.bouncycastle.asn1.x509.PolicyQualifierId id_qt_cps

public static final org.bouncycastle.asn1.x509.PolicyQualifierId id_qt_unotice
----------------METHODS----------------

static void <clinit>()

private void <init>(
java.lang.String)

________________CLASS________________


public class org.bouncycastle.asn1.x509.PolicyQualifierInfo extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.DERObjectIdentifier policyQualifierId

private org.bouncycastle.asn1.DEREncodable qualifier
----------------METHODS----------------

public void <init>(
java.lang.String)

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.DERObjectIdentifier
org.bouncycastle.asn1.DEREncodable)

public static org.bouncycastle.asn1.x509.PolicyQualifierInfo getInstance(
java.lang.Object)

public org.bouncycastle.asn1.DERObjectIdentifier getPolicyQualifierId()

public org.bouncycastle.asn1.DEREncodable getQualifier()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.x509.RSAPublicKeyStructure extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private java.math.BigInteger modulus

private java.math.BigInteger publicExponent
----------------METHODS----------------

public void <init>(
java.math.BigInteger
java.math.BigInteger)

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public static org.bouncycastle.asn1.x509.RSAPublicKeyStructure getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.x509.RSAPublicKeyStructure getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public java.math.BigInteger getModulus()

public java.math.BigInteger getPublicExponent()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.x509.ReasonFlags extends org.bouncycastle.asn1.DERBitString

----------------FIELDS----------------

public static final int AA_COMPROMISE

public static final int AFFILIATION_CHANGED

public static final int CA_COMPROMISE

public static final int CERTIFICATE_HOLD

public static final int CESSATION_OF_OPERATION

public static final int KEY_COMPROMISE

public static final int PRIVILEGE_WITHDRAWN

public static final int SUPERSEDED

public static final int UNUSED

public static final int aACompromise

public static final int affiliationChanged

public static final int cACompromise

public static final int certificateHold

public static final int cessationOfOperation

public static final int keyCompromise

public static final int privilegeWithdrawn

public static final int superseded

public static final int unused
----------------METHODS----------------

public void <init>(
int)

public void <init>(
org.bouncycastle.asn1.DERBitString)

________________CLASS________________


public class org.bouncycastle.asn1.x509.RoleSyntax extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.x509.GeneralNames roleAuthority

private org.bouncycastle.asn1.x509.GeneralName roleName
----------------METHODS----------------

public void <init>(
java.lang.String)

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.x509.GeneralName)

public void <init>(
org.bouncycastle.asn1.x509.GeneralNames
org.bouncycastle.asn1.x509.GeneralName)

public static org.bouncycastle.asn1.x509.RoleSyntax getInstance(
java.lang.Object)

public org.bouncycastle.asn1.x509.GeneralNames getRoleAuthority()

public java.lang.String[] getRoleAuthorityAsString()

public org.bouncycastle.asn1.x509.GeneralName getRoleName()

public java.lang.String getRoleNameAsString()

public org.bouncycastle.asn1.DERObject toASN1Object()

public java.lang.String toString()

________________CLASS________________


public class org.bouncycastle.asn1.x509.SubjectDirectoryAttributes extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private java.util.Vector attributes
----------------METHODS----------------

public void <init>(
java.util.Vector)

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public static org.bouncycastle.asn1.x509.SubjectDirectoryAttributes getInstance(
java.lang.Object)

public java.util.Vector getAttributes()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.x509.SubjectKeyIdentifier extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private byte[] keyidentifier
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1OctetString)

public void <init>(
org.bouncycastle.asn1.x509.SubjectPublicKeyInfo)

public void <init>(
byte[])

public static org.bouncycastle.asn1.x509.SubjectKeyIdentifier getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.x509.SubjectKeyIdentifier getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public byte[] getKeyIdentifier()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.x509.SubjectPublicKeyInfo extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.x509.AlgorithmIdentifier algId

private org.bouncycastle.asn1.DERBitString keyData
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.x509.AlgorithmIdentifier
org.bouncycastle.asn1.DEREncodable)

public void <init>(
org.bouncycastle.asn1.x509.AlgorithmIdentifier
byte[])

public static org.bouncycastle.asn1.x509.SubjectPublicKeyInfo getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.x509.SubjectPublicKeyInfo getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.x509.AlgorithmIdentifier getAlgorithmId()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public org.bouncycastle.asn1.DERObject getPublicKey()

public org.bouncycastle.asn1.DERBitString getPublicKeyData()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =1 name =CRLEntry )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/asn1/x509/TBSCertList; )
public class org.bouncycastle.asn1.x509.TBSCertList$CRLEntry extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.x509.X509Extensions crlEntryExtensions

 org.bouncycastle.asn1.x509.Time revocationDate

 org.bouncycastle.asn1.ASN1Sequence seq

final org.bouncycastle.asn1.x509.TBSCertList this$0

 org.bouncycastle.asn1.DERInteger userCertificate
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.x509.TBSCertList
org.bouncycastle.asn1.ASN1Sequence)

public org.bouncycastle.asn1.x509.X509Extensions getExtensions()

public org.bouncycastle.asn1.x509.Time getRevocationDate()

public org.bouncycastle.asn1.DERInteger getUserCertificate()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/bouncycastle/asn1/x509/TBSCertList$CRLEntry; )
public class org.bouncycastle.asn1.x509.TBSCertList extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.x509.X509Extensions crlExtensions

 org.bouncycastle.asn1.x509.X509Name issuer

 org.bouncycastle.asn1.x509.Time nextUpdate

 org.bouncycastle.asn1.x509.TBSCertList$CRLEntry[] revokedCertificates

 org.bouncycastle.asn1.ASN1Sequence seq

 org.bouncycastle.asn1.x509.AlgorithmIdentifier signature

 org.bouncycastle.asn1.x509.Time thisUpdate

 org.bouncycastle.asn1.DERInteger version
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public static org.bouncycastle.asn1.x509.TBSCertList getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.x509.TBSCertList getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.x509.X509Extensions getExtensions()

public org.bouncycastle.asn1.x509.X509Name getIssuer()

public org.bouncycastle.asn1.x509.Time getNextUpdate()

public org.bouncycastle.asn1.x509.TBSCertList$CRLEntry[] getRevokedCertificates()

public org.bouncycastle.asn1.x509.AlgorithmIdentifier getSignature()

public org.bouncycastle.asn1.x509.Time getThisUpdate()

public int getVersion()

public org.bouncycastle.asn1.DERInteger getVersionNumber()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public abstract interface class org.bouncycastle.asn1.x509.X509ObjectIdentifiers extends java.lang.Object

----------------FIELDS----------------

public static final org.bouncycastle.asn1.DERObjectIdentifier commonName

public static final org.bouncycastle.asn1.DERObjectIdentifier countryName

public static final java.lang.String id

public static final org.bouncycastle.asn1.DERObjectIdentifier id_SHA1

public static final org.bouncycastle.asn1.DERObjectIdentifier id_ea_rsa

public static final org.bouncycastle.asn1.DERObjectIdentifier localityName

public static final org.bouncycastle.asn1.DERObjectIdentifier ocspAccessMethod

public static final org.bouncycastle.asn1.DERObjectIdentifier organization

public static final org.bouncycastle.asn1.DERObjectIdentifier organizationalUnitName

public static final org.bouncycastle.asn1.DERObjectIdentifier ripemd160

public static final org.bouncycastle.asn1.DERObjectIdentifier ripemd160WithRSAEncryption

public static final org.bouncycastle.asn1.DERObjectIdentifier stateOrProvinceName
----------------METHODS----------------

static void <clinit>()

________________CLASS________________


public class org.bouncycastle.asn1.x509.TBSCertificateStructure extends org.bouncycastle.asn1.ASN1Encodable implements org.bouncycastle.asn1.x509.X509ObjectIdentifiers, org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers

----------------FIELDS----------------

 org.bouncycastle.asn1.x509.Time endDate

 org.bouncycastle.asn1.x509.X509Extensions extensions

 org.bouncycastle.asn1.x509.X509Name issuer

 org.bouncycastle.asn1.DERBitString issuerUniqueId

 org.bouncycastle.asn1.ASN1Sequence seq

 org.bouncycastle.asn1.DERInteger serialNumber

 org.bouncycastle.asn1.x509.AlgorithmIdentifier signature

 org.bouncycastle.asn1.x509.Time startDate

 org.bouncycastle.asn1.x509.X509Name subject

 org.bouncycastle.asn1.x509.SubjectPublicKeyInfo subjectPublicKeyInfo

 org.bouncycastle.asn1.DERBitString subjectUniqueId

 org.bouncycastle.asn1.DERInteger version
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public static org.bouncycastle.asn1.x509.TBSCertificateStructure getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.x509.TBSCertificateStructure getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.x509.Time getEndDate()

public org.bouncycastle.asn1.x509.X509Extensions getExtensions()

public org.bouncycastle.asn1.x509.X509Name getIssuer()

public org.bouncycastle.asn1.DERBitString getIssuerUniqueId()

public org.bouncycastle.asn1.DERInteger getSerialNumber()

public org.bouncycastle.asn1.x509.AlgorithmIdentifier getSignature()

public org.bouncycastle.asn1.x509.Time getStartDate()

public org.bouncycastle.asn1.x509.X509Name getSubject()

public org.bouncycastle.asn1.x509.SubjectPublicKeyInfo getSubjectPublicKeyInfo()

public org.bouncycastle.asn1.DERBitString getSubjectUniqueId()

public int getVersion()

public org.bouncycastle.asn1.DERInteger getVersionNumber()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.x509.Time extends org.bouncycastle.asn1.ASN1Encodable implements org.bouncycastle.asn1.ASN1Choice

----------------FIELDS----------------

 org.bouncycastle.asn1.DERObject time
----------------METHODS----------------

public void <init>(
java.util.Date)

public void <init>(
org.bouncycastle.asn1.DERObject)

public static org.bouncycastle.asn1.x509.Time getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.x509.Time getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public java.util.Date getDate()

public java.lang.String getTime()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.x509.UserNotice extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

private org.bouncycastle.asn1.x509.DisplayText explicitText

private org.bouncycastle.asn1.x509.NoticeReference noticeRef
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.x509.NoticeReference
java.lang.String)

public void <init>(
org.bouncycastle.asn1.x509.NoticeReference
org.bouncycastle.asn1.x509.DisplayText)

public org.bouncycastle.asn1.x509.DisplayText getExplicitText()

public org.bouncycastle.asn1.x509.NoticeReference getNoticeRef()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.x509.V1TBSCertificateGenerator extends java.lang.Object

----------------FIELDS----------------

 org.bouncycastle.asn1.x509.Time endDate

 org.bouncycastle.asn1.x509.X509Name issuer

 org.bouncycastle.asn1.DERInteger serialNumber

 org.bouncycastle.asn1.x509.AlgorithmIdentifier signature

 org.bouncycastle.asn1.x509.Time startDate

 org.bouncycastle.asn1.x509.X509Name subject

 org.bouncycastle.asn1.x509.SubjectPublicKeyInfo subjectPublicKeyInfo

 org.bouncycastle.asn1.DERTaggedObject version
----------------METHODS----------------

public void <init>()

public org.bouncycastle.asn1.x509.TBSCertificateStructure generateTBSCertificate()

public void setEndDate(
org.bouncycastle.asn1.DERUTCTime)

public void setEndDate(
org.bouncycastle.asn1.x509.Time)

public void setIssuer(
org.bouncycastle.asn1.x509.X509Name)

public void setSerialNumber(
org.bouncycastle.asn1.DERInteger)

public void setSignature(
org.bouncycastle.asn1.x509.AlgorithmIdentifier)

public void setStartDate(
org.bouncycastle.asn1.DERUTCTime)

public void setStartDate(
org.bouncycastle.asn1.x509.Time)

public void setSubject(
org.bouncycastle.asn1.x509.X509Name)

public void setSubjectPublicKeyInfo(
org.bouncycastle.asn1.x509.SubjectPublicKeyInfo)

________________CLASS________________


public class org.bouncycastle.asn1.x509.V2AttributeCertificateInfoGenerator extends java.lang.Object

----------------FIELDS----------------

private org.bouncycastle.asn1.x509.AttCertValidityPeriod attrCertValidityPeriod

private org.bouncycastle.asn1.ASN1EncodableVector attributes

private org.bouncycastle.asn1.DERGeneralizedTime endDate

private org.bouncycastle.asn1.x509.X509Extensions extensions

private org.bouncycastle.asn1.x509.Holder holder

private org.bouncycastle.asn1.x509.AttCertIssuer issuer

private org.bouncycastle.asn1.DERBitString issuerUniqueID

private org.bouncycastle.asn1.DERInteger serialNumber

private org.bouncycastle.asn1.x509.AlgorithmIdentifier signature

private org.bouncycastle.asn1.DERGeneralizedTime startDate

private org.bouncycastle.asn1.DERInteger version
----------------METHODS----------------

public void <init>()

public void addAttribute(
java.lang.String
org.bouncycastle.asn1.ASN1Encodable)

public void addAttribute(
org.bouncycastle.asn1.x509.Attribute)

public org.bouncycastle.asn1.x509.AttributeCertificateInfo generateAttributeCertificateInfo()

public void setEndDate(
org.bouncycastle.asn1.DERGeneralizedTime)

public void setExtensions(
org.bouncycastle.asn1.x509.X509Extensions)

public void setHolder(
org.bouncycastle.asn1.x509.Holder)

public void setIssuer(
org.bouncycastle.asn1.x509.AttCertIssuer)

public void setIssuerUniqueID(
org.bouncycastle.asn1.DERBitString)

public void setSerialNumber(
org.bouncycastle.asn1.DERInteger)

public void setSignature(
org.bouncycastle.asn1.x509.AlgorithmIdentifier)

public void setStartDate(
org.bouncycastle.asn1.DERGeneralizedTime)

________________CLASS________________


public class org.bouncycastle.asn1.x509.V2Form extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.x509.IssuerSerial baseCertificateID

 org.bouncycastle.asn1.x509.GeneralNames issuerName

 org.bouncycastle.asn1.x509.ObjectDigestInfo objectDigestInfo
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.x509.GeneralNames)

public static org.bouncycastle.asn1.x509.V2Form getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.x509.V2Form getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.x509.IssuerSerial getBaseCertificateID()

public org.bouncycastle.asn1.x509.GeneralNames getIssuerName()

public org.bouncycastle.asn1.x509.ObjectDigestInfo getObjectDigestInfo()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.x509.V2TBSCertListGenerator extends java.lang.Object

----------------FIELDS----------------

private java.util.Vector crlentries

 org.bouncycastle.asn1.x509.X509Extensions extensions

 org.bouncycastle.asn1.x509.X509Name issuer

 org.bouncycastle.asn1.x509.Time nextUpdate

 org.bouncycastle.asn1.x509.AlgorithmIdentifier signature

 org.bouncycastle.asn1.x509.Time thisUpdate

 org.bouncycastle.asn1.DERInteger version
----------------METHODS----------------

public void <init>()

public void addCRLEntry(
org.bouncycastle.asn1.ASN1Sequence)

public void addCRLEntry(
org.bouncycastle.asn1.DERInteger
org.bouncycastle.asn1.DERUTCTime
int)

public void addCRLEntry(
org.bouncycastle.asn1.DERInteger
org.bouncycastle.asn1.x509.Time
int)

public void addCRLEntry(
org.bouncycastle.asn1.DERInteger
org.bouncycastle.asn1.x509.Time
int
org.bouncycastle.asn1.DERGeneralizedTime)

public void addCRLEntry(
org.bouncycastle.asn1.DERInteger
org.bouncycastle.asn1.x509.Time
org.bouncycastle.asn1.x509.X509Extensions)

public org.bouncycastle.asn1.x509.TBSCertList generateTBSCertList()

public void setExtensions(
org.bouncycastle.asn1.x509.X509Extensions)

public void setIssuer(
org.bouncycastle.asn1.x509.X509Name)

public void setNextUpdate(
org.bouncycastle.asn1.DERUTCTime)

public void setNextUpdate(
org.bouncycastle.asn1.x509.Time)

public void setSignature(
org.bouncycastle.asn1.x509.AlgorithmIdentifier)

public void setThisUpdate(
org.bouncycastle.asn1.DERUTCTime)

public void setThisUpdate(
org.bouncycastle.asn1.x509.Time)

________________CLASS________________


public class org.bouncycastle.asn1.x509.V3TBSCertificateGenerator extends java.lang.Object

----------------FIELDS----------------

 org.bouncycastle.asn1.x509.Time endDate

 org.bouncycastle.asn1.x509.X509Extensions extensions

 org.bouncycastle.asn1.x509.X509Name issuer

 org.bouncycastle.asn1.DERInteger serialNumber

 org.bouncycastle.asn1.x509.AlgorithmIdentifier signature

 org.bouncycastle.asn1.x509.Time startDate

 org.bouncycastle.asn1.x509.X509Name subject

 org.bouncycastle.asn1.x509.SubjectPublicKeyInfo subjectPublicKeyInfo

 org.bouncycastle.asn1.DERTaggedObject version
----------------METHODS----------------

public void <init>()

public org.bouncycastle.asn1.x509.TBSCertificateStructure generateTBSCertificate()

public void setEndDate(
org.bouncycastle.asn1.DERUTCTime)

public void setEndDate(
org.bouncycastle.asn1.x509.Time)

public void setExtensions(
org.bouncycastle.asn1.x509.X509Extensions)

public void setIssuer(
org.bouncycastle.asn1.x509.X509Name)

public void setSerialNumber(
org.bouncycastle.asn1.DERInteger)

public void setSignature(
org.bouncycastle.asn1.x509.AlgorithmIdentifier)

public void setStartDate(
org.bouncycastle.asn1.DERUTCTime)

public void setStartDate(
org.bouncycastle.asn1.x509.Time)

public void setSubject(
org.bouncycastle.asn1.x509.X509Name)

public void setSubjectPublicKeyInfo(
org.bouncycastle.asn1.x509.SubjectPublicKeyInfo)

________________CLASS________________


public class org.bouncycastle.asn1.x509.X509Attributes extends java.lang.Object

----------------FIELDS----------------

public static final org.bouncycastle.asn1.DERObjectIdentifier RoleSyntax
----------------METHODS----------------

static void <clinit>()

public void <init>()

________________CLASS________________


public class org.bouncycastle.asn1.x509.X509CertificateStructure extends org.bouncycastle.asn1.ASN1Encodable implements org.bouncycastle.asn1.x509.X509ObjectIdentifiers, org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers

----------------FIELDS----------------

 org.bouncycastle.asn1.ASN1Sequence seq

 org.bouncycastle.asn1.DERBitString sig

 org.bouncycastle.asn1.x509.AlgorithmIdentifier sigAlgId

 org.bouncycastle.asn1.x509.TBSCertificateStructure tbsCert
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public static org.bouncycastle.asn1.x509.X509CertificateStructure getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.x509.X509CertificateStructure getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public org.bouncycastle.asn1.x509.Time getEndDate()

public org.bouncycastle.asn1.x509.X509Name getIssuer()

public org.bouncycastle.asn1.DERInteger getSerialNumber()

public org.bouncycastle.asn1.DERBitString getSignature()

public org.bouncycastle.asn1.x509.AlgorithmIdentifier getSignatureAlgorithm()

public org.bouncycastle.asn1.x509.Time getStartDate()

public org.bouncycastle.asn1.x509.X509Name getSubject()

public org.bouncycastle.asn1.x509.SubjectPublicKeyInfo getSubjectPublicKeyInfo()

public org.bouncycastle.asn1.x509.TBSCertificateStructure getTBSCertificate()

public int getVersion()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public abstract class org.bouncycastle.asn1.x509.X509NameEntryConverter extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

protected boolean canBePrintable(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected org.bouncycastle.asn1.DERObject convertHexEncoded(
java.lang.String
int)

public abstract org.bouncycastle.asn1.DERObject getConvertedValue(
org.bouncycastle.asn1.DERObjectIdentifier
java.lang.String)

________________CLASS________________


public class org.bouncycastle.asn1.x509.X509DefaultEntryConverter extends org.bouncycastle.asn1.x509.X509NameEntryConverter

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public org.bouncycastle.asn1.DERObject getConvertedValue(
org.bouncycastle.asn1.DERObjectIdentifier
java.lang.String)

________________CLASS________________


public class org.bouncycastle.asn1.x509.X509Extension extends java.lang.Object

----------------FIELDS----------------

 boolean critical

 org.bouncycastle.asn1.ASN1OctetString value
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.DERBoolean
org.bouncycastle.asn1.ASN1OctetString)

public void <init>(
boolean
org.bouncycastle.asn1.ASN1OctetString)

public boolean equals(
java.lang.Object)

public org.bouncycastle.asn1.ASN1OctetString getValue()

public int hashCode()

public boolean isCritical()

________________CLASS________________


public class org.bouncycastle.asn1.x509.X509Extensions extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

public static final org.bouncycastle.asn1.DERObjectIdentifier AuthorityInfoAccess

public static final org.bouncycastle.asn1.DERObjectIdentifier AuthorityKeyIdentifier

public static final org.bouncycastle.asn1.DERObjectIdentifier BasicConstraints

public static final org.bouncycastle.asn1.DERObjectIdentifier BiometricInfo

public static final org.bouncycastle.asn1.DERObjectIdentifier CRLDistributionPoints

public static final org.bouncycastle.asn1.DERObjectIdentifier CRLNumber

public static final org.bouncycastle.asn1.DERObjectIdentifier CertificateIssuer

public static final org.bouncycastle.asn1.DERObjectIdentifier CertificatePolicies

public static final org.bouncycastle.asn1.DERObjectIdentifier DeltaCRLIndicator

public static final org.bouncycastle.asn1.DERObjectIdentifier ExtendedKeyUsage

public static final org.bouncycastle.asn1.DERObjectIdentifier FreshestCRL

public static final org.bouncycastle.asn1.DERObjectIdentifier InhibitAnyPolicy

public static final org.bouncycastle.asn1.DERObjectIdentifier InstructionCode

public static final org.bouncycastle.asn1.DERObjectIdentifier InvalidityDate

public static final org.bouncycastle.asn1.DERObjectIdentifier IssuerAlternativeName

public static final org.bouncycastle.asn1.DERObjectIdentifier IssuingDistributionPoint

public static final org.bouncycastle.asn1.DERObjectIdentifier KeyUsage

public static final org.bouncycastle.asn1.DERObjectIdentifier NameConstraints

public static final org.bouncycastle.asn1.DERObjectIdentifier PolicyConstraints

public static final org.bouncycastle.asn1.DERObjectIdentifier PolicyMappings

public static final org.bouncycastle.asn1.DERObjectIdentifier PrivateKeyUsagePeriod

public static final org.bouncycastle.asn1.DERObjectIdentifier QCStatements

public static final org.bouncycastle.asn1.DERObjectIdentifier ReasonCode

public static final org.bouncycastle.asn1.DERObjectIdentifier SubjectAlternativeName

public static final org.bouncycastle.asn1.DERObjectIdentifier SubjectDirectoryAttributes

public static final org.bouncycastle.asn1.DERObjectIdentifier SubjectInfoAccess

public static final org.bouncycastle.asn1.DERObjectIdentifier SubjectKeyIdentifier

private org.bouncycastle.asn1.OrderedTable table
----------------METHODS----------------

static void <clinit>()

public void <init>(
java.util.Hashtable)

public void <init>(
java.util.Vector
java.util.Hashtable)

public void <init>(
java.util.Vector
java.util.Vector)

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public static org.bouncycastle.asn1.x509.X509Extensions getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.x509.X509Extensions getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public boolean equals(
java.lang.Object)

public org.bouncycastle.asn1.x509.X509Extension getExtension(
org.bouncycastle.asn1.DERObjectIdentifier)

public int hashCode()

public java.util.Enumeration oids()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.x509.X509Name extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

public static final org.bouncycastle.asn1.DERObjectIdentifier BUSINESS_CATEGORY

public static final org.bouncycastle.asn1.DERObjectIdentifier C

public static final org.bouncycastle.asn1.DERObjectIdentifier CN

public static final org.bouncycastle.asn1.DERObjectIdentifier COUNTRY_OF_CITIZENSHIP

public static final org.bouncycastle.asn1.DERObjectIdentifier COUNTRY_OF_RESIDENCE

public static final org.bouncycastle.asn1.DERObjectIdentifier DATE_OF_BIRTH

public static final org.bouncycastle.asn1.DERObjectIdentifier DC

public static final org.bouncycastle.asn1.DERObjectIdentifier DN_QUALIFIER

public static java.util.Hashtable DefaultLookUp

public static boolean DefaultReverse

public static java.util.Hashtable DefaultSymbols

public static final org.bouncycastle.asn1.DERObjectIdentifier E

public static final org.bouncycastle.asn1.DERObjectIdentifier EmailAddress

public static final org.bouncycastle.asn1.DERObjectIdentifier GENDER

public static final org.bouncycastle.asn1.DERObjectIdentifier GENERATION

public static final org.bouncycastle.asn1.DERObjectIdentifier GIVENNAME

public static final org.bouncycastle.asn1.DERObjectIdentifier INITIALS

public static final org.bouncycastle.asn1.DERObjectIdentifier L

public static final org.bouncycastle.asn1.DERObjectIdentifier NAME_AT_BIRTH

public static final org.bouncycastle.asn1.DERObjectIdentifier O

public static java.util.Hashtable OIDLookUp

public static final org.bouncycastle.asn1.DERObjectIdentifier OU

public static final org.bouncycastle.asn1.DERObjectIdentifier PLACE_OF_BIRTH

public static final org.bouncycastle.asn1.DERObjectIdentifier POSTAL_ADDRESS

public static final org.bouncycastle.asn1.DERObjectIdentifier POSTAL_CODE

public static final org.bouncycastle.asn1.DERObjectIdentifier PSEUDONYM

public static java.util.Hashtable RFC1779Symbols

public static java.util.Hashtable RFC2253Symbols

public static final org.bouncycastle.asn1.DERObjectIdentifier SERIALNUMBER

public static final org.bouncycastle.asn1.DERObjectIdentifier SN

public static final org.bouncycastle.asn1.DERObjectIdentifier ST

public static final org.bouncycastle.asn1.DERObjectIdentifier STREET

public static final org.bouncycastle.asn1.DERObjectIdentifier SURNAME

public static java.util.Hashtable SymbolLookUp

public static final org.bouncycastle.asn1.DERObjectIdentifier T

public static final org.bouncycastle.asn1.DERObjectIdentifier UID

public static final org.bouncycastle.asn1.DERObjectIdentifier UNIQUE_IDENTIFIER

public static final org.bouncycastle.asn1.DERObjectIdentifier UnstructuredAddress

public static final org.bouncycastle.asn1.DERObjectIdentifier UnstructuredName

private org.bouncycastle.asn1.x509.X509NameEntryConverter converter

private org.bouncycastle.asn1.x509.X509NameElementList elems

private org.bouncycastle.asn1.ASN1Sequence seq
----------------METHODS----------------

static void <clinit>()

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
org.bouncycastle.asn1.x509.X509NameEntryConverter)

public void <init>(
java.util.Hashtable)

public void <init>(
java.util.Vector
java.util.Hashtable)

public void <init>(
java.util.Vector
java.util.Hashtable
org.bouncycastle.asn1.x509.X509DefaultEntryConverter)

public void <init>(
java.util.Vector
java.util.Vector)

public void <init>(
java.util.Vector
java.util.Vector
org.bouncycastle.asn1.x509.X509NameEntryConverter)

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
boolean
java.lang.String)

public void <init>(
boolean
java.lang.String
org.bouncycastle.asn1.x509.X509NameEntryConverter)

public void <init>(
boolean
java.util.Hashtable
java.lang.String)

public void <init>(
boolean
java.util.Hashtable
java.lang.String
org.bouncycastle.asn1.x509.X509NameEntryConverter)

private void appendValue(
java.lang.StringBuffer
java.util.Hashtable
org.bouncycastle.asn1.DERObjectIdentifier
java.lang.String)

private java.lang.String bytesToString(
byte[])

private org.bouncycastle.asn1.DERObjectIdentifier decodeOID(
java.lang.String
java.util.Hashtable)

public static org.bouncycastle.asn1.x509.X509Name getInstance(
java.lang.Object)

public static org.bouncycastle.asn1.x509.X509Name getInstance(
org.bouncycastle.asn1.ASN1TaggedObject
boolean)

public boolean equals(
java.lang.Object)

public boolean equals(
java.lang.Object
boolean)

public java.util.Vector getOIDs()

public java.util.Vector getValues()

public int hashCode()

public org.bouncycastle.asn1.DERObject toASN1Object()

public java.lang.String toString()

public java.lang.String toString(
boolean
java.util.Hashtable)

________________CLASS________________


public class org.bouncycastle.asn1.x509.X509NameElementList extends java.lang.Object

----------------FIELDS----------------

private int added

private org.bouncycastle.asn1.DERObjectIdentifier key0

private org.bouncycastle.asn1.DERObjectIdentifier key1

private org.bouncycastle.asn1.DERObjectIdentifier key2

private org.bouncycastle.asn1.DERObjectIdentifier key3

private java.lang.Object[] rest

private int size

private java.lang.String value0

private java.lang.String value1

private java.lang.String value2

private java.lang.String value3
----------------METHODS----------------

public void <init>()

public void add(
org.bouncycastle.asn1.DERObjectIdentifier
java.lang.String)

public void add(
org.bouncycastle.asn1.DERObjectIdentifier
java.lang.String
boolean)

public boolean getAdded(
int)

public org.bouncycastle.asn1.DERObjectIdentifier getKey(
int)

public java.lang.String getValue(
int)

public org.bouncycastle.asn1.x509.X509NameElementList reverse()

public void setLastAddedFlag()

public int size()

________________CLASS________________


public class org.bouncycastle.asn1.x509.X509NameTokenizer extends java.lang.Object

----------------FIELDS----------------

private java.lang.StringBuffer buf

private int index

private char seperator

private java.lang.String value
----------------METHODS----------------

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
char)

public boolean hasMoreTokens()

public java.lang.String nextToken()

________________CLASS________________


public class org.bouncycastle.asn1.x509.qualified.BiometricData extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.ASN1OctetString biometricDataHash

 org.bouncycastle.asn1.x509.AlgorithmIdentifier hashAlgorithm

 org.bouncycastle.asn1.DERIA5String sourceDataUri

 org.bouncycastle.asn1.x509.qualified.TypeOfBiometricData typeOfBiometricData
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.x509.qualified.TypeOfBiometricData
org.bouncycastle.asn1.x509.AlgorithmIdentifier
org.bouncycastle.asn1.ASN1OctetString)

public void <init>(
org.bouncycastle.asn1.x509.qualified.TypeOfBiometricData
org.bouncycastle.asn1.x509.AlgorithmIdentifier
org.bouncycastle.asn1.ASN1OctetString
org.bouncycastle.asn1.DERIA5String)

public static org.bouncycastle.asn1.x509.qualified.BiometricData getInstance(
java.lang.Object)

public org.bouncycastle.asn1.ASN1OctetString getBiometricDataHash()

public org.bouncycastle.asn1.x509.AlgorithmIdentifier getHashAlgorithm()

public org.bouncycastle.asn1.DERIA5String getSourceDataUri()

public org.bouncycastle.asn1.x509.qualified.TypeOfBiometricData getTypeOfBiometricData()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public abstract interface class org.bouncycastle.asn1.x509.qualified.ETSIQCObjectIdentifiers extends java.lang.Object

----------------FIELDS----------------

public static final java.lang.String id_etsi_qcs

public static final org.bouncycastle.asn1.DERObjectIdentifier id_etsi_qcs_LimiteValue

public static final org.bouncycastle.asn1.DERObjectIdentifier id_etsi_qcs_QcCompliance

public static final org.bouncycastle.asn1.DERObjectIdentifier id_etsi_qcs_QcSSCD

public static final org.bouncycastle.asn1.DERObjectIdentifier id_etsi_qcs_RetentionPeriod
----------------METHODS----------------

static void <clinit>()

________________CLASS________________


public class org.bouncycastle.asn1.x509.qualified.Iso4217CurrencyCode extends org.bouncycastle.asn1.ASN1Encodable implements org.bouncycastle.asn1.ASN1Choice

----------------FIELDS----------------

final int ALPHABETIC_MAXSIZE

final int NUMERIC_MAXSIZE

final int NUMERIC_MINSIZE

 int numeric

 org.bouncycastle.asn1.DEREncodable obj
----------------METHODS----------------

public void <init>(
int)

public void <init>(
java.lang.String)

public static org.bouncycastle.asn1.x509.qualified.Iso4217CurrencyCode getInstance(
java.lang.Object)

public java.lang.String getAlphabetic()

public int getNumeric()

public boolean isAlphabetic()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.x509.qualified.MonetaryValue extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.DERInteger amount

 org.bouncycastle.asn1.x509.qualified.Iso4217CurrencyCode currency

 org.bouncycastle.asn1.DERInteger exponent
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.x509.qualified.Iso4217CurrencyCode
int
int)

public static org.bouncycastle.asn1.x509.qualified.MonetaryValue getInstance(
java.lang.Object)

public java.math.BigInteger getAmount()

public org.bouncycastle.asn1.x509.qualified.Iso4217CurrencyCode getCurrency()

public java.math.BigInteger getExponent()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public abstract interface class org.bouncycastle.asn1.x509.qualified.RFC3739QCObjectIdentifiers extends java.lang.Object

----------------FIELDS----------------

public static final java.lang.String id_qcs

public static final org.bouncycastle.asn1.DERObjectIdentifier id_qcs_pkixQCSyntax_v1

public static final org.bouncycastle.asn1.DERObjectIdentifier id_qcs_pkixQCSyntax_v2
----------------METHODS----------------

static void <clinit>()

________________CLASS________________


public class org.bouncycastle.asn1.x509.qualified.QCStatement extends org.bouncycastle.asn1.ASN1Encodable implements org.bouncycastle.asn1.x509.qualified.ETSIQCObjectIdentifiers, org.bouncycastle.asn1.x509.qualified.RFC3739QCObjectIdentifiers

----------------FIELDS----------------

 org.bouncycastle.asn1.DERObjectIdentifier qcStatementId

 org.bouncycastle.asn1.ASN1Encodable qcStatementInfo
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.DERObjectIdentifier)

public void <init>(
org.bouncycastle.asn1.DERObjectIdentifier
org.bouncycastle.asn1.ASN1Encodable)

public static org.bouncycastle.asn1.x509.qualified.QCStatement getInstance(
java.lang.Object)

public org.bouncycastle.asn1.DERObjectIdentifier getStatementId()

public org.bouncycastle.asn1.ASN1Encodable getStatementInfo()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.x509.qualified.SemanticsInformation extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.x509.GeneralName[] nameRegistrationAuthorities

 org.bouncycastle.asn1.DERObjectIdentifier semanticsIdentifier
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.asn1.DERObjectIdentifier)

public void <init>(
org.bouncycastle.asn1.DERObjectIdentifier
org.bouncycastle.asn1.x509.GeneralName[])

public void <init>(
org.bouncycastle.asn1.x509.GeneralName[])

public static org.bouncycastle.asn1.x509.qualified.SemanticsInformation getInstance(
java.lang.Object)

public org.bouncycastle.asn1.x509.GeneralName[] getNameRegistrationAuthorities()

public org.bouncycastle.asn1.DERObjectIdentifier getSemanticsIdentifier()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.asn1.x509.qualified.TypeOfBiometricData extends org.bouncycastle.asn1.ASN1Encodable implements org.bouncycastle.asn1.ASN1Choice

----------------FIELDS----------------

public static final int HANDWRITTEN_SIGNATURE

public static final int PICTURE

 org.bouncycastle.asn1.DEREncodable obj
----------------METHODS----------------

public void <init>(
int)

public void <init>(
org.bouncycastle.asn1.DERObjectIdentifier)

public static org.bouncycastle.asn1.x509.qualified.TypeOfBiometricData getInstance(
java.lang.Object)

public org.bouncycastle.asn1.DERObjectIdentifier getBiometricDataOid()

public int getPredefinedBiometricType()

public boolean isPredefined()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public final class org.bouncycastle.asn1.x509.sigi.SigIObjectIdentifiers extends java.lang.Object

----------------FIELDS----------------

public static final org.bouncycastle.asn1.DERObjectIdentifier id_sigi

public static final org.bouncycastle.asn1.DERObjectIdentifier id_sigi_cp

public static final org.bouncycastle.asn1.DERObjectIdentifier id_sigi_cp_sigconform

public static final org.bouncycastle.asn1.DERObjectIdentifier id_sigi_kp

public static final org.bouncycastle.asn1.DERObjectIdentifier id_sigi_kp_directoryService

public static final org.bouncycastle.asn1.DERObjectIdentifier id_sigi_on

public static final org.bouncycastle.asn1.DERObjectIdentifier id_sigi_on_personalData
----------------METHODS----------------

static void <clinit>()

private void <init>()

________________CLASS________________


public abstract interface class org.bouncycastle.asn1.x9.X9ObjectIdentifiers extends java.lang.Object

----------------FIELDS----------------

public static final java.lang.String ansi_X9_62

public static final org.bouncycastle.asn1.DERObjectIdentifier c2onb191v4

public static final org.bouncycastle.asn1.DERObjectIdentifier c2onb191v5

public static final org.bouncycastle.asn1.DERObjectIdentifier c2onb239v4

public static final org.bouncycastle.asn1.DERObjectIdentifier c2onb239v5

public static final org.bouncycastle.asn1.DERObjectIdentifier c2pnb163v1

public static final org.bouncycastle.asn1.DERObjectIdentifier c2pnb163v2

public static final org.bouncycastle.asn1.DERObjectIdentifier c2pnb163v3

public static final org.bouncycastle.asn1.DERObjectIdentifier c2pnb176w1

public static final org.bouncycastle.asn1.DERObjectIdentifier c2pnb208w1

public static final org.bouncycastle.asn1.DERObjectIdentifier c2pnb272w1

public static final org.bouncycastle.asn1.DERObjectIdentifier c2pnb368w1

public static final org.bouncycastle.asn1.DERObjectIdentifier c2png304v1

public static final org.bouncycastle.asn1.DERObjectIdentifier c2tnb191v1

public static final org.bouncycastle.asn1.DERObjectIdentifier c2tnb191v2

public static final org.bouncycastle.asn1.DERObjectIdentifier c2tnb191v3

public static final org.bouncycastle.asn1.DERObjectIdentifier c2tnb239v1

public static final org.bouncycastle.asn1.DERObjectIdentifier c2tnb239v2

public static final org.bouncycastle.asn1.DERObjectIdentifier c2tnb239v3

public static final org.bouncycastle.asn1.DERObjectIdentifier c2tnb359v1

public static final org.bouncycastle.asn1.DERObjectIdentifier c2tnb431r1

public static final java.lang.String cTwoCurve

public static final org.bouncycastle.asn1.DERObjectIdentifier characteristic_two_field

public static final org.bouncycastle.asn1.DERObjectIdentifier dhpublicnumber

public static final org.bouncycastle.asn1.DERObjectIdentifier ecdsa_with_SHA1

public static final org.bouncycastle.asn1.DERObjectIdentifier ecdsa_with_SHA2

public static final org.bouncycastle.asn1.DERObjectIdentifier ecdsa_with_SHA224

public static final org.bouncycastle.asn1.DERObjectIdentifier ecdsa_with_SHA256

public static final org.bouncycastle.asn1.DERObjectIdentifier ecdsa_with_SHA384

public static final org.bouncycastle.asn1.DERObjectIdentifier ecdsa_with_SHA512

public static final java.lang.String ellipticCurve

public static final org.bouncycastle.asn1.DERObjectIdentifier gnBasis

public static final org.bouncycastle.asn1.DERObjectIdentifier id_dsa

public static final org.bouncycastle.asn1.DERObjectIdentifier id_dsa_with_sha1

public static final org.bouncycastle.asn1.DERObjectIdentifier id_ecPublicKey

public static final java.lang.String id_ecSigType

public static final java.lang.String id_fieldType

public static final java.lang.String id_publicKeyType

public static final org.bouncycastle.asn1.DERObjectIdentifier ppBasis

public static final org.bouncycastle.asn1.DERObjectIdentifier prime192v1

public static final org.bouncycastle.asn1.DERObjectIdentifier prime192v2

public static final org.bouncycastle.asn1.DERObjectIdentifier prime192v3

public static final org.bouncycastle.asn1.DERObjectIdentifier prime239v1

public static final org.bouncycastle.asn1.DERObjectIdentifier prime239v2

public static final org.bouncycastle.asn1.DERObjectIdentifier prime239v3

public static final org.bouncycastle.asn1.DERObjectIdentifier prime256v1

public static final java.lang.String primeCurve

public static final org.bouncycastle.asn1.DERObjectIdentifier prime_field

public static final org.bouncycastle.asn1.DERObjectIdentifier tpBasis
----------------METHODS----------------

static void <clinit>()

________________CLASS________________


public abstract interface class org.bouncycastle.crypto.AsymmetricBlockCipher extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract int getInputBlockSize()

public abstract int getOutputBlockSize()

public abstract void init(
boolean
org.bouncycastle.crypto.CipherParameters)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/InvalidCipherTextException; )
public abstract byte[] processBlock(
byte[]
int
int)

________________CLASS________________


public class org.bouncycastle.crypto.AsymmetricCipherKeyPair extends java.lang.Object

----------------FIELDS----------------

private org.bouncycastle.crypto.CipherParameters privateParam

private org.bouncycastle.crypto.CipherParameters publicParam
----------------METHODS----------------

public void <init>(
org.bouncycastle.crypto.CipherParameters
org.bouncycastle.crypto.CipherParameters)

public org.bouncycastle.crypto.CipherParameters getPrivate()

public org.bouncycastle.crypto.CipherParameters getPublic()

________________CLASS________________


public abstract interface class org.bouncycastle.crypto.AsymmetricCipherKeyPairGenerator extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract org.bouncycastle.crypto.AsymmetricCipherKeyPair generateKeyPair()

public abstract void init(
org.bouncycastle.crypto.KeyGenerationParameters)

________________CLASS________________


public abstract interface class org.bouncycastle.crypto.BasicAgreement extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.math.BigInteger calculateAgreement(
org.bouncycastle.crypto.CipherParameters)

public abstract void init(
org.bouncycastle.crypto.CipherParameters)

________________CLASS________________


public abstract interface class org.bouncycastle.crypto.BlockCipher extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.lang.String getAlgorithmName()

public abstract int getBlockSize()
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public abstract void init(
boolean
org.bouncycastle.crypto.CipherParameters)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/DataLengthException;Ljava/lang/IllegalStateException; )
public abstract int processBlock(
byte[]
int
byte[]
int)

public abstract void reset()

________________CLASS________________


public class org.bouncycastle.crypto.BufferedAsymmetricBlockCipher extends java.lang.Object

----------------FIELDS----------------

protected byte[] buf

protected int bufOff

private final org.bouncycastle.crypto.AsymmetricBlockCipher cipher
----------------METHODS----------------

public void <init>(
org.bouncycastle.crypto.AsymmetricBlockCipher)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/InvalidCipherTextException; )
public byte[] doFinal()

public int getBufferPosition()

public int getInputBlockSize()

public int getOutputBlockSize()

public org.bouncycastle.crypto.AsymmetricBlockCipher getUnderlyingCipher()

public void init(
boolean
org.bouncycastle.crypto.CipherParameters)

public void processByte(
byte)

public void processBytes(
byte[]
int
int)

public void reset()

________________CLASS________________


public class org.bouncycastle.crypto.BufferedBlockCipher extends java.lang.Object

----------------FIELDS----------------

protected byte[] buf

protected int bufOff

protected org.bouncycastle.crypto.BlockCipher cipher

protected boolean forEncryption

protected boolean partialBlockOkay

protected boolean pgpCFB
----------------METHODS----------------

protected void <init>()

public void <init>(
org.bouncycastle.crypto.BlockCipher)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/DataLengthException;Ljava/lang/IllegalStateException;Lorg/bouncycastle/crypto/InvalidCipherTextException; )
public int doFinal(
byte[]
int)

public int getBlockSize()

public int getOutputSize(
int)

public org.bouncycastle.crypto.BlockCipher getUnderlyingCipher()

public int getUpdateOutputSize(
int)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public void init(
boolean
org.bouncycastle.crypto.CipherParameters)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/DataLengthException;Ljava/lang/IllegalStateException; )
public int processByte(
byte
byte[]
int)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/DataLengthException;Ljava/lang/IllegalStateException; )
public int processBytes(
byte[]
int
int
byte[]
int)

public void reset()

________________CLASS________________


public class org.bouncycastle.crypto.CipherKeyGenerator extends java.lang.Object

----------------FIELDS----------------

protected java.security.SecureRandom random

protected int strength
----------------METHODS----------------

public void <init>()

public byte[] generateKey()

public void init(
org.bouncycastle.crypto.KeyGenerationParameters)

________________CLASS________________


public abstract interface class org.bouncycastle.crypto.CipherParameters extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________


public class org.bouncycastle.crypto.CryptoException extends java.lang.Exception

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public abstract interface class org.bouncycastle.crypto.DSA extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.math.BigInteger[] generateSignature(
byte[])

public abstract void init(
boolean
org.bouncycastle.crypto.CipherParameters)

public abstract boolean verifySignature(
byte[]
java.math.BigInteger
java.math.BigInteger)

________________CLASS________________


public class org.bouncycastle.crypto.RuntimeCryptoException extends java.lang.RuntimeException

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class org.bouncycastle.crypto.DataLengthException extends org.bouncycastle.crypto.RuntimeCryptoException

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public abstract interface class org.bouncycastle.crypto.DerivationFunction extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/DataLengthException;Ljava/lang/IllegalArgumentException; )
public abstract int generateBytes(
byte[]
int
int)

public abstract org.bouncycastle.crypto.Digest getDigest()

public abstract void init(
org.bouncycastle.crypto.DerivationParameters)

________________CLASS________________


public abstract interface class org.bouncycastle.crypto.DerivationParameters extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________


public class org.bouncycastle.crypto.InvalidCipherTextException extends org.bouncycastle.crypto.CryptoException

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class org.bouncycastle.crypto.KeyGenerationParameters extends java.lang.Object

----------------FIELDS----------------

private java.security.SecureRandom random

private int strength
----------------METHODS----------------

public void <init>(
java.security.SecureRandom
int)

public java.security.SecureRandom getRandom()

public int getStrength()

________________CLASS________________


public abstract interface class org.bouncycastle.crypto.Mac extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/DataLengthException;Ljava/lang/IllegalStateException; )
public abstract int doFinal(
byte[]
int)

public abstract java.lang.String getAlgorithmName()

public abstract int getMacSize()
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public abstract void init(
org.bouncycastle.crypto.CipherParameters)

public abstract void reset()
@dalvik.annotation.Throws (value =Ljava/lang/IllegalStateException; )
public abstract void update(
byte)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/DataLengthException;Ljava/lang/IllegalStateException; )
public abstract void update(
byte[]
int
int)

________________CLASS________________


public abstract class org.bouncycastle.crypto.PBEParametersGenerator extends java.lang.Object

----------------FIELDS----------------

protected int iterationCount

protected byte[] password

protected byte[] salt
----------------METHODS----------------

protected void <init>()

public static byte[] PKCS12PasswordToBytes(
char[])

public static byte[] PKCS5PasswordToBytes(
char[])

public abstract org.bouncycastle.crypto.CipherParameters generateDerivedMacParameters(
int)

public abstract org.bouncycastle.crypto.CipherParameters generateDerivedParameters(
int)

public abstract org.bouncycastle.crypto.CipherParameters generateDerivedParameters(
int
int)

public int getIterationCount()

public byte[] getPassword()

public byte[] getSalt()

public void init(
byte[]
byte[]
int)

________________CLASS________________


public abstract interface class org.bouncycastle.crypto.Signer extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/CryptoException;Lorg/bouncycastle/crypto/DataLengthException; )
public abstract byte[] generateSignature()

public abstract void init(
boolean
org.bouncycastle.crypto.CipherParameters)

public abstract void reset()

public abstract void update(
byte)

public abstract void update(
byte[]
int
int)

public abstract boolean verifySignature(
byte[])

________________CLASS________________


public abstract interface class org.bouncycastle.crypto.SignerWithRecovery extends java.lang.Object implements org.bouncycastle.crypto.Signer

----------------FIELDS----------------
----------------METHODS----------------

public abstract byte[] getRecoveredMessage()

public abstract boolean hasFullMessage()

________________CLASS________________


public abstract interface class org.bouncycastle.crypto.StreamCipher extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.lang.String getAlgorithmName()
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public abstract void init(
boolean
org.bouncycastle.crypto.CipherParameters)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/DataLengthException; )
public abstract void processBytes(
byte[]
int
int
byte[]
int)

public abstract void reset()

public abstract byte returnByte(
byte)

________________CLASS________________


public class org.bouncycastle.crypto.StreamBlockCipher extends java.lang.Object implements org.bouncycastle.crypto.StreamCipher

----------------FIELDS----------------

private org.bouncycastle.crypto.BlockCipher cipher

private byte[] oneByte
----------------METHODS----------------

public void <init>(
org.bouncycastle.crypto.BlockCipher)

public java.lang.String getAlgorithmName()

public void init(
boolean
org.bouncycastle.crypto.CipherParameters)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/DataLengthException; )
public void processBytes(
byte[]
int
int
byte[]
int)

public void reset()

public byte returnByte(
byte)

________________CLASS________________


public abstract interface class org.bouncycastle.crypto.Wrapper extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.lang.String getAlgorithmName()

public abstract void init(
boolean
org.bouncycastle.crypto.CipherParameters)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/InvalidCipherTextException; )
public abstract byte[] unwrap(
byte[]
int
int)

public abstract byte[] wrap(
byte[]
int
int)

________________CLASS________________


public class org.bouncycastle.crypto.agreement.DHAgreement extends java.lang.Object

----------------FIELDS----------------

private org.bouncycastle.crypto.params.DHParameters dhParams

private org.bouncycastle.crypto.params.DHPrivateKeyParameters key

private java.math.BigInteger privateValue

private java.security.SecureRandom random
----------------METHODS----------------

public void <init>()

public java.math.BigInteger calculateAgreement(
org.bouncycastle.crypto.params.DHPublicKeyParameters
java.math.BigInteger)

public java.math.BigInteger calculateMessage()

public void init(
org.bouncycastle.crypto.CipherParameters)

________________CLASS________________


public class org.bouncycastle.crypto.agreement.DHBasicAgreement extends java.lang.Object implements org.bouncycastle.crypto.BasicAgreement

----------------FIELDS----------------

private org.bouncycastle.crypto.params.DHParameters dhParams

private org.bouncycastle.crypto.params.DHPrivateKeyParameters key

private java.security.SecureRandom random
----------------METHODS----------------

public void <init>()

public java.math.BigInteger calculateAgreement(
org.bouncycastle.crypto.CipherParameters)

public void init(
org.bouncycastle.crypto.CipherParameters)

________________CLASS________________


public abstract class org.bouncycastle.crypto.digests.GeneralDigest extends java.lang.Object implements org.bouncycastle.crypto.ExtendedDigest

----------------FIELDS----------------

private static final int BYTE_LENGTH

private long byteCount

private byte[] xBuf

private int xBufOff
----------------METHODS----------------

protected void <init>()

protected void <init>(
org.bouncycastle.crypto.digests.GeneralDigest)

public void finish()

public int getByteLength()

protected abstract void processBlock()

protected abstract void processLength(
long)

protected abstract void processWord(
byte[]
int)

public void reset()

public void update(
byte)

public void update(
byte[]
int
int)

________________CLASS________________


public abstract class org.bouncycastle.crypto.digests.LongDigest extends java.lang.Object implements org.bouncycastle.crypto.ExtendedDigest

----------------FIELDS----------------

private static final int BYTE_LENGTH

static final long[] K

protected long H1

protected long H2

protected long H3

protected long H4

protected long H5

protected long H6

protected long H7

protected long H8

private long[] W

private long byteCount1

private long byteCount2

private int wOff

private byte[] xBuf

private int xBufOff
----------------METHODS----------------

static void <clinit>()

protected void <init>()

protected void <init>(
org.bouncycastle.crypto.digests.LongDigest)

private long Ch(
long
long
long)

private long Maj(
long
long
long)

private long Sigma0(
long)

private long Sigma1(
long)

private long Sum0(
long)

private long Sum1(
long)

private void adjustByteCounts()

public void finish()

public int getByteLength()

protected void processBlock()

protected void processLength(
long
long)

protected void processWord(
byte[]
int)

public void reset()

protected void unpackWord(
long
byte[]
int)

public void update(
byte)

public void update(
byte[]
int
int)

________________CLASS________________


public class org.bouncycastle.crypto.digests.MD2Digest extends java.lang.Object implements org.bouncycastle.crypto.ExtendedDigest

----------------FIELDS----------------

private static final int DIGEST_LENGTH

private static final byte[] S

private byte[] C

private int COff

private byte[] M

private byte[] X

private int mOff

private int xOff
----------------METHODS----------------

static void <clinit>()

public void <init>()

public void <init>(
org.bouncycastle.crypto.digests.MD2Digest)

public int doFinal(
byte[]
int)

public java.lang.String getAlgorithmName()

public int getByteLength()

public int getDigestSize()

protected void processBlock(
byte[])

protected void processCheckSum(
byte[])

public void reset()

public void update(
byte)

public void update(
byte[]
int
int)

________________CLASS________________


public class org.bouncycastle.crypto.digests.MD4Digest extends org.bouncycastle.crypto.digests.GeneralDigest

----------------FIELDS----------------

private static final int DIGEST_LENGTH

private static final int S11

private static final int S12

private static final int S13

private static final int S14

private static final int S21

private static final int S22

private static final int S23

private static final int S24

private static final int S31

private static final int S32

private static final int S33

private static final int S34

private int H1

private int H2

private int H3

private int H4

private int[] X

private int xOff
----------------METHODS----------------

public void <init>()

public void <init>(
org.bouncycastle.crypto.digests.MD4Digest)

private int F(
int
int
int)

private int G(
int
int
int)

private int H(
int
int
int)

private int rotateLeft(
int
int)

private void unpackWord(
int
byte[]
int)

public int doFinal(
byte[]
int)

public java.lang.String getAlgorithmName()

public int getDigestSize()

protected void processBlock()

protected void processLength(
long)

protected void processWord(
byte[]
int)

public void reset()

________________CLASS________________


public class org.bouncycastle.crypto.digests.MD5Digest extends org.bouncycastle.crypto.digests.GeneralDigest

----------------FIELDS----------------

private static final int DIGEST_LENGTH

private static final int S11

private static final int S12

private static final int S13

private static final int S14

private static final int S21

private static final int S22

private static final int S23

private static final int S24

private static final int S31

private static final int S32

private static final int S33

private static final int S34

private static final int S41

private static final int S42

private static final int S43

private static final int S44

private int H1

private int H2

private int H3

private int H4

private int[] X

private int xOff
----------------METHODS----------------

public void <init>()

public void <init>(
org.bouncycastle.crypto.digests.MD5Digest)

private int F(
int
int
int)

private int G(
int
int
int)

private int H(
int
int
int)

private int K(
int
int
int)

private int rotateLeft(
int
int)

private void unpackWord(
int
byte[]
int)

public int doFinal(
byte[]
int)

public java.lang.String getAlgorithmName()

public int getDigestSize()

protected void processBlock()

protected void processLength(
long)

protected void processWord(
byte[]
int)

public void reset()

________________CLASS________________


public class org.bouncycastle.crypto.digests.SHA1Digest extends org.bouncycastle.crypto.digests.GeneralDigest

----------------FIELDS----------------

private static final int DIGEST_LENGTH

private static final int Y1

private static final int Y2

private static final int Y3

private static final int Y4

private int H1

private int H2

private int H3

private int H4

private int H5

private int[] X

private int xOff
----------------METHODS----------------

public void <init>()

public void <init>(
org.bouncycastle.crypto.digests.SHA1Digest)

private int f(
int
int
int)

private int g(
int
int
int)

private int h(
int
int
int)

private void unpackWord(
int
byte[]
int)

public int doFinal(
byte[]
int)

public java.lang.String getAlgorithmName()

public int getDigestSize()

protected void processBlock()

protected void processLength(
long)

protected void processWord(
byte[]
int)

public void reset()

________________CLASS________________


public class org.bouncycastle.crypto.digests.SHA224Digest extends org.bouncycastle.crypto.digests.GeneralDigest

----------------FIELDS----------------

private static final int DIGEST_LENGTH

static final int[] K

private int H1

private int H2

private int H3

private int H4

private int H5

private int H6

private int H7

private int H8

private int[] X

private int xOff
----------------METHODS----------------

static void <clinit>()

public void <init>()

public void <init>(
org.bouncycastle.crypto.digests.SHA224Digest)

private int Ch(
int
int
int)

private int Maj(
int
int
int)

private int Sum0(
int)

private int Sum1(
int)

private int Theta0(
int)

private int Theta1(
int)

private void unpackWord(
int
byte[]
int)

public int doFinal(
byte[]
int)

public java.lang.String getAlgorithmName()

public int getDigestSize()

protected void processBlock()

protected void processLength(
long)

protected void processWord(
byte[]
int)

public void reset()

________________CLASS________________


public class org.bouncycastle.crypto.digests.SHA256Digest extends org.bouncycastle.crypto.digests.GeneralDigest

----------------FIELDS----------------

private static final int DIGEST_LENGTH

static final int[] K

private int H1

private int H2

private int H3

private int H4

private int H5

private int H6

private int H7

private int H8

private int[] X

private int xOff
----------------METHODS----------------

static void <clinit>()

public void <init>()

public void <init>(
org.bouncycastle.crypto.digests.SHA256Digest)

private int Ch(
int
int
int)

private int Maj(
int
int
int)

private int Sum0(
int)

private int Sum1(
int)

private int Theta0(
int)

private int Theta1(
int)

private void unpackWord(
int
byte[]
int)

public int doFinal(
byte[]
int)

public java.lang.String getAlgorithmName()

public int getDigestSize()

protected void processBlock()

protected void processLength(
long)

protected void processWord(
byte[]
int)

public void reset()

________________CLASS________________


public class org.bouncycastle.crypto.digests.SHA384Digest extends org.bouncycastle.crypto.digests.LongDigest

----------------FIELDS----------------

private static final int DIGEST_LENGTH
----------------METHODS----------------

public void <init>()

public void <init>(
org.bouncycastle.crypto.digests.SHA384Digest)

public int doFinal(
byte[]
int)

public java.lang.String getAlgorithmName()

public int getDigestSize()

public void reset()

________________CLASS________________


public class org.bouncycastle.crypto.digests.SHA512Digest extends org.bouncycastle.crypto.digests.LongDigest

----------------FIELDS----------------

private static final int DIGEST_LENGTH
----------------METHODS----------------

public void <init>()

public void <init>(
org.bouncycastle.crypto.digests.SHA512Digest)

public int doFinal(
byte[]
int)

public java.lang.String getAlgorithmName()

public int getDigestSize()

public void reset()

________________CLASS________________


public class org.bouncycastle.crypto.digests.ShortenedDigest extends java.lang.Object implements org.bouncycastle.crypto.ExtendedDigest

----------------FIELDS----------------

private org.bouncycastle.crypto.ExtendedDigest baseDigest

private int length
----------------METHODS----------------

public void <init>(
org.bouncycastle.crypto.ExtendedDigest
int)

public int doFinal(
byte[]
int)

public java.lang.String getAlgorithmName()

public int getByteLength()

public int getDigestSize()

public void reset()

public void update(
byte)

public void update(
byte[]
int
int)

________________CLASS________________


public class org.bouncycastle.crypto.encodings.ISO9796d1Encoding extends java.lang.Object implements org.bouncycastle.crypto.AsymmetricBlockCipher

----------------FIELDS----------------

private static byte[] inverse

private static byte[] shadows

private int bitSize

private org.bouncycastle.crypto.AsymmetricBlockCipher engine

private boolean forEncryption

private int padBits
----------------METHODS----------------

static void <clinit>()

public void <init>(
org.bouncycastle.crypto.AsymmetricBlockCipher)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/InvalidCipherTextException; )
private byte[] decodeBlock(
byte[]
int
int)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/InvalidCipherTextException; )
private byte[] encodeBlock(
byte[]
int
int)

public int getInputBlockSize()

public int getOutputBlockSize()

public int getPadBits()

public org.bouncycastle.crypto.AsymmetricBlockCipher getUnderlyingCipher()

public void init(
boolean
org.bouncycastle.crypto.CipherParameters)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/InvalidCipherTextException; )
public byte[] processBlock(
byte[]
int
int)

public void setPadBits(
int)

________________CLASS________________


public class org.bouncycastle.crypto.encodings.OAEPEncoding extends java.lang.Object implements org.bouncycastle.crypto.AsymmetricBlockCipher

----------------FIELDS----------------

private byte[] defHash

private org.bouncycastle.crypto.AsymmetricBlockCipher engine

private boolean forEncryption

private org.bouncycastle.crypto.Digest hash

private java.security.SecureRandom random
----------------METHODS----------------

public void <init>(
org.bouncycastle.crypto.AsymmetricBlockCipher)

public void <init>(
org.bouncycastle.crypto.AsymmetricBlockCipher
org.bouncycastle.crypto.Digest)

public void <init>(
org.bouncycastle.crypto.AsymmetricBlockCipher
org.bouncycastle.crypto.Digest
byte[])

private void ItoOSP(
int
byte[])

private byte[] maskGeneratorFunction1(
byte[]
int
int
int)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/InvalidCipherTextException; )
public byte[] decodeBlock(
byte[]
int
int)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/InvalidCipherTextException; )
public byte[] encodeBlock(
byte[]
int
int)

public int getInputBlockSize()

public int getOutputBlockSize()

public org.bouncycastle.crypto.AsymmetricBlockCipher getUnderlyingCipher()

public void init(
boolean
org.bouncycastle.crypto.CipherParameters)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/InvalidCipherTextException; )
public byte[] processBlock(
byte[]
int
int)

________________CLASS________________


public class org.bouncycastle.crypto.encodings.PKCS1Encoding extends java.lang.Object implements org.bouncycastle.crypto.AsymmetricBlockCipher

----------------FIELDS----------------

private static int HEADER_LENGTH

public static java.lang.String STRICT_LENGTH_ENABLED_PROPERTY

private org.bouncycastle.crypto.AsymmetricBlockCipher engine

private boolean forEncryption

private boolean forPrivateKey

private java.security.SecureRandom random

private boolean useStrictLength
----------------METHODS----------------

static void <clinit>()

public void <init>(
org.bouncycastle.crypto.AsymmetricBlockCipher)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/InvalidCipherTextException; )
private byte[] decodeBlock(
byte[]
int
int)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/InvalidCipherTextException; )
private byte[] encodeBlock(
byte[]
int
int)

public int getInputBlockSize()

public int getOutputBlockSize()

public org.bouncycastle.crypto.AsymmetricBlockCipher getUnderlyingCipher()

public void init(
boolean
org.bouncycastle.crypto.CipherParameters)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/InvalidCipherTextException; )
public byte[] processBlock(
byte[]
int
int)

________________CLASS________________


public class org.bouncycastle.crypto.engines.AESEngine extends java.lang.Object implements org.bouncycastle.crypto.BlockCipher

----------------FIELDS----------------

private static final int BLOCK_SIZE

private static final byte[] S

private static final byte[] Si

private static final int[] T0

private static final int[] Tinv0

private static final int m1

private static final int m2

private static final int m3

private static final int[] rcon

private int C0

private int C1

private int C2

private int C3

private int ROUNDS

private int[][] WorkingKey

private boolean forEncryption
----------------METHODS----------------

static void <clinit>()

public void <init>()

private int FFmulX(
int)

private final void decryptBlock(
int[][])

private final void encryptBlock(
int[][])

private int[][] generateWorkingKey(
byte[]
boolean)

private int inv_mcol(
int)

private final void packBlock(
byte[]
int)

private int shift(
int
int)

private int subWord(
int)

private final void unpackBlock(
byte[]
int)

public java.lang.String getAlgorithmName()

public int getBlockSize()

public void init(
boolean
org.bouncycastle.crypto.CipherParameters)

public int processBlock(
byte[]
int
byte[]
int)

public void reset()

________________CLASS________________


public class org.bouncycastle.crypto.engines.AESFastEngine extends java.lang.Object implements org.bouncycastle.crypto.BlockCipher

----------------FIELDS----------------

private static final int BLOCK_SIZE

private static final byte[] S

private static final byte[] Si

private static final int[] T0

private static final int[] T1

private static final int[] T2

private static final int[] T3

private static final int[] Tinv0

private static final int[] Tinv1

private static final int[] Tinv2

private static final int[] Tinv3

private static final int m1

private static final int m2

private static final int m3

private static final int[] rcon

private int C0

private int C1

private int C2

private int C3

private int ROUNDS

private int[][] WorkingKey

private boolean forEncryption
----------------METHODS----------------

static void <clinit>()

public void <init>()

private int FFmulX(
int)

private final void decryptBlock(
int[][])

private final void encryptBlock(
int[][])

private int[][] generateWorkingKey(
byte[]
boolean)

private int inv_mcol(
int)

private final void packBlock(
byte[]
int)

private int shift(
int
int)

private int subWord(
int)

private final void unpackBlock(
byte[]
int)

public java.lang.String getAlgorithmName()

public int getBlockSize()

public void init(
boolean
org.bouncycastle.crypto.CipherParameters)

public int processBlock(
byte[]
int
byte[]
int)

public void reset()

________________CLASS________________


public class org.bouncycastle.crypto.engines.AESLightEngine extends java.lang.Object implements org.bouncycastle.crypto.BlockCipher

----------------FIELDS----------------

private static final int BLOCK_SIZE

private static final byte[] S

private static final byte[] Si

private static final int m1

private static final int m2

private static final int m3

private static final int[] rcon

private int C0

private int C1

private int C2

private int C3

private int ROUNDS

private int[][] WorkingKey

private boolean forEncryption
----------------METHODS----------------

static void <clinit>()

public void <init>()

private int FFmulX(
int)

private final void decryptBlock(
int[][])

private void encryptBlock(
int[][])

private int[][] generateWorkingKey(
byte[]
boolean)

private int inv_mcol(
int)

private int mcol(
int)

private final void packBlock(
byte[]
int)

private int shift(
int
int)

private int subWord(
int)

private final void unpackBlock(
byte[]
int)

public java.lang.String getAlgorithmName()

public int getBlockSize()

public void init(
boolean
org.bouncycastle.crypto.CipherParameters)

public int processBlock(
byte[]
int
byte[]
int)

public void reset()

________________CLASS________________


public class org.bouncycastle.crypto.engines.AESWrapEngine extends java.lang.Object implements org.bouncycastle.crypto.Wrapper

----------------FIELDS----------------

private org.bouncycastle.crypto.BlockCipher engine

private boolean forWrapping

private byte[] iv

private org.bouncycastle.crypto.params.KeyParameter param
----------------METHODS----------------

public void <init>()

public java.lang.String getAlgorithmName()

public void init(
boolean
org.bouncycastle.crypto.CipherParameters)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/InvalidCipherTextException; )
public byte[] unwrap(
byte[]
int
int)

public byte[] wrap(
byte[]
int
int)

________________CLASS________________


public class org.bouncycastle.crypto.engines.DESEngine extends java.lang.Object implements org.bouncycastle.crypto.BlockCipher

----------------FIELDS----------------

protected static final int BLOCK_SIZE

static short[] Df_Key

static int[] SP1

static int[] SP2

static int[] SP3

static int[] SP4

static int[] SP5

static int[] SP6

static int[] SP7

static int[] SP8

static int[] bigbyte

static short[] bytebit

static byte[] pc1

static byte[] pc2

static byte[] totrot

private int[] workingKey
----------------METHODS----------------

static void <clinit>()

public void <init>()

protected void desFunc(
int[]
byte[]
int
byte[]
int)

protected int[] generateWorkingKey(
boolean
byte[])

public java.lang.String getAlgorithmName()

public int getBlockSize()

public void init(
boolean
org.bouncycastle.crypto.CipherParameters)

public int processBlock(
byte[]
int
byte[]
int)

public void reset()

________________CLASS________________


public class org.bouncycastle.crypto.engines.DESedeEngine extends org.bouncycastle.crypto.engines.DESEngine

----------------FIELDS----------------

protected static final int BLOCK_SIZE

private boolean forEncryption

private int[] workingKey1

private int[] workingKey2

private int[] workingKey3
----------------METHODS----------------

public void <init>()

public java.lang.String getAlgorithmName()

public int getBlockSize()

public void init(
boolean
org.bouncycastle.crypto.CipherParameters)

public int processBlock(
byte[]
int
byte[]
int)

public void reset()

________________CLASS________________


public class org.bouncycastle.crypto.engines.DESedeWrapEngine extends java.lang.Object implements org.bouncycastle.crypto.Wrapper

----------------FIELDS----------------

private static final byte[] IV2

 byte[] digest

private org.bouncycastle.crypto.modes.CBCBlockCipher engine

private boolean forWrapping

private byte[] iv

private org.bouncycastle.crypto.params.KeyParameter param

private org.bouncycastle.crypto.params.ParametersWithIV paramPlusIV

 org.bouncycastle.crypto.Digest sha1
----------------METHODS----------------

static void <clinit>()

public void <init>()

private byte[] calculateCMSKeyChecksum(
byte[])

private boolean checkCMSKeyChecksum(
byte[]
byte[])

public java.lang.String getAlgorithmName()

public void init(
boolean
org.bouncycastle.crypto.CipherParameters)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/InvalidCipherTextException; )
public byte[] unwrap(
byte[]
int
int)

public byte[] wrap(
byte[]
int
int)

________________CLASS________________


public class org.bouncycastle.crypto.engines.IESEngine extends java.lang.Object

----------------FIELDS----------------

 org.bouncycastle.crypto.BasicAgreement agree

 org.bouncycastle.crypto.BufferedBlockCipher cipher

 boolean forEncryption

 org.bouncycastle.crypto.DerivationFunction kdf

 org.bouncycastle.crypto.Mac mac

 byte[] macBuf

 org.bouncycastle.crypto.params.IESParameters param

 org.bouncycastle.crypto.CipherParameters privParam

 org.bouncycastle.crypto.CipherParameters pubParam
----------------METHODS----------------

public void <init>(
org.bouncycastle.crypto.BasicAgreement
org.bouncycastle.crypto.DerivationFunction
org.bouncycastle.crypto.Mac)

public void <init>(
org.bouncycastle.crypto.BasicAgreement
org.bouncycastle.crypto.DerivationFunction
org.bouncycastle.crypto.Mac
org.bouncycastle.crypto.BufferedBlockCipher)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/InvalidCipherTextException; )
private byte[] decryptBlock(
byte[]
int
int
byte[])
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/InvalidCipherTextException; )
private byte[] encryptBlock(
byte[]
int
int
byte[])

public void init(
boolean
org.bouncycastle.crypto.CipherParameters
org.bouncycastle.crypto.CipherParameters
org.bouncycastle.crypto.CipherParameters)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/InvalidCipherTextException; )
public byte[] processBlock(
byte[]
int
int)

________________CLASS________________


public class org.bouncycastle.crypto.engines.NullEngine extends java.lang.Object implements org.bouncycastle.crypto.BlockCipher

----------------FIELDS----------------

protected static final int BLOCK_SIZE
----------------METHODS----------------

public void <init>()

public java.lang.String getAlgorithmName()

public int getBlockSize()
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public void init(
boolean
org.bouncycastle.crypto.CipherParameters)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/DataLengthException;Ljava/lang/IllegalStateException; )
public int processBlock(
byte[]
int
byte[]
int)

public void reset()

________________CLASS________________


public class org.bouncycastle.crypto.engines.RSAEngine extends java.lang.Object implements org.bouncycastle.crypto.AsymmetricBlockCipher

----------------FIELDS----------------

private boolean forEncryption

private org.bouncycastle.crypto.params.RSAKeyParameters key

private int shift
----------------METHODS----------------

public void <init>()

public int getInputBlockSize()

public int getOutputBlockSize()

public void init(
boolean
org.bouncycastle.crypto.CipherParameters)

public byte[] processBlock(
byte[]
int
int)

________________CLASS________________


public class org.bouncycastle.crypto.generators.BaseKDFBytesGenerator extends java.lang.Object implements org.bouncycastle.crypto.DerivationFunction

----------------FIELDS----------------

private int counterStart

private org.bouncycastle.crypto.Digest digest

private byte[] iv

private byte[] shared
----------------METHODS----------------

protected void <init>(
int
org.bouncycastle.crypto.Digest)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/DataLengthException;Ljava/lang/IllegalArgumentException; )
public int generateBytes(
byte[]
int
int)

public org.bouncycastle.crypto.Digest getDigest()

public void init(
org.bouncycastle.crypto.DerivationParameters)

________________CLASS________________


public class org.bouncycastle.crypto.generators.DESKeyGenerator extends org.bouncycastle.crypto.CipherKeyGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public byte[] generateKey()

________________CLASS________________


public class org.bouncycastle.crypto.generators.DESedeKeyGenerator extends org.bouncycastle.crypto.generators.DESKeyGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public byte[] generateKey()

public void init(
org.bouncycastle.crypto.KeyGenerationParameters)

________________CLASS________________


public class org.bouncycastle.crypto.generators.DHBasicKeyPairGenerator extends java.lang.Object implements org.bouncycastle.crypto.AsymmetricCipherKeyPairGenerator

----------------FIELDS----------------

private org.bouncycastle.crypto.generators.DHKeyGeneratorHelper helper

private org.bouncycastle.crypto.params.DHKeyGenerationParameters param
----------------METHODS----------------

public void <init>()

public org.bouncycastle.crypto.AsymmetricCipherKeyPair generateKeyPair()

public void init(
org.bouncycastle.crypto.KeyGenerationParameters)

________________CLASS________________


 class org.bouncycastle.crypto.generators.DHKeyGeneratorHelper extends java.lang.Object

----------------FIELDS----------------

static final org.bouncycastle.crypto.generators.DHKeyGeneratorHelper INSTANCE

private static final int MAX_ITERATIONS

private static java.math.BigInteger TWO

private static java.math.BigInteger ZERO
----------------METHODS----------------

static void <clinit>()

private void <init>()

private java.math.BigInteger createInRange(
java.math.BigInteger
java.security.SecureRandom)

 java.math.BigInteger calculatePrivate(
java.math.BigInteger
java.security.SecureRandom
int)

 java.math.BigInteger calculatePublic(
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger)

________________CLASS________________


public class org.bouncycastle.crypto.generators.DHKeyPairGenerator extends java.lang.Object implements org.bouncycastle.crypto.AsymmetricCipherKeyPairGenerator

----------------FIELDS----------------

private org.bouncycastle.crypto.generators.DHKeyGeneratorHelper helper

private org.bouncycastle.crypto.params.DHKeyGenerationParameters param
----------------METHODS----------------

public void <init>()

public org.bouncycastle.crypto.AsymmetricCipherKeyPair generateKeyPair()

public void init(
org.bouncycastle.crypto.KeyGenerationParameters)

________________CLASS________________


public class org.bouncycastle.crypto.generators.DHParametersGenerator extends java.lang.Object

----------------FIELDS----------------

private static java.math.BigInteger ONE

private static java.math.BigInteger TWO

private int certainty

private java.security.SecureRandom random

private int size
----------------METHODS----------------

static void <clinit>()

public void <init>()

public org.bouncycastle.crypto.params.DHParameters generateParameters()

public void init(
int
int
java.security.SecureRandom)

________________CLASS________________


public class org.bouncycastle.crypto.generators.DSAKeyPairGenerator extends java.lang.Object implements org.bouncycastle.crypto.AsymmetricCipherKeyPairGenerator

----------------FIELDS----------------

private static java.math.BigInteger ZERO

private org.bouncycastle.crypto.params.DSAKeyGenerationParameters param
----------------METHODS----------------

static void <clinit>()

public void <init>()

public org.bouncycastle.crypto.AsymmetricCipherKeyPair generateKeyPair()

public void init(
org.bouncycastle.crypto.KeyGenerationParameters)

________________CLASS________________


public class org.bouncycastle.crypto.generators.DSAParametersGenerator extends java.lang.Object

----------------FIELDS----------------

private static java.math.BigInteger ONE

private static java.math.BigInteger TWO

private int certainty

private java.security.SecureRandom random

private int size
----------------METHODS----------------

static void <clinit>()

public void <init>()

private void add(
byte[]
byte[]
int)

public org.bouncycastle.crypto.params.DSAParameters generateParameters()

public void init(
int
int
java.security.SecureRandom)

________________CLASS________________


public class org.bouncycastle.crypto.generators.KDF1BytesGenerator extends org.bouncycastle.crypto.generators.BaseKDFBytesGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>(
org.bouncycastle.crypto.Digest)

________________CLASS________________


public class org.bouncycastle.crypto.generators.KDF2BytesGenerator extends org.bouncycastle.crypto.generators.BaseKDFBytesGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>(
org.bouncycastle.crypto.Digest)

________________CLASS________________


public class org.bouncycastle.crypto.generators.MGF1BytesGenerator extends java.lang.Object implements org.bouncycastle.crypto.DerivationFunction

----------------FIELDS----------------

private org.bouncycastle.crypto.Digest digest

private int hLen

private byte[] seed
----------------METHODS----------------

public void <init>(
org.bouncycastle.crypto.Digest)

private void ItoOSP(
int
byte[])
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/DataLengthException;Ljava/lang/IllegalArgumentException; )
public int generateBytes(
byte[]
int
int)

public org.bouncycastle.crypto.Digest getDigest()

public void init(
org.bouncycastle.crypto.DerivationParameters)

________________CLASS________________


public class org.bouncycastle.crypto.generators.OpenSSLPBEParametersGenerator extends org.bouncycastle.crypto.PBEParametersGenerator

----------------FIELDS----------------

private org.bouncycastle.crypto.Digest digest
----------------METHODS----------------

public void <init>()

private byte[] generateDerivedKey(
int)

public org.bouncycastle.crypto.CipherParameters generateDerivedMacParameters(
int)

public org.bouncycastle.crypto.CipherParameters generateDerivedParameters(
int)

public org.bouncycastle.crypto.CipherParameters generateDerivedParameters(
int
int)

public void init(
byte[]
byte[])

________________CLASS________________


public class org.bouncycastle.crypto.generators.PKCS12ParametersGenerator extends org.bouncycastle.crypto.PBEParametersGenerator

----------------FIELDS----------------

public static final int IV_MATERIAL

public static final int KEY_MATERIAL

public static final int MAC_MATERIAL

private org.bouncycastle.crypto.Digest digest

private int u

private int v
----------------METHODS----------------

public void <init>(
org.bouncycastle.crypto.Digest)

private void adjust(
byte[]
int
byte[])

private byte[] generateDerivedKey(
int
int)

public org.bouncycastle.crypto.CipherParameters generateDerivedMacParameters(
int)

public org.bouncycastle.crypto.CipherParameters generateDerivedParameters(
int)

public org.bouncycastle.crypto.CipherParameters generateDerivedParameters(
int
int)

________________CLASS________________


public class org.bouncycastle.crypto.generators.PKCS5S1ParametersGenerator extends org.bouncycastle.crypto.PBEParametersGenerator

----------------FIELDS----------------

private org.bouncycastle.crypto.Digest digest
----------------METHODS----------------

public void <init>(
org.bouncycastle.crypto.Digest)

private byte[] generateDerivedKey()

public org.bouncycastle.crypto.CipherParameters generateDerivedMacParameters(
int)

public org.bouncycastle.crypto.CipherParameters generateDerivedParameters(
int)

public org.bouncycastle.crypto.CipherParameters generateDerivedParameters(
int
int)

________________CLASS________________


public class org.bouncycastle.crypto.generators.PKCS5S2ParametersGenerator extends org.bouncycastle.crypto.PBEParametersGenerator

----------------FIELDS----------------

private org.bouncycastle.crypto.Mac hMac
----------------METHODS----------------

public void <init>()

private void F(
byte[]
byte[]
int
byte[]
byte[]
int)

private byte[] generateDerivedKey(
int)

private void intToOctet(
byte[]
int)

public org.bouncycastle.crypto.CipherParameters generateDerivedMacParameters(
int)

public org.bouncycastle.crypto.CipherParameters generateDerivedParameters(
int)

public org.bouncycastle.crypto.CipherParameters generateDerivedParameters(
int
int)

________________CLASS________________


public class org.bouncycastle.crypto.generators.RSAKeyPairGenerator extends java.lang.Object implements org.bouncycastle.crypto.AsymmetricCipherKeyPairGenerator

----------------FIELDS----------------

private static java.math.BigInteger ONE

private org.bouncycastle.crypto.params.RSAKeyGenerationParameters param
----------------METHODS----------------

static void <clinit>()

public void <init>()

public org.bouncycastle.crypto.AsymmetricCipherKeyPair generateKeyPair()

public void init(
org.bouncycastle.crypto.KeyGenerationParameters)

________________CLASS________________


public class org.bouncycastle.crypto.io.DigestInputStream extends java.io.FilterInputStream

----------------FIELDS----------------

protected org.bouncycastle.crypto.Digest digest
----------------METHODS----------------

public void <init>(
java.io.InputStream
org.bouncycastle.crypto.Digest)

public org.bouncycastle.crypto.Digest getDigest()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[]
int
int)

________________CLASS________________


public class org.bouncycastle.crypto.io.DigestOutputStream extends java.io.FilterOutputStream

----------------FIELDS----------------

protected org.bouncycastle.crypto.Digest digest
----------------METHODS----------------

public void <init>(
java.io.OutputStream
org.bouncycastle.crypto.Digest)

public org.bouncycastle.crypto.Digest getDigest()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
byte[]
int
int)

________________CLASS________________


public class org.bouncycastle.crypto.io.MacInputStream extends java.io.FilterInputStream

----------------FIELDS----------------

protected org.bouncycastle.crypto.Mac mac
----------------METHODS----------------

public void <init>(
java.io.InputStream
org.bouncycastle.crypto.Mac)

public org.bouncycastle.crypto.Mac getMac()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int read(
byte[]
int
int)

________________CLASS________________


public class org.bouncycastle.crypto.io.MacOutputStream extends java.io.FilterOutputStream

----------------FIELDS----------------

protected org.bouncycastle.crypto.Mac mac
----------------METHODS----------------

public void <init>(
java.io.OutputStream
org.bouncycastle.crypto.Mac)

public org.bouncycastle.crypto.Mac getMac()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
byte[]
int
int)

________________CLASS________________


public class org.bouncycastle.crypto.macs.BlockCipherMac extends java.lang.Object implements org.bouncycastle.crypto.Mac

----------------FIELDS----------------

private byte[] buf

private int bufOff

private org.bouncycastle.crypto.BlockCipher cipher

private byte[] mac

private int macSize
----------------METHODS----------------

public void <init>(
org.bouncycastle.crypto.BlockCipher)

public void <init>(
org.bouncycastle.crypto.BlockCipher
int)

public int doFinal(
byte[]
int)

public java.lang.String getAlgorithmName()

public int getMacSize()

public void init(
org.bouncycastle.crypto.CipherParameters)

public void reset()

public void update(
byte)

public void update(
byte[]
int
int)

________________CLASS________________


public class org.bouncycastle.crypto.macs.CBCBlockCipherMac extends java.lang.Object implements org.bouncycastle.crypto.Mac

----------------FIELDS----------------

private byte[] buf

private int bufOff

private org.bouncycastle.crypto.BlockCipher cipher

private byte[] mac

private int macSize

private org.bouncycastle.crypto.paddings.BlockCipherPadding padding
----------------METHODS----------------

public void <init>(
org.bouncycastle.crypto.BlockCipher)

public void <init>(
org.bouncycastle.crypto.BlockCipher
int)

public void <init>(
org.bouncycastle.crypto.BlockCipher
int
org.bouncycastle.crypto.paddings.BlockCipherPadding)

public void <init>(
org.bouncycastle.crypto.BlockCipher
org.bouncycastle.crypto.paddings.BlockCipherPadding)

public int doFinal(
byte[]
int)

public java.lang.String getAlgorithmName()

public int getMacSize()

public void init(
org.bouncycastle.crypto.CipherParameters)

public void reset()

public void update(
byte)

public void update(
byte[]
int
int)

________________CLASS________________


public class org.bouncycastle.crypto.macs.CFBBlockCipherMac extends java.lang.Object implements org.bouncycastle.crypto.Mac

----------------FIELDS----------------

private byte[] buf

private int bufOff

private org.bouncycastle.crypto.macs.MacCFBBlockCipher cipher

private byte[] mac

private int macSize

private org.bouncycastle.crypto.paddings.BlockCipherPadding padding
----------------METHODS----------------

public void <init>(
org.bouncycastle.crypto.BlockCipher)

public void <init>(
org.bouncycastle.crypto.BlockCipher
int
int)

public void <init>(
org.bouncycastle.crypto.BlockCipher
int
int
org.bouncycastle.crypto.paddings.BlockCipherPadding)

public void <init>(
org.bouncycastle.crypto.BlockCipher
org.bouncycastle.crypto.paddings.BlockCipherPadding)

public int doFinal(
byte[]
int)

public java.lang.String getAlgorithmName()

public int getMacSize()

public void init(
org.bouncycastle.crypto.CipherParameters)

public void reset()

public void update(
byte)

public void update(
byte[]
int
int)

________________CLASS________________


public class org.bouncycastle.crypto.macs.HMac extends java.lang.Object implements org.bouncycastle.crypto.Mac

----------------FIELDS----------------

private static final byte IPAD

private static final byte OPAD

private static java.util.Hashtable blockLengths

private int blockLength

private org.bouncycastle.crypto.Digest digest

private int digestSize

private byte[] inputPad

private byte[] outputPad
----------------METHODS----------------

static void <clinit>()

public void <init>(
org.bouncycastle.crypto.Digest)

private void <init>(
org.bouncycastle.crypto.Digest
int)

private static int getByteLength(
org.bouncycastle.crypto.Digest)

public int doFinal(
byte[]
int)

public java.lang.String getAlgorithmName()

public int getMacSize()

public org.bouncycastle.crypto.Digest getUnderlyingDigest()

public void init(
org.bouncycastle.crypto.CipherParameters)

public void reset()

public void update(
byte)

public void update(
byte[]
int
int)

________________CLASS________________


public class org.bouncycastle.crypto.macs.ISO9797Alg3Mac extends java.lang.Object implements org.bouncycastle.crypto.Mac

----------------FIELDS----------------

private byte[] buf

private int bufOff

private org.bouncycastle.crypto.BlockCipher cipher

private org.bouncycastle.crypto.params.KeyParameter lastKey2

private org.bouncycastle.crypto.params.KeyParameter lastKey3

private byte[] mac

private int macSize

private org.bouncycastle.crypto.paddings.BlockCipherPadding padding
----------------METHODS----------------

public void <init>(
org.bouncycastle.crypto.BlockCipher)

public void <init>(
org.bouncycastle.crypto.BlockCipher
int)

public void <init>(
org.bouncycastle.crypto.BlockCipher
int
org.bouncycastle.crypto.paddings.BlockCipherPadding)

public void <init>(
org.bouncycastle.crypto.BlockCipher
org.bouncycastle.crypto.paddings.BlockCipherPadding)

public int doFinal(
byte[]
int)

public java.lang.String getAlgorithmName()

public int getMacSize()

public void init(
org.bouncycastle.crypto.CipherParameters)

public void reset()

public void update(
byte)

public void update(
byte[]
int
int)

________________CLASS________________


 class org.bouncycastle.crypto.macs.MacCFBBlockCipher extends java.lang.Object

----------------FIELDS----------------

private byte[] IV

private int blockSize

private byte[] cfbOutV

private byte[] cfbV

private org.bouncycastle.crypto.BlockCipher cipher
----------------METHODS----------------

public void <init>(
org.bouncycastle.crypto.BlockCipher
int)

public java.lang.String getAlgorithmName()

public int getBlockSize()

 void getMacBlock(
byte[])
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public void init(
org.bouncycastle.crypto.CipherParameters)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/DataLengthException;Ljava/lang/IllegalStateException; )
public int processBlock(
byte[]
int
byte[]
int)

public void reset()

________________CLASS________________


public class org.bouncycastle.crypto.macs.OldHMac extends java.lang.Object implements org.bouncycastle.crypto.Mac

----------------FIELDS----------------

private static final int BLOCK_LENGTH

private static final byte IPAD

private static final byte OPAD

private org.bouncycastle.crypto.Digest digest

private int digestSize

private byte[] inputPad

private byte[] outputPad
----------------METHODS----------------

public void <init>(
org.bouncycastle.crypto.Digest)

public int doFinal(
byte[]
int)

public java.lang.String getAlgorithmName()

public int getMacSize()

public org.bouncycastle.crypto.Digest getUnderlyingDigest()

public void init(
org.bouncycastle.crypto.CipherParameters)

public void reset()

public void update(
byte)

public void update(
byte[]
int
int)

________________CLASS________________


public class org.bouncycastle.crypto.modes.CBCBlockCipher extends java.lang.Object implements org.bouncycastle.crypto.BlockCipher

----------------FIELDS----------------

private byte[] IV

private int blockSize

private byte[] cbcNextV

private byte[] cbcV

private org.bouncycastle.crypto.BlockCipher cipher

private boolean encrypting
----------------METHODS----------------

public void <init>(
org.bouncycastle.crypto.BlockCipher)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/DataLengthException;Ljava/lang/IllegalStateException; )
private int decryptBlock(
byte[]
int
byte[]
int)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/DataLengthException;Ljava/lang/IllegalStateException; )
private int encryptBlock(
byte[]
int
byte[]
int)

public java.lang.String getAlgorithmName()

public int getBlockSize()

public org.bouncycastle.crypto.BlockCipher getUnderlyingCipher()
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public void init(
boolean
org.bouncycastle.crypto.CipherParameters)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/DataLengthException;Ljava/lang/IllegalStateException; )
public int processBlock(
byte[]
int
byte[]
int)

public void reset()

________________CLASS________________


public class org.bouncycastle.crypto.modes.CCMBlockCipher extends java.lang.Object

----------------FIELDS----------------

private int blockSize

private org.bouncycastle.crypto.BlockCipher cipher

private boolean forEncryption

private byte[] macBlock

private org.bouncycastle.crypto.params.CCMParameters params
----------------METHODS----------------

public void <init>(
org.bouncycastle.crypto.BlockCipher)

private boolean areEqual(
byte[]
byte[])

private int calculateMac(
byte[]
int
int
byte[])

public java.lang.String getAlgorithmName()

public byte[] getMac()

public org.bouncycastle.crypto.BlockCipher getUnderlyingCipher()
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public void init(
boolean
org.bouncycastle.crypto.CipherParameters)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalStateException;Lorg/bouncycastle/crypto/InvalidCipherTextException; )
public byte[] processPacket(
byte[]
int
int)

________________CLASS________________


public class org.bouncycastle.crypto.modes.CFBBlockCipher extends java.lang.Object implements org.bouncycastle.crypto.BlockCipher

----------------FIELDS----------------

private byte[] IV

private int blockSize

private byte[] cfbOutV

private byte[] cfbV

private org.bouncycastle.crypto.BlockCipher cipher

private boolean encrypting
----------------METHODS----------------

public void <init>(
org.bouncycastle.crypto.BlockCipher
int)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/DataLengthException;Ljava/lang/IllegalStateException; )
public int decryptBlock(
byte[]
int
byte[]
int)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/DataLengthException;Ljava/lang/IllegalStateException; )
public int encryptBlock(
byte[]
int
byte[]
int)

public java.lang.String getAlgorithmName()

public int getBlockSize()

public org.bouncycastle.crypto.BlockCipher getUnderlyingCipher()
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public void init(
boolean
org.bouncycastle.crypto.CipherParameters)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/DataLengthException;Ljava/lang/IllegalStateException; )
public int processBlock(
byte[]
int
byte[]
int)

public void reset()

________________CLASS________________


public class org.bouncycastle.crypto.modes.CTSBlockCipher extends org.bouncycastle.crypto.BufferedBlockCipher

----------------FIELDS----------------

private int blockSize
----------------METHODS----------------

public void <init>(
org.bouncycastle.crypto.BlockCipher)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/DataLengthException;Ljava/lang/IllegalStateException;Lorg/bouncycastle/crypto/InvalidCipherTextException; )
public int doFinal(
byte[]
int)

public int getOutputSize(
int)

public int getUpdateOutputSize(
int)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/DataLengthException;Ljava/lang/IllegalStateException; )
public int processByte(
byte
byte[]
int)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/DataLengthException;Ljava/lang/IllegalStateException; )
public int processBytes(
byte[]
int
int
byte[]
int)

________________CLASS________________


public class org.bouncycastle.crypto.modes.GOFBBlockCipher extends java.lang.Object implements org.bouncycastle.crypto.BlockCipher

----------------FIELDS----------------

static final int C1

static final int C2

private byte[] IV

 int N3

 int N4

private final int blockSize

private final org.bouncycastle.crypto.BlockCipher cipher

 boolean firstStep

private byte[] ofbOutV

private byte[] ofbV
----------------METHODS----------------

public void <init>(
org.bouncycastle.crypto.BlockCipher)

private int bytesToint(
byte[]
int)

private void intTobytes(
int
byte[]
int)

public java.lang.String getAlgorithmName()

public int getBlockSize()

public org.bouncycastle.crypto.BlockCipher getUnderlyingCipher()
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public void init(
boolean
org.bouncycastle.crypto.CipherParameters)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/DataLengthException;Ljava/lang/IllegalStateException; )
public int processBlock(
byte[]
int
byte[]
int)

public void reset()

________________CLASS________________


public class org.bouncycastle.crypto.modes.OFBBlockCipher extends java.lang.Object implements org.bouncycastle.crypto.BlockCipher

----------------FIELDS----------------

private byte[] IV

private final int blockSize

private final org.bouncycastle.crypto.BlockCipher cipher

private byte[] ofbOutV

private byte[] ofbV
----------------METHODS----------------

public void <init>(
org.bouncycastle.crypto.BlockCipher
int)

public java.lang.String getAlgorithmName()

public int getBlockSize()

public org.bouncycastle.crypto.BlockCipher getUnderlyingCipher()
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public void init(
boolean
org.bouncycastle.crypto.CipherParameters)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/DataLengthException;Ljava/lang/IllegalStateException; )
public int processBlock(
byte[]
int
byte[]
int)

public void reset()

________________CLASS________________


public class org.bouncycastle.crypto.modes.PaddedBlockCipher extends org.bouncycastle.crypto.BufferedBlockCipher

----------------FIELDS----------------
----------------METHODS----------------

public void <init>(
org.bouncycastle.crypto.BlockCipher)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/DataLengthException;Ljava/lang/IllegalStateException;Lorg/bouncycastle/crypto/InvalidCipherTextException; )
public int doFinal(
byte[]
int)

public int getOutputSize(
int)

public int getUpdateOutputSize(
int)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/DataLengthException;Ljava/lang/IllegalStateException; )
public int processByte(
byte
byte[]
int)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/DataLengthException;Ljava/lang/IllegalStateException; )
public int processBytes(
byte[]
int
int
byte[]
int)

________________CLASS________________


public class org.bouncycastle.crypto.modes.SICBlockCipher extends java.lang.Object implements org.bouncycastle.crypto.BlockCipher

----------------FIELDS----------------

private byte[] IV

private final int blockSize

private final org.bouncycastle.crypto.BlockCipher cipher

private byte[] counter

private byte[] counterOut
----------------METHODS----------------

public void <init>(
org.bouncycastle.crypto.BlockCipher)

public java.lang.String getAlgorithmName()

public int getBlockSize()

public org.bouncycastle.crypto.BlockCipher getUnderlyingCipher()
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public void init(
boolean
org.bouncycastle.crypto.CipherParameters)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/DataLengthException;Ljava/lang/IllegalStateException; )
public int processBlock(
byte[]
int
byte[]
int)

public void reset()

________________CLASS________________


public abstract interface class org.bouncycastle.crypto.paddings.BlockCipherPadding extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract int addPadding(
byte[]
int)

public abstract java.lang.String getPaddingName()
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public abstract void init(
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/InvalidCipherTextException; )
public abstract int padCount(
byte[])

________________CLASS________________


public class org.bouncycastle.crypto.paddings.ISO10126d2Padding extends java.lang.Object implements org.bouncycastle.crypto.paddings.BlockCipherPadding

----------------FIELDS----------------

 java.security.SecureRandom random
----------------METHODS----------------

public void <init>()

public int addPadding(
byte[]
int)

public java.lang.String getPaddingName()
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public void init(
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/InvalidCipherTextException; )
public int padCount(
byte[])

________________CLASS________________


public class org.bouncycastle.crypto.paddings.ISO7816d4Padding extends java.lang.Object implements org.bouncycastle.crypto.paddings.BlockCipherPadding

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public int addPadding(
byte[]
int)

public java.lang.String getPaddingName()
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public void init(
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/InvalidCipherTextException; )
public int padCount(
byte[])

________________CLASS________________


public class org.bouncycastle.crypto.paddings.PKCS7Padding extends java.lang.Object implements org.bouncycastle.crypto.paddings.BlockCipherPadding

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public int addPadding(
byte[]
int)

public java.lang.String getPaddingName()
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public void init(
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/InvalidCipherTextException; )
public int padCount(
byte[])

________________CLASS________________


public class org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher extends org.bouncycastle.crypto.BufferedBlockCipher

----------------FIELDS----------------

 org.bouncycastle.crypto.paddings.BlockCipherPadding padding
----------------METHODS----------------

public void <init>(
org.bouncycastle.crypto.BlockCipher)

public void <init>(
org.bouncycastle.crypto.BlockCipher
org.bouncycastle.crypto.paddings.BlockCipherPadding)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/DataLengthException;Ljava/lang/IllegalStateException;Lorg/bouncycastle/crypto/InvalidCipherTextException; )
public int doFinal(
byte[]
int)

public int getOutputSize(
int)

public int getUpdateOutputSize(
int)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public void init(
boolean
org.bouncycastle.crypto.CipherParameters)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/DataLengthException;Ljava/lang/IllegalStateException; )
public int processByte(
byte
byte[]
int)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/DataLengthException;Ljava/lang/IllegalStateException; )
public int processBytes(
byte[]
int
int
byte[]
int)

________________CLASS________________


public class org.bouncycastle.crypto.paddings.TBCPadding extends java.lang.Object implements org.bouncycastle.crypto.paddings.BlockCipherPadding

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public int addPadding(
byte[]
int)

public java.lang.String getPaddingName()
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public void init(
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/InvalidCipherTextException; )
public int padCount(
byte[])

________________CLASS________________


public class org.bouncycastle.crypto.paddings.X923Padding extends java.lang.Object implements org.bouncycastle.crypto.paddings.BlockCipherPadding

----------------FIELDS----------------

 java.security.SecureRandom random
----------------METHODS----------------

public void <init>()

public int addPadding(
byte[]
int)

public java.lang.String getPaddingName()
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public void init(
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/InvalidCipherTextException; )
public int padCount(
byte[])

________________CLASS________________


public class org.bouncycastle.crypto.paddings.ZeroBytePadding extends java.lang.Object implements org.bouncycastle.crypto.paddings.BlockCipherPadding

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public int addPadding(
byte[]
int)

public java.lang.String getPaddingName()
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public void init(
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/InvalidCipherTextException; )
public int padCount(
byte[])

________________CLASS________________


public class org.bouncycastle.crypto.params.AsymmetricKeyParameter extends java.lang.Object implements org.bouncycastle.crypto.CipherParameters

----------------FIELDS----------------

 boolean privateKey
----------------METHODS----------------

public void <init>(
boolean)

public boolean isPrivate()

________________CLASS________________


public class org.bouncycastle.crypto.params.CCMParameters extends java.lang.Object implements org.bouncycastle.crypto.CipherParameters

----------------FIELDS----------------

private byte[] associatedText

private org.bouncycastle.crypto.params.KeyParameter key

private int macSize

private byte[] nonce
----------------METHODS----------------

public void <init>(
org.bouncycastle.crypto.params.KeyParameter
int
byte[]
byte[])

public byte[] getAssociatedText()

public org.bouncycastle.crypto.params.KeyParameter getKey()

public int getMacSize()

public byte[] getNonce()

________________CLASS________________


public class org.bouncycastle.crypto.params.KeyParameter extends java.lang.Object implements org.bouncycastle.crypto.CipherParameters

----------------FIELDS----------------

private byte[] key
----------------METHODS----------------

public void <init>(
byte[])

public void <init>(
byte[]
int
int)

public byte[] getKey()

________________CLASS________________


public class org.bouncycastle.crypto.params.DESParameters extends org.bouncycastle.crypto.params.KeyParameter

----------------FIELDS----------------

public static final int DES_KEY_LENGTH

private static byte[] DES_weak_keys

private static final int N_DES_WEAK_KEYS
----------------METHODS----------------

static void <clinit>()

public void <init>(
byte[])

public static boolean isWeakKey(
byte[]
int)

public static void setOddParity(
byte[])

________________CLASS________________


public class org.bouncycastle.crypto.params.DESedeParameters extends org.bouncycastle.crypto.params.DESParameters

----------------FIELDS----------------

public static final int DES_EDE_KEY_LENGTH
----------------METHODS----------------

public void <init>(
byte[])

public static boolean isWeakKey(
byte[]
int)

public static boolean isWeakKey(
byte[]
int
int)

________________CLASS________________


public class org.bouncycastle.crypto.params.DHKeyGenerationParameters extends org.bouncycastle.crypto.KeyGenerationParameters

----------------FIELDS----------------

private org.bouncycastle.crypto.params.DHParameters params
----------------METHODS----------------

public void <init>(
java.security.SecureRandom
org.bouncycastle.crypto.params.DHParameters)

public org.bouncycastle.crypto.params.DHParameters getParameters()

________________CLASS________________


public class org.bouncycastle.crypto.params.DHKeyParameters extends org.bouncycastle.crypto.params.AsymmetricKeyParameter

----------------FIELDS----------------

private org.bouncycastle.crypto.params.DHParameters params
----------------METHODS----------------

protected void <init>(
boolean
org.bouncycastle.crypto.params.DHParameters)

public boolean equals(
java.lang.Object)

public org.bouncycastle.crypto.params.DHParameters getParameters()

public int hashCode()

________________CLASS________________


public class org.bouncycastle.crypto.params.DHParameters extends java.lang.Object implements org.bouncycastle.crypto.CipherParameters

----------------FIELDS----------------

private java.math.BigInteger g

private int j

private java.math.BigInteger p

private java.math.BigInteger q

private org.bouncycastle.crypto.params.DHValidationParameters validation
----------------METHODS----------------

public void <init>(
java.math.BigInteger
java.math.BigInteger)

public void <init>(
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger
int)

public void <init>(
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger
int
org.bouncycastle.crypto.params.DHValidationParameters)

public boolean equals(
java.lang.Object)

public java.math.BigInteger getG()

public int getJ()

public java.math.BigInteger getP()

public java.math.BigInteger getQ()

public org.bouncycastle.crypto.params.DHValidationParameters getValidationParameters()

public int hashCode()

________________CLASS________________


public class org.bouncycastle.crypto.params.DHPrivateKeyParameters extends org.bouncycastle.crypto.params.DHKeyParameters

----------------FIELDS----------------

private java.math.BigInteger x
----------------METHODS----------------

public void <init>(
java.math.BigInteger
org.bouncycastle.crypto.params.DHParameters)

public boolean equals(
java.lang.Object)

public java.math.BigInteger getX()

________________CLASS________________


public class org.bouncycastle.crypto.params.DHPublicKeyParameters extends org.bouncycastle.crypto.params.DHKeyParameters

----------------FIELDS----------------

private java.math.BigInteger y
----------------METHODS----------------

public void <init>(
java.math.BigInteger
org.bouncycastle.crypto.params.DHParameters)

public boolean equals(
java.lang.Object)

public java.math.BigInteger getY()

________________CLASS________________


public class org.bouncycastle.crypto.params.DHValidationParameters extends java.lang.Object

----------------FIELDS----------------

private int counter

private byte[] seed
----------------METHODS----------------

public void <init>(
byte[]
int)

public boolean equals(
java.lang.Object)

public int hashCode()

________________CLASS________________


public class org.bouncycastle.crypto.params.DSAKeyGenerationParameters extends org.bouncycastle.crypto.KeyGenerationParameters

----------------FIELDS----------------

private org.bouncycastle.crypto.params.DSAParameters params
----------------METHODS----------------

public void <init>(
java.security.SecureRandom
org.bouncycastle.crypto.params.DSAParameters)

public org.bouncycastle.crypto.params.DSAParameters getParameters()

________________CLASS________________


public class org.bouncycastle.crypto.params.DSAKeyParameters extends org.bouncycastle.crypto.params.AsymmetricKeyParameter

----------------FIELDS----------------

private org.bouncycastle.crypto.params.DSAParameters params
----------------METHODS----------------

public void <init>(
boolean
org.bouncycastle.crypto.params.DSAParameters)

public org.bouncycastle.crypto.params.DSAParameters getParameters()

________________CLASS________________


public class org.bouncycastle.crypto.params.DSAParameters extends java.lang.Object implements org.bouncycastle.crypto.CipherParameters

----------------FIELDS----------------

private java.math.BigInteger g

private java.math.BigInteger p

private java.math.BigInteger q

private org.bouncycastle.crypto.params.DSAValidationParameters validation
----------------METHODS----------------

public void <init>(
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger)

public void <init>(
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger
org.bouncycastle.crypto.params.DSAValidationParameters)

public boolean equals(
java.lang.Object)

public java.math.BigInteger getG()

public java.math.BigInteger getP()

public java.math.BigInteger getQ()

public org.bouncycastle.crypto.params.DSAValidationParameters getValidationParameters()

public int hashCode()

________________CLASS________________


public class org.bouncycastle.crypto.params.DSAPrivateKeyParameters extends org.bouncycastle.crypto.params.DSAKeyParameters

----------------FIELDS----------------

private java.math.BigInteger x
----------------METHODS----------------

public void <init>(
java.math.BigInteger
org.bouncycastle.crypto.params.DSAParameters)

public java.math.BigInteger getX()

________________CLASS________________


public class org.bouncycastle.crypto.params.DSAPublicKeyParameters extends org.bouncycastle.crypto.params.DSAKeyParameters

----------------FIELDS----------------

private java.math.BigInteger y
----------------METHODS----------------

public void <init>(
java.math.BigInteger
org.bouncycastle.crypto.params.DSAParameters)

public java.math.BigInteger getY()

________________CLASS________________


public class org.bouncycastle.crypto.params.DSAValidationParameters extends java.lang.Object

----------------FIELDS----------------

private int counter

private byte[] seed
----------------METHODS----------------

public void <init>(
byte[]
int)

public boolean equals(
java.lang.Object)

public int getCounter()

public byte[] getSeed()

________________CLASS________________


public class org.bouncycastle.crypto.params.IESParameters extends java.lang.Object implements org.bouncycastle.crypto.CipherParameters

----------------FIELDS----------------

private byte[] derivation

private byte[] encoding

private int macKeySize
----------------METHODS----------------

public void <init>(
byte[]
byte[]
int)

public byte[] getDerivationV()

public byte[] getEncodingV()

public int getMacKeySize()

________________CLASS________________


public class org.bouncycastle.crypto.params.IESWithCipherParameters extends org.bouncycastle.crypto.params.IESParameters

----------------FIELDS----------------

private int cipherKeySize
----------------METHODS----------------

public void <init>(
byte[]
byte[]
int
int)

public int getCipherKeySize()

________________CLASS________________


public class org.bouncycastle.crypto.params.ISO18033KDFParameters extends java.lang.Object implements org.bouncycastle.crypto.DerivationParameters

----------------FIELDS----------------

 byte[] seed
----------------METHODS----------------

public void <init>(
byte[])

public byte[] getSeed()

________________CLASS________________


public class org.bouncycastle.crypto.params.KDFParameters extends java.lang.Object implements org.bouncycastle.crypto.DerivationParameters

----------------FIELDS----------------

 byte[] iv

 byte[] shared
----------------METHODS----------------

public void <init>(
byte[]
byte[])

public byte[] getIV()

public byte[] getSharedSecret()

________________CLASS________________


public class org.bouncycastle.crypto.params.MGFParameters extends java.lang.Object implements org.bouncycastle.crypto.DerivationParameters

----------------FIELDS----------------

 byte[] seed
----------------METHODS----------------

public void <init>(
byte[])

public void <init>(
byte[]
int
int)

public byte[] getSeed()

________________CLASS________________


public class org.bouncycastle.crypto.params.ParametersWithIV extends java.lang.Object implements org.bouncycastle.crypto.CipherParameters

----------------FIELDS----------------

private byte[] iv

private org.bouncycastle.crypto.CipherParameters parameters
----------------METHODS----------------

public void <init>(
org.bouncycastle.crypto.CipherParameters
byte[])

public void <init>(
org.bouncycastle.crypto.CipherParameters
byte[]
int
int)

public byte[] getIV()

public org.bouncycastle.crypto.CipherParameters getParameters()

________________CLASS________________


public class org.bouncycastle.crypto.params.ParametersWithRandom extends java.lang.Object implements org.bouncycastle.crypto.CipherParameters

----------------FIELDS----------------

private org.bouncycastle.crypto.CipherParameters parameters

private java.security.SecureRandom random
----------------METHODS----------------

public void <init>(
org.bouncycastle.crypto.CipherParameters)

public void <init>(
org.bouncycastle.crypto.CipherParameters
java.security.SecureRandom)

public org.bouncycastle.crypto.CipherParameters getParameters()

public java.security.SecureRandom getRandom()

________________CLASS________________


public class org.bouncycastle.crypto.params.ParametersWithSBox extends java.lang.Object implements org.bouncycastle.crypto.CipherParameters

----------------FIELDS----------------

private org.bouncycastle.crypto.CipherParameters parameters

private byte[] sBox
----------------METHODS----------------

public void <init>(
org.bouncycastle.crypto.CipherParameters
byte[])

public org.bouncycastle.crypto.CipherParameters getParameters()

public byte[] getSBox()

________________CLASS________________


public class org.bouncycastle.crypto.params.ParametersWithSalt extends java.lang.Object implements org.bouncycastle.crypto.CipherParameters

----------------FIELDS----------------

private org.bouncycastle.crypto.CipherParameters parameters

private byte[] salt
----------------METHODS----------------

public void <init>(
org.bouncycastle.crypto.CipherParameters
byte[])

public void <init>(
org.bouncycastle.crypto.CipherParameters
byte[]
int
int)

public org.bouncycastle.crypto.CipherParameters getParameters()

public byte[] getSalt()

________________CLASS________________


public class org.bouncycastle.crypto.params.RC2Parameters extends java.lang.Object implements org.bouncycastle.crypto.CipherParameters

----------------FIELDS----------------

private int bits

private byte[] key
----------------METHODS----------------

public void <init>(
byte[])

public void <init>(
byte[]
int)

public int getEffectiveKeyBits()

public byte[] getKey()

________________CLASS________________


public class org.bouncycastle.crypto.params.RC5Parameters extends java.lang.Object implements org.bouncycastle.crypto.CipherParameters

----------------FIELDS----------------

private byte[] key

private int rounds
----------------METHODS----------------

public void <init>(
byte[]
int)

public byte[] getKey()

public int getRounds()

________________CLASS________________


public class org.bouncycastle.crypto.params.RSAKeyGenerationParameters extends org.bouncycastle.crypto.KeyGenerationParameters

----------------FIELDS----------------

private int certainty

private java.math.BigInteger publicExponent
----------------METHODS----------------

public void <init>(
java.math.BigInteger
java.security.SecureRandom
int
int)

public int getCertainty()

public java.math.BigInteger getPublicExponent()

________________CLASS________________


public class org.bouncycastle.crypto.params.RSAKeyParameters extends org.bouncycastle.crypto.params.AsymmetricKeyParameter

----------------FIELDS----------------

private java.math.BigInteger exponent

private java.math.BigInteger modulus
----------------METHODS----------------

public void <init>(
boolean
java.math.BigInteger
java.math.BigInteger)

public java.math.BigInteger getExponent()

public java.math.BigInteger getModulus()

________________CLASS________________


public class org.bouncycastle.crypto.params.RSAPrivateCrtKeyParameters extends org.bouncycastle.crypto.params.RSAKeyParameters

----------------FIELDS----------------

private java.math.BigInteger dP

private java.math.BigInteger dQ

private java.math.BigInteger e

private java.math.BigInteger p

private java.math.BigInteger q

private java.math.BigInteger qInv
----------------METHODS----------------

public void <init>(
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger
java.math.BigInteger)

public java.math.BigInteger getDP()

public java.math.BigInteger getDQ()

public java.math.BigInteger getP()

public java.math.BigInteger getPublicExponent()

public java.math.BigInteger getQ()

public java.math.BigInteger getQInv()

________________CLASS________________


public class org.bouncycastle.crypto.signers.DSASigner extends java.lang.Object implements org.bouncycastle.crypto.DSA

----------------FIELDS----------------

 org.bouncycastle.crypto.params.DSAKeyParameters key

 java.security.SecureRandom random
----------------METHODS----------------

public void <init>()

public java.math.BigInteger[] generateSignature(
byte[])

public void init(
boolean
org.bouncycastle.crypto.CipherParameters)

public boolean verifySignature(
byte[]
java.math.BigInteger
java.math.BigInteger)

________________CLASS________________


public class org.bouncycastle.crypto.signers.ISO9796d2PSSSigner extends java.lang.Object implements org.bouncycastle.crypto.SignerWithRecovery

----------------FIELDS----------------

public static final int TRAILER_IMPLICIT

public static final int TRAILER_RIPEMD128

public static final int TRAILER_RIPEMD160

public static final int TRAILER_SHA1

private byte[] block

private org.bouncycastle.crypto.AsymmetricBlockCipher cipher

private org.bouncycastle.crypto.Digest digest

private boolean fullMessage

private int hLen

private int keyBits

private byte[] mBuf

private int messageLength

private java.security.SecureRandom random

private byte[] recoveredMessage

private int saltLength

private byte[] standardSalt

private int trailer
----------------METHODS----------------

public void <init>(
org.bouncycastle.crypto.AsymmetricBlockCipher
org.bouncycastle.crypto.Digest
int)

public void <init>(
org.bouncycastle.crypto.AsymmetricBlockCipher
org.bouncycastle.crypto.Digest
int
boolean)

private void ItoOSP(
int
byte[])

private void LtoOSP(
long
byte[])

private void clearBlock(
byte[])

private boolean isSameAs(
byte[]
byte[])

private byte[] maskGeneratorFunction1(
byte[]
int
int
int)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/CryptoException; )
public byte[] generateSignature()

public byte[] getRecoveredMessage()

public boolean hasFullMessage()

public void init(
boolean
org.bouncycastle.crypto.CipherParameters)

public void reset()

public void update(
byte)

public void update(
byte[]
int
int)

public boolean verifySignature(
byte[])

________________CLASS________________


public class org.bouncycastle.crypto.signers.ISO9796d2Signer extends java.lang.Object implements org.bouncycastle.crypto.SignerWithRecovery

----------------FIELDS----------------

public static final int TRAILER_IMPLICIT

public static final int TRAILER_RIPEMD128

public static final int TRAILER_RIPEMD160

public static final int TRAILER_SHA1

private byte[] block

private org.bouncycastle.crypto.AsymmetricBlockCipher cipher

private org.bouncycastle.crypto.Digest digest

private boolean fullMessage

private int keyBits

private byte[] mBuf

private int messageLength

private byte[] recoveredMessage

private int trailer
----------------METHODS----------------

public void <init>(
org.bouncycastle.crypto.AsymmetricBlockCipher
org.bouncycastle.crypto.Digest)

public void <init>(
org.bouncycastle.crypto.AsymmetricBlockCipher
org.bouncycastle.crypto.Digest
boolean)

private void clearBlock(
byte[])

private boolean isSameAs(
byte[]
byte[])
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/CryptoException; )
public byte[] generateSignature()

public byte[] getRecoveredMessage()

public boolean hasFullMessage()

public void init(
boolean
org.bouncycastle.crypto.CipherParameters)

public void reset()

public void update(
byte)

public void update(
byte[]
int
int)

public boolean verifySignature(
byte[])

________________CLASS________________


public class org.bouncycastle.crypto.signers.PSSSigner extends java.lang.Object implements org.bouncycastle.crypto.Signer

----------------FIELDS----------------

public static final byte TRAILER_IMPLICIT

private byte[] block

private org.bouncycastle.crypto.AsymmetricBlockCipher cipher

private org.bouncycastle.crypto.Digest digest

private int emBits

private int hLen

private byte[] mDash

private java.security.SecureRandom random

private int sLen

private byte[] salt

private byte trailer
----------------METHODS----------------

public void <init>(
org.bouncycastle.crypto.AsymmetricBlockCipher
org.bouncycastle.crypto.Digest
int)

public void <init>(
org.bouncycastle.crypto.AsymmetricBlockCipher
org.bouncycastle.crypto.Digest
int
byte)

private void ItoOSP(
int
byte[])

private void clearBlock(
byte[])

private byte[] maskGeneratorFunction1(
byte[]
int
int
int)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/CryptoException;Lorg/bouncycastle/crypto/DataLengthException; )
public byte[] generateSignature()

public void init(
boolean
org.bouncycastle.crypto.CipherParameters)

public void reset()

public void update(
byte)

public void update(
byte[]
int
int)

public boolean verifySignature(
byte[])

________________CLASS________________


public class org.bouncycastle.crypto.util.PrivateKeyFactory extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static org.bouncycastle.crypto.params.AsymmetricKeyParameter createKey(
org.bouncycastle.asn1.pkcs.PrivateKeyInfo)

________________CLASS________________


public class org.bouncycastle.crypto.util.PublicKeyFactory extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static org.bouncycastle.crypto.params.AsymmetricKeyParameter createKey(
org.bouncycastle.asn1.x509.SubjectPublicKeyInfo)

________________CLASS________________


public class org.bouncycastle.i18n.LocalizedMessage extends java.lang.Object

----------------FIELDS----------------

protected java.lang.Object[] arguments

protected org.bouncycastle.i18n.filter.Filter filter

protected java.lang.Object[] filteredArguments

protected final java.lang.String id

protected final java.lang.String resource
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/lang/NullPointerException; )
public void <init>(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/lang/NullPointerException; )
public void <init>(
java.lang.String
java.lang.String
java.lang.Object[])

protected java.lang.String formatWithTimeZone(
java.lang.String
java.lang.Object[]
java.util.Locale
java.util.TimeZone)

public java.lang.Object[] getArguments()
@dalvik.annotation.Throws (value =Lorg/bouncycastle/i18n/MissingEntryException; )
public java.lang.String getEntry(
java.lang.String
java.util.Locale
java.util.TimeZone)

public org.bouncycastle.i18n.filter.Filter getFilter()

public java.lang.String getId()

public java.lang.String getResource()

public void setFilter(
org.bouncycastle.i18n.filter.Filter)

________________CLASS________________


public class org.bouncycastle.i18n.TextBundle extends org.bouncycastle.i18n.LocalizedMessage

----------------FIELDS----------------

public static final java.lang.String TEXT_ENTRY
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/lang/NullPointerException; )
public void <init>(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/lang/NullPointerException; )
public void <init>(
java.lang.String
java.lang.String
java.lang.Object[])
@dalvik.annotation.Throws (value =Lorg/bouncycastle/i18n/MissingEntryException; )
public java.lang.String getText(
java.util.Locale)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/i18n/MissingEntryException; )
public java.lang.String getText(
java.util.Locale
java.util.TimeZone)

________________CLASS________________


public class org.bouncycastle.i18n.MessageBundle extends org.bouncycastle.i18n.TextBundle

----------------FIELDS----------------

public static final java.lang.String TITLE_ENTRY
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/lang/NullPointerException; )
public void <init>(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/lang/NullPointerException; )
public void <init>(
java.lang.String
java.lang.String
java.lang.Object[])
@dalvik.annotation.Throws (value =Lorg/bouncycastle/i18n/MissingEntryException; )
public java.lang.String getTitle(
java.util.Locale)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/i18n/MissingEntryException; )
public java.lang.String getTitle(
java.util.Locale
java.util.TimeZone)

________________CLASS________________


public class org.bouncycastle.i18n.ErrorBundle extends org.bouncycastle.i18n.MessageBundle

----------------FIELDS----------------

public static final java.lang.String DETAIL_ENTRY

public static final java.lang.String SUMMARY_ENTRY
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/lang/NullPointerException; )
public void <init>(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/lang/NullPointerException; )
public void <init>(
java.lang.String
java.lang.String
java.lang.Object[])
@dalvik.annotation.Throws (value =Lorg/bouncycastle/i18n/MissingEntryException; )
public java.lang.String getDetail(
java.util.Locale)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/i18n/MissingEntryException; )
public java.lang.String getDetail(
java.util.Locale
java.util.TimeZone)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/i18n/MissingEntryException; )
public java.lang.String getSummary(
java.util.Locale)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/i18n/MissingEntryException; )
public java.lang.String getSummary(
java.util.Locale
java.util.TimeZone)

________________CLASS________________


public class org.bouncycastle.i18n.LocalizedException extends java.lang.Exception

----------------FIELDS----------------

private java.lang.Throwable cause

protected org.bouncycastle.i18n.ErrorBundle message
----------------METHODS----------------

public void <init>(
org.bouncycastle.i18n.ErrorBundle)

public void <init>(
org.bouncycastle.i18n.ErrorBundle
java.lang.Throwable)

public java.lang.Throwable getCause()

public org.bouncycastle.i18n.ErrorBundle getErrorMessage()

________________CLASS________________


public class org.bouncycastle.i18n.MissingEntryException extends java.lang.RuntimeException

----------------FIELDS----------------

protected final java.lang.String key

protected final java.lang.String resource
----------------METHODS----------------

public void <init>(
java.lang.String
java.lang.String
java.lang.String)

public java.lang.String getKey()

public java.lang.String getResource()

________________CLASS________________


public abstract interface class org.bouncycastle.i18n.filter.Filter extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.lang.String doFilter(
java.lang.String)

________________CLASS________________


public class org.bouncycastle.i18n.filter.HTMLFilter extends java.lang.Object implements org.bouncycastle.i18n.filter.Filter

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public java.lang.String doFilter(
java.lang.String)

________________CLASS________________


public class org.bouncycastle.i18n.filter.SQLFilter extends java.lang.Object implements org.bouncycastle.i18n.filter.Filter

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public java.lang.String doFilter(
java.lang.String)

________________CLASS________________


public class org.bouncycastle.i18n.filter.UntrustedInput extends java.lang.Object

----------------FIELDS----------------

protected java.lang.Object input
----------------METHODS----------------

public void <init>(
java.lang.Object)

public java.lang.Object getInput()

public java.lang.String getString()

public java.lang.String toString()

________________CLASS________________


public class org.bouncycastle.jce.PKCS10CertificationRequest extends org.bouncycastle.asn1.pkcs.CertificationRequest

----------------FIELDS----------------

private static java.util.Hashtable algorithms

private static java.util.Hashtable keyAlgorithms

private static java.util.Set noParams

private static java.util.Hashtable oids
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/NoSuchProviderException;Ljava/security/InvalidKeyException;Ljava/security/SignatureException; )
public void <init>(
java.lang.String
javax.security.auth.x500.X500Principal
java.security.PublicKey
org.bouncycastle.asn1.ASN1Set
java.security.PrivateKey)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/NoSuchProviderException;Ljava/security/InvalidKeyException;Ljava/security/SignatureException; )
public void <init>(
java.lang.String
javax.security.auth.x500.X500Principal
java.security.PublicKey
org.bouncycastle.asn1.ASN1Set
java.security.PrivateKey
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/NoSuchProviderException;Ljava/security/InvalidKeyException;Ljava/security/SignatureException; )
public void <init>(
java.lang.String
org.bouncycastle.asn1.x509.X509Name
java.security.PublicKey
org.bouncycastle.asn1.ASN1Set
java.security.PrivateKey)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/NoSuchProviderException;Ljava/security/InvalidKeyException;Ljava/security/SignatureException; )
public void <init>(
java.lang.String
org.bouncycastle.asn1.x509.X509Name
java.security.PublicKey
org.bouncycastle.asn1.ASN1Set
java.security.PrivateKey
java.lang.String)

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
byte[])

private static org.bouncycastle.asn1.x509.X509Name convertName(
javax.security.auth.x500.X500Principal)

private static org.bouncycastle.asn1.ASN1Sequence toDERSequence(
byte[])

public byte[] getEncoded()
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/NoSuchProviderException;Ljava/security/InvalidKeyException; )
public java.security.PublicKey getPublicKey()
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/NoSuchProviderException;Ljava/security/InvalidKeyException; )
public java.security.PublicKey getPublicKey(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/NoSuchProviderException;Ljava/security/InvalidKeyException;Ljava/security/SignatureException; )
public boolean verify()
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/NoSuchProviderException;Ljava/security/InvalidKeyException;Ljava/security/SignatureException; )
public boolean verify(
java.lang.String)

________________CLASS________________


public class org.bouncycastle.jce.PKCS7SignedData extends java.lang.Object implements org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers

----------------FIELDS----------------

private final java.lang.String ID_DSA

private final java.lang.String ID_MD2

private final java.lang.String ID_MD5

private final java.lang.String ID_PKCS7_DATA

private final java.lang.String ID_PKCS7_SIGNED_DATA

private final java.lang.String ID_RSA

private final java.lang.String ID_SHA1

private java.util.Collection certs

private java.util.Collection crls

private byte[] digest

private java.lang.String digestAlgorithm

private java.lang.String digestEncryptionAlgorithm

private java.util.Set digestalgos

private transient java.security.PrivateKey privKey

private java.security.Signature sig

private java.security.cert.X509Certificate signCert

private int signerversion

private int version
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/lang/SecurityException;Ljava/security/InvalidKeyException;Ljava/security/NoSuchProviderException;Ljava/security/NoSuchAlgorithmException; )
public void <init>(
java.security.PrivateKey
java.security.cert.Certificate[]
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/lang/SecurityException;Ljava/security/InvalidKeyException;Ljava/security/NoSuchProviderException;Ljava/security/NoSuchAlgorithmException; )
public void <init>(
java.security.PrivateKey
java.security.cert.Certificate[]
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/lang/SecurityException;Ljava/security/InvalidKeyException;Ljava/security/NoSuchProviderException;Ljava/security/NoSuchAlgorithmException; )
public void <init>(
java.security.PrivateKey
java.security.cert.Certificate[]
java.security.cert.CRL[]
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/lang/SecurityException;Ljava/security/cert/CRLException;Ljava/security/InvalidKeyException;Ljava/security/NoSuchProviderException;Ljava/security/NoSuchAlgorithmException; )
public void <init>(
byte[])
@dalvik.annotation.Throws (value =Ljava/lang/SecurityException;Ljava/security/cert/CRLException;Ljava/security/InvalidKeyException;Ljava/security/NoSuchProviderException;Ljava/security/NoSuchAlgorithmException; )
public void <init>(
byte[]
java.lang.String)

private org.bouncycastle.asn1.DERObject getIssuer(
byte[])

public java.util.Collection getCRLs()

public java.security.cert.Certificate[] getCertificates()

public java.lang.String getDigestAlgorithm()

public byte[] getEncoded()

public java.security.cert.X509Certificate getSigningCertificate()

public int getSigningInfoVersion()

public int getVersion()

public void reset()
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
public void update(
byte)
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
public void update(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
public boolean verify()

________________CLASS________________


public class org.bouncycastle.jce.PrincipalUtil extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/security/cert/CRLException; )
public static org.bouncycastle.jce.X509Principal getIssuerX509Principal(
java.security.cert.X509CRL)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateEncodingException; )
public static org.bouncycastle.jce.X509Principal getIssuerX509Principal(
java.security.cert.X509Certificate)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateEncodingException; )
public static org.bouncycastle.jce.X509Principal getSubjectX509Principal(
java.security.cert.X509Certificate)

________________CLASS________________


public class org.bouncycastle.jce.X509KeyUsage extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

public static final int cRLSign

public static final int dataEncipherment

public static final int decipherOnly

public static final int digitalSignature

public static final int encipherOnly

public static final int keyAgreement

public static final int keyCertSign

public static final int keyEncipherment

public static final int nonRepudiation

private int usage
----------------METHODS----------------

public void <init>(
int)

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public class org.bouncycastle.jce.X509Principal extends org.bouncycastle.asn1.x509.X509Name implements java.security.Principal

----------------FIELDS----------------
----------------METHODS----------------

public void <init>(
java.lang.String)

public void <init>(
java.util.Hashtable)

public void <init>(
java.util.Vector
java.util.Hashtable)

public void <init>(
java.util.Vector
java.util.Vector)

public void <init>(
org.bouncycastle.asn1.x509.X509Name)

public void <init>(
boolean
java.lang.String)

public void <init>(
boolean
java.util.Hashtable
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private static org.bouncycastle.asn1.ASN1Sequence readSequence(
org.bouncycastle.asn1.ASN1InputStream)

public byte[] getEncoded()

public java.lang.String getName()

________________CLASS________________


public class org.bouncycastle.jce.X509V1CertificateGenerator extends java.lang.Object

----------------FIELDS----------------

private static java.util.Hashtable algorithms

private org.bouncycastle.asn1.x509.AlgorithmIdentifier sigAlgId

private org.bouncycastle.asn1.DERObjectIdentifier sigOID

private java.lang.String signatureAlgorithm

private org.bouncycastle.asn1.x509.V1TBSCertificateGenerator tbsGen
----------------METHODS----------------

static void <clinit>()

public void <init>()
@dalvik.annotation.Throws (value =Ljava/lang/SecurityException;Ljava/security/SignatureException;Ljava/security/InvalidKeyException; )
public java.security.cert.X509Certificate generateX509Certificate(
java.security.PrivateKey)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchProviderException;Ljava/lang/SecurityException;Ljava/security/SignatureException;Ljava/security/InvalidKeyException; )
public java.security.cert.X509Certificate generateX509Certificate(
java.security.PrivateKey
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchProviderException;Ljava/lang/SecurityException;Ljava/security/SignatureException;Ljava/security/InvalidKeyException; )
public java.security.cert.X509Certificate generateX509Certificate(
java.security.PrivateKey
java.lang.String
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/lang/SecurityException;Ljava/security/SignatureException;Ljava/security/InvalidKeyException; )
public java.security.cert.X509Certificate generateX509Certificate(
java.security.PrivateKey
java.security.SecureRandom)

public void reset()

public void setIssuerDN(
org.bouncycastle.asn1.x509.X509Name)

public void setNotAfter(
java.util.Date)

public void setNotBefore(
java.util.Date)

public void setPublicKey(
java.security.PublicKey)

public void setSerialNumber(
java.math.BigInteger)

public void setSignatureAlgorithm(
java.lang.String)

public void setSubjectDN(
org.bouncycastle.asn1.x509.X509Name)

________________CLASS________________


public class org.bouncycastle.jce.X509V2CRLGenerator extends java.lang.Object

----------------FIELDS----------------

private static java.util.Hashtable algorithms

private java.text.SimpleDateFormat dateF

private java.util.Vector extOrdering

private java.util.Hashtable extensions

private org.bouncycastle.asn1.x509.AlgorithmIdentifier sigAlgId

private org.bouncycastle.asn1.DERObjectIdentifier sigOID

private java.lang.String signatureAlgorithm

private org.bouncycastle.asn1.x509.V2TBSCertListGenerator tbsGen

private java.util.SimpleTimeZone tz
----------------METHODS----------------

static void <clinit>()

public void <init>()

public void addCRLEntry(
java.math.BigInteger
java.util.Date
int)

public void addExtension(
java.lang.String
boolean
org.bouncycastle.asn1.DEREncodable)

public void addExtension(
java.lang.String
boolean
byte[])

public void addExtension(
org.bouncycastle.asn1.DERObjectIdentifier
boolean
org.bouncycastle.asn1.DEREncodable)

public void addExtension(
org.bouncycastle.asn1.DERObjectIdentifier
boolean
byte[])
@dalvik.annotation.Throws (value =Ljava/lang/SecurityException;Ljava/security/SignatureException;Ljava/security/InvalidKeyException; )
public java.security.cert.X509CRL generateX509CRL(
java.security.PrivateKey)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchProviderException;Ljava/lang/SecurityException;Ljava/security/SignatureException;Ljava/security/InvalidKeyException; )
public java.security.cert.X509CRL generateX509CRL(
java.security.PrivateKey
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchProviderException;Ljava/lang/SecurityException;Ljava/security/SignatureException;Ljava/security/InvalidKeyException; )
public java.security.cert.X509CRL generateX509CRL(
java.security.PrivateKey
java.lang.String
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/lang/SecurityException;Ljava/security/SignatureException;Ljava/security/InvalidKeyException; )
public java.security.cert.X509CRL generateX509CRL(
java.security.PrivateKey
java.security.SecureRandom)

public void reset()

public void setIssuerDN(
org.bouncycastle.asn1.x509.X509Name)

public void setNextUpdate(
java.util.Date)

public void setSignatureAlgorithm(
java.lang.String)

public void setThisUpdate(
java.util.Date)

________________CLASS________________


public class org.bouncycastle.jce.X509V3CertificateGenerator extends java.lang.Object

----------------FIELDS----------------

private static java.util.Hashtable algorithms

private java.util.Vector extOrdering

private java.util.Hashtable extensions

private org.bouncycastle.asn1.x509.AlgorithmIdentifier sigAlgId

private org.bouncycastle.asn1.DERObjectIdentifier sigOID

private java.lang.String signatureAlgorithm

private org.bouncycastle.asn1.x509.V3TBSCertificateGenerator tbsGen
----------------METHODS----------------

static void <clinit>()

public void <init>()

public void addExtension(
java.lang.String
boolean
org.bouncycastle.asn1.DEREncodable)

public void addExtension(
java.lang.String
boolean
byte[])

public void addExtension(
org.bouncycastle.asn1.DERObjectIdentifier
boolean
org.bouncycastle.asn1.DEREncodable)

public void addExtension(
org.bouncycastle.asn1.DERObjectIdentifier
boolean
byte[])
@dalvik.annotation.Throws (value =Ljava/lang/SecurityException;Ljava/security/SignatureException;Ljava/security/InvalidKeyException; )
public java.security.cert.X509Certificate generateX509Certificate(
java.security.PrivateKey)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchProviderException;Ljava/lang/SecurityException;Ljava/security/SignatureException;Ljava/security/InvalidKeyException; )
public java.security.cert.X509Certificate generateX509Certificate(
java.security.PrivateKey
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchProviderException;Ljava/lang/SecurityException;Ljava/security/SignatureException;Ljava/security/InvalidKeyException; )
public java.security.cert.X509Certificate generateX509Certificate(
java.security.PrivateKey
java.lang.String
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/lang/SecurityException;Ljava/security/SignatureException;Ljava/security/InvalidKeyException; )
public java.security.cert.X509Certificate generateX509Certificate(
java.security.PrivateKey
java.security.SecureRandom)

public void reset()

public void setIssuerDN(
org.bouncycastle.asn1.x509.X509Name)

public void setNotAfter(
java.util.Date)

public void setNotBefore(
java.util.Date)

public void setPublicKey(
java.security.PublicKey)

public void setSerialNumber(
java.math.BigInteger)

public void setSignatureAlgorithm(
java.lang.String)

public void setSubjectDN(
org.bouncycastle.asn1.x509.X509Name)

________________CLASS________________


public abstract interface class org.bouncycastle.jce.interfaces.BCKeyStore extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract void setRandom(
java.security.SecureRandom)

________________CLASS________________


public abstract interface class org.bouncycastle.jce.interfaces.IESKey extends java.lang.Object implements java.security.Key

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.security.PrivateKey getPrivate()

public abstract java.security.PublicKey getPublic()

________________CLASS________________


public abstract interface class org.bouncycastle.jce.interfaces.PKCS12BagAttributeCarrier extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract org.bouncycastle.asn1.DEREncodable getBagAttribute(
org.bouncycastle.asn1.DERObjectIdentifier)

public abstract java.util.Enumeration getBagAttributeKeys()

public abstract void setBagAttribute(
org.bouncycastle.asn1.DERObjectIdentifier
org.bouncycastle.asn1.DEREncodable)

________________CLASS________________


public class org.bouncycastle.jce.netscape.NetscapeCertRequest extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 java.lang.String challenge

 org.bouncycastle.asn1.DERBitString content

 org.bouncycastle.asn1.x509.AlgorithmIdentifier keyAlg

 java.security.PublicKey pubkey

 org.bouncycastle.asn1.x509.AlgorithmIdentifier sigAlg

 byte[] sigBits
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/spec/InvalidKeySpecException;Ljava/security/NoSuchProviderException; )
public void <init>(
java.lang.String
org.bouncycastle.asn1.x509.AlgorithmIdentifier
java.security.PublicKey)

public void <init>(
org.bouncycastle.asn1.ASN1Sequence)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
byte[])
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/spec/InvalidKeySpecException;Ljava/security/NoSuchProviderException; )
private org.bouncycastle.asn1.DERObject getKeySpec()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private static org.bouncycastle.asn1.ASN1Sequence getReq(
byte[])

public java.lang.String getChallenge()

public org.bouncycastle.asn1.x509.AlgorithmIdentifier getKeyAlgorithm()

public java.security.PublicKey getPublicKey()

public org.bouncycastle.asn1.x509.AlgorithmIdentifier getSigningAlgorithm()

public void setChallenge(
java.lang.String)

public void setKeyAlgorithm(
org.bouncycastle.asn1.x509.AlgorithmIdentifier)

public void setPublicKey(
java.security.PublicKey)

public void setSigningAlgorithm(
org.bouncycastle.asn1.x509.AlgorithmIdentifier)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/InvalidKeyException;Ljava/security/SignatureException;Ljava/security/NoSuchProviderException;Ljava/security/spec/InvalidKeySpecException; )
public void sign(
java.security.PrivateKey)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/InvalidKeyException;Ljava/security/SignatureException;Ljava/security/NoSuchProviderException;Ljava/security/spec/InvalidKeySpecException; )
public void sign(
java.security.PrivateKey
java.security.SecureRandom)

public org.bouncycastle.asn1.DERObject toASN1Object()
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/InvalidKeyException;Ljava/security/SignatureException;Ljava/security/NoSuchProviderException; )
public boolean verify(
java.lang.String)

________________CLASS________________


public class org.bouncycastle.jce.provider.AnnotatedException extends java.lang.Exception

----------------FIELDS----------------

private java.lang.Exception _underlyingException
----------------METHODS----------------

 void <init>(
java.lang.String)

 void <init>(
java.lang.String
java.lang.Exception)

public java.lang.Throwable getCause()

 java.lang.Exception getUnderlyingException()

________________CLASS________________


public final class org.bouncycastle.jce.provider.BouncyCastleProvider extends java.security.Provider

----------------FIELDS----------------

public static java.lang.String PROVIDER_NAME

private static java.lang.String info
----------------METHODS----------------

static void <clinit>()

public void <init>()

private void addHMACAlgorithm(
java.lang.String
java.lang.String
java.lang.String)

private void addHMACAlias(
java.lang.String
org.bouncycastle.asn1.DERObjectIdentifier)

private void addMacAlgorithms()

private void addMessageDigestAlgorithms()

private void addSignatureAlgorithm(
java.lang.String
java.lang.String
java.lang.String
org.bouncycastle.asn1.DERObjectIdentifier)

private void addSignatureAlgorithms()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/bouncycastle/jce/provider/BrokenPBE$Util; )
public abstract interface class org.bouncycastle.jce.provider.BrokenPBE extends java.lang.Object

----------------FIELDS----------------

public static final int MD5

public static final int OLD_PKCS12

public static final int PKCS12

public static final int PKCS5S1

public static final int PKCS5S2

public static final int RIPEMD160

public static final int SHA1
----------------METHODS----------------

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/bouncycastle/jce/provider/BrokenJCEBlockCipher$BrokePBEWithSHAAndDES2Key;Lorg/bouncycastle/jce/provider/BrokenJCEBlockCipher$OldPBEWithSHAAndDES3Key;Lorg/bouncycastle/jce/provider/BrokenJCEBlockCipher$BrokePBEWithSHAAndDES3Key;Lorg/bouncycastle/jce/provider/BrokenJCEBlockCipher$BrokePBEWithSHA1AndDES;Lorg/bouncycastle/jce/provider/BrokenJCEBlockCipher$BrokePBEWithMD5AndDES; )
public class org.bouncycastle.jce.provider.BrokenJCEBlockCipher extends java.lang.Object implements org.bouncycastle.jce.provider.BrokenPBE

----------------FIELDS----------------

private java.lang.Class[] availableSpecs

private org.bouncycastle.crypto.BufferedBlockCipher cipher

private java.security.AlgorithmParameters engineParams

private int ivLength

private org.bouncycastle.crypto.params.ParametersWithIV ivParam

private int pbeHash

private int pbeIvSize

private int pbeKeySize

private int pbeType
----------------METHODS----------------

protected void <init>(
org.bouncycastle.crypto.BlockCipher)

protected void <init>(
org.bouncycastle.crypto.BlockCipher
int
int
int
int)
@dalvik.annotation.Throws (value =Ljavax/crypto/IllegalBlockSizeException;Ljavax/crypto/BadPaddingException; )
protected int engineDoFinal(
byte[]
int
int
byte[]
int)
@dalvik.annotation.Throws (value =Ljavax/crypto/IllegalBlockSizeException;Ljavax/crypto/BadPaddingException; )
protected byte[] engineDoFinal(
byte[]
int
int)

protected int engineGetBlockSize()

protected byte[] engineGetIV()

protected int engineGetKeySize(
java.security.Key)

protected int engineGetOutputSize(
int)

protected java.security.AlgorithmParameters engineGetParameters()
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljava/security/InvalidAlgorithmParameterException; )
protected void engineInit(
int
java.security.Key
java.security.AlgorithmParameters
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
protected void engineInit(
int
java.security.Key
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljava/security/InvalidAlgorithmParameterException; )
protected void engineInit(
int
java.security.Key
java.security.spec.AlgorithmParameterSpec
java.security.SecureRandom)

protected void engineSetMode(
java.lang.String)
@dalvik.annotation.Throws (value =Ljavax/crypto/NoSuchPaddingException; )
protected void engineSetPadding(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
protected java.security.Key engineUnwrap(
byte[]
java.lang.String
int)

protected int engineUpdate(
byte[]
int
int
byte[]
int)

protected byte[] engineUpdate(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljavax/crypto/IllegalBlockSizeException;Ljava/security/InvalidKeyException; )
protected byte[] engineWrap(
java.security.Key)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/BrokenJCEBlockCipher; )
@dalvik.annotation.InnerClass (accessFlags =9 name =BrokePBEWithMD5AndDES )
public class org.bouncycastle.jce.provider.BrokenJCEBlockCipher$BrokePBEWithMD5AndDES extends org.bouncycastle.jce.provider.BrokenJCEBlockCipher

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/BrokenJCEBlockCipher; )
@dalvik.annotation.InnerClass (accessFlags =9 name =BrokePBEWithSHA1AndDES )
public class org.bouncycastle.jce.provider.BrokenJCEBlockCipher$BrokePBEWithSHA1AndDES extends org.bouncycastle.jce.provider.BrokenJCEBlockCipher

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/BrokenJCEBlockCipher; )
@dalvik.annotation.InnerClass (accessFlags =9 name =BrokePBEWithSHAAndDES2Key )
public class org.bouncycastle.jce.provider.BrokenJCEBlockCipher$BrokePBEWithSHAAndDES2Key extends org.bouncycastle.jce.provider.BrokenJCEBlockCipher

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =BrokePBEWithSHAAndDES3Key )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/BrokenJCEBlockCipher; )
public class org.bouncycastle.jce.provider.BrokenJCEBlockCipher$BrokePBEWithSHAAndDES3Key extends org.bouncycastle.jce.provider.BrokenJCEBlockCipher

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/BrokenJCEBlockCipher; )
@dalvik.annotation.InnerClass (accessFlags =9 name =OldPBEWithSHAAndDES3Key )
public class org.bouncycastle.jce.provider.BrokenJCEBlockCipher$OldPBEWithSHAAndDES3Key extends org.bouncycastle.jce.provider.BrokenJCEBlockCipher

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________


public class org.bouncycastle.jce.provider.BrokenKDF2BytesGenerator extends java.lang.Object implements org.bouncycastle.crypto.DerivationFunction

----------------FIELDS----------------

private org.bouncycastle.crypto.Digest digest

private byte[] iv

private byte[] shared
----------------METHODS----------------

public void <init>(
org.bouncycastle.crypto.Digest)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/crypto/DataLengthException;Ljava/lang/IllegalArgumentException; )
public int generateBytes(
byte[]
int
int)

public org.bouncycastle.crypto.Digest getDigest()

public void init(
org.bouncycastle.crypto.DerivationParameters)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =Util )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/BrokenPBE; )
public class org.bouncycastle.jce.provider.BrokenPBE$Util extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

private static org.bouncycastle.crypto.PBEParametersGenerator makePBEGenerator(
int
int)

static org.bouncycastle.crypto.CipherParameters makePBEMacParameters(
org.bouncycastle.jce.provider.JCEPBEKey
java.security.spec.AlgorithmParameterSpec
int
int
int)

static org.bouncycastle.crypto.CipherParameters makePBEParameters(
org.bouncycastle.jce.provider.JCEPBEKey
java.security.spec.AlgorithmParameterSpec
int
int
java.lang.String
int
int)

private static void setOddParity(
byte[])

________________CLASS________________


public class org.bouncycastle.jce.provider.CertPathValidatorUtilities extends java.lang.Object

----------------FIELDS----------------

protected static final java.lang.String ANY_POLICY

protected static final java.lang.String BASIC_CONSTRAINTS

protected static final java.lang.String CERTIFICATE_POLICIES

protected static final java.lang.String CRL_NUMBER

protected static final int CRL_SIGN

protected static final java.lang.String DELTA_CRL_INDICATOR

protected static final java.lang.String INHIBIT_ANY_POLICY

protected static final java.lang.String ISSUING_DISTRIBUTION_POINT

protected static final int KEY_CERT_SIGN

protected static final java.lang.String KEY_USAGE

protected static final java.lang.String NAME_CONSTRAINTS

protected static final java.lang.String POLICY_CONSTRAINTS

protected static final java.lang.String POLICY_MAPPINGS

protected static final java.lang.String SUBJECT_ALTERNATIVE_NAME

protected static final java.lang.String[] crlReasons
----------------METHODS----------------

static void <clinit>()

public void <init>()
@dalvik.annotation.Throws (value =Ljava/security/cert/CertPathValidatorException; )
protected static void checkExcludedDN(
java.util.Set
org.bouncycastle.asn1.ASN1Sequence)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertPathValidatorException; )
protected static void checkExcludedEmail(
java.util.Set
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertPathValidatorException; )
protected static void checkExcludedIP(
java.util.Set
byte[])
@dalvik.annotation.Throws (value =Ljava/security/cert/CertPathValidatorException; )
protected static void checkPermittedDN(
java.util.Set
org.bouncycastle.asn1.ASN1Sequence)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertPathValidatorException; )
protected static void checkPermittedEmail(
java.util.Set
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertPathValidatorException; )
protected static void checkPermittedIP(
java.util.Set
byte[])
@dalvik.annotation.Throws (value =Lorg/bouncycastle/jce/provider/AnnotatedException; )
protected static final java.util.Collection findCRLs(
java.security.cert.X509CRLSelector
java.util.List)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertPathValidatorException; )
protected static final java.security.cert.TrustAnchor findTrustAnchor(
java.security.cert.X509Certificate
java.security.cert.CertPath
int
java.util.Set)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertPathValidatorException; )
protected static org.bouncycastle.asn1.x509.AlgorithmIdentifier getAlgorithmIdentifier(
java.security.PublicKey)

protected static javax.security.auth.x500.X500Principal getEncodedIssuerPrincipal(
java.security.cert.X509Certificate)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/jce/provider/AnnotatedException; )
protected static org.bouncycastle.asn1.DERObject getExtensionValue(
java.security.cert.X509Extension
java.lang.String)

protected static javax.security.auth.x500.X500Principal getIssuerPrincipal(
java.security.cert.X509CRL)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/jce/provider/AnnotatedException; )
private static org.bouncycastle.asn1.DERObject getObject(
java.lang.String
byte[])
@dalvik.annotation.Throws (value =Ljava/security/cert/CertPathValidatorException; )
protected static final java.util.Set getQualifierSet(
org.bouncycastle.asn1.ASN1Sequence)

protected static javax.security.auth.x500.X500Principal getSubjectPrincipal(
java.security.cert.X509Certificate)

protected static java.util.Date getValidDate(
java.security.cert.PKIXParameters)

protected static java.util.Set intersectDN(
java.util.Set
org.bouncycastle.asn1.ASN1Sequence)

protected static java.util.Set intersectEmail(
java.util.Set
java.lang.String)

protected static java.util.Set intersectIP(
java.util.Set
byte[])

protected static boolean isAnyPolicy(
java.util.Set)

protected static boolean isSelfIssued(
java.security.cert.X509Certificate)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/jce/provider/AnnotatedException;Ljava/security/cert/CertPathValidatorException; )
protected static void prepareNextCertB1(
int
java.util.List[]
java.lang.String
java.util.Map
java.security.cert.X509Certificate)

protected static org.bouncycastle.jce.provider.PKIXPolicyNode prepareNextCertB2(
int
java.util.List[]
java.lang.String
org.bouncycastle.jce.provider.PKIXPolicyNode)

protected static boolean processCertD1i(
int
java.util.List[]
org.bouncycastle.asn1.DERObjectIdentifier
java.util.Set)

protected static void processCertD1ii(
int
java.util.List[]
org.bouncycastle.asn1.DERObjectIdentifier
java.util.Set)

protected static org.bouncycastle.jce.provider.PKIXPolicyNode removePolicyNode(
org.bouncycastle.jce.provider.PKIXPolicyNode
java.util.List[]
org.bouncycastle.jce.provider.PKIXPolicyNode)

private static void removePolicyNodeRecurse(
java.util.List[]
org.bouncycastle.jce.provider.PKIXPolicyNode)

protected static java.util.Set unionDN(
java.util.Set
org.bouncycastle.asn1.ASN1Sequence)

protected static java.util.Set unionEmail(
java.util.Set
java.lang.String)

protected static java.util.Set unionIP(
java.util.Set
byte[])

private static boolean withinDNSubtree(
org.bouncycastle.asn1.ASN1Sequence
org.bouncycastle.asn1.ASN1Sequence)

________________CLASS________________


public class org.bouncycastle.jce.provider.CertStoreCollectionSpi extends java.security.cert.CertStoreSpi

----------------FIELDS----------------

private java.security.cert.CollectionCertStoreParameters params
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/security/InvalidAlgorithmParameterException; )
public void <init>(
java.security.cert.CertStoreParameters)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertStoreException; )
public java.util.Collection engineGetCRLs(
java.security.cert.CRLSelector)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertStoreException; )
public java.util.Collection engineGetCertificates(
java.security.cert.CertSelector)

________________CLASS________________


public class org.bouncycastle.jce.provider.DHUtil extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
public static org.bouncycastle.crypto.params.AsymmetricKeyParameter generatePrivateKeyParameter(
java.security.PrivateKey)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
public static org.bouncycastle.crypto.params.AsymmetricKeyParameter generatePublicKeyParameter(
java.security.PublicKey)

________________CLASS________________


public class org.bouncycastle.jce.provider.DSAUtil extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
public static org.bouncycastle.crypto.params.AsymmetricKeyParameter generatePrivateKeyParameter(
java.security.PrivateKey)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
public static org.bouncycastle.crypto.params.AsymmetricKeyParameter generatePublicKeyParameter(
java.security.PublicKey)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/bouncycastle/jce/provider/PBE$Util; )
public abstract interface class org.bouncycastle.jce.provider.PBE extends java.lang.Object

----------------FIELDS----------------

public static final int MD5

public static final int OPENSSL

public static final int PKCS12

public static final int PKCS5S1

public static final int PKCS5S2

public static final int RIPEMD160

public static final int SHA1

public static final int SHA256

public static final int TIGER
----------------METHODS----------------

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/bouncycastle/jce/provider/WrapCipherSpi$DESEDEWrap;Lorg/bouncycastle/jce/provider/WrapCipherSpi$AESWrap; )
public abstract class org.bouncycastle.jce.provider.WrapCipherSpi extends javax.crypto.CipherSpi implements org.bouncycastle.jce.provider.PBE

----------------FIELDS----------------

private java.lang.Class[] availableSpecs

protected java.security.AlgorithmParameters engineParams

protected int pbeHash

protected int pbeIvSize

protected int pbeKeySize

protected int pbeType

protected org.bouncycastle.crypto.Wrapper wrapEngine
----------------METHODS----------------

protected void <init>()

protected void <init>(
org.bouncycastle.crypto.Wrapper)
@dalvik.annotation.Throws (value =Ljavax/crypto/IllegalBlockSizeException;Ljavax/crypto/BadPaddingException; )
protected int engineDoFinal(
byte[]
int
int
byte[]
int)
@dalvik.annotation.Throws (value =Ljavax/crypto/IllegalBlockSizeException;Ljavax/crypto/BadPaddingException; )
protected byte[] engineDoFinal(
byte[]
int
int)

protected int engineGetBlockSize()

protected byte[] engineGetIV()

protected int engineGetKeySize(
java.security.Key)

protected int engineGetOutputSize(
int)

protected java.security.AlgorithmParameters engineGetParameters()
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljava/security/InvalidAlgorithmParameterException; )
protected void engineInit(
int
java.security.Key
java.security.AlgorithmParameters
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
protected void engineInit(
int
java.security.Key
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljava/security/InvalidAlgorithmParameterException; )
protected void engineInit(
int
java.security.Key
java.security.spec.AlgorithmParameterSpec
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
protected void engineSetMode(
java.lang.String)
@dalvik.annotation.Throws (value =Ljavax/crypto/NoSuchPaddingException; )
protected void engineSetPadding(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
protected java.security.Key engineUnwrap(
byte[]
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljavax/crypto/ShortBufferException; )
protected int engineUpdate(
byte[]
int
int
byte[]
int)

protected byte[] engineUpdate(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljavax/crypto/IllegalBlockSizeException;Ljava/security/InvalidKeyException; )
protected byte[] engineWrap(
java.security.Key)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/bouncycastle/jce/provider/JCEBlockCipher$PBEWithAESCBC;Lorg/bouncycastle/jce/provider/JCEBlockCipher$PBEWithSHAAndDES2Key;Lorg/bouncycastle/jce/provider/JCEBlockCipher$PBEWithSHAAndDES3Key;Lorg/bouncycastle/jce/provider/JCEBlockCipher$PBEWithSHA1AndDES;Lorg/bouncycastle/jce/provider/JCEBlockCipher$PBEWithMD5AndDES;Lorg/bouncycastle/jce/provider/JCEBlockCipher$AESOFB;Lorg/bouncycastle/jce/provider/JCEBlockCipher$AESCFB;Lorg/bouncycastle/jce/provider/JCEBlockCipher$AESCBC;Lorg/bouncycastle/jce/provider/JCEBlockCipher$AES;Lorg/bouncycastle/jce/provider/JCEBlockCipher$DESedeCBC;Lorg/bouncycastle/jce/provider/JCEBlockCipher$DESede;Lorg/bouncycastle/jce/provider/JCEBlockCipher$DESCBC;Lorg/bouncycastle/jce/provider/JCEBlockCipher$DES; )
public class org.bouncycastle.jce.provider.JCEBlockCipher extends org.bouncycastle.jce.provider.WrapCipherSpi implements org.bouncycastle.jce.provider.PBE

----------------FIELDS----------------

private java.lang.Class[] availableSpecs

private org.bouncycastle.crypto.BlockCipher baseEngine

private org.bouncycastle.crypto.BufferedBlockCipher cipher

private int ivLength

private org.bouncycastle.crypto.params.ParametersWithIV ivParam

private java.lang.String modeName

private boolean padded

private java.lang.String pbeAlgorithm

private javax.crypto.spec.PBEParameterSpec pbeSpec
----------------METHODS----------------

protected void <init>(
org.bouncycastle.crypto.BlockCipher)

protected void <init>(
org.bouncycastle.crypto.BlockCipher
int)
@dalvik.annotation.Throws (value =Ljavax/crypto/IllegalBlockSizeException;Ljavax/crypto/BadPaddingException; )
protected int engineDoFinal(
byte[]
int
int
byte[]
int)
@dalvik.annotation.Throws (value =Ljavax/crypto/IllegalBlockSizeException;Ljavax/crypto/BadPaddingException; )
protected byte[] engineDoFinal(
byte[]
int
int)

protected int engineGetBlockSize()

protected byte[] engineGetIV()

protected int engineGetKeySize(
java.security.Key)

protected int engineGetOutputSize(
int)

protected java.security.AlgorithmParameters engineGetParameters()
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljava/security/InvalidAlgorithmParameterException; )
protected void engineInit(
int
java.security.Key
java.security.AlgorithmParameters
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
protected void engineInit(
int
java.security.Key
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljava/security/InvalidAlgorithmParameterException; )
protected void engineInit(
int
java.security.Key
java.security.spec.AlgorithmParameterSpec
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
protected void engineSetMode(
java.lang.String)
@dalvik.annotation.Throws (value =Ljavax/crypto/NoSuchPaddingException; )
protected void engineSetPadding(
java.lang.String)
@dalvik.annotation.Throws (value =Ljavax/crypto/ShortBufferException; )
protected int engineUpdate(
byte[]
int
int
byte[]
int)

protected byte[] engineUpdate(
byte[]
int
int)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =AES )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEBlockCipher; )
public class org.bouncycastle.jce.provider.JCEBlockCipher$AES extends org.bouncycastle.jce.provider.JCEBlockCipher

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =AESCBC )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEBlockCipher; )
public class org.bouncycastle.jce.provider.JCEBlockCipher$AESCBC extends org.bouncycastle.jce.provider.JCEBlockCipher

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =AESCFB )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEBlockCipher; )
public class org.bouncycastle.jce.provider.JCEBlockCipher$AESCFB extends org.bouncycastle.jce.provider.JCEBlockCipher

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEBlockCipher; )
@dalvik.annotation.InnerClass (accessFlags =9 name =AESOFB )
public class org.bouncycastle.jce.provider.JCEBlockCipher$AESOFB extends org.bouncycastle.jce.provider.JCEBlockCipher

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEBlockCipher; )
@dalvik.annotation.InnerClass (accessFlags =9 name =DES )
public class org.bouncycastle.jce.provider.JCEBlockCipher$DES extends org.bouncycastle.jce.provider.JCEBlockCipher

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEBlockCipher; )
@dalvik.annotation.InnerClass (accessFlags =9 name =DESCBC )
public class org.bouncycastle.jce.provider.JCEBlockCipher$DESCBC extends org.bouncycastle.jce.provider.JCEBlockCipher

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =DESede )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEBlockCipher; )
public class org.bouncycastle.jce.provider.JCEBlockCipher$DESede extends org.bouncycastle.jce.provider.JCEBlockCipher

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEBlockCipher; )
@dalvik.annotation.InnerClass (accessFlags =9 name =DESedeCBC )
public class org.bouncycastle.jce.provider.JCEBlockCipher$DESedeCBC extends org.bouncycastle.jce.provider.JCEBlockCipher

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =PBEWithAESCBC )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEBlockCipher; )
public class org.bouncycastle.jce.provider.JCEBlockCipher$PBEWithAESCBC extends org.bouncycastle.jce.provider.JCEBlockCipher

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEBlockCipher; )
@dalvik.annotation.InnerClass (accessFlags =9 name =PBEWithMD5AndDES )
public class org.bouncycastle.jce.provider.JCEBlockCipher$PBEWithMD5AndDES extends org.bouncycastle.jce.provider.JCEBlockCipher

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =PBEWithSHA1AndDES )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEBlockCipher; )
public class org.bouncycastle.jce.provider.JCEBlockCipher$PBEWithSHA1AndDES extends org.bouncycastle.jce.provider.JCEBlockCipher

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEBlockCipher; )
@dalvik.annotation.InnerClass (accessFlags =9 name =PBEWithSHAAndDES2Key )
public class org.bouncycastle.jce.provider.JCEBlockCipher$PBEWithSHAAndDES2Key extends org.bouncycastle.jce.provider.JCEBlockCipher

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =PBEWithSHAAndDES3Key )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEBlockCipher; )
public class org.bouncycastle.jce.provider.JCEBlockCipher$PBEWithSHAAndDES3Key extends org.bouncycastle.jce.provider.JCEBlockCipher

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________


public class org.bouncycastle.jce.provider.JCEDHKeyAgreement extends javax.crypto.KeyAgreementSpi

----------------FIELDS----------------

private java.math.BigInteger g

private java.math.BigInteger p

private java.security.SecureRandom random

private java.math.BigInteger result

private java.math.BigInteger x
----------------METHODS----------------

public void <init>()

private byte[] bigIntToBytes(
java.math.BigInteger)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljava/lang/IllegalStateException; )
protected java.security.Key engineDoPhase(
java.security.Key
boolean)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalStateException;Ljavax/crypto/ShortBufferException; )
protected int engineGenerateSecret(
byte[]
int)

protected javax.crypto.SecretKey engineGenerateSecret(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalStateException; )
protected byte[] engineGenerateSecret()
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
protected void engineInit(
java.security.Key
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljava/security/InvalidAlgorithmParameterException; )
protected void engineInit(
java.security.Key
java.security.spec.AlgorithmParameterSpec
java.security.SecureRandom)

________________CLASS________________


public class org.bouncycastle.jce.provider.JCEDHPrivateKey extends java.lang.Object implements javax.crypto.interfaces.DHPrivateKey, org.bouncycastle.jce.interfaces.PKCS12BagAttributeCarrier

----------------FIELDS----------------

 javax.crypto.spec.DHParameterSpec dhSpec

private java.util.Hashtable pkcs12Attributes

private java.util.Vector pkcs12Ordering

 java.math.BigInteger x
----------------METHODS----------------

protected void <init>()

 void <init>(
javax.crypto.interfaces.DHPrivateKey)

 void <init>(
javax.crypto.spec.DHPrivateKeySpec)

 void <init>(
org.bouncycastle.asn1.pkcs.PrivateKeyInfo)

 void <init>(
org.bouncycastle.crypto.params.DHPrivateKeyParameters)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

public java.lang.String getAlgorithm()

public org.bouncycastle.asn1.DEREncodable getBagAttribute(
org.bouncycastle.asn1.DERObjectIdentifier)

public java.util.Enumeration getBagAttributeKeys()

public byte[] getEncoded()

public java.lang.String getFormat()

public javax.crypto.spec.DHParameterSpec getParams()

public java.math.BigInteger getX()

public void setBagAttribute(
org.bouncycastle.asn1.DERObjectIdentifier
org.bouncycastle.asn1.DEREncodable)

________________CLASS________________


public class org.bouncycastle.jce.provider.JCEDHPublicKey extends java.lang.Object implements javax.crypto.interfaces.DHPublicKey

----------------FIELDS----------------

private javax.crypto.spec.DHParameterSpec dhSpec

private java.math.BigInteger y
----------------METHODS----------------

 void <init>(
java.math.BigInteger
javax.crypto.spec.DHParameterSpec)

 void <init>(
javax.crypto.interfaces.DHPublicKey)

 void <init>(
javax.crypto.spec.DHPublicKeySpec)

 void <init>(
org.bouncycastle.asn1.x509.SubjectPublicKeyInfo)

 void <init>(
org.bouncycastle.crypto.params.DHPublicKeyParameters)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

public java.lang.String getAlgorithm()

public byte[] getEncoded()

public java.lang.String getFormat()

public javax.crypto.spec.DHParameterSpec getParams()

public java.math.BigInteger getY()

________________CLASS________________


 class org.bouncycastle.jce.provider.JCEDigestUtil extends java.lang.Object

----------------FIELDS----------------

private static java.util.Set md5

private static java.util.Map oids

private static java.util.Set sha1

private static java.util.Set sha224

private static java.util.Set sha256

private static java.util.Set sha384

private static java.util.Set sha512
----------------METHODS----------------

static void <clinit>()

 void <init>()

static org.bouncycastle.crypto.Digest getDigest(
java.lang.String)

static org.bouncycastle.asn1.DERObjectIdentifier getOID(
java.lang.String)

static boolean isSameDigest(
java.lang.String
java.lang.String)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/bouncycastle/jce/provider/JCEIESCipher$IES;Lorg/bouncycastle/jce/provider/JCEIESCipher$BrokenIES; )
public class org.bouncycastle.jce.provider.JCEIESCipher extends org.bouncycastle.jce.provider.WrapCipherSpi

----------------FIELDS----------------

private java.lang.Class[] availableSpecs

private java.io.ByteArrayOutputStream buffer

private org.bouncycastle.crypto.engines.IESEngine cipher

private java.security.AlgorithmParameters engineParam

private org.bouncycastle.jce.spec.IESParameterSpec engineParams

private int state
----------------METHODS----------------

public void <init>(
org.bouncycastle.crypto.engines.IESEngine)
@dalvik.annotation.Throws (value =Ljavax/crypto/IllegalBlockSizeException;Ljavax/crypto/BadPaddingException; )
protected int engineDoFinal(
byte[]
int
int
byte[]
int)
@dalvik.annotation.Throws (value =Ljavax/crypto/IllegalBlockSizeException;Ljavax/crypto/BadPaddingException; )
protected byte[] engineDoFinal(
byte[]
int
int)

protected int engineGetBlockSize()

protected byte[] engineGetIV()

protected int engineGetKeySize(
java.security.Key)

protected int engineGetOutputSize(
int)

protected java.security.AlgorithmParameters engineGetParameters()
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljava/security/InvalidAlgorithmParameterException; )
protected void engineInit(
int
java.security.Key
java.security.AlgorithmParameters
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
protected void engineInit(
int
java.security.Key
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljava/security/InvalidAlgorithmParameterException; )
protected void engineInit(
int
java.security.Key
java.security.spec.AlgorithmParameterSpec
java.security.SecureRandom)

protected void engineSetMode(
java.lang.String)
@dalvik.annotation.Throws (value =Ljavax/crypto/NoSuchPaddingException; )
protected void engineSetPadding(
java.lang.String)

protected int engineUpdate(
byte[]
int
int
byte[]
int)

protected byte[] engineUpdate(
byte[]
int
int)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =BrokenIES )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEIESCipher; )
public class org.bouncycastle.jce.provider.JCEIESCipher$BrokenIES extends org.bouncycastle.jce.provider.JCEIESCipher

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =IES )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEIESCipher; )
public class org.bouncycastle.jce.provider.JCEIESCipher$IES extends org.bouncycastle.jce.provider.JCEIESCipher

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/bouncycastle/jce/provider/JCEKeyGenerator$HMACTIGER;Lorg/bouncycastle/jce/provider/JCEKeyGenerator$HMACSHA512;Lorg/bouncycastle/jce/provider/JCEKeyGenerator$HMACSHA384;Lorg/bouncycastle/jce/provider/JCEKeyGenerator$HMACSHA256;Lorg/bouncycastle/jce/provider/JCEKeyGenerator$HMACSHA224;Lorg/bouncycastle/jce/provider/JCEKeyGenerator$HMACSHA1;Lorg/bouncycastle/jce/provider/JCEKeyGenerator$RIPEMD160HMAC;Lorg/bouncycastle/jce/provider/JCEKeyGenerator$RIPEMD128HMAC;Lorg/bouncycastle/jce/provider/JCEKeyGenerator$MD5HMAC;Lorg/bouncycastle/jce/provider/JCEKeyGenerator$MD4HMAC;Lorg/bouncycastle/jce/provider/JCEKeyGenerator$MD2HMAC;Lorg/bouncycastle/jce/provider/JCEKeyGenerator$IDEA;Lorg/bouncycastle/jce/provider/JCEKeyGenerator$CAST6;Lorg/bouncycastle/jce/provider/JCEKeyGenerator$CAST5;Lorg/bouncycastle/jce/provider/JCEKeyGenerator$Camellia;Lorg/bouncycastle/jce/provider/JCEKeyGenerator$Serpent;Lorg/bouncycastle/jce/provider/JCEKeyGenerator$Rijndael;Lorg/bouncycastle/jce/provider/JCEKeyGenerator$GOST28147;Lorg/bouncycastle/jce/provider/JCEKeyGenerator$AES256;Lorg/bouncycastle/jce/provider/JCEKeyGenerator$AES192;Lorg/bouncycastle/jce/provider/JCEKeyGenerator$AES128;Lorg/bouncycastle/jce/provider/JCEKeyGenerator$AES;Lorg/bouncycastle/jce/provider/JCEKeyGenerator$RC6;Lorg/bouncycastle/jce/provider/JCEKeyGenerator$RC564;Lorg/bouncycastle/jce/provider/JCEKeyGenerator$RC5;Lorg/bouncycastle/jce/provider/JCEKeyGenerator$RC4;Lorg/bouncycastle/jce/provider/JCEKeyGenerator$RC2;Lorg/bouncycastle/jce/provider/JCEKeyGenerator$Twofish;Lorg/bouncycastle/jce/provider/JCEKeyGenerator$Blowfish;Lorg/bouncycastle/jce/provider/JCEKeyGenerator$Skipjack;Lorg/bouncycastle/jce/provider/JCEKeyGenerator$DESede3;Lorg/bouncycastle/jce/provider/JCEKeyGenerator$DESede;Lorg/bouncycastle/jce/provider/JCEKeyGenerator$DES; )
public class org.bouncycastle.jce.provider.JCEKeyGenerator extends javax.crypto.KeyGeneratorSpi

----------------FIELDS----------------

protected java.lang.String algName

protected int defaultKeySize

protected org.bouncycastle.crypto.CipherKeyGenerator engine

protected int keySize

protected boolean uninitialised
----------------METHODS----------------

protected void <init>(
java.lang.String
int
org.bouncycastle.crypto.CipherKeyGenerator)

protected javax.crypto.SecretKey engineGenerateKey()

protected void engineInit(
int
java.security.SecureRandom)

protected void engineInit(
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/InvalidAlgorithmParameterException; )
protected void engineInit(
java.security.spec.AlgorithmParameterSpec
java.security.SecureRandom)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEKeyGenerator; )
@dalvik.annotation.InnerClass (accessFlags =9 name =AES128 )
public class org.bouncycastle.jce.provider.JCEKeyGenerator$AES128 extends org.bouncycastle.jce.provider.JCEKeyGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEKeyGenerator; )
@dalvik.annotation.InnerClass (accessFlags =9 name =AES192 )
public class org.bouncycastle.jce.provider.JCEKeyGenerator$AES192 extends org.bouncycastle.jce.provider.JCEKeyGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =AES256 )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEKeyGenerator; )
public class org.bouncycastle.jce.provider.JCEKeyGenerator$AES256 extends org.bouncycastle.jce.provider.JCEKeyGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEKeyGenerator; )
@dalvik.annotation.InnerClass (accessFlags =9 name =AES )
public class org.bouncycastle.jce.provider.JCEKeyGenerator$AES extends org.bouncycastle.jce.provider.JCEKeyGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEKeyGenerator; )
@dalvik.annotation.InnerClass (accessFlags =9 name =Blowfish )
public class org.bouncycastle.jce.provider.JCEKeyGenerator$Blowfish extends org.bouncycastle.jce.provider.JCEKeyGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =CAST5 )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEKeyGenerator; )
public class org.bouncycastle.jce.provider.JCEKeyGenerator$CAST5 extends org.bouncycastle.jce.provider.JCEKeyGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =CAST6 )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEKeyGenerator; )
public class org.bouncycastle.jce.provider.JCEKeyGenerator$CAST6 extends org.bouncycastle.jce.provider.JCEKeyGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEKeyGenerator; )
@dalvik.annotation.InnerClass (accessFlags =9 name =Camellia )
public class org.bouncycastle.jce.provider.JCEKeyGenerator$Camellia extends org.bouncycastle.jce.provider.JCEKeyGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =DES )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEKeyGenerator; )
public class org.bouncycastle.jce.provider.JCEKeyGenerator$DES extends org.bouncycastle.jce.provider.JCEKeyGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =DESede3 )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEKeyGenerator; )
public class org.bouncycastle.jce.provider.JCEKeyGenerator$DESede3 extends org.bouncycastle.jce.provider.JCEKeyGenerator

----------------FIELDS----------------

private boolean keySizeSet
----------------METHODS----------------

public void <init>()

protected javax.crypto.SecretKey engineGenerateKey()

protected void engineInit(
int
java.security.SecureRandom)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =DESede )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEKeyGenerator; )
public class org.bouncycastle.jce.provider.JCEKeyGenerator$DESede extends org.bouncycastle.jce.provider.JCEKeyGenerator

----------------FIELDS----------------

private boolean keySizeSet
----------------METHODS----------------

public void <init>()

protected javax.crypto.SecretKey engineGenerateKey()

protected void engineInit(
int
java.security.SecureRandom)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =GOST28147 )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEKeyGenerator; )
public class org.bouncycastle.jce.provider.JCEKeyGenerator$GOST28147 extends org.bouncycastle.jce.provider.JCEKeyGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =HMACSHA1 )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEKeyGenerator; )
public class org.bouncycastle.jce.provider.JCEKeyGenerator$HMACSHA1 extends org.bouncycastle.jce.provider.JCEKeyGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEKeyGenerator; )
@dalvik.annotation.InnerClass (accessFlags =9 name =HMACSHA224 )
public class org.bouncycastle.jce.provider.JCEKeyGenerator$HMACSHA224 extends org.bouncycastle.jce.provider.JCEKeyGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =HMACSHA256 )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEKeyGenerator; )
public class org.bouncycastle.jce.provider.JCEKeyGenerator$HMACSHA256 extends org.bouncycastle.jce.provider.JCEKeyGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =HMACSHA384 )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEKeyGenerator; )
public class org.bouncycastle.jce.provider.JCEKeyGenerator$HMACSHA384 extends org.bouncycastle.jce.provider.JCEKeyGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEKeyGenerator; )
@dalvik.annotation.InnerClass (accessFlags =9 name =HMACSHA512 )
public class org.bouncycastle.jce.provider.JCEKeyGenerator$HMACSHA512 extends org.bouncycastle.jce.provider.JCEKeyGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEKeyGenerator; )
@dalvik.annotation.InnerClass (accessFlags =9 name =HMACTIGER )
public class org.bouncycastle.jce.provider.JCEKeyGenerator$HMACTIGER extends org.bouncycastle.jce.provider.JCEKeyGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =IDEA )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEKeyGenerator; )
public class org.bouncycastle.jce.provider.JCEKeyGenerator$IDEA extends org.bouncycastle.jce.provider.JCEKeyGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =MD2HMAC )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEKeyGenerator; )
public class org.bouncycastle.jce.provider.JCEKeyGenerator$MD2HMAC extends org.bouncycastle.jce.provider.JCEKeyGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEKeyGenerator; )
@dalvik.annotation.InnerClass (accessFlags =9 name =MD4HMAC )
public class org.bouncycastle.jce.provider.JCEKeyGenerator$MD4HMAC extends org.bouncycastle.jce.provider.JCEKeyGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =MD5HMAC )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEKeyGenerator; )
public class org.bouncycastle.jce.provider.JCEKeyGenerator$MD5HMAC extends org.bouncycastle.jce.provider.JCEKeyGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEKeyGenerator; )
@dalvik.annotation.InnerClass (accessFlags =9 name =RC2 )
public class org.bouncycastle.jce.provider.JCEKeyGenerator$RC2 extends org.bouncycastle.jce.provider.JCEKeyGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =RC4 )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEKeyGenerator; )
public class org.bouncycastle.jce.provider.JCEKeyGenerator$RC4 extends org.bouncycastle.jce.provider.JCEKeyGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEKeyGenerator; )
@dalvik.annotation.InnerClass (accessFlags =9 name =RC564 )
public class org.bouncycastle.jce.provider.JCEKeyGenerator$RC564 extends org.bouncycastle.jce.provider.JCEKeyGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEKeyGenerator; )
@dalvik.annotation.InnerClass (accessFlags =9 name =RC5 )
public class org.bouncycastle.jce.provider.JCEKeyGenerator$RC5 extends org.bouncycastle.jce.provider.JCEKeyGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEKeyGenerator; )
@dalvik.annotation.InnerClass (accessFlags =9 name =RC6 )
public class org.bouncycastle.jce.provider.JCEKeyGenerator$RC6 extends org.bouncycastle.jce.provider.JCEKeyGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEKeyGenerator; )
@dalvik.annotation.InnerClass (accessFlags =9 name =RIPEMD128HMAC )
public class org.bouncycastle.jce.provider.JCEKeyGenerator$RIPEMD128HMAC extends org.bouncycastle.jce.provider.JCEKeyGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =RIPEMD160HMAC )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEKeyGenerator; )
public class org.bouncycastle.jce.provider.JCEKeyGenerator$RIPEMD160HMAC extends org.bouncycastle.jce.provider.JCEKeyGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =Rijndael )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEKeyGenerator; )
public class org.bouncycastle.jce.provider.JCEKeyGenerator$Rijndael extends org.bouncycastle.jce.provider.JCEKeyGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEKeyGenerator; )
@dalvik.annotation.InnerClass (accessFlags =9 name =Serpent )
public class org.bouncycastle.jce.provider.JCEKeyGenerator$Serpent extends org.bouncycastle.jce.provider.JCEKeyGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =Skipjack )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEKeyGenerator; )
public class org.bouncycastle.jce.provider.JCEKeyGenerator$Skipjack extends org.bouncycastle.jce.provider.JCEKeyGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =Twofish )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEKeyGenerator; )
public class org.bouncycastle.jce.provider.JCEKeyGenerator$Twofish extends org.bouncycastle.jce.provider.JCEKeyGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/bouncycastle/jce/provider/JCEMac$PBEWithSHA;Lorg/bouncycastle/jce/provider/JCEMac$OldSHA512;Lorg/bouncycastle/jce/provider/JCEMac$SHA512;Lorg/bouncycastle/jce/provider/JCEMac$OldSHA384;Lorg/bouncycastle/jce/provider/JCEMac$SHA384;Lorg/bouncycastle/jce/provider/JCEMac$SHA256;Lorg/bouncycastle/jce/provider/JCEMac$SHA224;Lorg/bouncycastle/jce/provider/JCEMac$SHA1;Lorg/bouncycastle/jce/provider/JCEMac$MD5;Lorg/bouncycastle/jce/provider/JCEMac$DES9797Alg3;Lorg/bouncycastle/jce/provider/JCEMac$DESede64;Lorg/bouncycastle/jce/provider/JCEMac$DESedeCFB8;Lorg/bouncycastle/jce/provider/JCEMac$DESCFB8;Lorg/bouncycastle/jce/provider/JCEMac$DESede;Lorg/bouncycastle/jce/provider/JCEMac$DES; )
public class org.bouncycastle.jce.provider.JCEMac extends javax.crypto.MacSpi implements org.bouncycastle.jce.provider.PBE

----------------FIELDS----------------

private int keySize

private org.bouncycastle.crypto.Mac macEngine

private int pbeHash

private int pbeType
----------------METHODS----------------

protected void <init>(
org.bouncycastle.crypto.Mac)

protected void <init>(
org.bouncycastle.crypto.Mac
int
int
int)

protected byte[] engineDoFinal()

protected int engineGetMacLength()
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljava/security/InvalidAlgorithmParameterException; )
protected void engineInit(
java.security.Key
java.security.spec.AlgorithmParameterSpec)

protected void engineReset()

protected void engineUpdate(
byte)

protected void engineUpdate(
byte[]
int
int)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =DES9797Alg3 )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEMac; )
public class org.bouncycastle.jce.provider.JCEMac$DES9797Alg3 extends org.bouncycastle.jce.provider.JCEMac

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEMac; )
@dalvik.annotation.InnerClass (accessFlags =9 name =DES )
public class org.bouncycastle.jce.provider.JCEMac$DES extends org.bouncycastle.jce.provider.JCEMac

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =DESCFB8 )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEMac; )
public class org.bouncycastle.jce.provider.JCEMac$DESCFB8 extends org.bouncycastle.jce.provider.JCEMac

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEMac; )
@dalvik.annotation.InnerClass (accessFlags =9 name =DESede64 )
public class org.bouncycastle.jce.provider.JCEMac$DESede64 extends org.bouncycastle.jce.provider.JCEMac

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEMac; )
@dalvik.annotation.InnerClass (accessFlags =9 name =DESede )
public class org.bouncycastle.jce.provider.JCEMac$DESede extends org.bouncycastle.jce.provider.JCEMac

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEMac; )
@dalvik.annotation.InnerClass (accessFlags =9 name =DESedeCFB8 )
public class org.bouncycastle.jce.provider.JCEMac$DESedeCFB8 extends org.bouncycastle.jce.provider.JCEMac

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =MD5 )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEMac; )
public class org.bouncycastle.jce.provider.JCEMac$MD5 extends org.bouncycastle.jce.provider.JCEMac

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =OldSHA384 )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEMac; )
public class org.bouncycastle.jce.provider.JCEMac$OldSHA384 extends org.bouncycastle.jce.provider.JCEMac

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =OldSHA512 )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEMac; )
public class org.bouncycastle.jce.provider.JCEMac$OldSHA512 extends org.bouncycastle.jce.provider.JCEMac

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEMac; )
@dalvik.annotation.InnerClass (accessFlags =9 name =PBEWithSHA )
public class org.bouncycastle.jce.provider.JCEMac$PBEWithSHA extends org.bouncycastle.jce.provider.JCEMac

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEMac; )
@dalvik.annotation.InnerClass (accessFlags =9 name =SHA1 )
public class org.bouncycastle.jce.provider.JCEMac$SHA1 extends org.bouncycastle.jce.provider.JCEMac

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =SHA224 )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEMac; )
public class org.bouncycastle.jce.provider.JCEMac$SHA224 extends org.bouncycastle.jce.provider.JCEMac

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEMac; )
@dalvik.annotation.InnerClass (accessFlags =9 name =SHA256 )
public class org.bouncycastle.jce.provider.JCEMac$SHA256 extends org.bouncycastle.jce.provider.JCEMac

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEMac; )
@dalvik.annotation.InnerClass (accessFlags =9 name =SHA384 )
public class org.bouncycastle.jce.provider.JCEMac$SHA384 extends org.bouncycastle.jce.provider.JCEMac

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEMac; )
@dalvik.annotation.InnerClass (accessFlags =9 name =SHA512 )
public class org.bouncycastle.jce.provider.JCEMac$SHA512 extends org.bouncycastle.jce.provider.JCEMac

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________


public class org.bouncycastle.jce.provider.JCEPBEKey extends java.lang.Object implements javax.crypto.interfaces.PBEKey

----------------FIELDS----------------

 java.lang.String algorithm

 int digest

 int ivSize

 int keySize

 org.bouncycastle.asn1.DERObjectIdentifier oid

 org.bouncycastle.crypto.CipherParameters param

 javax.crypto.spec.PBEKeySpec pbeKeySpec

 boolean tryWrong

 int type
----------------METHODS----------------

public void <init>(
java.lang.String
org.bouncycastle.asn1.DERObjectIdentifier
int
int
int
int
javax.crypto.spec.PBEKeySpec
org.bouncycastle.crypto.CipherParameters)

public java.lang.String getAlgorithm()

 int getDigest()

public byte[] getEncoded()

public java.lang.String getFormat()

public int getIterationCount()

 int getIvSize()

 int getKeySize()

public org.bouncycastle.asn1.DERObjectIdentifier getOID()

 org.bouncycastle.crypto.CipherParameters getParam()

public char[] getPassword()

public byte[] getSalt()

 int getType()

 void setTryWrongPKCS12Zero(
boolean)

 boolean shouldTryWrongPKCS12()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/bouncycastle/jce/provider/JCERSACipher$ISO9796d1Padding;Lorg/bouncycastle/jce/provider/JCERSACipher$OAEPPadding;Lorg/bouncycastle/jce/provider/JCERSACipher$PKCS1v1_5Padding_PublicOnly;Lorg/bouncycastle/jce/provider/JCERSACipher$PKCS1v1_5Padding_PrivateOnly;Lorg/bouncycastle/jce/provider/JCERSACipher$PKCS1v1_5Padding;Lorg/bouncycastle/jce/provider/JCERSACipher$NoPadding; )
public class org.bouncycastle.jce.provider.JCERSACipher extends org.bouncycastle.jce.provider.WrapCipherSpi

----------------FIELDS----------------

private java.io.ByteArrayOutputStream bOut

private org.bouncycastle.crypto.AsymmetricBlockCipher cipher

private java.security.AlgorithmParameters engineParams

private java.security.spec.AlgorithmParameterSpec paramSpec

private boolean privateKeyOnly

private boolean publicKeyOnly
----------------METHODS----------------

public void <init>(
javax.crypto.spec.OAEPParameterSpec)

public void <init>(
org.bouncycastle.crypto.AsymmetricBlockCipher)

public void <init>(
boolean
boolean
org.bouncycastle.crypto.AsymmetricBlockCipher)
@dalvik.annotation.Throws (value =Ljavax/crypto/NoSuchPaddingException; )
private void initFromSpec(
javax.crypto.spec.OAEPParameterSpec)
@dalvik.annotation.Throws (value =Ljavax/crypto/IllegalBlockSizeException;Ljavax/crypto/BadPaddingException; )
protected int engineDoFinal(
byte[]
int
int
byte[]
int)
@dalvik.annotation.Throws (value =Ljavax/crypto/IllegalBlockSizeException;Ljavax/crypto/BadPaddingException; )
protected byte[] engineDoFinal(
byte[]
int
int)

protected int engineGetBlockSize()

protected byte[] engineGetIV()

protected int engineGetKeySize(
java.security.Key)

protected int engineGetOutputSize(
int)

protected java.security.AlgorithmParameters engineGetParameters()
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljava/security/InvalidAlgorithmParameterException; )
protected void engineInit(
int
java.security.Key
java.security.AlgorithmParameters
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
protected void engineInit(
int
java.security.Key
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljava/security/InvalidAlgorithmParameterException; )
protected void engineInit(
int
java.security.Key
java.security.spec.AlgorithmParameterSpec
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException; )
protected void engineSetMode(
java.lang.String)
@dalvik.annotation.Throws (value =Ljavax/crypto/NoSuchPaddingException; )
protected void engineSetPadding(
java.lang.String)

protected int engineUpdate(
byte[]
int
int
byte[]
int)

protected byte[] engineUpdate(
byte[]
int
int)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =ISO9796d1Padding )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCERSACipher; )
public class org.bouncycastle.jce.provider.JCERSACipher$ISO9796d1Padding extends org.bouncycastle.jce.provider.JCERSACipher

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCERSACipher; )
@dalvik.annotation.InnerClass (accessFlags =9 name =NoPadding )
public class org.bouncycastle.jce.provider.JCERSACipher$NoPadding extends org.bouncycastle.jce.provider.JCERSACipher

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =OAEPPadding )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCERSACipher; )
public class org.bouncycastle.jce.provider.JCERSACipher$OAEPPadding extends org.bouncycastle.jce.provider.JCERSACipher

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCERSACipher; )
@dalvik.annotation.InnerClass (accessFlags =9 name =PKCS1v1_5Padding )
public class org.bouncycastle.jce.provider.JCERSACipher$PKCS1v1_5Padding extends org.bouncycastle.jce.provider.JCERSACipher

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =PKCS1v1_5Padding_PrivateOnly )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCERSACipher; )
public class org.bouncycastle.jce.provider.JCERSACipher$PKCS1v1_5Padding_PrivateOnly extends org.bouncycastle.jce.provider.JCERSACipher

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCERSACipher; )
@dalvik.annotation.InnerClass (accessFlags =9 name =PKCS1v1_5Padding_PublicOnly )
public class org.bouncycastle.jce.provider.JCERSACipher$PKCS1v1_5Padding_PublicOnly extends org.bouncycastle.jce.provider.JCERSACipher

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________


public class org.bouncycastle.jce.provider.JCERSAPrivateKey extends java.lang.Object implements java.security.interfaces.RSAPrivateKey, org.bouncycastle.jce.interfaces.PKCS12BagAttributeCarrier

----------------FIELDS----------------

protected java.math.BigInteger modulus

private java.util.Hashtable pkcs12Attributes

private java.util.Vector pkcs12Ordering

protected java.math.BigInteger privateExponent
----------------METHODS----------------

protected void <init>()

 void <init>(
java.security.interfaces.RSAPrivateKey)

 void <init>(
java.security.spec.RSAPrivateKeySpec)

 void <init>(
org.bouncycastle.crypto.params.RSAKeyParameters)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/ClassNotFoundException; )
private void readObject(
java.io.ObjectInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeObject(
java.io.ObjectOutputStream)

public boolean equals(
java.lang.Object)

public java.lang.String getAlgorithm()

public org.bouncycastle.asn1.DEREncodable getBagAttribute(
org.bouncycastle.asn1.DERObjectIdentifier)

public java.util.Enumeration getBagAttributeKeys()

public byte[] getEncoded()

public java.lang.String getFormat()

public java.math.BigInteger getModulus()

public java.math.BigInteger getPrivateExponent()

public int hashCode()

public void setBagAttribute(
org.bouncycastle.asn1.DERObjectIdentifier
org.bouncycastle.asn1.DEREncodable)

________________CLASS________________


public class org.bouncycastle.jce.provider.JCERSAPrivateCrtKey extends org.bouncycastle.jce.provider.JCERSAPrivateKey implements java.security.interfaces.RSAPrivateCrtKey

----------------FIELDS----------------

private java.math.BigInteger crtCoefficient

private java.math.BigInteger primeExponentP

private java.math.BigInteger primeExponentQ

private java.math.BigInteger primeP

private java.math.BigInteger primeQ

private java.math.BigInteger publicExponent
----------------METHODS----------------

 void <init>(
java.security.interfaces.RSAPrivateCrtKey)

 void <init>(
java.security.spec.RSAPrivateCrtKeySpec)

 void <init>(
org.bouncycastle.asn1.pkcs.PrivateKeyInfo)

 void <init>(
org.bouncycastle.asn1.pkcs.RSAPrivateKeyStructure)

 void <init>(
org.bouncycastle.crypto.params.RSAPrivateCrtKeyParameters)

public boolean equals(
java.lang.Object)

public java.math.BigInteger getCrtCoefficient()

public byte[] getEncoded()

public java.lang.String getFormat()

public java.math.BigInteger getPrimeExponentP()

public java.math.BigInteger getPrimeExponentQ()

public java.math.BigInteger getPrimeP()

public java.math.BigInteger getPrimeQ()

public java.math.BigInteger getPublicExponent()

public java.lang.String toString()

________________CLASS________________


public class org.bouncycastle.jce.provider.JCERSAPublicKey extends java.lang.Object implements java.security.interfaces.RSAPublicKey

----------------FIELDS----------------

private java.math.BigInteger modulus

private java.math.BigInteger publicExponent
----------------METHODS----------------

 void <init>(
java.security.interfaces.RSAPublicKey)

 void <init>(
java.security.spec.RSAPublicKeySpec)

 void <init>(
org.bouncycastle.asn1.x509.SubjectPublicKeyInfo)

 void <init>(
org.bouncycastle.crypto.params.RSAKeyParameters)

public boolean equals(
java.lang.Object)

public java.lang.String getAlgorithm()

public byte[] getEncoded()

public java.lang.String getFormat()

public java.math.BigInteger getModulus()

public java.math.BigInteger getPublicExponent()

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/bouncycastle/jce/provider/JCESecretKeyFactory$PBEWithMD5And256BitAESCBCOpenSSL;Lorg/bouncycastle/jce/provider/JCESecretKeyFactory$PBEWithMD5And192BitAESCBCOpenSSL;Lorg/bouncycastle/jce/provider/JCESecretKeyFactory$PBEWithMD5And128BitAESCBCOpenSSL;Lorg/bouncycastle/jce/provider/JCESecretKeyFactory$PBEWithSHA256And256BitAESBC;Lorg/bouncycastle/jce/provider/JCESecretKeyFactory$PBEWithSHA256And192BitAESBC;Lorg/bouncycastle/jce/provider/JCESecretKeyFactory$PBEWithSHA256And128BitAESBC;Lorg/bouncycastle/jce/provider/JCESecretKeyFactory$PBEWithSHAAnd256BitAESBC;Lorg/bouncycastle/jce/provider/JCESecretKeyFactory$PBEWithSHAAnd192BitAESBC;Lorg/bouncycastle/jce/provider/JCESecretKeyFactory$PBEWithSHAAnd128BitAESBC;Lorg/bouncycastle/jce/provider/JCESecretKeyFactory$PBEWithTiger;Lorg/bouncycastle/jce/provider/JCESecretKeyFactory$PBEWithSHA;Lorg/bouncycastle/jce/provider/JCESecretKeyFactory$PBEWithRIPEMD160;Lorg/bouncycastle/jce/provider/JCESecretKeyFactory$PBEWithSHAAnd40BitRC4;Lorg/bouncycastle/jce/provider/JCESecretKeyFactory$PBEWithSHAAnd128BitRC4;Lorg/bouncycastle/jce/provider/JCESecretKeyFactory$PBEWithSHAAndIDEA;Lorg/bouncycastle/jce/provider/JCESecretKeyFactory$PBEWithSHAAndTwofish;Lorg/bouncycastle/jce/provider/JCESecretKeyFactory$PBEWithSHAAnd40BitRC2;Lorg/bouncycastle/jce/provider/JCESecretKeyFactory$PBEWithSHAAnd128BitRC2;Lorg/bouncycastle/jce/provider/JCESecretKeyFactory$PBEWithSHAAndDES2Key;Lorg/bouncycastle/jce/provider/JCESecretKeyFactory$PBEWithSHAAndDES3Key;Lorg/bouncycastle/jce/provider/JCESecretKeyFactory$PBEWithSHA1AndRC2;Lorg/bouncycastle/jce/provider/JCESecretKeyFactory$PBEWithSHA1AndDES;Lorg/bouncycastle/jce/provider/JCESecretKeyFactory$PBEWithMD5AndRC2;Lorg/bouncycastle/jce/provider/JCESecretKeyFactory$PBEWithMD5AndDES;Lorg/bouncycastle/jce/provider/JCESecretKeyFactory$DESede;Lorg/bouncycastle/jce/provider/JCESecretKeyFactory$DES;Lorg/bouncycastle/jce/provider/JCESecretKeyFactory$DESPBEKeyFactory;Lorg/bouncycastle/jce/provider/JCESecretKeyFactory$PBEKeyFactory; )
public class org.bouncycastle.jce.provider.JCESecretKeyFactory extends javax.crypto.SecretKeyFactorySpi implements org.bouncycastle.jce.provider.PBE

----------------FIELDS----------------

protected java.lang.String algName

protected org.bouncycastle.asn1.DERObjectIdentifier algOid
----------------METHODS----------------

protected void <init>(
java.lang.String
org.bouncycastle.asn1.DERObjectIdentifier)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidKeySpecException; )
protected javax.crypto.SecretKey engineGenerateSecret(
java.security.spec.KeySpec)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidKeySpecException; )
protected java.security.spec.KeySpec engineGetKeySpec(
javax.crypto.SecretKey
java.lang.Class)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
protected javax.crypto.SecretKey engineTranslateKey(
javax.crypto.SecretKey)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =DES )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCESecretKeyFactory; )
public class org.bouncycastle.jce.provider.JCESecretKeyFactory$DES extends org.bouncycastle.jce.provider.JCESecretKeyFactory

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidKeySpecException; )
protected javax.crypto.SecretKey engineGenerateSecret(
java.security.spec.KeySpec)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCESecretKeyFactory; )
@dalvik.annotation.InnerClass (accessFlags =9 name =DESPBEKeyFactory )
public class org.bouncycastle.jce.provider.JCESecretKeyFactory$DESPBEKeyFactory extends org.bouncycastle.jce.provider.JCESecretKeyFactory

----------------FIELDS----------------

private int digest

private boolean forCipher

private int ivSize

private int keySize

private int scheme
----------------METHODS----------------

public void <init>(
java.lang.String
org.bouncycastle.asn1.DERObjectIdentifier
boolean
int
int
int
int)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidKeySpecException; )
protected javax.crypto.SecretKey engineGenerateSecret(
java.security.spec.KeySpec)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =DESede )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCESecretKeyFactory; )
public class org.bouncycastle.jce.provider.JCESecretKeyFactory$DESede extends org.bouncycastle.jce.provider.JCESecretKeyFactory

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidKeySpecException; )
protected javax.crypto.SecretKey engineGenerateSecret(
java.security.spec.KeySpec)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidKeySpecException; )
protected java.security.spec.KeySpec engineGetKeySpec(
javax.crypto.SecretKey
java.lang.Class)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =PBEKeyFactory )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCESecretKeyFactory; )
public class org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEKeyFactory extends org.bouncycastle.jce.provider.JCESecretKeyFactory

----------------FIELDS----------------

private int digest

private boolean forCipher

private int ivSize

private int keySize

private int scheme
----------------METHODS----------------

public void <init>(
java.lang.String
org.bouncycastle.asn1.DERObjectIdentifier
boolean
int
int
int
int)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidKeySpecException; )
protected javax.crypto.SecretKey engineGenerateSecret(
java.security.spec.KeySpec)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =PBEWithMD5And128BitAESCBCOpenSSL )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCESecretKeyFactory; )
public class org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEWithMD5And128BitAESCBCOpenSSL extends org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEKeyFactory

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCESecretKeyFactory; )
@dalvik.annotation.InnerClass (accessFlags =9 name =PBEWithMD5And192BitAESCBCOpenSSL )
public class org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEWithMD5And192BitAESCBCOpenSSL extends org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEKeyFactory

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCESecretKeyFactory; )
@dalvik.annotation.InnerClass (accessFlags =9 name =PBEWithMD5And256BitAESCBCOpenSSL )
public class org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEWithMD5And256BitAESCBCOpenSSL extends org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEKeyFactory

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =PBEWithMD5AndDES )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCESecretKeyFactory; )
public class org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEWithMD5AndDES extends org.bouncycastle.jce.provider.JCESecretKeyFactory$DESPBEKeyFactory

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCESecretKeyFactory; )
@dalvik.annotation.InnerClass (accessFlags =9 name =PBEWithMD5AndRC2 )
public class org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEWithMD5AndRC2 extends org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEKeyFactory

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCESecretKeyFactory; )
@dalvik.annotation.InnerClass (accessFlags =9 name =PBEWithRIPEMD160 )
public class org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEWithRIPEMD160 extends org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEKeyFactory

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =PBEWithSHA1AndDES )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCESecretKeyFactory; )
public class org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEWithSHA1AndDES extends org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEKeyFactory

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =PBEWithSHA1AndRC2 )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCESecretKeyFactory; )
public class org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEWithSHA1AndRC2 extends org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEKeyFactory

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCESecretKeyFactory; )
@dalvik.annotation.InnerClass (accessFlags =9 name =PBEWithSHA256And128BitAESBC )
public class org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEWithSHA256And128BitAESBC extends org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEKeyFactory

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =PBEWithSHA256And192BitAESBC )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCESecretKeyFactory; )
public class org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEWithSHA256And192BitAESBC extends org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEKeyFactory

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCESecretKeyFactory; )
@dalvik.annotation.InnerClass (accessFlags =9 name =PBEWithSHA256And256BitAESBC )
public class org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEWithSHA256And256BitAESBC extends org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEKeyFactory

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCESecretKeyFactory; )
@dalvik.annotation.InnerClass (accessFlags =9 name =PBEWithSHA )
public class org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEWithSHA extends org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEKeyFactory

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =PBEWithSHAAnd128BitAESBC )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCESecretKeyFactory; )
public class org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEWithSHAAnd128BitAESBC extends org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEKeyFactory

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =PBEWithSHAAnd128BitRC2 )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCESecretKeyFactory; )
public class org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEWithSHAAnd128BitRC2 extends org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEKeyFactory

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =PBEWithSHAAnd128BitRC4 )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCESecretKeyFactory; )
public class org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEWithSHAAnd128BitRC4 extends org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEKeyFactory

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCESecretKeyFactory; )
@dalvik.annotation.InnerClass (accessFlags =9 name =PBEWithSHAAnd192BitAESBC )
public class org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEWithSHAAnd192BitAESBC extends org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEKeyFactory

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCESecretKeyFactory; )
@dalvik.annotation.InnerClass (accessFlags =9 name =PBEWithSHAAnd256BitAESBC )
public class org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEWithSHAAnd256BitAESBC extends org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEKeyFactory

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =PBEWithSHAAnd40BitRC2 )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCESecretKeyFactory; )
public class org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEWithSHAAnd40BitRC2 extends org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEKeyFactory

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCESecretKeyFactory; )
@dalvik.annotation.InnerClass (accessFlags =9 name =PBEWithSHAAnd40BitRC4 )
public class org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEWithSHAAnd40BitRC4 extends org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEKeyFactory

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =PBEWithSHAAndDES2Key )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCESecretKeyFactory; )
public class org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEWithSHAAndDES2Key extends org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEKeyFactory

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCESecretKeyFactory; )
@dalvik.annotation.InnerClass (accessFlags =9 name =PBEWithSHAAndDES3Key )
public class org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEWithSHAAndDES3Key extends org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEKeyFactory

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCESecretKeyFactory; )
@dalvik.annotation.InnerClass (accessFlags =9 name =PBEWithSHAAndIDEA )
public class org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEWithSHAAndIDEA extends org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEKeyFactory

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =PBEWithSHAAndTwofish )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCESecretKeyFactory; )
public class org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEWithSHAAndTwofish extends org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEKeyFactory

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =PBEWithTiger )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCESecretKeyFactory; )
public class org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEWithTiger extends org.bouncycastle.jce.provider.JCESecretKeyFactory$PBEKeyFactory

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/bouncycastle/jce/provider/JCEStreamCipher$DESede_OFB8;Lorg/bouncycastle/jce/provider/JCEStreamCipher$DES_OFB8;Lorg/bouncycastle/jce/provider/JCEStreamCipher$DESede_CFB8;Lorg/bouncycastle/jce/provider/JCEStreamCipher$DES_CFB8; )
public class org.bouncycastle.jce.provider.JCEStreamCipher extends org.bouncycastle.jce.provider.WrapCipherSpi implements org.bouncycastle.jce.provider.PBE

----------------FIELDS----------------

private java.lang.Class[] availableSpecs

private org.bouncycastle.crypto.StreamCipher cipher

private int ivLength

private org.bouncycastle.crypto.params.ParametersWithIV ivParam

private java.lang.String pbeAlgorithm

private javax.crypto.spec.PBEParameterSpec pbeSpec
----------------METHODS----------------

protected void <init>(
org.bouncycastle.crypto.BlockCipher
int)

protected void <init>(
org.bouncycastle.crypto.StreamCipher)

protected int engineDoFinal(
byte[]
int
int
byte[]
int)

protected byte[] engineDoFinal(
byte[]
int
int)

protected int engineGetBlockSize()

protected byte[] engineGetIV()

protected int engineGetKeySize(
java.security.Key)

protected int engineGetOutputSize(
int)

protected java.security.AlgorithmParameters engineGetParameters()
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljava/security/InvalidAlgorithmParameterException; )
protected void engineInit(
int
java.security.Key
java.security.AlgorithmParameters
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
protected void engineInit(
int
java.security.Key
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException;Ljava/security/InvalidAlgorithmParameterException; )
protected void engineInit(
int
java.security.Key
java.security.spec.AlgorithmParameterSpec
java.security.SecureRandom)

protected void engineSetMode(
java.lang.String)
@dalvik.annotation.Throws (value =Ljavax/crypto/NoSuchPaddingException; )
protected void engineSetPadding(
java.lang.String)
@dalvik.annotation.Throws (value =Ljavax/crypto/ShortBufferException; )
protected int engineUpdate(
byte[]
int
int
byte[]
int)

protected byte[] engineUpdate(
byte[]
int
int)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEStreamCipher; )
@dalvik.annotation.InnerClass (accessFlags =9 name =DES_CFB8 )
public class org.bouncycastle.jce.provider.JCEStreamCipher$DES_CFB8 extends org.bouncycastle.jce.provider.JCEStreamCipher

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEStreamCipher; )
@dalvik.annotation.InnerClass (accessFlags =9 name =DES_OFB8 )
public class org.bouncycastle.jce.provider.JCEStreamCipher$DES_OFB8 extends org.bouncycastle.jce.provider.JCEStreamCipher

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEStreamCipher; )
@dalvik.annotation.InnerClass (accessFlags =9 name =DESede_CFB8 )
public class org.bouncycastle.jce.provider.JCEStreamCipher$DESede_CFB8 extends org.bouncycastle.jce.provider.JCEStreamCipher

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JCEStreamCipher; )
@dalvik.annotation.InnerClass (accessFlags =9 name =DESede_OFB8 )
public class org.bouncycastle.jce.provider.JCEStreamCipher$DESede_OFB8 extends org.bouncycastle.jce.provider.JCEStreamCipher

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/bouncycastle/jce/provider/JDKAlgorithmParameterGenerator$CAST5;Lorg/bouncycastle/jce/provider/JDKAlgorithmParameterGenerator$IDEA;Lorg/bouncycastle/jce/provider/JDKAlgorithmParameterGenerator$AES;Lorg/bouncycastle/jce/provider/JDKAlgorithmParameterGenerator$RC2;Lorg/bouncycastle/jce/provider/JDKAlgorithmParameterGenerator$DES;Lorg/bouncycastle/jce/provider/JDKAlgorithmParameterGenerator$DSA;Lorg/bouncycastle/jce/provider/JDKAlgorithmParameterGenerator$DH; )
public abstract class org.bouncycastle.jce.provider.JDKAlgorithmParameterGenerator extends java.security.AlgorithmParameterGeneratorSpi

----------------FIELDS----------------

protected java.security.SecureRandom random

protected int strength
----------------METHODS----------------

public void <init>()

protected void engineInit(
int
java.security.SecureRandom)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =AES )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKAlgorithmParameterGenerator; )
public class org.bouncycastle.jce.provider.JDKAlgorithmParameterGenerator$AES extends org.bouncycastle.jce.provider.JDKAlgorithmParameterGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

protected java.security.AlgorithmParameters engineGenerateParameters()
@dalvik.annotation.Throws (value =Ljava/security/InvalidAlgorithmParameterException; )
protected void engineInit(
java.security.spec.AlgorithmParameterSpec
java.security.SecureRandom)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKAlgorithmParameterGenerator; )
@dalvik.annotation.InnerClass (accessFlags =9 name =CAST5 )
public class org.bouncycastle.jce.provider.JDKAlgorithmParameterGenerator$CAST5 extends org.bouncycastle.jce.provider.JDKAlgorithmParameterGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

protected java.security.AlgorithmParameters engineGenerateParameters()
@dalvik.annotation.Throws (value =Ljava/security/InvalidAlgorithmParameterException; )
protected void engineInit(
java.security.spec.AlgorithmParameterSpec
java.security.SecureRandom)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =DES )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKAlgorithmParameterGenerator; )
public class org.bouncycastle.jce.provider.JDKAlgorithmParameterGenerator$DES extends org.bouncycastle.jce.provider.JDKAlgorithmParameterGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

protected java.security.AlgorithmParameters engineGenerateParameters()
@dalvik.annotation.Throws (value =Ljava/security/InvalidAlgorithmParameterException; )
protected void engineInit(
java.security.spec.AlgorithmParameterSpec
java.security.SecureRandom)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =DH )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKAlgorithmParameterGenerator; )
public class org.bouncycastle.jce.provider.JDKAlgorithmParameterGenerator$DH extends org.bouncycastle.jce.provider.JDKAlgorithmParameterGenerator

----------------FIELDS----------------

private int l
----------------METHODS----------------

public void <init>()

protected java.security.AlgorithmParameters engineGenerateParameters()
@dalvik.annotation.Throws (value =Ljava/security/InvalidAlgorithmParameterException; )
protected void engineInit(
java.security.spec.AlgorithmParameterSpec
java.security.SecureRandom)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =DSA )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKAlgorithmParameterGenerator; )
public class org.bouncycastle.jce.provider.JDKAlgorithmParameterGenerator$DSA extends org.bouncycastle.jce.provider.JDKAlgorithmParameterGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

protected java.security.AlgorithmParameters engineGenerateParameters()
@dalvik.annotation.Throws (value =Ljava/security/InvalidAlgorithmParameterException; )
protected void engineInit(
java.security.spec.AlgorithmParameterSpec
java.security.SecureRandom)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =IDEA )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKAlgorithmParameterGenerator; )
public class org.bouncycastle.jce.provider.JDKAlgorithmParameterGenerator$IDEA extends org.bouncycastle.jce.provider.JDKAlgorithmParameterGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

protected java.security.AlgorithmParameters engineGenerateParameters()
@dalvik.annotation.Throws (value =Ljava/security/InvalidAlgorithmParameterException; )
protected void engineInit(
java.security.spec.AlgorithmParameterSpec
java.security.SecureRandom)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKAlgorithmParameterGenerator; )
@dalvik.annotation.InnerClass (accessFlags =9 name =RC2 )
public class org.bouncycastle.jce.provider.JDKAlgorithmParameterGenerator$RC2 extends org.bouncycastle.jce.provider.JDKAlgorithmParameterGenerator

----------------FIELDS----------------

 javax.crypto.spec.RC2ParameterSpec spec
----------------METHODS----------------

public void <init>()

protected java.security.AlgorithmParameters engineGenerateParameters()
@dalvik.annotation.Throws (value =Ljava/security/InvalidAlgorithmParameterException; )
protected void engineInit(
java.security.spec.AlgorithmParameterSpec
java.security.SecureRandom)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/bouncycastle/jce/provider/JDKAlgorithmParameters$PSS;Lorg/bouncycastle/jce/provider/JDKAlgorithmParameters$OAEP;Lorg/bouncycastle/jce/provider/JDKAlgorithmParameters$IES;Lorg/bouncycastle/jce/provider/JDKAlgorithmParameters$DSA;Lorg/bouncycastle/jce/provider/JDKAlgorithmParameters$DH;Lorg/bouncycastle/jce/provider/JDKAlgorithmParameters$PKCS12PBE;Lorg/bouncycastle/jce/provider/JDKAlgorithmParameters$CAST5AlgorithmParameters;Lorg/bouncycastle/jce/provider/JDKAlgorithmParameters$RC2AlgorithmParameters;Lorg/bouncycastle/jce/provider/JDKAlgorithmParameters$IDEAAlgorithmParameters;Lorg/bouncycastle/jce/provider/JDKAlgorithmParameters$IVAlgorithmParameters; )
public abstract class org.bouncycastle.jce.provider.JDKAlgorithmParameters extends java.security.AlgorithmParametersSpi

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKAlgorithmParameters; )
@dalvik.annotation.InnerClass (accessFlags =9 name =CAST5AlgorithmParameters )
public class org.bouncycastle.jce.provider.JDKAlgorithmParameters$CAST5AlgorithmParameters extends org.bouncycastle.jce.provider.JDKAlgorithmParameters

----------------FIELDS----------------

private byte[] iv

private int keyLength
----------------METHODS----------------

public void <init>()

protected byte[] engineGetEncoded()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected byte[] engineGetEncoded(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidParameterSpecException; )
protected java.security.spec.AlgorithmParameterSpec engineGetParameterSpec(
java.lang.Class)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidParameterSpecException; )
protected void engineInit(
java.security.spec.AlgorithmParameterSpec)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void engineInit(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void engineInit(
byte[]
java.lang.String)

protected java.lang.String engineToString()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKAlgorithmParameters; )
@dalvik.annotation.InnerClass (accessFlags =9 name =DH )
public class org.bouncycastle.jce.provider.JDKAlgorithmParameters$DH extends org.bouncycastle.jce.provider.JDKAlgorithmParameters

----------------FIELDS----------------

 javax.crypto.spec.DHParameterSpec currentSpec
----------------METHODS----------------

public void <init>()

protected byte[] engineGetEncoded()

protected byte[] engineGetEncoded(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidParameterSpecException; )
protected java.security.spec.AlgorithmParameterSpec engineGetParameterSpec(
java.lang.Class)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidParameterSpecException; )
protected void engineInit(
java.security.spec.AlgorithmParameterSpec)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void engineInit(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void engineInit(
byte[]
java.lang.String)

protected java.lang.String engineToString()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =DSA )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKAlgorithmParameters; )
public class org.bouncycastle.jce.provider.JDKAlgorithmParameters$DSA extends org.bouncycastle.jce.provider.JDKAlgorithmParameters

----------------FIELDS----------------

 java.security.spec.DSAParameterSpec currentSpec
----------------METHODS----------------

public void <init>()

protected byte[] engineGetEncoded()

protected byte[] engineGetEncoded(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidParameterSpecException; )
protected java.security.spec.AlgorithmParameterSpec engineGetParameterSpec(
java.lang.Class)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidParameterSpecException; )
protected void engineInit(
java.security.spec.AlgorithmParameterSpec)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void engineInit(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void engineInit(
byte[]
java.lang.String)

protected java.lang.String engineToString()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKAlgorithmParameters; )
@dalvik.annotation.InnerClass (accessFlags =9 name =IDEAAlgorithmParameters )
public class org.bouncycastle.jce.provider.JDKAlgorithmParameters$IDEAAlgorithmParameters extends org.bouncycastle.jce.provider.JDKAlgorithmParameters

----------------FIELDS----------------

private byte[] iv
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected byte[] engineGetEncoded()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected byte[] engineGetEncoded(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidParameterSpecException; )
protected java.security.spec.AlgorithmParameterSpec engineGetParameterSpec(
java.lang.Class)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidParameterSpecException; )
protected void engineInit(
java.security.spec.AlgorithmParameterSpec)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void engineInit(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void engineInit(
byte[]
java.lang.String)

protected java.lang.String engineToString()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKAlgorithmParameters; )
@dalvik.annotation.InnerClass (accessFlags =9 name =IES )
public class org.bouncycastle.jce.provider.JDKAlgorithmParameters$IES extends org.bouncycastle.jce.provider.JDKAlgorithmParameters

----------------FIELDS----------------

 org.bouncycastle.jce.spec.IESParameterSpec currentSpec
----------------METHODS----------------

public void <init>()

protected byte[] engineGetEncoded()

protected byte[] engineGetEncoded(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidParameterSpecException; )
protected java.security.spec.AlgorithmParameterSpec engineGetParameterSpec(
java.lang.Class)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidParameterSpecException; )
protected void engineInit(
java.security.spec.AlgorithmParameterSpec)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void engineInit(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void engineInit(
byte[]
java.lang.String)

protected java.lang.String engineToString()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =IVAlgorithmParameters )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKAlgorithmParameters; )
public class org.bouncycastle.jce.provider.JDKAlgorithmParameters$IVAlgorithmParameters extends org.bouncycastle.jce.provider.JDKAlgorithmParameters

----------------FIELDS----------------

private byte[] iv
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected byte[] engineGetEncoded()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected byte[] engineGetEncoded(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidParameterSpecException; )
protected java.security.spec.AlgorithmParameterSpec engineGetParameterSpec(
java.lang.Class)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidParameterSpecException; )
protected void engineInit(
java.security.spec.AlgorithmParameterSpec)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void engineInit(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void engineInit(
byte[]
java.lang.String)

protected java.lang.String engineToString()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =OAEP )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKAlgorithmParameters; )
public class org.bouncycastle.jce.provider.JDKAlgorithmParameters$OAEP extends org.bouncycastle.jce.provider.JDKAlgorithmParameters

----------------FIELDS----------------

 javax.crypto.spec.OAEPParameterSpec currentSpec
----------------METHODS----------------

public void <init>()

protected byte[] engineGetEncoded()

protected byte[] engineGetEncoded(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidParameterSpecException; )
protected java.security.spec.AlgorithmParameterSpec engineGetParameterSpec(
java.lang.Class)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidParameterSpecException; )
protected void engineInit(
java.security.spec.AlgorithmParameterSpec)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void engineInit(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void engineInit(
byte[]
java.lang.String)

protected java.lang.String engineToString()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKAlgorithmParameters; )
@dalvik.annotation.InnerClass (accessFlags =9 name =PKCS12PBE )
public class org.bouncycastle.jce.provider.JDKAlgorithmParameters$PKCS12PBE extends org.bouncycastle.jce.provider.JDKAlgorithmParameters

----------------FIELDS----------------

 org.bouncycastle.asn1.pkcs.PKCS12PBEParams params
----------------METHODS----------------

public void <init>()

protected byte[] engineGetEncoded()

protected byte[] engineGetEncoded(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidParameterSpecException; )
protected java.security.spec.AlgorithmParameterSpec engineGetParameterSpec(
java.lang.Class)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidParameterSpecException; )
protected void engineInit(
java.security.spec.AlgorithmParameterSpec)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void engineInit(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void engineInit(
byte[]
java.lang.String)

protected java.lang.String engineToString()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKAlgorithmParameters; )
@dalvik.annotation.InnerClass (accessFlags =9 name =PSS )
public class org.bouncycastle.jce.provider.JDKAlgorithmParameters$PSS extends org.bouncycastle.jce.provider.JDKAlgorithmParameters

----------------FIELDS----------------

 java.security.spec.PSSParameterSpec currentSpec
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected byte[] engineGetEncoded()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected byte[] engineGetEncoded(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidParameterSpecException; )
protected java.security.spec.AlgorithmParameterSpec engineGetParameterSpec(
java.lang.Class)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidParameterSpecException; )
protected void engineInit(
java.security.spec.AlgorithmParameterSpec)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void engineInit(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void engineInit(
byte[]
java.lang.String)

protected java.lang.String engineToString()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =RC2AlgorithmParameters )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKAlgorithmParameters; )
public class org.bouncycastle.jce.provider.JDKAlgorithmParameters$RC2AlgorithmParameters extends org.bouncycastle.jce.provider.JDKAlgorithmParameters

----------------FIELDS----------------

private short[] ekb

private byte[] iv

private int parameterVersion

private short[] table
----------------METHODS----------------

public void <init>()

protected byte[] engineGetEncoded()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected byte[] engineGetEncoded(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidParameterSpecException; )
protected java.security.spec.AlgorithmParameterSpec engineGetParameterSpec(
java.lang.Class)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidParameterSpecException; )
protected void engineInit(
java.security.spec.AlgorithmParameterSpec)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void engineInit(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void engineInit(
byte[]
java.lang.String)

protected java.lang.String engineToString()

________________CLASS________________


public class org.bouncycastle.jce.provider.JDKDSAPrivateKey extends java.lang.Object implements java.security.interfaces.DSAPrivateKey, org.bouncycastle.jce.interfaces.PKCS12BagAttributeCarrier

----------------FIELDS----------------

 java.security.interfaces.DSAParams dsaSpec

private java.util.Hashtable pkcs12Attributes

private java.util.Vector pkcs12Ordering

 java.math.BigInteger x
----------------METHODS----------------

protected void <init>()

 void <init>(
java.security.interfaces.DSAPrivateKey)

 void <init>(
java.security.spec.DSAPrivateKeySpec)

 void <init>(
org.bouncycastle.asn1.pkcs.PrivateKeyInfo)

 void <init>(
org.bouncycastle.crypto.params.DSAPrivateKeyParameters)

public boolean equals(
java.lang.Object)

public java.lang.String getAlgorithm()

public org.bouncycastle.asn1.DEREncodable getBagAttribute(
org.bouncycastle.asn1.DERObjectIdentifier)

public java.util.Enumeration getBagAttributeKeys()

public byte[] getEncoded()

public java.lang.String getFormat()

public java.security.interfaces.DSAParams getParams()

public java.math.BigInteger getX()

public void setBagAttribute(
org.bouncycastle.asn1.DERObjectIdentifier
org.bouncycastle.asn1.DEREncodable)

________________CLASS________________


public class org.bouncycastle.jce.provider.JDKDSAPublicKey extends java.lang.Object implements java.security.interfaces.DSAPublicKey

----------------FIELDS----------------

private java.security.interfaces.DSAParams dsaSpec

private java.math.BigInteger y
----------------METHODS----------------

 void <init>(
java.math.BigInteger
java.security.spec.DSAParameterSpec)

 void <init>(
java.security.interfaces.DSAPublicKey)

 void <init>(
java.security.spec.DSAPublicKeySpec)

 void <init>(
org.bouncycastle.asn1.x509.SubjectPublicKeyInfo)

 void <init>(
org.bouncycastle.crypto.params.DSAPublicKeyParameters)

public boolean equals(
java.lang.Object)

public java.lang.String getAlgorithm()

public byte[] getEncoded()

public java.lang.String getFormat()

public java.security.interfaces.DSAParams getParams()

public java.math.BigInteger getY()

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =4104 name =null )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKDSASigner; )
 class org.bouncycastle.jce.provider.JDKDSASigner$1 extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKDSASigner; )
@dalvik.annotation.InnerClass (accessFlags =10 name =NullDigest )
 class org.bouncycastle.jce.provider.JDKDSASigner$NullDigest extends java.lang.Object implements org.bouncycastle.crypto.Digest

----------------FIELDS----------------

private java.io.ByteArrayOutputStream bOut
----------------METHODS----------------

private void <init>()

 void <init>(
org.bouncycastle.jce.provider.JDKDSASigner$1)

public int doFinal(
byte[]
int)

public java.lang.String getAlgorithmName()

public int getDigestSize()

public void reset()

public void update(
byte)

public void update(
byte[]
int
int)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/bouncycastle/jce/provider/JDKDSASigner$1;Lorg/bouncycastle/jce/provider/JDKDSASigner$NullDigest;Lorg/bouncycastle/jce/provider/JDKDSASigner$noneDSA;Lorg/bouncycastle/jce/provider/JDKDSASigner$stdDSA; )
public class org.bouncycastle.jce.provider.JDKDSASigner extends java.security.Signature implements org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers, org.bouncycastle.asn1.x509.X509ObjectIdentifiers

----------------FIELDS----------------

private org.bouncycastle.crypto.Digest digest

private java.security.SecureRandom random

private org.bouncycastle.crypto.DSA signer
----------------METHODS----------------

protected void <init>(
java.lang.String
org.bouncycastle.crypto.Digest
org.bouncycastle.crypto.DSA)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private java.math.BigInteger[] derDecode(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private byte[] derEncode(
java.math.BigInteger
java.math.BigInteger)

protected java.lang.Object engineGetParameter(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
protected void engineInitSign(
java.security.PrivateKey)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
protected void engineInitSign(
java.security.PrivateKey
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
protected void engineInitVerify(
java.security.PublicKey)

protected void engineSetParameter(
java.lang.String
java.lang.Object)

protected void engineSetParameter(
java.security.spec.AlgorithmParameterSpec)
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
protected byte[] engineSign()
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
protected void engineUpdate(
byte)
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
protected void engineUpdate(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
protected boolean engineVerify(
byte[])

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKDSASigner; )
@dalvik.annotation.InnerClass (accessFlags =9 name =noneDSA )
public class org.bouncycastle.jce.provider.JDKDSASigner$noneDSA extends org.bouncycastle.jce.provider.JDKDSASigner

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =stdDSA )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKDSASigner; )
public class org.bouncycastle.jce.provider.JDKDSASigner$stdDSA extends org.bouncycastle.jce.provider.JDKDSASigner

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/bouncycastle/jce/provider/JDKDigestSignature$MD5WithRSAEncryption;Lorg/bouncycastle/jce/provider/JDKDigestSignature$MD4WithRSAEncryption;Lorg/bouncycastle/jce/provider/JDKDigestSignature$MD2WithRSAEncryption;Lorg/bouncycastle/jce/provider/JDKDigestSignature$SHA512WithRSAEncryption;Lorg/bouncycastle/jce/provider/JDKDigestSignature$SHA384WithRSAEncryption;Lorg/bouncycastle/jce/provider/JDKDigestSignature$SHA256WithRSAEncryption;Lorg/bouncycastle/jce/provider/JDKDigestSignature$SHA224WithRSAEncryption;Lorg/bouncycastle/jce/provider/JDKDigestSignature$SHA1WithRSAEncryption; )
public class org.bouncycastle.jce.provider.JDKDigestSignature extends java.security.Signature implements org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers, org.bouncycastle.asn1.x509.X509ObjectIdentifiers

----------------FIELDS----------------

private org.bouncycastle.asn1.x509.AlgorithmIdentifier algId

private org.bouncycastle.crypto.AsymmetricBlockCipher cipher

private org.bouncycastle.crypto.Digest digest
----------------METHODS----------------

protected void <init>(
java.lang.String
org.bouncycastle.asn1.DERObjectIdentifier
org.bouncycastle.crypto.Digest
org.bouncycastle.crypto.AsymmetricBlockCipher)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private byte[] derEncode(
byte[])

private java.lang.String getType(
java.lang.Object)

protected java.lang.Object engineGetParameter(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
protected void engineInitSign(
java.security.PrivateKey)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
protected void engineInitVerify(
java.security.PublicKey)

protected void engineSetParameter(
java.lang.String
java.lang.Object)

protected void engineSetParameter(
java.security.spec.AlgorithmParameterSpec)
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
protected byte[] engineSign()
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
protected void engineUpdate(
byte)
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
protected void engineUpdate(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
protected boolean engineVerify(
byte[])

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =MD2WithRSAEncryption )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKDigestSignature; )
public class org.bouncycastle.jce.provider.JDKDigestSignature$MD2WithRSAEncryption extends org.bouncycastle.jce.provider.JDKDigestSignature

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKDigestSignature; )
@dalvik.annotation.InnerClass (accessFlags =9 name =MD4WithRSAEncryption )
public class org.bouncycastle.jce.provider.JDKDigestSignature$MD4WithRSAEncryption extends org.bouncycastle.jce.provider.JDKDigestSignature

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =MD5WithRSAEncryption )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKDigestSignature; )
public class org.bouncycastle.jce.provider.JDKDigestSignature$MD5WithRSAEncryption extends org.bouncycastle.jce.provider.JDKDigestSignature

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =SHA1WithRSAEncryption )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKDigestSignature; )
public class org.bouncycastle.jce.provider.JDKDigestSignature$SHA1WithRSAEncryption extends org.bouncycastle.jce.provider.JDKDigestSignature

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =SHA224WithRSAEncryption )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKDigestSignature; )
public class org.bouncycastle.jce.provider.JDKDigestSignature$SHA224WithRSAEncryption extends org.bouncycastle.jce.provider.JDKDigestSignature

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =SHA256WithRSAEncryption )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKDigestSignature; )
public class org.bouncycastle.jce.provider.JDKDigestSignature$SHA256WithRSAEncryption extends org.bouncycastle.jce.provider.JDKDigestSignature

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =SHA384WithRSAEncryption )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKDigestSignature; )
public class org.bouncycastle.jce.provider.JDKDigestSignature$SHA384WithRSAEncryption extends org.bouncycastle.jce.provider.JDKDigestSignature

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =SHA512WithRSAEncryption )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKDigestSignature; )
public class org.bouncycastle.jce.provider.JDKDigestSignature$SHA512WithRSAEncryption extends org.bouncycastle.jce.provider.JDKDigestSignature

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =SigAlgParameters )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKECDSAAlgParameters; )
public class org.bouncycastle.jce.provider.JDKECDSAAlgParameters$SigAlgParameters extends org.bouncycastle.jce.provider.JDKAlgorithmParameters

----------------FIELDS----------------

private org.bouncycastle.asn1.DEREncodable params
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected byte[] engineGetEncoded()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected byte[] engineGetEncoded(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidParameterSpecException; )
protected java.security.spec.AlgorithmParameterSpec engineGetParameterSpec(
java.lang.Class)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidParameterSpecException; )
protected void engineInit(
java.security.spec.AlgorithmParameterSpec)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void engineInit(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void engineInit(
byte[]
java.lang.String)

protected java.lang.String engineToString()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/bouncycastle/jce/provider/JDKECDSAAlgParameters$SigAlgParameters; )
public abstract class org.bouncycastle.jce.provider.JDKECDSAAlgParameters extends java.security.AlgorithmParametersSpi

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/bouncycastle/jce/provider/JDKISOSignature$MD5WithRSAEncryption;Lorg/bouncycastle/jce/provider/JDKISOSignature$SHA1WithRSAEncryption; )
public class org.bouncycastle.jce.provider.JDKISOSignature extends java.security.Signature

----------------FIELDS----------------

private org.bouncycastle.crypto.signers.ISO9796d2Signer signer
----------------METHODS----------------

protected void <init>(
java.lang.String
org.bouncycastle.crypto.Digest
org.bouncycastle.crypto.AsymmetricBlockCipher)

protected java.lang.Object engineGetParameter(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
protected void engineInitSign(
java.security.PrivateKey)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
protected void engineInitVerify(
java.security.PublicKey)

protected void engineSetParameter(
java.lang.String
java.lang.Object)

protected void engineSetParameter(
java.security.spec.AlgorithmParameterSpec)
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
protected byte[] engineSign()
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
protected void engineUpdate(
byte)
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
protected void engineUpdate(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
protected boolean engineVerify(
byte[])

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKISOSignature; )
@dalvik.annotation.InnerClass (accessFlags =9 name =MD5WithRSAEncryption )
public class org.bouncycastle.jce.provider.JDKISOSignature$MD5WithRSAEncryption extends org.bouncycastle.jce.provider.JDKISOSignature

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKISOSignature; )
@dalvik.annotation.InnerClass (accessFlags =9 name =SHA1WithRSAEncryption )
public class org.bouncycastle.jce.provider.JDKISOSignature$SHA1WithRSAEncryption extends org.bouncycastle.jce.provider.JDKISOSignature

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/bouncycastle/jce/provider/JDKKeyFactory$ECDHC;Lorg/bouncycastle/jce/provider/JDKKeyFactory$ECDH;Lorg/bouncycastle/jce/provider/JDKKeyFactory$ECGOST3410;Lorg/bouncycastle/jce/provider/JDKKeyFactory$ECDSA;Lorg/bouncycastle/jce/provider/JDKKeyFactory$EC;Lorg/bouncycastle/jce/provider/JDKKeyFactory$X509;Lorg/bouncycastle/jce/provider/JDKKeyFactory$ElGamal;Lorg/bouncycastle/jce/provider/JDKKeyFactory$GOST3410;Lorg/bouncycastle/jce/provider/JDKKeyFactory$DSA;Lorg/bouncycastle/jce/provider/JDKKeyFactory$DH;Lorg/bouncycastle/jce/provider/JDKKeyFactory$RSA; )
public abstract class org.bouncycastle.jce.provider.JDKKeyFactory extends java.security.KeyFactorySpi

----------------FIELDS----------------

protected boolean elGamalFactory
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
static java.security.PrivateKey createPrivateKeyFromDERStream(
byte[])

static java.security.PrivateKey createPrivateKeyFromPrivateKeyInfo(
org.bouncycastle.asn1.pkcs.PrivateKeyInfo)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
static java.security.PublicKey createPublicKeyFromDERStream(
byte[])

static java.security.PublicKey createPublicKeyFromPublicKeyInfo(
org.bouncycastle.asn1.x509.SubjectPublicKeyInfo)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidKeySpecException; )
protected java.security.spec.KeySpec engineGetKeySpec(
java.security.Key
java.lang.Class)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
protected java.security.Key engineTranslateKey(
java.security.Key)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKKeyFactory; )
@dalvik.annotation.InnerClass (accessFlags =9 name =DH )
public class org.bouncycastle.jce.provider.JDKKeyFactory$DH extends org.bouncycastle.jce.provider.JDKKeyFactory

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidKeySpecException; )
protected java.security.PrivateKey engineGeneratePrivate(
java.security.spec.KeySpec)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidKeySpecException; )
protected java.security.PublicKey engineGeneratePublic(
java.security.spec.KeySpec)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKKeyFactory; )
@dalvik.annotation.InnerClass (accessFlags =9 name =DSA )
public class org.bouncycastle.jce.provider.JDKKeyFactory$DSA extends org.bouncycastle.jce.provider.JDKKeyFactory

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidKeySpecException; )
protected java.security.PrivateKey engineGeneratePrivate(
java.security.spec.KeySpec)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidKeySpecException; )
protected java.security.PublicKey engineGeneratePublic(
java.security.spec.KeySpec)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =EC )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKKeyFactory; )
public class org.bouncycastle.jce.provider.JDKKeyFactory$EC extends org.bouncycastle.jce.provider.JDKKeyFactory

----------------FIELDS----------------

 java.lang.String algorithm
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidKeySpecException; )
protected java.security.PrivateKey engineGeneratePrivate(
java.security.spec.KeySpec)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidKeySpecException; )
protected java.security.PublicKey engineGeneratePublic(
java.security.spec.KeySpec)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =ECDH )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKKeyFactory; )
public class org.bouncycastle.jce.provider.JDKKeyFactory$ECDH extends org.bouncycastle.jce.provider.JDKKeyFactory$EC

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =ECDHC )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKKeyFactory; )
public class org.bouncycastle.jce.provider.JDKKeyFactory$ECDHC extends org.bouncycastle.jce.provider.JDKKeyFactory$EC

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =ECDSA )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKKeyFactory; )
public class org.bouncycastle.jce.provider.JDKKeyFactory$ECDSA extends org.bouncycastle.jce.provider.JDKKeyFactory$EC

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =ECGOST3410 )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKKeyFactory; )
public class org.bouncycastle.jce.provider.JDKKeyFactory$ECGOST3410 extends org.bouncycastle.jce.provider.JDKKeyFactory$EC

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKKeyFactory; )
@dalvik.annotation.InnerClass (accessFlags =9 name =ElGamal )
public class org.bouncycastle.jce.provider.JDKKeyFactory$ElGamal extends org.bouncycastle.jce.provider.JDKKeyFactory

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidKeySpecException; )
protected java.security.PrivateKey engineGeneratePrivate(
java.security.spec.KeySpec)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidKeySpecException; )
protected java.security.PublicKey engineGeneratePublic(
java.security.spec.KeySpec)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKKeyFactory; )
@dalvik.annotation.InnerClass (accessFlags =9 name =GOST3410 )
public class org.bouncycastle.jce.provider.JDKKeyFactory$GOST3410 extends org.bouncycastle.jce.provider.JDKKeyFactory

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidKeySpecException; )
protected java.security.PrivateKey engineGeneratePrivate(
java.security.spec.KeySpec)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidKeySpecException; )
protected java.security.PublicKey engineGeneratePublic(
java.security.spec.KeySpec)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =RSA )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKKeyFactory; )
public class org.bouncycastle.jce.provider.JDKKeyFactory$RSA extends org.bouncycastle.jce.provider.JDKKeyFactory

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidKeySpecException; )
protected java.security.PrivateKey engineGeneratePrivate(
java.security.spec.KeySpec)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidKeySpecException; )
protected java.security.PublicKey engineGeneratePublic(
java.security.spec.KeySpec)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKKeyFactory; )
@dalvik.annotation.InnerClass (accessFlags =9 name =X509 )
public class org.bouncycastle.jce.provider.JDKKeyFactory$X509 extends org.bouncycastle.jce.provider.JDKKeyFactory

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidKeySpecException; )
protected java.security.PrivateKey engineGeneratePrivate(
java.security.spec.KeySpec)
@dalvik.annotation.Throws (value =Ljava/security/spec/InvalidKeySpecException; )
protected java.security.PublicKey engineGeneratePublic(
java.security.spec.KeySpec)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/bouncycastle/jce/provider/JDKKeyPairGenerator$DSA;Lorg/bouncycastle/jce/provider/JDKKeyPairGenerator$DH;Lorg/bouncycastle/jce/provider/JDKKeyPairGenerator$RSA; )
public abstract class org.bouncycastle.jce.provider.JDKKeyPairGenerator extends java.security.KeyPairGenerator

----------------FIELDS----------------
----------------METHODS----------------

public void <init>(
java.lang.String)

public abstract java.security.KeyPair generateKeyPair()

public abstract void initialize(
int
java.security.SecureRandom)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =DH )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKKeyPairGenerator; )
public class org.bouncycastle.jce.provider.JDKKeyPairGenerator$DH extends org.bouncycastle.jce.provider.JDKKeyPairGenerator

----------------FIELDS----------------

 int certainty

 org.bouncycastle.crypto.generators.DHBasicKeyPairGenerator engine

 boolean initialised

 org.bouncycastle.crypto.params.DHKeyGenerationParameters param

 java.security.SecureRandom random

 int strength
----------------METHODS----------------

public void <init>()

public java.security.KeyPair generateKeyPair()

public void initialize(
int
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/InvalidAlgorithmParameterException; )
public void initialize(
java.security.spec.AlgorithmParameterSpec
java.security.SecureRandom)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKKeyPairGenerator; )
@dalvik.annotation.InnerClass (accessFlags =9 name =DSA )
public class org.bouncycastle.jce.provider.JDKKeyPairGenerator$DSA extends org.bouncycastle.jce.provider.JDKKeyPairGenerator

----------------FIELDS----------------

 int certainty

 org.bouncycastle.crypto.generators.DSAKeyPairGenerator engine

 boolean initialised

 org.bouncycastle.crypto.params.DSAKeyGenerationParameters param

 java.security.SecureRandom random

 int strength
----------------METHODS----------------

public void <init>()

public java.security.KeyPair generateKeyPair()

public void initialize(
int
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/InvalidAlgorithmParameterException; )
public void initialize(
java.security.spec.AlgorithmParameterSpec
java.security.SecureRandom)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKKeyPairGenerator; )
@dalvik.annotation.InnerClass (accessFlags =9 name =RSA )
public class org.bouncycastle.jce.provider.JDKKeyPairGenerator$RSA extends org.bouncycastle.jce.provider.JDKKeyPairGenerator

----------------FIELDS----------------

static final java.math.BigInteger defaultPublicExponent

static final int defaultTests

 org.bouncycastle.crypto.generators.RSAKeyPairGenerator engine

 org.bouncycastle.crypto.params.RSAKeyGenerationParameters param
----------------METHODS----------------

static void <clinit>()

public void <init>()

public java.security.KeyPair generateKeyPair()

public void initialize(
int
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/InvalidAlgorithmParameterException; )
public void initialize(
java.security.spec.AlgorithmParameterSpec
java.security.SecureRandom)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/bouncycastle/jce/provider/JDKKeyStore$BouncyCastleStore;Lorg/bouncycastle/jce/provider/JDKKeyStore$StoreEntry; )
public class org.bouncycastle.jce.provider.JDKKeyStore extends java.security.KeyStoreSpi implements org.bouncycastle.jce.interfaces.BCKeyStore

----------------FIELDS----------------

static final int CERTIFICATE

static final int KEY

private static final java.lang.String KEY_CIPHER

static final int KEY_PRIVATE

static final int KEY_PUBLIC

private static final int KEY_SALT_SIZE

static final int KEY_SECRET

private static final int MIN_ITERATIONS

static final int NULL

static final int SEALED

static final int SECRET

private static final java.lang.String STORE_CIPHER

private static final int STORE_SALT_SIZE

private static final int STORE_VERSION

protected java.security.SecureRandom random

protected java.util.Hashtable table
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
static void access$000(
org.bouncycastle.jce.provider.JDKKeyStore
java.security.Key
java.io.DataOutputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
static java.security.Key access$100(
org.bouncycastle.jce.provider.JDKKeyStore
java.io.DataInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private java.security.cert.Certificate decodeCertificate(
java.io.DataInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private java.security.Key decodeKey(
java.io.DataInputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void encodeCertificate(
java.security.cert.Certificate
java.io.DataOutputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void encodeKey(
java.security.Key
java.io.DataOutputStream)

public java.util.Enumeration engineAliases()

public boolean engineContainsAlias(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException; )
public void engineDeleteEntry(
java.lang.String)

public java.security.cert.Certificate engineGetCertificate(
java.lang.String)

public java.lang.String engineGetCertificateAlias(
java.security.cert.Certificate)

public java.security.cert.Certificate[] engineGetCertificateChain(
java.lang.String)

public java.util.Date engineGetCreationDate(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/UnrecoverableKeyException; )
public java.security.Key engineGetKey(
java.lang.String
char[])

public boolean engineIsCertificateEntry(
java.lang.String)

public boolean engineIsKeyEntry(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void engineLoad(
java.io.InputStream
char[])
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException; )
public void engineSetCertificateEntry(
java.lang.String
java.security.cert.Certificate)
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException; )
public void engineSetKeyEntry(
java.lang.String
java.security.Key
char[]
java.security.cert.Certificate[])
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException; )
public void engineSetKeyEntry(
java.lang.String
byte[]
java.security.cert.Certificate[])

public int engineSize()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void engineStore(
java.io.OutputStream
char[])

protected boolean isSameAs(
byte[]
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void loadStore(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected javax.crypto.Cipher makePBECipher(
java.lang.String
int
char[]
byte[]
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected void saveStore(
java.io.OutputStream)

public void setRandom(
java.security.SecureRandom)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =BouncyCastleStore )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKKeyStore; )
public class org.bouncycastle.jce.provider.JDKKeyStore$BouncyCastleStore extends org.bouncycastle.jce.provider.JDKKeyStore

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void engineLoad(
java.io.InputStream
char[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void engineStore(
java.io.OutputStream
char[])

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =2 name =StoreEntry )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKKeyStore; )
 class org.bouncycastle.jce.provider.JDKKeyStore$StoreEntry extends java.lang.Object

----------------FIELDS----------------

 java.lang.String alias

 java.security.cert.Certificate[] certChain

 java.util.Date date

 java.lang.Object obj

final org.bouncycastle.jce.provider.JDKKeyStore this$0

 int type
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/lang/Exception; )
 void <init>(
org.bouncycastle.jce.provider.JDKKeyStore
java.lang.String
java.security.Key
char[]
java.security.cert.Certificate[])

 void <init>(
org.bouncycastle.jce.provider.JDKKeyStore
java.lang.String
java.security.Key
java.security.cert.Certificate[])

 void <init>(
org.bouncycastle.jce.provider.JDKKeyStore
java.lang.String
java.security.cert.Certificate)

 void <init>(
org.bouncycastle.jce.provider.JDKKeyStore
java.lang.String
java.util.Date
int
java.lang.Object)

 void <init>(
org.bouncycastle.jce.provider.JDKKeyStore
java.lang.String
java.util.Date
int
java.lang.Object
java.security.cert.Certificate[])

 void <init>(
org.bouncycastle.jce.provider.JDKKeyStore
java.lang.String
byte[]
java.security.cert.Certificate[])

 java.lang.String getAlias()

 java.security.cert.Certificate[] getCertificateChain()

 java.util.Date getDate()

 java.lang.Object getObject()
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/UnrecoverableKeyException; )
 java.lang.Object getObject(
char[])

 int getType()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/bouncycastle/jce/provider/JDKMessageDigest$MD5;Lorg/bouncycastle/jce/provider/JDKMessageDigest$SHA512;Lorg/bouncycastle/jce/provider/JDKMessageDigest$SHA384;Lorg/bouncycastle/jce/provider/JDKMessageDigest$SHA256;Lorg/bouncycastle/jce/provider/JDKMessageDigest$SHA224;Lorg/bouncycastle/jce/provider/JDKMessageDigest$SHA1; )
public class org.bouncycastle.jce.provider.JDKMessageDigest extends java.security.MessageDigest

----------------FIELDS----------------

 org.bouncycastle.crypto.Digest digest
----------------METHODS----------------

protected void <init>(
org.bouncycastle.crypto.Digest)

public byte[] engineDigest()

public void engineReset()

public void engineUpdate(
byte)

public void engineUpdate(
byte[]
int
int)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =MD5 )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKMessageDigest; )
public class org.bouncycastle.jce.provider.JDKMessageDigest$MD5 extends org.bouncycastle.jce.provider.JDKMessageDigest implements java.lang.Cloneable

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/lang/CloneNotSupportedException; )
public java.lang.Object clone()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =SHA1 )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKMessageDigest; )
public class org.bouncycastle.jce.provider.JDKMessageDigest$SHA1 extends org.bouncycastle.jce.provider.JDKMessageDigest implements java.lang.Cloneable

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/lang/CloneNotSupportedException; )
public java.lang.Object clone()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKMessageDigest; )
@dalvik.annotation.InnerClass (accessFlags =9 name =SHA224 )
public class org.bouncycastle.jce.provider.JDKMessageDigest$SHA224 extends org.bouncycastle.jce.provider.JDKMessageDigest implements java.lang.Cloneable

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/lang/CloneNotSupportedException; )
public java.lang.Object clone()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =SHA256 )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKMessageDigest; )
public class org.bouncycastle.jce.provider.JDKMessageDigest$SHA256 extends org.bouncycastle.jce.provider.JDKMessageDigest implements java.lang.Cloneable

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/lang/CloneNotSupportedException; )
public java.lang.Object clone()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =SHA384 )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKMessageDigest; )
public class org.bouncycastle.jce.provider.JDKMessageDigest$SHA384 extends org.bouncycastle.jce.provider.JDKMessageDigest implements java.lang.Cloneable

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/lang/CloneNotSupportedException; )
public java.lang.Object clone()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =SHA512 )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKMessageDigest; )
public class org.bouncycastle.jce.provider.JDKMessageDigest$SHA512 extends org.bouncycastle.jce.provider.JDKMessageDigest implements java.lang.Cloneable

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/lang/CloneNotSupportedException; )
public java.lang.Object clone()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/bouncycastle/jce/provider/JDKPKCS12KeyStore$DefPKCS12KeyStore;Lorg/bouncycastle/jce/provider/JDKPKCS12KeyStore$BCPKCS12KeyStore;Lorg/bouncycastle/jce/provider/JDKPKCS12KeyStore$CertId; )
public class org.bouncycastle.jce.provider.JDKPKCS12KeyStore extends java.security.KeyStoreSpi implements org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers, org.bouncycastle.asn1.x509.X509ObjectIdentifiers, org.bouncycastle.jce.interfaces.BCKeyStore

----------------FIELDS----------------

static final int CERTIFICATE

private static final java.lang.String CERT_ALGORITHM

static final int KEY

private static final java.lang.String KEY_ALGORITHM

static final int KEY_PRIVATE

static final int KEY_PUBLIC

static final int KEY_SECRET

private static final int MIN_ITERATIONS

static final int NULL

private static final int SALT_SIZE

static final int SEALED

static final int SECRET

private java.security.cert.CertificateFactory certFact

private java.util.Hashtable certs

private java.util.Hashtable chainCerts

private java.util.Hashtable keyCerts

private java.util.Hashtable keys

private java.util.Hashtable localIds

protected java.security.SecureRandom random
----------------METHODS----------------

public void <init>(
java.lang.String)

static org.bouncycastle.asn1.x509.SubjectKeyIdentifier access$000(
org.bouncycastle.jce.provider.JDKPKCS12KeyStore
java.security.PublicKey)

private org.bouncycastle.asn1.x509.SubjectKeyIdentifier createSubjectKeyId(
java.security.PublicKey)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected org.bouncycastle.asn1.ASN1Sequence decryptData(
org.bouncycastle.asn1.x509.AlgorithmIdentifier
byte[]
char[]
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected byte[] encryptData(
java.lang.String
byte[]
org.bouncycastle.asn1.pkcs.PKCS12PBEParams
char[])

public java.util.Enumeration engineAliases()

public boolean engineContainsAlias(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException; )
public void engineDeleteEntry(
java.lang.String)

public java.security.cert.Certificate engineGetCertificate(
java.lang.String)

public java.lang.String engineGetCertificateAlias(
java.security.cert.Certificate)

public java.security.cert.Certificate[] engineGetCertificateChain(
java.lang.String)

public java.util.Date engineGetCreationDate(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/UnrecoverableKeyException; )
public java.security.Key engineGetKey(
java.lang.String
char[])

public boolean engineIsCertificateEntry(
java.lang.String)

public boolean engineIsKeyEntry(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void engineLoad(
java.io.InputStream
char[])
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException; )
public void engineSetCertificateEntry(
java.lang.String
java.security.cert.Certificate)
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException; )
public void engineSetKeyEntry(
java.lang.String
java.security.Key
char[]
java.security.cert.Certificate[])
@dalvik.annotation.Throws (value =Ljava/security/KeyStoreException; )
public void engineSetKeyEntry(
java.lang.String
byte[]
java.security.cert.Certificate[])

public int engineSize()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void engineStore(
java.io.OutputStream
char[])

public void setRandom(
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected java.security.PrivateKey unwrapKey(
org.bouncycastle.asn1.x509.AlgorithmIdentifier
byte[]
char[]
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
protected byte[] wrapKey(
java.lang.String
java.security.Key
org.bouncycastle.asn1.pkcs.PKCS12PBEParams
char[])

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =BCPKCS12KeyStore )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKPKCS12KeyStore; )
public class org.bouncycastle.jce.provider.JDKPKCS12KeyStore$BCPKCS12KeyStore extends org.bouncycastle.jce.provider.JDKPKCS12KeyStore

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =2 name =CertId )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKPKCS12KeyStore; )
 class org.bouncycastle.jce.provider.JDKPKCS12KeyStore$CertId extends java.lang.Object

----------------FIELDS----------------

 byte[] id

final org.bouncycastle.jce.provider.JDKPKCS12KeyStore this$0
----------------METHODS----------------

 void <init>(
org.bouncycastle.jce.provider.JDKPKCS12KeyStore
java.security.PublicKey)

 void <init>(
org.bouncycastle.jce.provider.JDKPKCS12KeyStore
byte[])

public boolean equals(
java.lang.Object)

public int hashCode()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKPKCS12KeyStore; )
@dalvik.annotation.InnerClass (accessFlags =9 name =DefPKCS12KeyStore )
public class org.bouncycastle.jce.provider.JDKPKCS12KeyStore$DefPKCS12KeyStore extends org.bouncycastle.jce.provider.JDKPKCS12KeyStore

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/bouncycastle/jce/provider/JDKPSSSigner$SHA512withRSA;Lorg/bouncycastle/jce/provider/JDKPSSSigner$SHA384withRSA;Lorg/bouncycastle/jce/provider/JDKPSSSigner$SHA256withRSA;Lorg/bouncycastle/jce/provider/JDKPSSSigner$SHA224withRSA;Lorg/bouncycastle/jce/provider/JDKPSSSigner$SHA1withRSA;Lorg/bouncycastle/jce/provider/JDKPSSSigner$PSSwithRSA; )
public class org.bouncycastle.jce.provider.JDKPSSSigner extends java.security.Signature

----------------FIELDS----------------

private org.bouncycastle.crypto.Digest digest

private java.security.AlgorithmParameters engineParams

private java.security.spec.PSSParameterSpec originalSpec

private java.security.spec.PSSParameterSpec paramSpec

private org.bouncycastle.crypto.signers.PSSSigner pss

private int saltLength

private org.bouncycastle.crypto.AsymmetricBlockCipher signer

private byte trailer
----------------METHODS----------------

protected void <init>(
java.lang.String
org.bouncycastle.crypto.AsymmetricBlockCipher
java.security.spec.PSSParameterSpec)

private byte getTrailer(
int)

protected java.lang.Object engineGetParameter(
java.lang.String)

protected java.security.AlgorithmParameters engineGetParameters()
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
protected void engineInitSign(
java.security.PrivateKey)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
protected void engineInitSign(
java.security.PrivateKey
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
protected void engineInitVerify(
java.security.PublicKey)

protected void engineSetParameter(
java.lang.String
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/security/InvalidParameterException; )
protected void engineSetParameter(
java.security.spec.AlgorithmParameterSpec)
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
protected byte[] engineSign()
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
protected void engineUpdate(
byte)
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
protected void engineUpdate(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/security/SignatureException; )
protected boolean engineVerify(
byte[])

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =PSSwithRSA )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKPSSSigner; )
public class org.bouncycastle.jce.provider.JDKPSSSigner$PSSwithRSA extends org.bouncycastle.jce.provider.JDKPSSSigner

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =SHA1withRSA )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKPSSSigner; )
public class org.bouncycastle.jce.provider.JDKPSSSigner$SHA1withRSA extends org.bouncycastle.jce.provider.JDKPSSSigner

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =SHA224withRSA )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKPSSSigner; )
public class org.bouncycastle.jce.provider.JDKPSSSigner$SHA224withRSA extends org.bouncycastle.jce.provider.JDKPSSSigner

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =SHA256withRSA )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKPSSSigner; )
public class org.bouncycastle.jce.provider.JDKPSSSigner$SHA256withRSA extends org.bouncycastle.jce.provider.JDKPSSSigner

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKPSSSigner; )
@dalvik.annotation.InnerClass (accessFlags =9 name =SHA384withRSA )
public class org.bouncycastle.jce.provider.JDKPSSSigner$SHA384withRSA extends org.bouncycastle.jce.provider.JDKPSSSigner

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =SHA512withRSA )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/JDKPSSSigner; )
public class org.bouncycastle.jce.provider.JDKPSSSigner$SHA512withRSA extends org.bouncycastle.jce.provider.JDKPSSSigner

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________


public class org.bouncycastle.jce.provider.JDKX509CertificateFactory extends java.security.cert.CertificateFactorySpi

----------------FIELDS----------------

private static final long MAX_MEMORY

private java.io.InputStream currentCrlStream

private java.io.InputStream currentStream

private org.bouncycastle.asn1.pkcs.SignedData sCrlData

private int sCrlDataObjectCount

private org.bouncycastle.asn1.pkcs.SignedData sData

private int sDataObjectCount
----------------METHODS----------------

static void <clinit>()

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private int getLimit(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/security/cert/CRLException; )
private java.security.cert.CRL readDERCRL(
org.bouncycastle.asn1.ASN1InputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private java.security.cert.Certificate readDERCertificate(
org.bouncycastle.asn1.ASN1InputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private java.lang.String readLine(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/security/cert/CRLException; )
private java.security.cert.CRL readPEMCRL(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private java.security.cert.Certificate readPEMCertificate(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/security/cert/CRLException; )
private java.security.cert.CRL readPKCS7CRL(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private java.security.cert.Certificate readPKCS7Certificate(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/security/cert/CRLException; )
public java.security.cert.CRL engineGenerateCRL(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/security/cert/CRLException; )
public java.util.Collection engineGenerateCRLs(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException; )
public java.security.cert.CertPath engineGenerateCertPath(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException; )
public java.security.cert.CertPath engineGenerateCertPath(
java.io.InputStream
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException; )
public java.security.cert.CertPath engineGenerateCertPath(
java.util.List)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException; )
public java.security.cert.Certificate engineGenerateCertificate(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException; )
public java.util.Collection engineGenerateCertificates(
java.io.InputStream)

public java.util.Iterator engineGetCertPathEncodings()

________________CLASS________________


 class org.bouncycastle.jce.provider.OldPKCS12ParametersGenerator extends org.bouncycastle.crypto.PBEParametersGenerator

----------------FIELDS----------------

public static final int IV_MATERIAL

public static final int KEY_MATERIAL

public static final int MAC_MATERIAL

private org.bouncycastle.crypto.Digest digest

private int u

private int v
----------------METHODS----------------

public void <init>(
org.bouncycastle.crypto.Digest)

private void adjust(
byte[]
int
byte[])

private byte[] generateDerivedKey(
int
int)

public org.bouncycastle.crypto.CipherParameters generateDerivedMacParameters(
int)

public org.bouncycastle.crypto.CipherParameters generateDerivedParameters(
int)

public org.bouncycastle.crypto.CipherParameters generateDerivedParameters(
int
int)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =Util )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/PBE; )
public class org.bouncycastle.jce.provider.PBE$Util extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

private static org.bouncycastle.crypto.PBEParametersGenerator makePBEGenerator(
int
int)

static org.bouncycastle.crypto.CipherParameters makePBEMacParameters(
javax.crypto.spec.PBEKeySpec
int
int
int)

static org.bouncycastle.crypto.CipherParameters makePBEMacParameters(
org.bouncycastle.jce.provider.JCEPBEKey
java.security.spec.AlgorithmParameterSpec)

static org.bouncycastle.crypto.CipherParameters makePBEParameters(
javax.crypto.spec.PBEKeySpec
int
int
int
int)

static org.bouncycastle.crypto.CipherParameters makePBEParameters(
org.bouncycastle.jce.provider.JCEPBEKey
java.security.spec.AlgorithmParameterSpec
java.lang.String)

________________CLASS________________


public class org.bouncycastle.jce.provider.PKIXCertPath extends java.security.cert.CertPath

----------------FIELDS----------------

static final java.util.List certPathEncodings

private java.util.List certificates
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException; )
 void <init>(
java.io.InputStream
java.lang.String)

 void <init>(
java.util.List)

private java.util.List sortCerts(
java.util.List)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateEncodingException; )
private org.bouncycastle.asn1.DERObject toASN1Object(
java.security.cert.X509Certificate)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateEncodingException; )
private byte[] toDEREncoded(
org.bouncycastle.asn1.ASN1Encodable)

public java.util.List getCertificates()
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateEncodingException; )
public byte[] getEncoded()
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateEncodingException; )
public byte[] getEncoded(
java.lang.String)

public java.util.Iterator getEncodings()

________________CLASS________________


public class org.bouncycastle.jce.provider.PKIXCertPathBuilderSpi extends java.security.cert.CertPathBuilderSpi

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/security/cert/CertStoreException; )
private final java.util.Collection findCertificates(
java.security.cert.CertSelector
java.util.List)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertPathValidatorException; )
private final java.security.cert.X509Certificate findIssuer(
java.security.cert.X509Certificate
java.util.List)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertPathBuilderException;Ljava/security/InvalidAlgorithmParameterException; )
public java.security.cert.CertPathBuilderResult engineBuild(
java.security.cert.CertPathParameters)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertPathBuilderException; )
final java.security.cert.TrustAnchor findTrustAnchor(
java.security.cert.X509Certificate
java.util.Set)

________________CLASS________________


public class org.bouncycastle.jce.provider.PKIXCertPathValidatorSpi extends java.security.cert.CertPathValidatorSpi

----------------FIELDS----------------

private static final java.lang.String ANY_POLICY

private static final java.lang.String BASIC_CONSTRAINTS

private static final java.lang.String CERTIFICATE_POLICIES

private static final java.lang.String CRL_NUMBER

private static final int CRL_SIGN

private static final java.lang.String DELTA_CRL_INDICATOR

private static final java.lang.String INHIBIT_ANY_POLICY

private static final java.lang.String ISSUING_DISTRIBUTION_POINT

private static final int KEY_CERT_SIGN

private static final java.lang.String KEY_USAGE

private static final java.lang.String NAME_CONSTRAINTS

private static final java.lang.String POLICY_CONSTRAINTS

private static final java.lang.String POLICY_MAPPINGS

private static final java.lang.String SUBJECT_ALTERNATIVE_NAME

private static final java.lang.String[] crlReasons
----------------METHODS----------------

static void <clinit>()

public void <init>()
@dalvik.annotation.Throws (value =Lorg/bouncycastle/jce/provider/AnnotatedException; )
private void checkCRLs(
java.security.cert.PKIXParameters
java.security.cert.X509Certificate
java.util.Date
java.security.cert.X509Certificate
java.security.PublicKey)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertPathValidatorException;Ljava/security/InvalidAlgorithmParameterException; )
public java.security.cert.CertPathValidatorResult engineValidate(
java.security.cert.CertPath
java.security.cert.CertPathParameters)

________________CLASS________________


public class org.bouncycastle.jce.provider.PKIXPolicyNode extends java.lang.Object implements java.security.cert.PolicyNode

----------------FIELDS----------------

protected java.util.List children

protected boolean critical

protected int depth

protected java.util.Set expectedPolicies

protected java.security.cert.PolicyNode parent

protected java.util.Set policyQualifiers

protected java.lang.String validPolicy
----------------METHODS----------------

public void <init>(
java.util.List
int
java.util.Set
java.security.cert.PolicyNode
java.util.Set
java.lang.String
boolean)

public void addChild(
org.bouncycastle.jce.provider.PKIXPolicyNode)

public java.lang.Object clone()

public org.bouncycastle.jce.provider.PKIXPolicyNode copy()

public java.util.Iterator getChildren()

public int getDepth()

public java.util.Set getExpectedPolicies()

public java.security.cert.PolicyNode getParent()

public java.util.Set getPolicyQualifiers()

public java.lang.String getValidPolicy()

public boolean hasChildren()

public boolean isCritical()

public void removeChild(
org.bouncycastle.jce.provider.PKIXPolicyNode)

public void setCritical(
boolean)

public void setParent(
org.bouncycastle.jce.provider.PKIXPolicyNode)

public java.lang.String toString()

public java.lang.String toString(
java.lang.String)

________________CLASS________________


 class org.bouncycastle.jce.provider.RSAUtil extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

static org.bouncycastle.crypto.params.RSAKeyParameters generatePrivateKeyParameter(
java.security.interfaces.RSAPrivateKey)

static org.bouncycastle.crypto.params.RSAKeyParameters generatePublicKeyParameter(
java.security.interfaces.RSAPublicKey)

static boolean isRsaOid(
org.bouncycastle.asn1.DERObjectIdentifier)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =AESWrap )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/WrapCipherSpi; )
public class org.bouncycastle.jce.provider.WrapCipherSpi$AESWrap extends org.bouncycastle.jce.provider.WrapCipherSpi

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =9 name =DESEDEWrap )
@dalvik.annotation.EnclosingClass (value =Lorg/bouncycastle/jce/provider/WrapCipherSpi; )
public class org.bouncycastle.jce.provider.WrapCipherSpi$DESEDEWrap extends org.bouncycastle.jce.provider.WrapCipherSpi

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________


public class org.bouncycastle.jce.provider.X509CRLEntryObject extends java.security.cert.X509CRLEntry

----------------FIELDS----------------

private org.bouncycastle.asn1.x509.TBSCertList$CRLEntry c

private boolean isIndirect

private javax.security.auth.x500.X500Principal previousCertificateIssuer
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.x509.TBSCertList$CRLEntry)

public void <init>(
org.bouncycastle.asn1.x509.TBSCertList$CRLEntry
boolean
javax.security.auth.x500.X500Principal)

private java.util.Set getExtensionOIDs(
boolean)

public javax.security.auth.x500.X500Principal getCertificateIssuer()

public java.util.Set getCriticalExtensionOIDs()
@dalvik.annotation.Throws (value =Ljava/security/cert/CRLException; )
public byte[] getEncoded()

public byte[] getExtensionValue(
java.lang.String)

public java.util.Set getNonCriticalExtensionOIDs()

public java.util.Date getRevocationDate()

public java.math.BigInteger getSerialNumber()

public boolean hasExtensions()

public boolean hasUnsupportedCriticalExtension()

public java.lang.String toString()

________________CLASS________________


public class org.bouncycastle.jce.provider.X509CRLObject extends java.security.cert.X509CRL

----------------FIELDS----------------

private org.bouncycastle.asn1.x509.CertificateList c

private java.lang.String sigAlgName

private byte[] sigAlgParams
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/security/cert/CRLException; )
public void <init>(
org.bouncycastle.asn1.x509.CertificateList)

private java.util.Set getExtensionOIDs(
boolean)

private boolean isIndirectCRL()

public java.util.Set getCriticalExtensionOIDs()
@dalvik.annotation.Throws (value =Ljava/security/cert/CRLException; )
public byte[] getEncoded()

public byte[] getExtensionValue(
java.lang.String)

public java.security.Principal getIssuerDN()

public javax.security.auth.x500.X500Principal getIssuerX500Principal()

public java.util.Date getNextUpdate()

public java.util.Set getNonCriticalExtensionOIDs()

public java.security.cert.X509CRLEntry getRevokedCertificate(
java.math.BigInteger)

public java.util.Set getRevokedCertificates()

public java.lang.String getSigAlgName()

public java.lang.String getSigAlgOID()

public byte[] getSigAlgParams()

public byte[] getSignature()
@dalvik.annotation.Throws (value =Ljava/security/cert/CRLException; )
public byte[] getTBSCertList()

public java.util.Date getThisUpdate()

public int getVersion()

public boolean hasUnsupportedCriticalExtension()

public boolean isRevoked(
java.security.cert.Certificate)

public java.lang.String toString()
@dalvik.annotation.Throws (value =Ljava/security/cert/CRLException;Ljava/security/NoSuchAlgorithmException;Ljava/security/InvalidKeyException;Ljava/security/NoSuchProviderException;Ljava/security/SignatureException; )
public void verify(
java.security.PublicKey)
@dalvik.annotation.Throws (value =Ljava/security/cert/CRLException;Ljava/security/NoSuchAlgorithmException;Ljava/security/InvalidKeyException;Ljava/security/NoSuchProviderException;Ljava/security/SignatureException; )
public void verify(
java.security.PublicKey
java.lang.String)

________________CLASS________________


public class org.bouncycastle.jce.provider.X509CertificateObject extends java.security.cert.X509Certificate implements org.bouncycastle.jce.interfaces.PKCS12BagAttributeCarrier

----------------FIELDS----------------

private org.bouncycastle.asn1.x509.X509CertificateStructure c

private org.bouncycastle.asn1.OrderedTable pkcs12
----------------METHODS----------------

public void <init>(
org.bouncycastle.asn1.x509.X509CertificateStructure)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException;Ljava/security/NoSuchAlgorithmException;Ljava/security/SignatureException;Ljava/security/InvalidKeyException;Ljava/security/cert/CertificateEncodingException; )
private void checkSignature(
java.security.PublicKey
java.security.Signature)

private byte[] getExtensionBytes(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateExpiredException;Ljava/security/cert/CertificateNotYetValidException; )
public void checkValidity()
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateExpiredException;Ljava/security/cert/CertificateNotYetValidException; )
public void checkValidity(
java.util.Date)

public boolean equals(
java.lang.Object)

public org.bouncycastle.asn1.DEREncodable getBagAttribute(
org.bouncycastle.asn1.DERObjectIdentifier)

public java.util.Enumeration getBagAttributeKeys()

public int getBasicConstraints()

public java.util.Set getCriticalExtensionOIDs()
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateEncodingException; )
public byte[] getEncoded()
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateParsingException; )
public java.util.List getExtendedKeyUsage()

public byte[] getExtensionValue(
java.lang.String)

public java.security.Principal getIssuerDN()

public boolean[] getIssuerUniqueID()

public javax.security.auth.x500.X500Principal getIssuerX500Principal()

public boolean[] getKeyUsage()

public java.util.Set getNonCriticalExtensionOIDs()

public java.util.Date getNotAfter()

public java.util.Date getNotBefore()

public java.security.PublicKey getPublicKey()

public java.math.BigInteger getSerialNumber()

public java.lang.String getSigAlgName()

public java.lang.String getSigAlgOID()

public byte[] getSigAlgParams()

public byte[] getSignature()

public java.security.Principal getSubjectDN()

public boolean[] getSubjectUniqueID()

public javax.security.auth.x500.X500Principal getSubjectX500Principal()
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateEncodingException; )
public byte[] getTBSCertificate()

public int getVersion()

public boolean hasUnsupportedCriticalExtension()

public int hashCode()

public void setBagAttribute(
org.bouncycastle.asn1.DERObjectIdentifier
org.bouncycastle.asn1.DEREncodable)

public java.lang.String toString()
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException;Ljava/security/NoSuchAlgorithmException;Ljava/security/InvalidKeyException;Ljava/security/NoSuchProviderException;Ljava/security/SignatureException; )
public final void verify(
java.security.PublicKey)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException;Ljava/security/NoSuchAlgorithmException;Ljava/security/InvalidKeyException;Ljava/security/NoSuchProviderException;Ljava/security/SignatureException; )
public final void verify(
java.security.PublicKey
java.lang.String)

________________CLASS________________


 class org.bouncycastle.jce.provider.X509SignatureUtil extends java.lang.Object

----------------FIELDS----------------

private static final org.bouncycastle.asn1.ASN1Null derNull
----------------METHODS----------------

static void <clinit>()

 void <init>()

private static java.lang.String getDigestAlgName(
org.bouncycastle.asn1.DERObjectIdentifier)

static java.lang.String getSignatureName(
org.bouncycastle.asn1.x509.AlgorithmIdentifier)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchAlgorithmException;Ljava/security/SignatureException;Ljava/security/InvalidKeyException; )
static void setSignatureParameters(
java.security.Signature
org.bouncycastle.asn1.DEREncodable)

________________CLASS________________


public class org.bouncycastle.jce.spec.IEKeySpec extends java.lang.Object implements java.security.spec.KeySpec, org.bouncycastle.jce.interfaces.IESKey

----------------FIELDS----------------

private java.security.PrivateKey privKey

private java.security.PublicKey pubKey
----------------METHODS----------------

public void <init>(
java.security.PrivateKey
java.security.PublicKey)

public java.lang.String getAlgorithm()

public byte[] getEncoded()

public java.lang.String getFormat()

public java.security.PrivateKey getPrivate()

public java.security.PublicKey getPublic()

________________CLASS________________


public class org.bouncycastle.jce.spec.IESParameterSpec extends java.lang.Object implements java.security.spec.AlgorithmParameterSpec

----------------FIELDS----------------

private byte[] derivation

private byte[] encoding

private int macKeySize
----------------METHODS----------------

public void <init>(
byte[]
byte[]
int)

public byte[] getDerivationV()

public byte[] getEncodingV()

public int getMacKeySize()

________________CLASS________________


public class org.bouncycastle.openssl.PEMWriter extends java.io.BufferedWriter

----------------FIELDS----------------
----------------METHODS----------------

public void <init>(
java.io.Writer)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeEncoded(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private void writeHexEncoded(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void writeObject(
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void writeObject(
java.lang.Object
java.lang.String
char[]
java.security.SecureRandom)

________________CLASS________________


public final class org.bouncycastle.util.Arrays extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

private void <init>()

public static boolean areEqual(
byte[]
byte[])

public static void fill(
byte[]
byte)

public static void fill(
long[]
long)

public static void fill(
short[]
short)

________________CLASS________________


public final class org.bouncycastle.util.BigIntegers extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public static byte[] asUnsignedByteArray(
java.math.BigInteger)

________________CLASS________________


public final class org.bouncycastle.util.Strings extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public static java.lang.String fromUTF8ByteArray(
byte[])

public static java.lang.String toLowerCase(
java.lang.String)

public static byte[] toUTF8ByteArray(
java.lang.String)

public static java.lang.String toUpperCase(
java.lang.String)

________________CLASS________________


public class org.bouncycastle.util.encoders.Base64 extends java.lang.Object

----------------FIELDS----------------

private static final org.bouncycastle.util.encoders.Encoder encoder
----------------METHODS----------------

static void <clinit>()

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static int decode(
java.lang.String
java.io.OutputStream)

public static byte[] decode(
java.lang.String)

public static byte[] decode(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static int encode(
byte[]
int
int
java.io.OutputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static int encode(
byte[]
java.io.OutputStream)

public static byte[] encode(
byte[])

________________CLASS________________


public abstract interface class org.bouncycastle.util.encoders.Encoder extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int decode(
java.lang.String
java.io.OutputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int decode(
byte[]
int
int
java.io.OutputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract int encode(
byte[]
int
int
java.io.OutputStream)

________________CLASS________________


public class org.bouncycastle.util.encoders.Base64Encoder extends java.lang.Object implements org.bouncycastle.util.encoders.Encoder

----------------FIELDS----------------

protected final byte[] decodingTable

protected final byte[] encodingTable

protected byte padding
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private int decodeLastBlock(
java.io.OutputStream
char
char
char
char)

private boolean ignore(
char)

private int nextI(
java.lang.String
int
int)

private int nextI(
byte[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int decode(
java.lang.String
java.io.OutputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int decode(
byte[]
int
int
java.io.OutputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int encode(
byte[]
int
int
java.io.OutputStream)

protected void initialiseDecodingTable()

________________CLASS________________


public class org.bouncycastle.util.encoders.BufferedDecoder extends java.lang.Object

----------------FIELDS----------------

protected byte[] buf

protected int bufOff

protected org.bouncycastle.util.encoders.Translator translator
----------------METHODS----------------

public void <init>(
org.bouncycastle.util.encoders.Translator
int)

public int processByte(
byte
byte[]
int)

public int processBytes(
byte[]
int
int
byte[]
int)

________________CLASS________________


public class org.bouncycastle.util.encoders.BufferedEncoder extends java.lang.Object

----------------FIELDS----------------

protected byte[] buf

protected int bufOff

protected org.bouncycastle.util.encoders.Translator translator
----------------METHODS----------------

public void <init>(
org.bouncycastle.util.encoders.Translator
int)

public int processByte(
byte
byte[]
int)

public int processBytes(
byte[]
int
int
byte[]
int)

________________CLASS________________


public class org.bouncycastle.util.encoders.Hex extends java.lang.Object

----------------FIELDS----------------

private static final org.bouncycastle.util.encoders.Encoder encoder
----------------METHODS----------------

static void <clinit>()

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static int decode(
java.lang.String
java.io.OutputStream)

public static byte[] decode(
java.lang.String)

public static byte[] decode(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static int encode(
byte[]
int
int
java.io.OutputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static int encode(
byte[]
java.io.OutputStream)

public static byte[] encode(
byte[])

public static byte[] encode(
byte[]
int
int)

________________CLASS________________


public class org.bouncycastle.util.encoders.HexEncoder extends java.lang.Object implements org.bouncycastle.util.encoders.Encoder

----------------FIELDS----------------

protected final byte[] decodingTable

protected final byte[] encodingTable
----------------METHODS----------------

public void <init>()

private boolean ignore(
char)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int decode(
java.lang.String
java.io.OutputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int decode(
byte[]
int
int
java.io.OutputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public int encode(
byte[]
int
int
java.io.OutputStream)

protected void initialiseDecodingTable()

________________CLASS________________


public abstract interface class org.bouncycastle.util.encoders.Translator extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract int decode(
byte[]
int
int
byte[]
int)

public abstract int encode(
byte[]
int
int
byte[]
int)

public abstract int getDecodedBlockSize()

public abstract int getEncodedBlockSize()

________________CLASS________________


public class org.bouncycastle.util.encoders.HexTranslator extends java.lang.Object implements org.bouncycastle.util.encoders.Translator

----------------FIELDS----------------

private static final byte[] hexTable
----------------METHODS----------------

static void <clinit>()

public void <init>()

public int decode(
byte[]
int
int
byte[]
int)

public int encode(
byte[]
int
int
byte[]
int)

public int getDecodedBlockSize()

public int getEncodedBlockSize()

________________CLASS________________


public class org.bouncycastle.util.encoders.UrlBase64 extends java.lang.Object

----------------FIELDS----------------

private static final org.bouncycastle.util.encoders.Encoder encoder
----------------METHODS----------------

static void <clinit>()

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static int decode(
java.lang.String
java.io.OutputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static int decode(
byte[]
java.io.OutputStream)

public static byte[] decode(
java.lang.String)

public static byte[] decode(
byte[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static int encode(
byte[]
java.io.OutputStream)

public static byte[] encode(
byte[])

________________CLASS________________


public class org.bouncycastle.util.encoders.UrlBase64Encoder extends org.bouncycastle.util.encoders.Base64Encoder

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

________________CLASS________________


public class org.bouncycastle.x509.AttributeCertificateHolder extends java.lang.Object implements java.security.cert.CertSelector

----------------FIELDS----------------

final org.bouncycastle.asn1.x509.Holder holder
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateParsingException; )
public void <init>(
java.security.cert.X509Certificate)

public void <init>(
javax.security.auth.x500.X500Principal)

public void <init>(
javax.security.auth.x500.X500Principal
java.math.BigInteger)

 void <init>(
org.bouncycastle.asn1.ASN1Sequence)

public void <init>(
org.bouncycastle.jce.X509Principal)

public void <init>(
org.bouncycastle.jce.X509Principal
java.math.BigInteger)

private org.bouncycastle.asn1.x509.GeneralNames generateGeneralNames(
org.bouncycastle.jce.X509Principal)

private java.lang.Object[] getNames(
org.bouncycastle.asn1.x509.GeneralName[])

private java.security.Principal[] getPrincipals(
org.bouncycastle.asn1.x509.GeneralNames)

private boolean matchesDN(
org.bouncycastle.jce.X509Principal
org.bouncycastle.asn1.x509.GeneralNames)

public java.lang.Object clone()

public java.security.Principal[] getEntityNames()

public java.security.Principal[] getIssuer()

public java.math.BigInteger getSerialNumber()

public boolean match(
java.security.cert.Certificate)

________________CLASS________________


public class org.bouncycastle.x509.AttributeCertificateIssuer extends java.lang.Object implements java.security.cert.CertSelector

----------------FIELDS----------------

final org.bouncycastle.asn1.ASN1Encodable form
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
javax.security.auth.x500.X500Principal)

 void <init>(
org.bouncycastle.asn1.x509.AttCertIssuer)

public void <init>(
org.bouncycastle.jce.X509Principal)

private java.lang.Object[] getNames()

private boolean matchesDN(
javax.security.auth.x500.X500Principal
org.bouncycastle.asn1.x509.GeneralNames)

public java.lang.Object clone()

public java.security.Principal[] getPrincipals()

public boolean match(
java.security.cert.Certificate)

________________CLASS________________


public class org.bouncycastle.x509.CertPathReviewerException extends org.bouncycastle.i18n.LocalizedException

----------------FIELDS----------------

private java.security.cert.CertPath certPath

private int index
----------------METHODS----------------

public void <init>(
org.bouncycastle.i18n.ErrorBundle)

public void <init>(
org.bouncycastle.i18n.ErrorBundle
java.lang.Throwable)

public void <init>(
org.bouncycastle.i18n.ErrorBundle
java.lang.Throwable
java.security.cert.CertPath
int)

public void <init>(
org.bouncycastle.i18n.ErrorBundle
java.security.cert.CertPath
int)

public java.security.cert.CertPath getCertPath()

public int getIndex()

________________CLASS________________


public class org.bouncycastle.x509.PKIXCertPathReviewer extends org.bouncycastle.jce.provider.CertPathValidatorUtilities

----------------FIELDS----------------

private static final java.lang.String AUTH_INFO_ACCESS

private static final java.lang.String CRL_DIST_POINTS

private static final java.lang.String QC_STATEMENT

private static final java.lang.String RESOURCE_NAME

protected java.security.cert.CertPath certPath

protected java.util.List certs

protected java.util.List[] errors

protected int n

protected java.util.List[] notifications

protected java.security.cert.PKIXParameters pkixParams

protected java.security.cert.PolicyNode policyTree

protected java.security.PublicKey subjectPublicKey

protected java.security.cert.TrustAnchor trustAnchor

protected java.util.Date validDate
----------------METHODS----------------

static void <clinit>()
@dalvik.annotation.Throws (value =Lorg/bouncycastle/x509/CertPathReviewerException; )
public void <init>(
java.security.cert.CertPath
java.security.cert.PKIXParameters)

private java.lang.String IPtoString(
byte[])
@dalvik.annotation.Throws (value =Lorg/bouncycastle/x509/CertPathReviewerException; )
private void checkCRLs(
java.security.cert.PKIXParameters
java.security.cert.X509Certificate
java.util.Date
java.security.cert.X509Certificate
java.security.PublicKey
java.util.Vector
int)

private void checkCriticalExtensions()

private void checkNameConstraints()

private void checkPathLength()

private void checkPolicy()

private void checkSignatures()
@dalvik.annotation.Throws (value =Lorg/bouncycastle/x509/CertPathReviewerException; )
private java.security.cert.X509CRL getCRL(
java.lang.String)

private java.util.Vector getCRLDistUrls(
org.bouncycastle.asn1.x509.CRLDistPoint
org.bouncycastle.asn1.x509.AuthorityInformationAccess)

private java.util.Vector getOCSPUrls(
org.bouncycastle.asn1.x509.AuthorityInformationAccess)
@dalvik.annotation.Throws (value =Lorg/bouncycastle/x509/CertPathReviewerException; )
private java.util.Collection getTrustAnchors(
java.security.cert.X509Certificate
java.util.Set)

private boolean processQcStatements(
java.security.cert.X509Certificate
int)

protected void addError(
org.bouncycastle.i18n.ErrorBundle)

protected void addError(
org.bouncycastle.i18n.ErrorBundle
int)

protected void addNotification(
org.bouncycastle.i18n.ErrorBundle)

protected void addNotification(
org.bouncycastle.i18n.ErrorBundle
int)

protected void doChecks()

public java.security.cert.CertPath getCertPath()

public int getCertPathSize()

public java.util.List getErrors(
int)

public java.util.List[] getErrors()

public java.util.List getNotifications(
int)

public java.util.List[] getNotifications()

public java.security.cert.PolicyNode getPolicyTree()

public java.security.PublicKey getSubjectPublicKey()

public java.security.cert.TrustAnchor getTrustAnchor()

public boolean isValidCertPath()

________________CLASS________________


public class org.bouncycastle.x509.X509Attribute extends org.bouncycastle.asn1.ASN1Encodable

----------------FIELDS----------------

 org.bouncycastle.asn1.x509.Attribute attr
----------------METHODS----------------

public void <init>(
java.lang.String
org.bouncycastle.asn1.ASN1Encodable)

public void <init>(
java.lang.String
org.bouncycastle.asn1.ASN1EncodableVector)

 void <init>(
org.bouncycastle.asn1.ASN1Encodable)

public java.lang.String getOID()

public org.bouncycastle.asn1.ASN1Encodable[] getValues()

public org.bouncycastle.asn1.DERObject toASN1Object()

________________CLASS________________


public abstract interface class org.bouncycastle.x509.X509AttributeCertificate extends java.lang.Object implements java.security.cert.X509Extension

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateExpiredException;Ljava/security/cert/CertificateNotYetValidException; )
public abstract void checkValidity()
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateExpiredException;Ljava/security/cert/CertificateNotYetValidException; )
public abstract void checkValidity(
java.util.Date)

public abstract org.bouncycastle.x509.X509Attribute[] getAttributes()

public abstract org.bouncycastle.x509.X509Attribute[] getAttributes(
java.lang.String)

public abstract java.util.Set getCriticalExtensionOIDs()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract byte[] getEncoded()

public abstract org.bouncycastle.x509.AttributeCertificateHolder getHolder()

public abstract org.bouncycastle.x509.AttributeCertificateIssuer getIssuer()

public abstract boolean[] getIssuerUniqueID()

public abstract java.util.Set getNonCriticalExtensionOIDs()

public abstract java.util.Date getNotAfter()

public abstract java.util.Date getNotBefore()

public abstract java.math.BigInteger getSerialNumber()

public abstract byte[] getSignature()

public abstract int getVersion()
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException;Ljava/security/NoSuchAlgorithmException;Ljava/security/InvalidKeyException;Ljava/security/NoSuchProviderException;Ljava/security/SignatureException; )
public abstract void verify(
java.security.PublicKey
java.lang.String)

________________CLASS________________


 class org.bouncycastle.x509.X509Util extends java.lang.Object

----------------FIELDS----------------

private static java.util.Hashtable algorithms

private static java.util.Set noParams
----------------METHODS----------------

static void <clinit>()

 void <init>()

static org.bouncycastle.jce.X509Principal convertPrincipal(
javax.security.auth.x500.X500Principal)

static java.util.Iterator getAlgNames()

static org.bouncycastle.asn1.DERObjectIdentifier getAlgorithmOID(
java.lang.String)

static org.bouncycastle.asn1.x509.AlgorithmIdentifier getSigAlgID(
org.bouncycastle.asn1.DERObjectIdentifier)

________________CLASS________________


public class org.bouncycastle.x509.X509V1CertificateGenerator extends java.lang.Object

----------------FIELDS----------------

private org.bouncycastle.asn1.x509.AlgorithmIdentifier sigAlgId

private org.bouncycastle.asn1.DERObjectIdentifier sigOID

private java.lang.String signatureAlgorithm

private org.bouncycastle.asn1.x509.V1TBSCertificateGenerator tbsGen
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/lang/SecurityException;Ljava/security/SignatureException;Ljava/security/InvalidKeyException; )
public java.security.cert.X509Certificate generateX509Certificate(
java.security.PrivateKey)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchProviderException;Ljava/lang/SecurityException;Ljava/security/SignatureException;Ljava/security/InvalidKeyException; )
public java.security.cert.X509Certificate generateX509Certificate(
java.security.PrivateKey
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchProviderException;Ljava/lang/SecurityException;Ljava/security/SignatureException;Ljava/security/InvalidKeyException; )
public java.security.cert.X509Certificate generateX509Certificate(
java.security.PrivateKey
java.lang.String
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/lang/SecurityException;Ljava/security/SignatureException;Ljava/security/InvalidKeyException; )
public java.security.cert.X509Certificate generateX509Certificate(
java.security.PrivateKey
java.security.SecureRandom)

public java.util.Iterator getSignatureAlgNames()

public void reset()

public void setIssuerDN(
javax.security.auth.x500.X500Principal)

public void setIssuerDN(
org.bouncycastle.asn1.x509.X509Name)

public void setNotAfter(
java.util.Date)

public void setNotBefore(
java.util.Date)

public void setPublicKey(
java.security.PublicKey)

public void setSerialNumber(
java.math.BigInteger)

public void setSignatureAlgorithm(
java.lang.String)

public void setSubjectDN(
javax.security.auth.x500.X500Principal)

public void setSubjectDN(
org.bouncycastle.asn1.x509.X509Name)

________________CLASS________________


public class org.bouncycastle.x509.X509V2AttributeCertificate extends java.lang.Object implements org.bouncycastle.x509.X509AttributeCertificate

----------------FIELDS----------------

private org.bouncycastle.asn1.x509.AttributeCertificate cert

private java.util.Date notAfter

private java.util.Date notBefore
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
java.io.InputStream)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void <init>(
org.bouncycastle.asn1.x509.AttributeCertificate)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
byte[])

private java.util.Set getExtensionOIDs(
boolean)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateExpiredException;Ljava/security/cert/CertificateNotYetValidException; )
public void checkValidity()
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateExpiredException;Ljava/security/cert/CertificateNotYetValidException; )
public void checkValidity(
java.util.Date)

public org.bouncycastle.x509.X509Attribute[] getAttributes()

public org.bouncycastle.x509.X509Attribute[] getAttributes(
java.lang.String)

public java.util.Set getCriticalExtensionOIDs()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public byte[] getEncoded()

public byte[] getExtensionValue(
java.lang.String)

public org.bouncycastle.x509.AttributeCertificateHolder getHolder()

public org.bouncycastle.x509.AttributeCertificateIssuer getIssuer()

public boolean[] getIssuerUniqueID()

public java.util.Set getNonCriticalExtensionOIDs()

public java.util.Date getNotAfter()

public java.util.Date getNotBefore()

public java.math.BigInteger getSerialNumber()

public byte[] getSignature()

public int getVersion()

public boolean hasUnsupportedCriticalExtension()
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateException;Ljava/security/NoSuchAlgorithmException;Ljava/security/InvalidKeyException;Ljava/security/NoSuchProviderException;Ljava/security/SignatureException; )
public final void verify(
java.security.PublicKey
java.lang.String)

________________CLASS________________


public class org.bouncycastle.x509.X509V2AttributeCertificateGenerator extends java.lang.Object

----------------FIELDS----------------

private org.bouncycastle.asn1.x509.V2AttributeCertificateInfoGenerator acInfoGen

private java.util.Vector extOrdering

private java.util.Hashtable extensions

private org.bouncycastle.asn1.x509.AlgorithmIdentifier sigAlgId

private org.bouncycastle.asn1.DERObjectIdentifier sigOID

private java.lang.String signatureAlgorithm
----------------METHODS----------------

public void <init>()

public void addAttribute(
org.bouncycastle.x509.X509Attribute)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void addExtension(
java.lang.String
boolean
org.bouncycastle.asn1.ASN1Encodable)

public void addExtension(
java.lang.String
boolean
byte[])
@dalvik.annotation.Throws (value =Ljava/security/NoSuchProviderException;Ljava/lang/SecurityException;Ljava/security/SignatureException;Ljava/security/InvalidKeyException; )
public org.bouncycastle.x509.X509AttributeCertificate generateCertificate(
java.security.PrivateKey
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchProviderException;Ljava/lang/SecurityException;Ljava/security/SignatureException;Ljava/security/InvalidKeyException; )
public org.bouncycastle.x509.X509AttributeCertificate generateCertificate(
java.security.PrivateKey
java.lang.String
java.security.SecureRandom)

public java.util.Iterator getSignatureAlgNames()

public void reset()

public void setHolder(
org.bouncycastle.x509.AttributeCertificateHolder)

public void setIssuer(
org.bouncycastle.x509.AttributeCertificateIssuer)

public void setIssuerUniqueId(
boolean[])

public void setNotAfter(
java.util.Date)

public void setNotBefore(
java.util.Date)

public void setSerialNumber(
java.math.BigInteger)

public void setSignatureAlgorithm(
java.lang.String)

________________CLASS________________


public class org.bouncycastle.x509.X509V2CRLGenerator extends java.lang.Object

----------------FIELDS----------------

private java.text.SimpleDateFormat dateF

private java.util.Vector extOrdering

private java.util.Hashtable extensions

private org.bouncycastle.asn1.x509.AlgorithmIdentifier sigAlgId

private org.bouncycastle.asn1.DERObjectIdentifier sigOID

private java.lang.String signatureAlgorithm

private org.bouncycastle.asn1.x509.V2TBSCertListGenerator tbsGen

private java.util.SimpleTimeZone tz
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/security/cert/CRLException; )
public void addCRL(
java.security.cert.X509CRL)

public void addCRLEntry(
java.math.BigInteger
java.util.Date
int)

public void addCRLEntry(
java.math.BigInteger
java.util.Date
int
java.util.Date)

public void addCRLEntry(
java.math.BigInteger
java.util.Date
org.bouncycastle.asn1.x509.X509Extensions)

public void addExtension(
java.lang.String
boolean
org.bouncycastle.asn1.DEREncodable)

public void addExtension(
java.lang.String
boolean
byte[])

public void addExtension(
org.bouncycastle.asn1.DERObjectIdentifier
boolean
org.bouncycastle.asn1.DEREncodable)

public void addExtension(
org.bouncycastle.asn1.DERObjectIdentifier
boolean
byte[])
@dalvik.annotation.Throws (value =Ljava/lang/SecurityException;Ljava/security/SignatureException;Ljava/security/InvalidKeyException; )
public java.security.cert.X509CRL generateX509CRL(
java.security.PrivateKey)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchProviderException;Ljava/lang/SecurityException;Ljava/security/SignatureException;Ljava/security/InvalidKeyException; )
public java.security.cert.X509CRL generateX509CRL(
java.security.PrivateKey
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchProviderException;Ljava/lang/SecurityException;Ljava/security/SignatureException;Ljava/security/InvalidKeyException; )
public java.security.cert.X509CRL generateX509CRL(
java.security.PrivateKey
java.lang.String
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/lang/SecurityException;Ljava/security/SignatureException;Ljava/security/InvalidKeyException; )
public java.security.cert.X509CRL generateX509CRL(
java.security.PrivateKey
java.security.SecureRandom)

public java.util.Iterator getSignatureAlgNames()

public void reset()

public void setIssuerDN(
javax.security.auth.x500.X500Principal)

public void setIssuerDN(
org.bouncycastle.asn1.x509.X509Name)

public void setNextUpdate(
java.util.Date)

public void setSignatureAlgorithm(
java.lang.String)

public void setThisUpdate(
java.util.Date)

________________CLASS________________


public class org.bouncycastle.x509.X509V3CertificateGenerator extends java.lang.Object

----------------FIELDS----------------

private java.util.Vector extOrdering

private java.util.Hashtable extensions

private org.bouncycastle.asn1.x509.AlgorithmIdentifier sigAlgId

private org.bouncycastle.asn1.DERObjectIdentifier sigOID

private java.lang.String signatureAlgorithm

private org.bouncycastle.asn1.x509.V3TBSCertificateGenerator tbsGen
----------------METHODS----------------

public void <init>()

public void addExtension(
java.lang.String
boolean
org.bouncycastle.asn1.DEREncodable)

public void addExtension(
java.lang.String
boolean
byte[])

public void addExtension(
org.bouncycastle.asn1.DERObjectIdentifier
boolean
org.bouncycastle.asn1.DEREncodable)

public void addExtension(
org.bouncycastle.asn1.DERObjectIdentifier
boolean
byte[])
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateParsingException; )
public void copyAndAddExtension(
java.lang.String
boolean
java.security.cert.X509Certificate)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateParsingException; )
public void copyAndAddExtension(
org.bouncycastle.asn1.DERObjectIdentifier
boolean
java.security.cert.X509Certificate)
@dalvik.annotation.Throws (value =Ljava/lang/SecurityException;Ljava/security/SignatureException;Ljava/security/InvalidKeyException; )
public java.security.cert.X509Certificate generateX509Certificate(
java.security.PrivateKey)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchProviderException;Ljava/lang/SecurityException;Ljava/security/SignatureException;Ljava/security/InvalidKeyException; )
public java.security.cert.X509Certificate generateX509Certificate(
java.security.PrivateKey
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/security/NoSuchProviderException;Ljava/lang/SecurityException;Ljava/security/SignatureException;Ljava/security/InvalidKeyException; )
public java.security.cert.X509Certificate generateX509Certificate(
java.security.PrivateKey
java.lang.String
java.security.SecureRandom)
@dalvik.annotation.Throws (value =Ljava/lang/SecurityException;Ljava/security/SignatureException;Ljava/security/InvalidKeyException; )
public java.security.cert.X509Certificate generateX509Certificate(
java.security.PrivateKey
java.security.SecureRandom)

public java.util.Iterator getSignatureAlgNames()

public void reset()

public void setIssuerDN(
javax.security.auth.x500.X500Principal)

public void setIssuerDN(
org.bouncycastle.asn1.x509.X509Name)

public void setNotAfter(
java.util.Date)

public void setNotBefore(
java.util.Date)

public void setPublicKey(
java.security.PublicKey)

public void setSerialNumber(
java.math.BigInteger)

public void setSignatureAlgorithm(
java.lang.String)

public void setSubjectDN(
javax.security.auth.x500.X500Principal)

public void setSubjectDN(
org.bouncycastle.asn1.x509.X509Name)

________________CLASS________________


public class org.bouncycastle.x509.extension.AuthorityKeyIdentifierStructure extends org.bouncycastle.asn1.x509.AuthorityKeyIdentifier

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
public void <init>(
java.security.PublicKey)
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateParsingException; )
public void <init>(
java.security.cert.X509Certificate)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
byte[])
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateParsingException; )
private static org.bouncycastle.asn1.ASN1Sequence fromCertificate(
java.security.cert.X509Certificate)
@dalvik.annotation.Throws (value =Ljava/security/InvalidKeyException; )
private static org.bouncycastle.asn1.ASN1Sequence fromKey(
java.security.PublicKey)

________________CLASS________________


public class org.bouncycastle.x509.extension.SubjectKeyIdentifierStructure extends org.bouncycastle.asn1.x509.SubjectKeyIdentifier

----------------FIELDS----------------

private org.bouncycastle.asn1.x509.AuthorityKeyIdentifier authKeyID
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateParsingException; )
public void <init>(
java.security.PublicKey)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void <init>(
byte[])
@dalvik.annotation.Throws (value =Ljava/security/cert/CertificateParsingException; )
private static org.bouncycastle.asn1.ASN1OctetString fromPublicKey(
java.security.PublicKey)

________________CLASS________________


public class org.bouncycastle.x509.extension.X509ExtensionUtil extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static org.bouncycastle.asn1.ASN1Encodable fromExtensionValue(
byte[])

________________CLASS________________


public class org.json.JSONArray extends java.lang.Object

----------------FIELDS----------------

private java.util.ArrayList myArrayList
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public void <init>(
java.lang.String)

public void <init>(
java.util.Collection)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public void <init>(
org.json.JSONTokener)

public boolean equals(
java.lang.Object)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public java.lang.Object get(
int)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public boolean getBoolean(
int)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public double getDouble(
int)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public int getInt(
int)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public org.json.JSONArray getJSONArray(
int)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public org.json.JSONObject getJSONObject(
int)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public long getLong(
int)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public java.lang.String getString(
int)

public boolean isNull(
int)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public java.lang.String join(
java.lang.String)

public int length()

public java.lang.Object opt(
int)

public boolean optBoolean(
int)

public boolean optBoolean(
int
boolean)

public double optDouble(
int)

public double optDouble(
int
double)

public int optInt(
int)

public int optInt(
int
int)

public org.json.JSONArray optJSONArray(
int)

public org.json.JSONObject optJSONObject(
int)

public long optLong(
int)

public long optLong(
int
long)

public java.lang.String optString(
int)

public java.lang.String optString(
int
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public org.json.JSONArray put(
double)

public org.json.JSONArray put(
int)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public org.json.JSONArray put(
int
double)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public org.json.JSONArray put(
int
int)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public org.json.JSONArray put(
int
long)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public org.json.JSONArray put(
int
java.lang.Object)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public org.json.JSONArray put(
int
boolean)

public org.json.JSONArray put(
long)

public org.json.JSONArray put(
java.lang.Object)

public org.json.JSONArray put(
boolean)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public org.json.JSONObject toJSONObject(
org.json.JSONArray)

public java.lang.String toString()
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public java.lang.String toString(
int)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
 java.lang.String toString(
int
int)

________________CLASS________________


public class org.json.JSONException extends java.lang.Exception

----------------FIELDS----------------
----------------METHODS----------------

public void <init>(
java.lang.String)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/json/JSONObject; )
@dalvik.annotation.InnerClass (accessFlags =4104 name =null )
 class org.json.JSONObject$1 extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/json/JSONObject; )
@dalvik.annotation.InnerClass (accessFlags =26 name =Null )
final class org.json.JSONObject$Null extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

private void <init>()

 void <init>(
org.json.JSONObject$1)

protected final java.lang.Object clone()

public boolean equals(
java.lang.Object)

public java.lang.String toString()

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/json/JSONObject$1;Lorg/json/JSONObject$Null; )
public class org.json.JSONObject extends java.lang.Object

----------------FIELDS----------------

public static final java.lang.Object NULL

private java.util.HashMap myHashMap
----------------METHODS----------------

static void <clinit>()

public void <init>()
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public void <init>(
java.lang.String)

public void <init>(
java.util.Map)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public void <init>(
org.json.JSONObject
java.lang.String[])
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public void <init>(
org.json.JSONTokener)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public static java.lang.String numberToString(
java.lang.Number)

public static java.lang.String quote(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
static void testValidity(
java.lang.Object)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
static java.lang.String valueToString(
java.lang.Object)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
static java.lang.String valueToString(
java.lang.Object
int
int)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public org.json.JSONObject accumulate(
java.lang.String
java.lang.Object)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public java.lang.Object get(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public boolean getBoolean(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public double getDouble(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public int getInt(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public org.json.JSONArray getJSONArray(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public org.json.JSONObject getJSONObject(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public long getLong(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public java.lang.String getString(
java.lang.String)

public boolean has(
java.lang.String)

public boolean isNull(
java.lang.String)

public java.util.Iterator keys()

public int length()

public org.json.JSONArray names()

public java.lang.Object opt(
java.lang.String)

public boolean optBoolean(
java.lang.String)

public boolean optBoolean(
java.lang.String
boolean)

public double optDouble(
java.lang.String)

public double optDouble(
java.lang.String
double)

public int optInt(
java.lang.String)

public int optInt(
java.lang.String
int)

public org.json.JSONArray optJSONArray(
java.lang.String)

public org.json.JSONObject optJSONObject(
java.lang.String)

public long optLong(
java.lang.String)

public long optLong(
java.lang.String
long)

public java.lang.String optString(
java.lang.String)

public java.lang.String optString(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public org.json.JSONObject put(
java.lang.String
double)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public org.json.JSONObject put(
java.lang.String
int)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public org.json.JSONObject put(
java.lang.String
long)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public org.json.JSONObject put(
java.lang.String
java.lang.Object)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public org.json.JSONObject put(
java.lang.String
boolean)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public org.json.JSONObject putOpt(
java.lang.String
java.lang.Object)

public java.lang.Object remove(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public org.json.JSONArray toJSONArray(
org.json.JSONArray)

public java.lang.String toString()
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public java.lang.String toString(
int)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
 java.lang.String toString(
int
int)

________________CLASS________________


public class org.json.JSONStringer extends java.lang.Object

----------------FIELDS----------------

private static final int maxdepth

private boolean comma

private char mode

private java.lang.StringBuilder sb

private char[] stack

private int top
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
private org.json.JSONStringer append(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
private org.json.JSONStringer end(
char
char)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
private void pop(
char)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
private void push(
char)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public org.json.JSONStringer array()
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public org.json.JSONStringer endArray()
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public org.json.JSONStringer endObject()
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public org.json.JSONStringer key(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public org.json.JSONStringer object()

public java.lang.String toString()
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public org.json.JSONStringer value(
double)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public org.json.JSONStringer value(
long)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public org.json.JSONStringer value(
java.lang.Object)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public org.json.JSONStringer value(
boolean)

________________CLASS________________


public class org.json.JSONTokener extends java.lang.Object

----------------FIELDS----------------

private int myIndex

private java.lang.String mySource
----------------METHODS----------------

public void <init>(
java.lang.String)

public static int dehexchar(
char)

public void back()

public boolean more()

public char next()
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public char next(
char)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public java.lang.String next(
int)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public char nextClean()
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public java.lang.String nextString(
char)

public java.lang.String nextTo(
char)

public java.lang.String nextTo(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/json/JSONException; )
public java.lang.Object nextValue()

public void skipPast(
java.lang.String)

public char skipTo(
char)

public org.json.JSONException syntaxError(
java.lang.String)

public java.lang.String toString()

________________CLASS________________


public class org.kxml2.io.KXmlParser extends java.lang.Object implements org.xmlpull.v1.XmlPullParser

----------------FIELDS----------------

private static final java.lang.String ILLEGAL_TYPE

private static final int LEGACY

private static final java.lang.String UNEXPECTED_EOF

private static final int XML_DECL

private int attributeCount

private java.lang.String[] attributes

private int column

private boolean degenerated

private int depth

private java.lang.String[] elementStack

private java.lang.String encoding

private java.util.HashMap entityMap

private java.lang.String error

private boolean isWhitespace

private int line

private java.lang.Object location

private java.lang.String name

private java.lang.String namespace

private int[] nspCounts

private java.lang.String[] nspStack

private int[] peek

private int peekCount

private java.lang.String prefix

private boolean processNsp

private java.io.Reader reader

private boolean relaxed

private char[] srcBuf

private int srcCount

private int srcPos

private int stackMismatch

private java.lang.Boolean standalone

private boolean token

private char[] txtBuf

private int txtPos

private int type

private boolean unresolved

private java.lang.String version

private boolean wasCR
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
private final boolean adjustNsp()

private final java.lang.String[] ensureCapacity(
java.lang.String[]
int)
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
private final void error(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
private final void exception(
java.lang.String)

private final java.lang.String get(
int)

private final boolean isProp(
java.lang.String
boolean
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Lorg/xmlpull/v1/XmlPullParserException; )
private final void nextImpl()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Lorg/xmlpull/v1/XmlPullParserException; )
private final void parseDoctype(
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Lorg/xmlpull/v1/XmlPullParserException; )
private final void parseEndTag()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Lorg/xmlpull/v1/XmlPullParserException; )
private final int parseLegacy(
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Lorg/xmlpull/v1/XmlPullParserException; )
private final void parseStartTag(
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private final int peek(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private final int peekType()

private final void push(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Lorg/xmlpull/v1/XmlPullParserException; )
private final void pushEntity()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Lorg/xmlpull/v1/XmlPullParserException; )
private final void pushText(
int
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private final int read()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Lorg/xmlpull/v1/XmlPullParserException; )
private final void read(
char)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Lorg/xmlpull/v1/XmlPullParserException; )
private final java.lang.String readName()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private final void skip()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public void defineEntityReplacementText(
java.lang.String
java.lang.String)

public int getAttributeCount()

public java.lang.String getAttributeName(
int)

public java.lang.String getAttributeNamespace(
int)

public java.lang.String getAttributePrefix(
int)

public java.lang.String getAttributeType(
int)

public java.lang.String getAttributeValue(
int)

public java.lang.String getAttributeValue(
java.lang.String
java.lang.String)

public int getColumnNumber()

public int getDepth()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public int getEventType()

public boolean getFeature(
java.lang.String)

public java.lang.String getInputEncoding()

public int getLineNumber()

public java.lang.String getName()

public java.lang.String getNamespace()

public java.lang.String getNamespace(
java.lang.String)

public int getNamespaceCount(
int)

public java.lang.String getNamespacePrefix(
int)

public java.lang.String getNamespaceUri(
int)

public java.lang.String getPositionDescription()

public java.lang.String getPrefix()

public java.lang.Object getProperty(
java.lang.String)

public java.lang.String getText()

public char[] getTextCharacters(
int[])

public boolean isAttributeDefault(
int)
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public boolean isEmptyElementTag()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public boolean isWhitespace()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException;Ljava/io/IOException; )
public int next()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException;Ljava/io/IOException; )
public int nextTag()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException;Ljava/io/IOException; )
public java.lang.String nextText()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException;Ljava/io/IOException; )
public int nextToken()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException;Ljava/io/IOException; )
public void require(
int
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public void setFeature(
java.lang.String
boolean)
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public void setInput(
java.io.InputStream
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public void setInput(
java.io.Reader)
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public void setProperty(
java.lang.String
java.lang.Object)
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException;Ljava/io/IOException; )
public void skipSubTree()

________________CLASS________________


public abstract interface class org.xmlpull.v1.XmlSerializer extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/IllegalArgumentException;Ljava/lang/IllegalStateException; )
public abstract org.xmlpull.v1.XmlSerializer attribute(
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/IllegalArgumentException;Ljava/lang/IllegalStateException; )
public abstract void cdsect(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/IllegalArgumentException;Ljava/lang/IllegalStateException; )
public abstract void comment(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/IllegalArgumentException;Ljava/lang/IllegalStateException; )
public abstract void docdecl(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/IllegalArgumentException;Ljava/lang/IllegalStateException; )
public abstract void endDocument()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/IllegalArgumentException;Ljava/lang/IllegalStateException; )
public abstract org.xmlpull.v1.XmlSerializer endTag(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/IllegalArgumentException;Ljava/lang/IllegalStateException; )
public abstract void entityRef(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public abstract void flush()

public abstract int getDepth()

public abstract boolean getFeature(
java.lang.String)

public abstract java.lang.String getName()

public abstract java.lang.String getNamespace()
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException; )
public abstract java.lang.String getPrefix(
java.lang.String
boolean)

public abstract java.lang.Object getProperty(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/IllegalArgumentException;Ljava/lang/IllegalStateException; )
public abstract void ignorableWhitespace(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/IllegalArgumentException;Ljava/lang/IllegalStateException; )
public abstract void processingInstruction(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException;Ljava/lang/IllegalStateException; )
public abstract void setFeature(
java.lang.String
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/IllegalArgumentException;Ljava/lang/IllegalStateException; )
public abstract void setOutput(
java.io.OutputStream
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/IllegalArgumentException;Ljava/lang/IllegalStateException; )
public abstract void setOutput(
java.io.Writer)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/IllegalArgumentException;Ljava/lang/IllegalStateException; )
public abstract void setPrefix(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/lang/IllegalArgumentException;Ljava/lang/IllegalStateException; )
public abstract void setProperty(
java.lang.String
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/IllegalArgumentException;Ljava/lang/IllegalStateException; )
public abstract void startDocument(
java.lang.String
java.lang.Boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/IllegalArgumentException;Ljava/lang/IllegalStateException; )
public abstract org.xmlpull.v1.XmlSerializer startTag(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/IllegalArgumentException;Ljava/lang/IllegalStateException; )
public abstract org.xmlpull.v1.XmlSerializer text(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Ljava/lang/IllegalArgumentException;Ljava/lang/IllegalStateException; )
public abstract org.xmlpull.v1.XmlSerializer text(
char[]
int
int)

________________CLASS________________


public class org.kxml2.io.KXmlSerializer extends java.lang.Object implements org.xmlpull.v1.XmlSerializer

----------------FIELDS----------------

private static final int WRITE_BUFFER_SIZE

private int auto

private int depth

private java.lang.String[] elementStack

private java.lang.String encoding

private boolean[] indent

private int[] nspCounts

private java.lang.String[] nspStack

private boolean pending

private boolean unicode

private java.io.BufferedWriter writer
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private final void check(
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private final java.lang.String getPrefix(
java.lang.String
boolean
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private final void writeEscaped(
java.lang.String
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public org.xmlpull.v1.XmlSerializer attribute(
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void cdsect(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void comment(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void docdecl(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void endDocument()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public org.xmlpull.v1.XmlSerializer endTag(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void entityRef(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void flush()

public int getDepth()

public boolean getFeature(
java.lang.String)

public java.lang.String getName()

public java.lang.String getNamespace()

public java.lang.String getPrefix(
java.lang.String
boolean)

public java.lang.Object getProperty(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void ignorableWhitespace(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void processingInstruction(
java.lang.String)

public void setFeature(
java.lang.String
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void setOutput(
java.io.OutputStream
java.lang.String)

public void setOutput(
java.io.Writer)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void setPrefix(
java.lang.String
java.lang.String)

public void setProperty(
java.lang.String
java.lang.Object)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void startDocument(
java.lang.String
java.lang.Boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public org.xmlpull.v1.XmlSerializer startTag(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public org.xmlpull.v1.XmlSerializer text(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public org.xmlpull.v1.XmlSerializer text(
char[]
int
int)

________________CLASS________________


public class org.kxml2.kdom.Node extends java.lang.Object

----------------FIELDS----------------

public static final int CDSECT

public static final int COMMENT

public static final int DOCDECL

public static final int DOCUMENT

public static final int ELEMENT

public static final int ENTITY_REF

public static final int IGNORABLE_WHITESPACE

public static final int PROCESSING_INSTRUCTION

public static final int TEXT

protected java.util.ArrayList children

protected java.lang.StringBuffer types
----------------METHODS----------------

public void <init>()

public void addChild(
int
int
java.lang.Object)

public void addChild(
int
java.lang.Object)

public org.kxml2.kdom.Element createElement(
java.lang.String
java.lang.String)

public java.lang.Object getChild(
int)

public int getChildCount()

public org.kxml2.kdom.Element getElement(
int)

public org.kxml2.kdom.Element getElement(
java.lang.String
java.lang.String)

public java.lang.String getText(
int)

public int getType(
int)

public int indexOf(
java.lang.String
java.lang.String
int)

public boolean isText(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Lorg/xmlpull/v1/XmlPullParserException; )
public void parse(
org.xmlpull.v1.XmlPullParser)

public void removeChild(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
org.xmlpull.v1.XmlSerializer)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void writeChildren(
org.xmlpull.v1.XmlSerializer)

________________CLASS________________


public class org.kxml2.kdom.Document extends org.kxml2.kdom.Node

----------------FIELDS----------------

 java.lang.String encoding

protected int rootIndex

 java.lang.Boolean standalone
----------------METHODS----------------

public void <init>()

public void addChild(
int
int
java.lang.Object)

public java.lang.String getEncoding()

public java.lang.String getName()

public org.kxml2.kdom.Element getRootElement()

public java.lang.Boolean getStandalone()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Lorg/xmlpull/v1/XmlPullParserException; )
public void parse(
org.xmlpull.v1.XmlPullParser)

public void removeChild(
int)

public void setEncoding(
java.lang.String)

public void setStandalone(
java.lang.Boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
org.xmlpull.v1.XmlSerializer)

________________CLASS________________


public class org.kxml2.kdom.Element extends org.kxml2.kdom.Node

----------------FIELDS----------------

protected java.util.ArrayList attributes

protected java.lang.String name

protected java.lang.String namespace

protected org.kxml2.kdom.Node parent

protected java.util.ArrayList prefixes
----------------METHODS----------------

public void <init>()

public void clear()

public org.kxml2.kdom.Element createElement(
java.lang.String
java.lang.String)

public int getAttributeCount()

public java.lang.String getAttributeName(
int)

public java.lang.String getAttributeNamespace(
int)

public java.lang.String getAttributeValue(
int)

public java.lang.String getAttributeValue(
java.lang.String)

public java.lang.String getAttributeValue(
java.lang.String
java.lang.String)

public java.lang.String getName()

public java.lang.String getNamespace()

public int getNamespaceCount()

public java.lang.String getNamespacePrefix(
int)

public java.lang.String getNamespaceUri(
int)

public java.lang.String getNamespaceUri(
java.lang.String)

public org.kxml2.kdom.Node getParent()

public org.kxml2.kdom.Node getRoot()

public void init()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Lorg/xmlpull/v1/XmlPullParserException; )
public void parse(
org.xmlpull.v1.XmlPullParser)

public void setAttribute(
java.lang.String
java.lang.String
java.lang.String)

public void setName(
java.lang.String)

public void setNamespace(
java.lang.String)

protected void setParent(
org.kxml2.kdom.Node)

public void setPrefix(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void write(
org.xmlpull.v1.XmlSerializer)

________________CLASS________________


public abstract interface class org.kxml2.wap.Wbxml extends java.lang.Object

----------------FIELDS----------------

public static final int END

public static final int ENTITY

public static final int EXT_0

public static final int EXT_1

public static final int EXT_2

public static final int EXT_I_0

public static final int EXT_I_1

public static final int EXT_I_2

public static final int EXT_T_0

public static final int EXT_T_1

public static final int EXT_T_2

public static final int LITERAL

public static final int LITERAL_A

public static final int LITERAL_AC

public static final int LITERAL_C

public static final int OPAQUE

public static final int PI

public static final int STR_I

public static final int STR_T

public static final int SWITCH_PAGE
----------------METHODS----------------

________________CLASS________________


public class org.kxml2.wap.WbxmlParser extends java.lang.Object implements org.xmlpull.v1.XmlPullParser

----------------FIELDS----------------

private static final java.lang.String ILLEGAL_TYPE

private static final java.lang.String UNEXPECTED_EOF

public static final int WAP_EXTENSION

private int ATTR_START_TABLE

private int ATTR_VALUE_TABLE

private int TAG_TABLE

private java.lang.String[] attrStartTable

private java.lang.String[] attrValueTable

private int attributeCount

private java.lang.String[] attributes

private java.util.Hashtable cacheStringTable

 int charSet

private int codePage

private boolean degenerated

private int depth

private java.lang.String[] elementStack

private java.lang.String encoding

private java.io.InputStream in

private boolean isWhitespace

private java.lang.String name

private java.lang.String namespace

private int nextId

private int[] nspCounts

private java.lang.String[] nspStack

private java.lang.String prefix

private boolean processNsp

 int publicIdentifierId

private byte[] stringTable

private java.util.Vector tables

private java.lang.String[] tagTable

private java.lang.String text

private int type

 int version

private int wapExtensionCode

private java.lang.Object wapExtensionData
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
private final boolean adjustNsp()

private final java.lang.String[] ensureCapacity(
java.lang.String[]
int)
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
private final void exception(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Lorg/xmlpull/v1/XmlPullParserException; )
private final void nextImpl()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
private int peekId()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
private void selectPage(
int
boolean)

private final void setTable(
int
int
java.lang.String[])
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public void defineEntityReplacementText(
java.lang.String
java.lang.String)

public int getAttributeCount()

public java.lang.String getAttributeName(
int)

public java.lang.String getAttributeNamespace(
int)

public java.lang.String getAttributePrefix(
int)

public java.lang.String getAttributeType(
int)

public java.lang.String getAttributeValue(
int)

public java.lang.String getAttributeValue(
java.lang.String
java.lang.String)

public int getColumnNumber()

public int getDepth()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public int getEventType()

public boolean getFeature(
java.lang.String)

public java.lang.String getInputEncoding()

public int getLineNumber()

public java.lang.String getName()

public java.lang.String getNamespace()

public java.lang.String getNamespace(
java.lang.String)

public int getNamespaceCount(
int)

public java.lang.String getNamespacePrefix(
int)

public java.lang.String getNamespaceUri(
int)

public java.lang.String getPositionDescription()

public java.lang.String getPrefix()

public java.lang.Object getProperty(
java.lang.String)

public java.lang.String getText()

public char[] getTextCharacters(
int[])

public boolean isAttributeDefault(
int)
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public boolean isEmptyElementTag()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public boolean isWhitespace()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException;Ljava/io/IOException; )
public int next()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException;Ljava/io/IOException; )
public int nextTag()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException;Ljava/io/IOException; )
public java.lang.String nextText()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException;Ljava/io/IOException; )
public int nextToken()
@dalvik.annotation.Throws (value =Ljava/io/IOException;Lorg/xmlpull/v1/XmlPullParserException; )
 void parseElement(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Lorg/xmlpull/v1/XmlPullParserException; )
public void parseWapExtension(
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Lorg/xmlpull/v1/XmlPullParserException; )
public void readAttr()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 int readByte()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 int readInt()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 java.lang.String readStrI()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 java.lang.String readStrT()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException;Ljava/io/IOException; )
public void require(
int
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 java.lang.String resolveId(
java.lang.String[]
int)

public void setAttrStartTable(
int
java.lang.String[])

public void setAttrValueTable(
int
java.lang.String[])
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public void setFeature(
java.lang.String
boolean)
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public void setInput(
java.io.InputStream
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public void setInput(
java.io.Reader)
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public void setProperty(
java.lang.String
java.lang.Object)

public void setTagTable(
int
java.lang.String[])

________________CLASS________________


public class org.kxml2.wap.WbxmlSerializer extends java.lang.Object implements org.xmlpull.v1.XmlSerializer

----------------FIELDS----------------

private int attrPage

 java.util.Hashtable attrStartTable

 java.util.Hashtable attrValueTable

 java.util.Vector attributes

 java.io.ByteArrayOutputStream buf

 int depth

private java.lang.String encoding

 java.lang.String name

 java.lang.String namespace

 java.io.OutputStream out

 java.lang.String pending

 java.util.Hashtable stringTable

 java.io.ByteArrayOutputStream stringTableBuf

private int tagPage

 java.util.Hashtable tagTable
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
static void writeInt(
java.io.OutputStream
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
static void writeStrI(
java.io.OutputStream
java.lang.String)

public org.xmlpull.v1.XmlSerializer attribute(
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void cdsect(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void checkPending(
boolean)

public void comment(
java.lang.String)

public void docdecl(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void endDocument()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public org.xmlpull.v1.XmlSerializer endTag(
java.lang.String
java.lang.String)

public void entityRef(
java.lang.String)

public void flush()

public int getDepth()

public boolean getFeature(
java.lang.String)

public java.lang.String getName()

public java.lang.String getNamespace()

public java.lang.String getPrefix(
java.lang.String
boolean)

public java.lang.Object getProperty(
java.lang.String)

public void ignorableWhitespace(
java.lang.String)

public void processingInstruction(
java.lang.String)

public void setAttrStartTable(
int
java.lang.String[])

public void setAttrValueTable(
int
java.lang.String[])

public void setFeature(
java.lang.String
boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void setOutput(
java.io.OutputStream
java.lang.String)

public void setOutput(
java.io.Writer)

public void setPrefix(
java.lang.String
java.lang.String)

public void setProperty(
java.lang.String
java.lang.Object)

public void setTagTable(
int
java.lang.String[])
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public void startDocument(
java.lang.String
java.lang.Boolean)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public org.xmlpull.v1.XmlSerializer startTag(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public org.xmlpull.v1.XmlSerializer text(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public org.xmlpull.v1.XmlSerializer text(
char[]
int
int)

public void writeLegacy(
int
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
 void writeStrT(
java.lang.String)

________________CLASS________________


public abstract class org.kxml2.wap.syncml.SyncML extends java.lang.Object

----------------FIELDS----------------

public static final java.lang.String[] TAG_TABLE_0

public static final java.lang.String[] TAG_TABLE_1

public static final java.lang.String[] TAG_TABLE_2_DM
----------------METHODS----------------

static void <clinit>()

public void <init>()

public static org.kxml2.wap.WbxmlParser createDMParser()

public static org.kxml2.wap.WbxmlSerializer createDMSerializer()

public static org.kxml2.wap.WbxmlParser createParser()

public static org.kxml2.wap.WbxmlSerializer createSerializer()

________________CLASS________________


public abstract class org.kxml2.wap.wml.Wml extends java.lang.Object

----------------FIELDS----------------

public static final java.lang.String[] ATTR_START_TABLE

public static final java.lang.String[] ATTR_VALUE_TABLE

public static final java.lang.String[] TAG_TABLE
----------------METHODS----------------

static void <clinit>()

public void <init>()

public static org.kxml2.wap.WbxmlParser createParser()

public static org.kxml2.wap.WbxmlSerializer createSerializer()

________________CLASS________________


public abstract class org.kxml2.wap.wv.WV extends java.lang.Object

----------------FIELDS----------------

public static final java.lang.String[] attrStartTable

public static final java.lang.String[] attrValueTable

public static final java.lang.String[] tagTablePage0

public static final java.lang.String[] tagTablePage1

public static final java.lang.String[] tagTablePage2

public static final java.lang.String[] tagTablePage3

public static final java.lang.String[] tagTablePage4

public static final java.lang.String[] tagTablePage5

public static final java.lang.String[] tagTablePage6

public static final java.lang.String[] tagTablePage7

public static final java.lang.String[] tagTablePage8

public static final java.lang.String[] tagTablePage9

public static final java.lang.String[] tagTablePageA
----------------METHODS----------------

static void <clinit>()

public void <init>()
@dalvik.annotation.Throws (value =Ljava/io/IOException; )
public static org.kxml2.wap.WbxmlParser createParser()

________________CLASS________________


public class org.openssl.NativeBN extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public static native int BN_CTX_new()

public static native boolean BN_add(
int
int
int)

public static native boolean BN_add_word(
int
int)

public static native boolean BN_bin2bn(
byte[]
int
boolean
int)

public static native byte[] BN_bn2bin(
int
byte[])

public static native java.lang.String BN_bn2dec(
int)

public static native java.lang.String BN_bn2hex(
int)

public static native int BN_cmp(
int
int)

public static native boolean BN_copy(
int
int)

public static native int BN_dec2bn(
int
java.lang.String)

public static native boolean BN_div(
int
int
int
int
int)

public static native int BN_div_word(
int
int)

public static native boolean BN_exp(
int
int
int
int)

public static native void BN_free(
int)

public static native boolean BN_gcd(
int
int
int
int)

public static native boolean BN_generate_prime_ex(
int
int
boolean
int
int
int)

public static native int BN_hex2bn(
int
java.lang.String)

public static native boolean BN_is_bit_set(
int
int)

public static native boolean BN_is_prime_ex(
int
int
int
int)

public static native boolean BN_lshift(
int
int
int)

public static native boolean BN_mod_exp(
int
int
int
int
int)

public static native boolean BN_mod_inverse(
int
int
int
int)

public static native int BN_mod_word(
int
int)

public static native boolean BN_mul(
int
int
int
int)

public static native boolean BN_mul_word(
int
int)

public static native int BN_new()

public static native boolean BN_nnmod(
int
int
int
int)

public static native void BN_set_negative(
int
int)

public static native boolean BN_sub(
int
int
int)

public static native boolean BN_sub_word(
int
int)

public static native java.lang.String ERR_error_string(
int)

public static native int ERR_get_error()

public static native int bitLength(
int)

public static native int[] bn2litEndInts(
int
int[])

public static native byte[] bn2twosComp(
int
byte[])

public static native boolean litEndInts2bn(
int[]
int
boolean
int)

public static native long longInt(
int)

public static native boolean modifyBit(
int
int
int)

public static native boolean putLongInt(
int
long)

public static native boolean putULongInt(
int
long
boolean)

public static native int sign(
int)

public static native boolean twosComp2bn(
byte[]
int
int)

public static native boolean twosCompFitsIntoBytes(
int
int)

________________CLASS________________


public class org.w3c.dom.DOMException extends java.lang.RuntimeException

----------------FIELDS----------------

public static final short DOMSTRING_SIZE_ERR

public static final short HIERARCHY_REQUEST_ERR

public static final short INDEX_SIZE_ERR

public static final short INUSE_ATTRIBUTE_ERR

public static final short INVALID_ACCESS_ERR

public static final short INVALID_CHARACTER_ERR

public static final short INVALID_MODIFICATION_ERR

public static final short INVALID_STATE_ERR

public static final short NAMESPACE_ERR

public static final short NOT_FOUND_ERR

public static final short NOT_SUPPORTED_ERR

public static final short NO_DATA_ALLOWED_ERR

public static final short NO_MODIFICATION_ALLOWED_ERR

public static final short SYNTAX_ERR

public static final short WRONG_DOCUMENT_ERR

public short code
----------------METHODS----------------

public void <init>(
short
java.lang.String)

________________CLASS________________


public abstract interface class org.xml.sax.AttributeList extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

public abstract int getLength()

public abstract java.lang.String getName(
int)

public abstract java.lang.String getType(
int)

public abstract java.lang.String getType(
java.lang.String)

public abstract java.lang.String getValue(
int)

public abstract java.lang.String getValue(
java.lang.String)

________________CLASS________________


public abstract interface class org.xml.sax.DTDHandler extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public abstract void notationDecl(
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public abstract void unparsedEntityDecl(
java.lang.String
java.lang.String
java.lang.String
java.lang.String)

________________CLASS________________


public abstract interface class org.xml.sax.DocumentHandler extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public abstract void characters(
char[]
int
int)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public abstract void endDocument()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public abstract void endElement(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public abstract void ignorableWhitespace(
char[]
int
int)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public abstract void processingInstruction(
java.lang.String
java.lang.String)

public abstract void setDocumentLocator(
org.xml.sax.Locator)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public abstract void startDocument()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public abstract void startElement(
java.lang.String
org.xml.sax.AttributeList)

________________CLASS________________


public class org.xml.sax.HandlerBase extends java.lang.Object implements org.xml.sax.EntityResolver, org.xml.sax.DTDHandler, org.xml.sax.DocumentHandler, org.xml.sax.ErrorHandler

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void characters(
char[]
int
int)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void endDocument()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void endElement(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void error(
org.xml.sax.SAXParseException)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void fatalError(
org.xml.sax.SAXParseException)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void ignorableWhitespace(
char[]
int
int)

public void notationDecl(
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void processingInstruction(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public org.xml.sax.InputSource resolveEntity(
java.lang.String
java.lang.String)

public void setDocumentLocator(
org.xml.sax.Locator)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void startDocument()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void startElement(
java.lang.String
org.xml.sax.AttributeList)

public void unparsedEntityDecl(
java.lang.String
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void warning(
org.xml.sax.SAXParseException)

________________CLASS________________


public class org.xml.sax.InputSource extends java.lang.Object

----------------FIELDS----------------

private java.io.InputStream byteStream

private java.io.Reader characterStream

private java.lang.String encoding

private java.lang.String publicId

private java.lang.String systemId
----------------METHODS----------------

public void <init>()

public void <init>(
java.io.InputStream)

public void <init>(
java.io.Reader)

public void <init>(
java.lang.String)

public java.io.InputStream getByteStream()

public java.io.Reader getCharacterStream()

public java.lang.String getEncoding()

public java.lang.String getPublicId()

public java.lang.String getSystemId()

public void setByteStream(
java.io.InputStream)

public void setCharacterStream(
java.io.Reader)

public void setEncoding(
java.lang.String)

public void setPublicId(
java.lang.String)

public void setSystemId(
java.lang.String)

________________CLASS________________


public abstract interface class org.xml.sax.Parser extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException;Ljava/io/IOException; )
public abstract void parse(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException;Ljava/io/IOException; )
public abstract void parse(
org.xml.sax.InputSource)

public abstract void setDTDHandler(
org.xml.sax.DTDHandler)

public abstract void setDocumentHandler(
org.xml.sax.DocumentHandler)

public abstract void setEntityResolver(
org.xml.sax.EntityResolver)

public abstract void setErrorHandler(
org.xml.sax.ErrorHandler)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public abstract void setLocale(
java.util.Locale)

________________CLASS________________


public class org.xml.sax.SAXNotRecognizedException extends org.xml.sax.SAXException

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public class org.xml.sax.SAXNotSupportedException extends org.xml.sax.SAXException

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()

public void <init>(
java.lang.String)

________________CLASS________________


public abstract interface class org.xml.sax.XMLFilter extends java.lang.Object implements org.xml.sax.XMLReader

----------------FIELDS----------------
----------------METHODS----------------

public abstract org.xml.sax.XMLReader getParent()

public abstract void setParent(
org.xml.sax.XMLReader)

________________CLASS________________


public abstract interface class org.xml.sax.ext.Attributes2 extends java.lang.Object implements org.xml.sax.Attributes

----------------FIELDS----------------
----------------METHODS----------------

public abstract boolean isDeclared(
int)

public abstract boolean isDeclared(
java.lang.String)

public abstract boolean isDeclared(
java.lang.String
java.lang.String)

public abstract boolean isSpecified(
int)

public abstract boolean isSpecified(
java.lang.String)

public abstract boolean isSpecified(
java.lang.String
java.lang.String)

________________CLASS________________


public class org.xml.sax.helpers.AttributesImpl extends java.lang.Object implements org.xml.sax.Attributes

----------------FIELDS----------------

 java.lang.String[] data

 int length
----------------METHODS----------------

public void <init>()

public void <init>(
org.xml.sax.Attributes)
@dalvik.annotation.Throws (value =Ljava/lang/ArrayIndexOutOfBoundsException; )
private void badIndex(
int)

private void ensureCapacity(
int)

public void addAttribute(
java.lang.String
java.lang.String
java.lang.String
java.lang.String
java.lang.String)

public void clear()

public int getIndex(
java.lang.String)

public int getIndex(
java.lang.String
java.lang.String)

public int getLength()

public java.lang.String getLocalName(
int)

public java.lang.String getQName(
int)

public java.lang.String getType(
int)

public java.lang.String getType(
java.lang.String)

public java.lang.String getType(
java.lang.String
java.lang.String)

public java.lang.String getURI(
int)

public java.lang.String getValue(
int)

public java.lang.String getValue(
java.lang.String)

public java.lang.String getValue(
java.lang.String
java.lang.String)

public void removeAttribute(
int)

public void setAttribute(
int
java.lang.String
java.lang.String
java.lang.String
java.lang.String
java.lang.String)

public void setAttributes(
org.xml.sax.Attributes)

public void setLocalName(
int
java.lang.String)

public void setQName(
int
java.lang.String)

public void setType(
int
java.lang.String)

public void setURI(
int
java.lang.String)

public void setValue(
int
java.lang.String)

________________CLASS________________


public class org.xml.sax.ext.Attributes2Impl extends org.xml.sax.helpers.AttributesImpl implements org.xml.sax.ext.Attributes2

----------------FIELDS----------------

private boolean[] declared

private boolean[] specified
----------------METHODS----------------

public void <init>()

public void <init>(
org.xml.sax.Attributes)

public void addAttribute(
java.lang.String
java.lang.String
java.lang.String
java.lang.String
java.lang.String)

public boolean isDeclared(
int)

public boolean isDeclared(
java.lang.String)

public boolean isDeclared(
java.lang.String
java.lang.String)

public boolean isSpecified(
int)

public boolean isSpecified(
java.lang.String)

public boolean isSpecified(
java.lang.String
java.lang.String)

public void removeAttribute(
int)

public void setAttributes(
org.xml.sax.Attributes)

public void setDeclared(
int
boolean)

public void setSpecified(
int
boolean)

________________CLASS________________


public abstract interface class org.xml.sax.ext.DeclHandler extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public abstract void attributeDecl(
java.lang.String
java.lang.String
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public abstract void elementDecl(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public abstract void externalEntityDecl(
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public abstract void internalEntityDecl(
java.lang.String
java.lang.String)

________________CLASS________________


public class org.xml.sax.helpers.DefaultHandler extends java.lang.Object implements org.xml.sax.EntityResolver, org.xml.sax.DTDHandler, org.xml.sax.ContentHandler, org.xml.sax.ErrorHandler

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void characters(
char[]
int
int)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void endDocument()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void endElement(
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void endPrefixMapping(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void error(
org.xml.sax.SAXParseException)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void fatalError(
org.xml.sax.SAXParseException)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void ignorableWhitespace(
char[]
int
int)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void notationDecl(
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void processingInstruction(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Lorg/xml/sax/SAXException; )
public org.xml.sax.InputSource resolveEntity(
java.lang.String
java.lang.String)

public void setDocumentLocator(
org.xml.sax.Locator)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void skippedEntity(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void startDocument()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void startElement(
java.lang.String
java.lang.String
java.lang.String
org.xml.sax.Attributes)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void startPrefixMapping(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void unparsedEntityDecl(
java.lang.String
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void warning(
org.xml.sax.SAXParseException)

________________CLASS________________


public abstract interface class org.xml.sax.ext.LexicalHandler extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public abstract void comment(
char[]
int
int)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public abstract void endCDATA()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public abstract void endDTD()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public abstract void endEntity(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public abstract void startCDATA()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public abstract void startDTD(
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public abstract void startEntity(
java.lang.String)

________________CLASS________________


public abstract interface class org.xml.sax.ext.EntityResolver2 extends java.lang.Object implements org.xml.sax.EntityResolver

----------------FIELDS----------------
----------------METHODS----------------
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException;Ljava/io/IOException; )
public abstract org.xml.sax.InputSource getExternalSubset(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException;Ljava/io/IOException; )
public abstract org.xml.sax.InputSource resolveEntity(
java.lang.String
java.lang.String
java.lang.String
java.lang.String)

________________CLASS________________


public class org.xml.sax.ext.DefaultHandler2 extends org.xml.sax.helpers.DefaultHandler implements org.xml.sax.ext.LexicalHandler, org.xml.sax.ext.DeclHandler, org.xml.sax.ext.EntityResolver2

----------------FIELDS----------------
----------------METHODS----------------

public void <init>()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void attributeDecl(
java.lang.String
java.lang.String
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void comment(
char[]
int
int)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void elementDecl(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void endCDATA()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void endDTD()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void endEntity(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void externalEntityDecl(
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException;Ljava/io/IOException; )
public org.xml.sax.InputSource getExternalSubset(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void internalEntityDecl(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException;Ljava/io/IOException; )
public org.xml.sax.InputSource resolveEntity(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException;Ljava/io/IOException; )
public org.xml.sax.InputSource resolveEntity(
java.lang.String
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void startCDATA()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void startDTD(
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void startEntity(
java.lang.String)

________________CLASS________________


public abstract interface class org.xml.sax.ext.Locator2 extends java.lang.Object implements org.xml.sax.Locator

----------------FIELDS----------------
----------------METHODS----------------

public abstract java.lang.String getEncoding()

public abstract java.lang.String getXMLVersion()

________________CLASS________________


public class org.xml.sax.helpers.LocatorImpl extends java.lang.Object implements org.xml.sax.Locator

----------------FIELDS----------------

private int columnNumber

private int lineNumber

private java.lang.String publicId

private java.lang.String systemId
----------------METHODS----------------

public void <init>()

public void <init>(
org.xml.sax.Locator)

public int getColumnNumber()

public int getLineNumber()

public java.lang.String getPublicId()

public java.lang.String getSystemId()

public void setColumnNumber(
int)

public void setLineNumber(
int)

public void setPublicId(
java.lang.String)

public void setSystemId(
java.lang.String)

________________CLASS________________


public class org.xml.sax.ext.Locator2Impl extends org.xml.sax.helpers.LocatorImpl implements org.xml.sax.ext.Locator2

----------------FIELDS----------------

private java.lang.String encoding

private java.lang.String version
----------------METHODS----------------

public void <init>()

public void <init>(
org.xml.sax.Locator)

public java.lang.String getEncoding()

public java.lang.String getXMLVersion()

public void setEncoding(
java.lang.String)

public void setXMLVersion(
java.lang.String)

________________CLASS________________


public class org.xml.sax.helpers.AttributeListImpl extends java.lang.Object implements org.xml.sax.AttributeList

----------------FIELDS----------------

 java.util.Vector names

 java.util.Vector types

 java.util.Vector values
----------------METHODS----------------

public void <init>()

public void <init>(
org.xml.sax.AttributeList)

public void addAttribute(
java.lang.String
java.lang.String
java.lang.String)

public void clear()

public int getLength()

public java.lang.String getName(
int)

public java.lang.String getType(
int)

public java.lang.String getType(
java.lang.String)

public java.lang.String getValue(
int)

public java.lang.String getValue(
java.lang.String)

public void removeAttribute(
java.lang.String)

public void setAttributeList(
org.xml.sax.AttributeList)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =16 name =Context )
@dalvik.annotation.EnclosingClass (value =Lorg/xml/sax/helpers/NamespaceSupport; )
final class org.xml.sax.helpers.NamespaceSupport$Context extends java.lang.Object

----------------FIELDS----------------

 java.util.Hashtable attributeNameTable

private boolean declSeen

private java.util.Vector declarations

 boolean declsOK

 java.lang.String defaultNS

 java.util.Hashtable elementNameTable

private org.xml.sax.helpers.NamespaceSupport$Context parent

 java.util.Hashtable prefixTable

final org.xml.sax.helpers.NamespaceSupport this$0

 java.util.Hashtable uriTable
----------------METHODS----------------

 void <init>(
org.xml.sax.helpers.NamespaceSupport)

private void copyTables()

 void clear()

 void declarePrefix(
java.lang.String
java.lang.String)

 java.util.Enumeration getDeclaredPrefixes()

 java.lang.String getPrefix(
java.lang.String)

 java.util.Enumeration getPrefixes()

 java.lang.String getURI(
java.lang.String)

 java.lang.String[] processName(
java.lang.String
boolean)

 void setParent(
org.xml.sax.helpers.NamespaceSupport$Context)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/xml/sax/helpers/NamespaceSupport$Context; )
public class org.xml.sax.helpers.NamespaceSupport extends java.lang.Object

----------------FIELDS----------------

private static final java.util.Enumeration EMPTY_ENUMERATION

public static final java.lang.String NSDECL

public static final java.lang.String XMLNS

private int contextPos

private org.xml.sax.helpers.NamespaceSupport$Context[] contexts

private org.xml.sax.helpers.NamespaceSupport$Context currentContext

private boolean namespaceDeclUris
----------------METHODS----------------

static void <clinit>()

public void <init>()

static boolean access$000(
org.xml.sax.helpers.NamespaceSupport)

static java.util.Enumeration access$100()

public boolean declarePrefix(
java.lang.String
java.lang.String)

public java.util.Enumeration getDeclaredPrefixes()

public java.lang.String getPrefix(
java.lang.String)

public java.util.Enumeration getPrefixes()

public java.util.Enumeration getPrefixes(
java.lang.String)

public java.lang.String getURI(
java.lang.String)

public boolean isNamespaceDeclUris()

public void popContext()

public java.lang.String[] processName(
java.lang.String
java.lang.String[]
boolean)

public void pushContext()

public void reset()

public void setNamespaceDeclUris(
boolean)

________________CLASS________________


 class org.xml.sax.helpers.NewInstance extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

 void <init>()

static java.lang.ClassLoader getClassLoader()
@dalvik.annotation.Throws (value =Ljava/lang/ClassNotFoundException;Ljava/lang/IllegalAccessException;Ljava/lang/InstantiationException; )
static java.lang.Object newInstance(
java.lang.ClassLoader
java.lang.String)

________________CLASS________________

@dalvik.annotation.EnclosingClass (value =Lorg/xml/sax/helpers/ParserAdapter; )
@dalvik.annotation.InnerClass (accessFlags =16 name =AttributeListAdapter )
final class org.xml.sax.helpers.ParserAdapter$AttributeListAdapter extends java.lang.Object implements org.xml.sax.Attributes

----------------FIELDS----------------

private org.xml.sax.AttributeList qAtts

final org.xml.sax.helpers.ParserAdapter this$0
----------------METHODS----------------

 void <init>(
org.xml.sax.helpers.ParserAdapter)

public int getIndex(
java.lang.String)

public int getIndex(
java.lang.String
java.lang.String)

public int getLength()

public java.lang.String getLocalName(
int)

public java.lang.String getQName(
int)

public java.lang.String getType(
int)

public java.lang.String getType(
java.lang.String)

public java.lang.String getType(
java.lang.String
java.lang.String)

public java.lang.String getURI(
int)

public java.lang.String getValue(
int)

public java.lang.String getValue(
java.lang.String)

public java.lang.String getValue(
java.lang.String
java.lang.String)

 void setAttributeList(
org.xml.sax.AttributeList)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/xml/sax/helpers/ParserAdapter$AttributeListAdapter; )
public class org.xml.sax.helpers.ParserAdapter extends java.lang.Object implements org.xml.sax.XMLReader, org.xml.sax.DocumentHandler

----------------FIELDS----------------

private static final java.lang.String FEATURES

private static final java.lang.String NAMESPACES

private static final java.lang.String NAMESPACE_PREFIXES

private static final java.lang.String XMLNS_URIs

private org.xml.sax.helpers.ParserAdapter$AttributeListAdapter attAdapter

private org.xml.sax.helpers.AttributesImpl atts

 org.xml.sax.ContentHandler contentHandler

 org.xml.sax.DTDHandler dtdHandler

 org.xml.sax.EntityResolver entityResolver

 org.xml.sax.ErrorHandler errorHandler

 org.xml.sax.Locator locator

private java.lang.String[] nameParts

private boolean namespaces

private org.xml.sax.helpers.NamespaceSupport nsSupport

private org.xml.sax.Parser parser

private boolean parsing

private boolean prefixes

private boolean uris
----------------METHODS----------------
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void <init>()

public void <init>(
org.xml.sax.Parser)

static org.xml.sax.helpers.AttributesImpl access$000(
org.xml.sax.helpers.ParserAdapter)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXNotSupportedException; )
private void checkNotParsing(
java.lang.String
java.lang.String)

private org.xml.sax.SAXParseException makeException(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
private java.lang.String[] processName(
java.lang.String
boolean
boolean)

private void setup(
org.xml.sax.Parser)

private void setupParser()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void characters(
char[]
int
int)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void endDocument()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void endElement(
java.lang.String)

public org.xml.sax.ContentHandler getContentHandler()

public org.xml.sax.DTDHandler getDTDHandler()

public org.xml.sax.EntityResolver getEntityResolver()

public org.xml.sax.ErrorHandler getErrorHandler()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXNotRecognizedException;Lorg/xml/sax/SAXNotSupportedException; )
public boolean getFeature(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXNotRecognizedException;Lorg/xml/sax/SAXNotSupportedException; )
public java.lang.Object getProperty(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void ignorableWhitespace(
char[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Lorg/xml/sax/SAXException; )
public void parse(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Lorg/xml/sax/SAXException; )
public void parse(
org.xml.sax.InputSource)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void processingInstruction(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
 void reportError(
java.lang.String)

public void setContentHandler(
org.xml.sax.ContentHandler)

public void setDTDHandler(
org.xml.sax.DTDHandler)

public void setDocumentLocator(
org.xml.sax.Locator)

public void setEntityResolver(
org.xml.sax.EntityResolver)

public void setErrorHandler(
org.xml.sax.ErrorHandler)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXNotRecognizedException;Lorg/xml/sax/SAXNotSupportedException; )
public void setFeature(
java.lang.String
boolean)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXNotRecognizedException;Lorg/xml/sax/SAXNotSupportedException; )
public void setProperty(
java.lang.String
java.lang.Object)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void startDocument()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void startElement(
java.lang.String
org.xml.sax.AttributeList)

________________CLASS________________


public class org.xml.sax.helpers.ParserFactory extends java.lang.Object

----------------FIELDS----------------
----------------METHODS----------------

private void <init>()
@dalvik.annotation.Throws (value =Ljava/lang/ClassNotFoundException;Ljava/lang/IllegalAccessException;Ljava/lang/InstantiationException;Ljava/lang/NullPointerException;Ljava/lang/ClassCastException; )
public static org.xml.sax.Parser makeParser()
@dalvik.annotation.Throws (value =Ljava/lang/ClassNotFoundException;Ljava/lang/IllegalAccessException;Ljava/lang/InstantiationException;Ljava/lang/ClassCastException; )
public static org.xml.sax.Parser makeParser(
java.lang.String)

________________CLASS________________


public class org.xml.sax.helpers.XMLFilterImpl extends java.lang.Object implements org.xml.sax.XMLFilter, org.xml.sax.EntityResolver, org.xml.sax.DTDHandler, org.xml.sax.ContentHandler, org.xml.sax.ErrorHandler

----------------FIELDS----------------

private org.xml.sax.ContentHandler contentHandler

private org.xml.sax.DTDHandler dtdHandler

private org.xml.sax.EntityResolver entityResolver

private org.xml.sax.ErrorHandler errorHandler

private org.xml.sax.Locator locator

private org.xml.sax.XMLReader parent
----------------METHODS----------------

public void <init>()

public void <init>(
org.xml.sax.XMLReader)

private void setupParse()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void characters(
char[]
int
int)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void endDocument()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void endElement(
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void endPrefixMapping(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void error(
org.xml.sax.SAXParseException)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void fatalError(
org.xml.sax.SAXParseException)

public org.xml.sax.ContentHandler getContentHandler()

public org.xml.sax.DTDHandler getDTDHandler()

public org.xml.sax.EntityResolver getEntityResolver()

public org.xml.sax.ErrorHandler getErrorHandler()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXNotRecognizedException;Lorg/xml/sax/SAXNotSupportedException; )
public boolean getFeature(
java.lang.String)

public org.xml.sax.XMLReader getParent()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXNotRecognizedException;Lorg/xml/sax/SAXNotSupportedException; )
public java.lang.Object getProperty(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void ignorableWhitespace(
char[]
int
int)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void notationDecl(
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException;Ljava/io/IOException; )
public void parse(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException;Ljava/io/IOException; )
public void parse(
org.xml.sax.InputSource)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void processingInstruction(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException;Ljava/io/IOException; )
public org.xml.sax.InputSource resolveEntity(
java.lang.String
java.lang.String)

public void setContentHandler(
org.xml.sax.ContentHandler)

public void setDTDHandler(
org.xml.sax.DTDHandler)

public void setDocumentLocator(
org.xml.sax.Locator)

public void setEntityResolver(
org.xml.sax.EntityResolver)

public void setErrorHandler(
org.xml.sax.ErrorHandler)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXNotRecognizedException;Lorg/xml/sax/SAXNotSupportedException; )
public void setFeature(
java.lang.String
boolean)

public void setParent(
org.xml.sax.XMLReader)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXNotRecognizedException;Lorg/xml/sax/SAXNotSupportedException; )
public void setProperty(
java.lang.String
java.lang.Object)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void skippedEntity(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void startDocument()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void startElement(
java.lang.String
java.lang.String
java.lang.String
org.xml.sax.Attributes)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void startPrefixMapping(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void unparsedEntityDecl(
java.lang.String
java.lang.String
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void warning(
org.xml.sax.SAXParseException)

________________CLASS________________

@dalvik.annotation.InnerClass (accessFlags =16 name =AttributesAdapter )
@dalvik.annotation.EnclosingClass (value =Lorg/xml/sax/helpers/XMLReaderAdapter; )
final class org.xml.sax.helpers.XMLReaderAdapter$AttributesAdapter extends java.lang.Object implements org.xml.sax.AttributeList

----------------FIELDS----------------

private org.xml.sax.Attributes attributes

final org.xml.sax.helpers.XMLReaderAdapter this$0
----------------METHODS----------------

 void <init>(
org.xml.sax.helpers.XMLReaderAdapter)

public int getLength()

public java.lang.String getName(
int)

public java.lang.String getType(
int)

public java.lang.String getType(
java.lang.String)

public java.lang.String getValue(
int)

public java.lang.String getValue(
java.lang.String)

 void setAttributes(
org.xml.sax.Attributes)

________________CLASS________________

@dalvik.annotation.MemberClasses (value =Lorg/xml/sax/helpers/XMLReaderAdapter$AttributesAdapter; )
public class org.xml.sax.helpers.XMLReaderAdapter extends java.lang.Object implements org.xml.sax.Parser, org.xml.sax.ContentHandler

----------------FIELDS----------------

 org.xml.sax.DocumentHandler documentHandler

 org.xml.sax.helpers.XMLReaderAdapter$AttributesAdapter qAtts

 org.xml.sax.XMLReader xmlReader
----------------METHODS----------------
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void <init>()

public void <init>(
org.xml.sax.XMLReader)

private void setup(
org.xml.sax.XMLReader)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
private void setupXMLReader()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void characters(
char[]
int
int)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void endDocument()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void endElement(
java.lang.String
java.lang.String
java.lang.String)

public void endPrefixMapping(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void ignorableWhitespace(
char[]
int
int)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Lorg/xml/sax/SAXException; )
public void parse(
java.lang.String)
@dalvik.annotation.Throws (value =Ljava/io/IOException;Lorg/xml/sax/SAXException; )
public void parse(
org.xml.sax.InputSource)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void processingInstruction(
java.lang.String
java.lang.String)

public void setDTDHandler(
org.xml.sax.DTDHandler)

public void setDocumentHandler(
org.xml.sax.DocumentHandler)

public void setDocumentLocator(
org.xml.sax.Locator)

public void setEntityResolver(
org.xml.sax.EntityResolver)

public void setErrorHandler(
org.xml.sax.ErrorHandler)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void setLocale(
java.util.Locale)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void skippedEntity(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void startDocument()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public void startElement(
java.lang.String
java.lang.String
java.lang.String
org.xml.sax.Attributes)

public void startPrefixMapping(
java.lang.String
java.lang.String)

________________CLASS________________


public final class org.xml.sax.helpers.XMLReaderFactory extends java.lang.Object

----------------FIELDS----------------

private static final java.lang.String property
----------------METHODS----------------

private void <init>()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public static org.xml.sax.XMLReader createXMLReader()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
public static org.xml.sax.XMLReader createXMLReader(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
private static org.xml.sax.XMLReader loadClass(
java.lang.ClassLoader
java.lang.String)

________________CLASS________________


public class org.xmlpull.v1.XmlPullParserException extends java.lang.Exception

----------------FIELDS----------------

protected int column

protected java.lang.Throwable detail

protected int row
----------------METHODS----------------

public void <init>(
java.lang.String)

public void <init>(
java.lang.String
org.xmlpull.v1.XmlPullParser
java.lang.Throwable)

public int getColumnNumber()

public java.lang.Throwable getDetail()

public int getLineNumber()

public void printStackTrace()

________________CLASS________________


public class org.xmlpull.v1.XmlPullParserFactory extends java.lang.Object

----------------FIELDS----------------

public static final java.lang.String PROPERTY_NAME

private static final java.lang.String RESOURCE_NAME

static final java.lang.Class referenceContextClass

protected java.lang.String classNamesLocation

protected java.util.HashMap features

protected java.util.ArrayList parserClasses

protected java.util.ArrayList serializerClasses
----------------METHODS----------------

static void <clinit>()

protected void <init>()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public static org.xmlpull.v1.XmlPullParserFactory newInstance()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public static org.xmlpull.v1.XmlPullParserFactory newInstance(
java.lang.String
java.lang.Class)

public boolean getFeature(
java.lang.String)

public boolean isNamespaceAware()

public boolean isValidating()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public org.xmlpull.v1.XmlPullParser newPullParser()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public org.xmlpull.v1.XmlSerializer newSerializer()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public void setFeature(
java.lang.String
boolean)

public void setNamespaceAware(
boolean)

public void setValidating(
boolean)

________________CLASS________________


public class org.xmlpull.v1.sax2.Driver extends java.lang.Object implements org.xml.sax.Locator, org.xml.sax.XMLReader, org.xml.sax.Attributes

----------------FIELDS----------------

protected static final java.lang.String APACHE_DYNAMIC_VALIDATION_FEATURE

protected static final java.lang.String APACHE_SCHEMA_VALIDATION_FEATURE

protected static final java.lang.String DECLARATION_HANDLER_PROPERTY

protected static final java.lang.String LEXICAL_HANDLER_PROPERTY

protected static final java.lang.String NAMESPACES_FEATURE

protected static final java.lang.String NAMESPACE_PREFIXES_FEATURE

protected static final java.lang.String VALIDATION_FEATURE

protected org.xml.sax.ContentHandler contentHandler

protected org.xml.sax.ErrorHandler errorHandler

protected org.xmlpull.v1.XmlPullParser pp

protected java.lang.String systemId
----------------METHODS----------------
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public void <init>()
@dalvik.annotation.Throws (value =Lorg/xmlpull/v1/XmlPullParserException; )
public void <init>(
org.xmlpull.v1.XmlPullParser)

public int getColumnNumber()

public org.xml.sax.ContentHandler getContentHandler()

public org.xml.sax.DTDHandler getDTDHandler()

public org.xml.sax.EntityResolver getEntityResolver()

public org.xml.sax.ErrorHandler getErrorHandler()
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXNotRecognizedException;Lorg/xml/sax/SAXNotSupportedException; )
public boolean getFeature(
java.lang.String)

public int getIndex(
java.lang.String)

public int getIndex(
java.lang.String
java.lang.String)

public int getLength()

public int getLineNumber()

public java.lang.String getLocalName(
int)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXNotRecognizedException;Lorg/xml/sax/SAXNotSupportedException; )
public java.lang.Object getProperty(
java.lang.String)

public java.lang.String getPublicId()

public java.lang.String getQName(
int)

public java.lang.String getSystemId()

public java.lang.String getType(
int)

public java.lang.String getType(
java.lang.String)

public java.lang.String getType(
java.lang.String
java.lang.String)

public java.lang.String getURI(
int)

public java.lang.String getValue(
int)

public java.lang.String getValue(
java.lang.String)

public java.lang.String getValue(
java.lang.String
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException;Ljava/io/IOException; )
public void parse(
java.lang.String)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException;Ljava/io/IOException; )
public void parse(
org.xml.sax.InputSource)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException;Ljava/io/IOException; )
public void parseSubTree(
org.xmlpull.v1.XmlPullParser)

public void setContentHandler(
org.xml.sax.ContentHandler)

public void setDTDHandler(
org.xml.sax.DTDHandler)

public void setEntityResolver(
org.xml.sax.EntityResolver)

public void setErrorHandler(
org.xml.sax.ErrorHandler)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXNotRecognizedException;Lorg/xml/sax/SAXNotSupportedException; )
public void setFeature(
java.lang.String
boolean)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXNotRecognizedException;Lorg/xml/sax/SAXNotSupportedException; )
public void setProperty(
java.lang.String
java.lang.Object)
@dalvik.annotation.Throws (value =Lorg/xml/sax/SAXException; )
protected void startElement(
java.lang.String
java.lang.String
java.lang.String)

________________CLASS________________


public final class sun.misc.Unsafe extends java.lang.Object

----------------FIELDS----------------

private static final sun.misc.Unsafe THE_ONE

private final org.apache.harmony.kernel.vm.LangAccess lang
----------------METHODS----------------

static void <clinit>()

private void <init>()

private static native int arrayBaseOffset0(
java.lang.Class)

private static native int arrayIndexScale0(
java.lang.Class)

public static sun.misc.Unsafe getUnsafe()

private static native long objectFieldOffset0(
java.lang.reflect.Field)

public int arrayBaseOffset(
java.lang.Class)

public int arrayIndexScale(
java.lang.Class)

public native boolean compareAndSwapInt(
java.lang.Object
long
int
int)

public native boolean compareAndSwapLong(
java.lang.Object
long
long
long)

public native boolean compareAndSwapObject(
java.lang.Object
long
java.lang.Object
java.lang.Object)

public native int getInt(
java.lang.Object
long)

public native int getIntVolatile(
java.lang.Object
long)

public native long getLong(
java.lang.Object
long)

public native long getLongVolatile(
java.lang.Object
long)

public native java.lang.Object getObject(
java.lang.Object
long)

public native java.lang.Object getObjectVolatile(
java.lang.Object
long)

public long objectFieldOffset(
java.lang.reflect.Field)

public void park(
boolean
long)

public native void putInt(
java.lang.Object
long
int)

public native void putIntVolatile(
java.lang.Object
long
int)

public native void putLong(
java.lang.Object
long
long)

public native void putLongVolatile(
java.lang.Object
long
long)

public native void putObject(
java.lang.Object
long
java.lang.Object)

public native void putObjectVolatile(
java.lang.Object
long
java.lang.Object)

public void unpark(
java.lang.Object)
