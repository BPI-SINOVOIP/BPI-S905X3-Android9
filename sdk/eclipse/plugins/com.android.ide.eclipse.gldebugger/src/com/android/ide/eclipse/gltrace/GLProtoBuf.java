// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gltrace.proto

package com.android.ide.eclipse.gltrace;

public final class GLProtoBuf {
  private GLProtoBuf() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }
  public static final class GLMessage extends
      com.google.protobuf.GeneratedMessageLite {
    // Use GLMessage.newBuilder() to construct.
    private GLMessage() {
      initFields();
    }
    private GLMessage(boolean noInit) {}
    
    private static final GLMessage defaultInstance;
    public static GLMessage getDefaultInstance() {
      return defaultInstance;
    }
    
    @Override
    public GLMessage getDefaultInstanceForType() {
      return defaultInstance;
    }
    
    public enum Function
        implements com.google.protobuf.Internal.EnumLite {
      glActiveTexture(0, 0),
      glAlphaFunc(1, 1),
      glAlphaFuncx(2, 2),
      glAlphaFuncxOES(3, 3),
      glAttachShader(4, 4),
      glBeginPerfMonitorAMD(5, 5),
      glBindAttribLocation(6, 6),
      glBindBuffer(7, 7),
      glBindFramebuffer(8, 8),
      glBindFramebufferOES(9, 9),
      glBindRenderbuffer(10, 10),
      glBindRenderbufferOES(11, 11),
      glBindTexture(12, 12),
      glBindVertexArrayOES(13, 13),
      glBlendColor(14, 14),
      glBlendEquation(15, 15),
      glBlendEquationOES(16, 16),
      glBlendEquationSeparate(17, 17),
      glBlendEquationSeparateOES(18, 18),
      glBlendFunc(19, 19),
      glBlendFuncSeparate(20, 20),
      glBlendFuncSeparateOES(21, 21),
      glBufferData(22, 22),
      glBufferSubData(23, 23),
      glCheckFramebufferStatus(24, 24),
      glCheckFramebufferStatusOES(25, 25),
      glClearColor(26, 26),
      glClearColorx(27, 27),
      glClearColorxOES(28, 28),
      glClearDepthf(29, 29),
      glClearDepthfOES(30, 30),
      glClearDepthx(31, 31),
      glClearDepthxOES(32, 32),
      glClear(33, 33),
      glClearStencil(34, 34),
      glClientActiveTexture(35, 35),
      glClipPlanef(36, 36),
      glClipPlanefIMG(37, 37),
      glClipPlanefOES(38, 38),
      glClipPlanex(39, 39),
      glClipPlanexIMG(40, 40),
      glClipPlanexOES(41, 41),
      glColor4f(42, 42),
      glColor4ub(43, 43),
      glColor4x(44, 44),
      glColor4xOES(45, 45),
      glColorMask(46, 46),
      glColorPointer(47, 47),
      glCompileShader(48, 48),
      glCompressedTexImage2D(49, 49),
      glCompressedTexImage3DOES(50, 50),
      glCompressedTexSubImage2D(51, 51),
      glCompressedTexSubImage3DOES(52, 52),
      glCopyTexImage2D(53, 53),
      glCopyTexSubImage2D(54, 54),
      glCopyTexSubImage3DOES(55, 55),
      glCoverageMaskNV(56, 56),
      glCoverageOperationNV(57, 57),
      glCreateProgram(58, 58),
      glCreateShader(59, 59),
      glCullFace(60, 60),
      glCurrentPaletteMatrixOES(61, 61),
      glDeleteBuffers(62, 62),
      glDeleteFencesNV(63, 63),
      glDeleteFramebuffers(64, 64),
      glDeleteFramebuffersOES(65, 65),
      glDeletePerfMonitorsAMD(66, 66),
      glDeleteProgram(67, 67),
      glDeleteRenderbuffers(68, 68),
      glDeleteRenderbuffersOES(69, 69),
      glDeleteShader(70, 70),
      glDeleteTextures(71, 71),
      glDeleteVertexArraysOES(72, 72),
      glDepthFunc(73, 73),
      glDepthMask(74, 74),
      glDepthRangef(75, 75),
      glDepthRangefOES(76, 76),
      glDepthRangex(77, 77),
      glDepthRangexOES(78, 78),
      glDetachShader(79, 79),
      glDisableClientState(80, 80),
      glDisableDriverControlQCOM(81, 81),
      glDisable(82, 82),
      glDisableVertexAttribArray(83, 83),
      glDiscardFramebufferEXT(84, 84),
      glDrawArrays(85, 85),
      glDrawElements(86, 86),
      glDrawTexfOES(87, 87),
      glDrawTexfvOES(88, 88),
      glDrawTexiOES(89, 89),
      glDrawTexivOES(90, 90),
      glDrawTexsOES(91, 91),
      glDrawTexsvOES(92, 92),
      glDrawTexxOES(93, 93),
      glDrawTexxvOES(94, 94),
      glEGLImageTargetRenderbufferStorageOES(95, 95),
      glEGLImageTargetTexture2DOES(96, 96),
      glEnableClientState(97, 97),
      glEnableDriverControlQCOM(98, 98),
      glEnable(99, 99),
      glEnableVertexAttribArray(100, 100),
      glEndPerfMonitorAMD(101, 101),
      glEndTilingQCOM(102, 102),
      glExtGetBufferPointervQCOM(103, 103),
      glExtGetBuffersQCOM(104, 104),
      glExtGetFramebuffersQCOM(105, 105),
      glExtGetProgramBinarySourceQCOM(106, 106),
      glExtGetProgramsQCOM(107, 107),
      glExtGetRenderbuffersQCOM(108, 108),
      glExtGetShadersQCOM(109, 109),
      glExtGetTexLevelParameterivQCOM(110, 110),
      glExtGetTexSubImageQCOM(111, 111),
      glExtGetTexturesQCOM(112, 112),
      glExtIsProgramBinaryQCOM(113, 113),
      glExtTexObjectStateOverrideiQCOM(114, 114),
      glFinishFenceNV(115, 115),
      glFinish(116, 116),
      glFlush(117, 117),
      glFogf(118, 118),
      glFogfv(119, 119),
      glFogx(120, 120),
      glFogxOES(121, 121),
      glFogxv(122, 122),
      glFogxvOES(123, 123),
      glFramebufferRenderbuffer(124, 124),
      glFramebufferRenderbufferOES(125, 125),
      glFramebufferTexture2D(126, 126),
      glFramebufferTexture2DMultisampleIMG(127, 127),
      glFramebufferTexture2DOES(128, 128),
      glFramebufferTexture3DOES(129, 129),
      glFrontFace(130, 130),
      glFrustumf(131, 131),
      glFrustumfOES(132, 132),
      glFrustumx(133, 133),
      glFrustumxOES(134, 134),
      glGenBuffers(135, 135),
      glGenerateMipmap(136, 136),
      glGenerateMipmapOES(137, 137),
      glGenFencesNV(138, 138),
      glGenFramebuffers(139, 139),
      glGenFramebuffersOES(140, 140),
      glGenPerfMonitorsAMD(141, 141),
      glGenRenderbuffers(142, 142),
      glGenRenderbuffersOES(143, 143),
      glGenTextures(144, 144),
      glGenVertexArraysOES(145, 145),
      glGetActiveAttrib(146, 146),
      glGetActiveUniform(147, 147),
      glGetAttachedShaders(148, 148),
      glGetAttribLocation(149, 149),
      glGetBooleanv(150, 150),
      glGetBufferParameteriv(151, 151),
      glGetBufferPointervOES(152, 152),
      glGetClipPlanef(153, 153),
      glGetClipPlanefOES(154, 154),
      glGetClipPlanex(155, 155),
      glGetClipPlanexOES(156, 156),
      glGetDriverControlsQCOM(157, 157),
      glGetDriverControlStringQCOM(158, 158),
      glGetError(159, 159),
      glGetFenceivNV(160, 160),
      glGetFixedv(161, 161),
      glGetFixedvOES(162, 162),
      glGetFloatv(163, 163),
      glGetFramebufferAttachmentParameteriv(164, 164),
      glGetFramebufferAttachmentParameterivOES(165, 165),
      glGetIntegerv(166, 166),
      glGetLightfv(167, 167),
      glGetLightxv(168, 168),
      glGetLightxvOES(169, 169),
      glGetMaterialfv(170, 170),
      glGetMaterialxv(171, 171),
      glGetMaterialxvOES(172, 172),
      glGetPerfMonitorCounterDataAMD(173, 173),
      glGetPerfMonitorCounterInfoAMD(174, 174),
      glGetPerfMonitorCountersAMD(175, 175),
      glGetPerfMonitorCounterStringAMD(176, 176),
      glGetPerfMonitorGroupsAMD(177, 177),
      glGetPerfMonitorGroupStringAMD(178, 178),
      glGetPointerv(179, 179),
      glGetProgramBinaryOES(180, 180),
      glGetProgramInfoLog(181, 181),
      glGetProgramiv(182, 182),
      glGetRenderbufferParameteriv(183, 183),
      glGetRenderbufferParameterivOES(184, 184),
      glGetShaderInfoLog(185, 185),
      glGetShaderiv(186, 186),
      glGetShaderPrecisionFormat(187, 187),
      glGetShaderSource(188, 188),
      glGetString(189, 189),
      glGetTexEnvfv(190, 190),
      glGetTexEnviv(191, 191),
      glGetTexEnvxv(192, 192),
      glGetTexEnvxvOES(193, 193),
      glGetTexGenfvOES(194, 194),
      glGetTexGenivOES(195, 195),
      glGetTexGenxvOES(196, 196),
      glGetTexParameterfv(197, 197),
      glGetTexParameteriv(198, 198),
      glGetTexParameterxv(199, 199),
      glGetTexParameterxvOES(200, 200),
      glGetUniformfv(201, 201),
      glGetUniformiv(202, 202),
      glGetUniformLocation(203, 203),
      glGetVertexAttribfv(204, 204),
      glGetVertexAttribiv(205, 205),
      glGetVertexAttribPointerv(206, 206),
      glHint(207, 207),
      glIsBuffer(208, 208),
      glIsEnabled(209, 209),
      glIsFenceNV(210, 210),
      glIsFramebuffer(211, 211),
      glIsFramebufferOES(212, 212),
      glIsProgram(213, 213),
      glIsRenderbuffer(214, 214),
      glIsRenderbufferOES(215, 215),
      glIsShader(216, 216),
      glIsTexture(217, 217),
      glIsVertexArrayOES(218, 218),
      glLightf(219, 219),
      glLightfv(220, 220),
      glLightModelf(221, 221),
      glLightModelfv(222, 222),
      glLightModelx(223, 223),
      glLightModelxOES(224, 224),
      glLightModelxv(225, 225),
      glLightModelxvOES(226, 226),
      glLightx(227, 227),
      glLightxOES(228, 228),
      glLightxv(229, 229),
      glLightxvOES(230, 230),
      glLineWidth(231, 231),
      glLineWidthx(232, 232),
      glLineWidthxOES(233, 233),
      glLinkProgram(234, 234),
      glLoadIdentity(235, 235),
      glLoadMatrixf(236, 236),
      glLoadMatrixx(237, 237),
      glLoadMatrixxOES(238, 238),
      glLoadPaletteFromModelViewMatrixOES(239, 239),
      glLogicOp(240, 240),
      glMapBufferOES(241, 241),
      glMaterialf(242, 242),
      glMaterialfv(243, 243),
      glMaterialx(244, 244),
      glMaterialxOES(245, 245),
      glMaterialxv(246, 246),
      glMaterialxvOES(247, 247),
      glMatrixIndexPointerOES(248, 248),
      glMatrixMode(249, 249),
      glMultiDrawArraysEXT(250, 250),
      glMultiDrawElementsEXT(251, 251),
      glMultiTexCoord4f(252, 252),
      glMultiTexCoord4x(253, 253),
      glMultiTexCoord4xOES(254, 254),
      glMultMatrixf(255, 255),
      glMultMatrixx(256, 256),
      glMultMatrixxOES(257, 257),
      glNormal3f(258, 258),
      glNormal3x(259, 259),
      glNormal3xOES(260, 260),
      glNormalPointer(261, 261),
      glOrthof(262, 262),
      glOrthofOES(263, 263),
      glOrthox(264, 264),
      glOrthoxOES(265, 265),
      glPixelStorei(266, 266),
      glPointParameterf(267, 267),
      glPointParameterfv(268, 268),
      glPointParameterx(269, 269),
      glPointParameterxOES(270, 270),
      glPointParameterxv(271, 271),
      glPointParameterxvOES(272, 272),
      glPointSize(273, 273),
      glPointSizePointerOES(274, 274),
      glPointSizex(275, 275),
      glPointSizexOES(276, 276),
      glPolygonOffset(277, 277),
      glPolygonOffsetx(278, 278),
      glPolygonOffsetxOES(279, 279),
      glPopMatrix(280, 280),
      glProgramBinaryOES(281, 281),
      glPushMatrix(282, 282),
      glQueryMatrixxOES(283, 283),
      glReadPixels(284, 284),
      glReleaseShaderCompiler(285, 285),
      glRenderbufferStorage(286, 286),
      glRenderbufferStorageMultisampleIMG(287, 287),
      glRenderbufferStorageOES(288, 288),
      glRotatef(289, 289),
      glRotatex(290, 290),
      glRotatexOES(291, 291),
      glSampleCoverage(292, 292),
      glSampleCoveragex(293, 293),
      glSampleCoveragexOES(294, 294),
      glScalef(295, 295),
      glScalex(296, 296),
      glScalexOES(297, 297),
      glScissor(298, 298),
      glSelectPerfMonitorCountersAMD(299, 299),
      glSetFenceNV(300, 300),
      glShadeModel(301, 301),
      glShaderBinary(302, 302),
      glShaderSource(303, 303),
      glStartTilingQCOM(304, 304),
      glStencilFunc(305, 305),
      glStencilFuncSeparate(306, 306),
      glStencilMask(307, 307),
      glStencilMaskSeparate(308, 308),
      glStencilOp(309, 309),
      glStencilOpSeparate(310, 310),
      glTestFenceNV(311, 311),
      glTexCoordPointer(312, 312),
      glTexEnvf(313, 313),
      glTexEnvfv(314, 314),
      glTexEnvi(315, 315),
      glTexEnviv(316, 316),
      glTexEnvx(317, 317),
      glTexEnvxOES(318, 318),
      glTexEnvxv(319, 319),
      glTexEnvxvOES(320, 320),
      glTexGenfOES(321, 321),
      glTexGenfvOES(322, 322),
      glTexGeniOES(323, 323),
      glTexGenivOES(324, 324),
      glTexGenxOES(325, 325),
      glTexGenxvOES(326, 326),
      glTexImage2D(327, 327),
      glTexImage3DOES(328, 328),
      glTexParameterf(329, 329),
      glTexParameterfv(330, 330),
      glTexParameteri(331, 331),
      glTexParameteriv(332, 332),
      glTexParameterx(333, 333),
      glTexParameterxOES(334, 334),
      glTexParameterxv(335, 335),
      glTexParameterxvOES(336, 336),
      glTexSubImage2D(337, 337),
      glTexSubImage3DOES(338, 338),
      glTranslatef(339, 339),
      glTranslatex(340, 340),
      glTranslatexOES(341, 341),
      glUniform1f(342, 342),
      glUniform1fv(343, 343),
      glUniform1i(344, 344),
      glUniform1iv(345, 345),
      glUniform2f(346, 346),
      glUniform2fv(347, 347),
      glUniform2i(348, 348),
      glUniform2iv(349, 349),
      glUniform3f(350, 350),
      glUniform3fv(351, 351),
      glUniform3i(352, 352),
      glUniform3iv(353, 353),
      glUniform4f(354, 354),
      glUniform4fv(355, 355),
      glUniform4i(356, 356),
      glUniform4iv(357, 357),
      glUniformMatrix2fv(358, 358),
      glUniformMatrix3fv(359, 359),
      glUniformMatrix4fv(360, 360),
      glUnmapBufferOES(361, 361),
      glUseProgram(362, 362),
      glValidateProgram(363, 363),
      glVertexAttrib1f(364, 364),
      glVertexAttrib1fv(365, 365),
      glVertexAttrib2f(366, 366),
      glVertexAttrib2fv(367, 367),
      glVertexAttrib3f(368, 368),
      glVertexAttrib3fv(369, 369),
      glVertexAttrib4f(370, 370),
      glVertexAttrib4fv(371, 371),
      glVertexAttribPointer(372, 372),
      glVertexPointer(373, 373),
      glViewport(374, 374),
      glWeightPointerOES(375, 375),
      glReadBuffer(376, 376),
      glDrawRangeElements(377, 377),
      glTexImage3D(378, 378),
      glTexSubImage3D(379, 379),
      glCopyTexSubImage3D(380, 380),
      glCompressedTexImage3D(381, 381),
      glCompressedTexSubImage3D(382, 382),
      glGenQueries(383, 383),
      glDeleteQueries(384, 384),
      glIsQuery(385, 385),
      glBeginQuery(386, 386),
      glEndQuery(387, 387),
      glGetQueryiv(388, 388),
      glGetQueryObjectuiv(389, 389),
      glUnmapBuffer(390, 390),
      glGetBufferPointerv(391, 391),
      glDrawBuffers(392, 392),
      glUniformMatrix2x3fv(393, 393),
      glUniformMatrix3x2fv(394, 394),
      glUniformMatrix2x4fv(395, 395),
      glUniformMatrix4x2fv(396, 396),
      glUniformMatrix3x4fv(397, 397),
      glUniformMatrix4x3fv(398, 398),
      glBlitFramebuffer(399, 399),
      glRenderbufferStorageMultisample(400, 400),
      glFramebufferTextureLayer(401, 401),
      glMapBufferRange(402, 402),
      glFlushMappedBufferRange(403, 403),
      glBindVertexArray(404, 404),
      glDeleteVertexArrays(405, 405),
      glGenVertexArrays(406, 406),
      glIsVertexArray(407, 407),
      glGetIntegeri_v(408, 408),
      glBeginTransformFeedback(409, 409),
      glEndTransformFeedback(410, 410),
      glBindBufferRange(411, 411),
      glBindBufferBase(412, 412),
      glTransformFeedbackVaryings(413, 413),
      glGetTransformFeedbackVarying(414, 414),
      glVertexAttribIPointer(415, 415),
      glGetVertexAttribIiv(416, 416),
      glGetVertexAttribIuiv(417, 417),
      glVertexAttribI4i(418, 418),
      glVertexAttribI4ui(419, 419),
      glVertexAttribI4iv(420, 420),
      glVertexAttribI4uiv(421, 421),
      glGetUniformuiv(422, 422),
      glGetFragDataLocation(423, 423),
      glUniform1ui(424, 424),
      glUniform2ui(425, 425),
      glUniform3ui(426, 426),
      glUniform4ui(427, 427),
      glUniform1uiv(428, 428),
      glUniform2uiv(429, 429),
      glUniform3uiv(430, 430),
      glUniform4uiv(431, 431),
      glClearBufferiv(432, 432),
      glClearBufferuiv(433, 433),
      glClearBufferfv(434, 434),
      glClearBufferfi(435, 435),
      glGetStringi(436, 436),
      glCopyBufferSubData(437, 437),
      glGetUniformIndices(438, 438),
      glGetActiveUniformsiv(439, 439),
      glGetUniformBlockIndex(440, 440),
      glGetActiveUniformBlockiv(441, 441),
      glGetActiveUniformBlockName(442, 442),
      glUniformBlockBinding(443, 443),
      glDrawArraysInstanced(444, 444),
      glDrawElementsInstanced(445, 445),
      glFenceSync(446, 446),
      glIsSync(447, 447),
      glDeleteSync(448, 448),
      glClientWaitSync(449, 449),
      glWaitSync(450, 450),
      glGetInteger64v(451, 451),
      glGetSynciv(452, 452),
      glGetInteger64i_v(453, 453),
      glGetBufferParameteri64v(454, 454),
      glGenSamplers(455, 455),
      glDeleteSamplers(456, 456),
      glIsSampler(457, 457),
      glBindSampler(458, 458),
      glSamplerParameteri(459, 459),
      glSamplerParameteriv(460, 460),
      glSamplerParameterf(461, 461),
      glSamplerParameterfv(462, 462),
      glGetSamplerParameteriv(463, 463),
      glGetSamplerParameterfv(464, 464),
      glVertexAttribDivisor(465, 465),
      glBindTransformFeedback(466, 466),
      glDeleteTransformFeedbacks(467, 467),
      glGenTransformFeedbacks(468, 468),
      glIsTransformFeedback(469, 469),
      glPauseTransformFeedback(470, 470),
      glResumeTransformFeedback(471, 471),
      glGetProgramBinary(472, 472),
      glProgramBinary(473, 473),
      glProgramParameteri(474, 474),
      glInvalidateFramebuffer(475, 475),
      glInvalidateSubFramebuffer(476, 476),
      glTexStorage2D(477, 477),
      glTexStorage3D(478, 478),
      glGetInternalformativ(479, 479),
      glActiveShaderProgramEXT(480, 502),
      glAlphaFuncQCOM(481, 503),
      glBeginQueryEXT(482, 504),
      glBindProgramPipelineEXT(483, 505),
      glBlitFramebufferANGLE(484, 506),
      glCreateShaderProgramvEXT(485, 507),
      glDeleteProgramPipelinesEXT(486, 508),
      glDeleteQueriesEXT(487, 509),
      glDrawBuffersNV(488, 510),
      glEndQueryEXT(489, 511),
      glFramebufferTexture2DMultisampleEXT(490, 512),
      glGenProgramPipelinesEXT(491, 513),
      glGenQueriesEXT(492, 514),
      glGetGraphicsResetStatusEXT(493, 515),
      glGetObjectLabelEXT(494, 516),
      glGetProgramPipelineInfoLogEXT(495, 517),
      glGetProgramPipelineivEXT(496, 518),
      glGetQueryObjectuivEXT(497, 519),
      glGetQueryivEXT(498, 520),
      glGetnUniformfvEXT(499, 521),
      glInsertEventMarkerEXT(501, 522),
      glIsProgramPipelineEXT(502, 523),
      glIsQueryEXT(503, 524),
      glLabelObjectEXT(504, 525),
      glPopGroupMarkerEXT(505, 526),
      glProgramParameteriEXT(506, 527),
      glProgramUniform1fEXT(507, 528),
      glProgramUniform1fvEXT(508, 529),
      glProgramUniform1iEXT(509, 530),
      glProgramUniform1ivEXT(510, 531),
      glProgramUniform2fEXT(511, 532),
      glProgramUniform2fvEXT(512, 533),
      glProgramUniform2iEXT(513, 534),
      glProgramUniform2ivEXT(514, 535),
      glProgramUniform3fEXT(515, 536),
      glProgramUniform3fvEXT(516, 537),
      glProgramUniform3iEXT(517, 538),
      glProgramUniform3ivEXT(518, 539),
      glProgramUniform4fEXT(519, 540),
      glProgramUniform4fvEXT(520, 541),
      glProgramUniform4iEXT(521, 542),
      glProgramUniform4ivEXT(522, 543),
      glProgramUniformMatrix2fvEXT(523, 544),
      glProgramUniformMatrix3fvEXT(524, 545),
      glProgramUniformMatrix4fvEXT(525, 546),
      glPushGroupMarkerEXT(526, 547),
      glReadBufferNV(527, 548),
      glReadnPixelsEXT(528, 549),
      glRenderbufferStorageMultisampleANGLE(529, 550),
      glRenderbufferStorageMultisampleAPPLE(530, 551),
      glRenderbufferStorageMultisampleEXT(531, 552),
      glResolveMultisampleFramebufferAPPLE(532, 553),
      glTexStorage1DEXT(533, 554),
      glTexStorage2DEXT(534, 555),
      glTexStorage3DEXT(535, 556),
      glTextureStorage1DEXT(536, 557),
      glTextureStorage2DEXT(537, 558),
      glTextureStorage3DEXT(538, 559),
      glUseProgramStagesEXT(539, 560),
      glValidateProgramPipelineEXT(540, 561),
      eglGetDisplay(541, 2000),
      eglInitialize(542, 2001),
      eglTerminate(543, 2002),
      eglGetConfigs(544, 2003),
      eglChooseConfig(545, 2004),
      eglGetConfigAttrib(546, 2005),
      eglCreateWindowSurface(547, 2006),
      eglCreatePixmapSurface(548, 2007),
      eglCreatePbufferSurface(549, 2008),
      eglDestroySurface(550, 2009),
      eglQuerySurface(551, 2010),
      eglCreateContext(552, 2011),
      eglDestroyContext(553, 2012),
      eglMakeCurrent(554, 2013),
      eglGetCurrentContext(555, 2014),
      eglGetCurrentSurface(556, 2015),
      eglGetCurrentDisplay(557, 2016),
      eglQueryContext(558, 2017),
      eglWaitGL(559, 2018),
      eglWaitNative(560, 2019),
      eglSwapBuffers(561, 2020),
      eglCopyBuffers(562, 2021),
      eglGetError(563, 2022),
      eglQueryString(564, 2023),
      eglGetProcAddress(565, 2024),
      eglSurfaceAttrib(566, 2025),
      eglBindTexImage(567, 2026),
      eglReleaseTexImage(568, 2027),
      eglSwapInterval(569, 2028),
      eglBindAPI(570, 2029),
      eglQueryAPI(571, 2030),
      eglWaitClient(572, 2031),
      eglReleaseThread(573, 2032),
      eglCreatePbufferFromClientBuffer(574, 2033),
      eglLockSurfaceKHR(575, 2034),
      eglUnlockSurfaceKHR(576, 2035),
      eglCreateImageKHR(577, 2036),
      eglDestroyImageKHR(578, 2037),
      eglCreateSyncKHR(579, 2038),
      eglDestroySyncKHR(580, 2039),
      eglClientWaitSyncKHR(581, 2040),
      eglGetSyncAttribKHR(582, 2041),
      eglSetSwapRectangleANDROID(583, 2042),
      eglGetRenderBufferANDROID(584, 2043),
      eglGetSystemTimeFrequencyNV(585, 2044),
      eglGetSystemTimeNV(586, 2045),
      invalid(587, 3000),
      glVertexAttribPointerData(588, 3001),
      ;
      
      public static final Function glGetnUniformivEXT = glGetnUniformfvEXT;
      
      @Override
    public final int getNumber() { return value; }
      
      public static Function valueOf(int value) {
        switch (value) {
          case 0: return glActiveTexture;
          case 1: return glAlphaFunc;
          case 2: return glAlphaFuncx;
          case 3: return glAlphaFuncxOES;
          case 4: return glAttachShader;
          case 5: return glBeginPerfMonitorAMD;
          case 6: return glBindAttribLocation;
          case 7: return glBindBuffer;
          case 8: return glBindFramebuffer;
          case 9: return glBindFramebufferOES;
          case 10: return glBindRenderbuffer;
          case 11: return glBindRenderbufferOES;
          case 12: return glBindTexture;
          case 13: return glBindVertexArrayOES;
          case 14: return glBlendColor;
          case 15: return glBlendEquation;
          case 16: return glBlendEquationOES;
          case 17: return glBlendEquationSeparate;
          case 18: return glBlendEquationSeparateOES;
          case 19: return glBlendFunc;
          case 20: return glBlendFuncSeparate;
          case 21: return glBlendFuncSeparateOES;
          case 22: return glBufferData;
          case 23: return glBufferSubData;
          case 24: return glCheckFramebufferStatus;
          case 25: return glCheckFramebufferStatusOES;
          case 26: return glClearColor;
          case 27: return glClearColorx;
          case 28: return glClearColorxOES;
          case 29: return glClearDepthf;
          case 30: return glClearDepthfOES;
          case 31: return glClearDepthx;
          case 32: return glClearDepthxOES;
          case 33: return glClear;
          case 34: return glClearStencil;
          case 35: return glClientActiveTexture;
          case 36: return glClipPlanef;
          case 37: return glClipPlanefIMG;
          case 38: return glClipPlanefOES;
          case 39: return glClipPlanex;
          case 40: return glClipPlanexIMG;
          case 41: return glClipPlanexOES;
          case 42: return glColor4f;
          case 43: return glColor4ub;
          case 44: return glColor4x;
          case 45: return glColor4xOES;
          case 46: return glColorMask;
          case 47: return glColorPointer;
          case 48: return glCompileShader;
          case 49: return glCompressedTexImage2D;
          case 50: return glCompressedTexImage3DOES;
          case 51: return glCompressedTexSubImage2D;
          case 52: return glCompressedTexSubImage3DOES;
          case 53: return glCopyTexImage2D;
          case 54: return glCopyTexSubImage2D;
          case 55: return glCopyTexSubImage3DOES;
          case 56: return glCoverageMaskNV;
          case 57: return glCoverageOperationNV;
          case 58: return glCreateProgram;
          case 59: return glCreateShader;
          case 60: return glCullFace;
          case 61: return glCurrentPaletteMatrixOES;
          case 62: return glDeleteBuffers;
          case 63: return glDeleteFencesNV;
          case 64: return glDeleteFramebuffers;
          case 65: return glDeleteFramebuffersOES;
          case 66: return glDeletePerfMonitorsAMD;
          case 67: return glDeleteProgram;
          case 68: return glDeleteRenderbuffers;
          case 69: return glDeleteRenderbuffersOES;
          case 70: return glDeleteShader;
          case 71: return glDeleteTextures;
          case 72: return glDeleteVertexArraysOES;
          case 73: return glDepthFunc;
          case 74: return glDepthMask;
          case 75: return glDepthRangef;
          case 76: return glDepthRangefOES;
          case 77: return glDepthRangex;
          case 78: return glDepthRangexOES;
          case 79: return glDetachShader;
          case 80: return glDisableClientState;
          case 81: return glDisableDriverControlQCOM;
          case 82: return glDisable;
          case 83: return glDisableVertexAttribArray;
          case 84: return glDiscardFramebufferEXT;
          case 85: return glDrawArrays;
          case 86: return glDrawElements;
          case 87: return glDrawTexfOES;
          case 88: return glDrawTexfvOES;
          case 89: return glDrawTexiOES;
          case 90: return glDrawTexivOES;
          case 91: return glDrawTexsOES;
          case 92: return glDrawTexsvOES;
          case 93: return glDrawTexxOES;
          case 94: return glDrawTexxvOES;
          case 95: return glEGLImageTargetRenderbufferStorageOES;
          case 96: return glEGLImageTargetTexture2DOES;
          case 97: return glEnableClientState;
          case 98: return glEnableDriverControlQCOM;
          case 99: return glEnable;
          case 100: return glEnableVertexAttribArray;
          case 101: return glEndPerfMonitorAMD;
          case 102: return glEndTilingQCOM;
          case 103: return glExtGetBufferPointervQCOM;
          case 104: return glExtGetBuffersQCOM;
          case 105: return glExtGetFramebuffersQCOM;
          case 106: return glExtGetProgramBinarySourceQCOM;
          case 107: return glExtGetProgramsQCOM;
          case 108: return glExtGetRenderbuffersQCOM;
          case 109: return glExtGetShadersQCOM;
          case 110: return glExtGetTexLevelParameterivQCOM;
          case 111: return glExtGetTexSubImageQCOM;
          case 112: return glExtGetTexturesQCOM;
          case 113: return glExtIsProgramBinaryQCOM;
          case 114: return glExtTexObjectStateOverrideiQCOM;
          case 115: return glFinishFenceNV;
          case 116: return glFinish;
          case 117: return glFlush;
          case 118: return glFogf;
          case 119: return glFogfv;
          case 120: return glFogx;
          case 121: return glFogxOES;
          case 122: return glFogxv;
          case 123: return glFogxvOES;
          case 124: return glFramebufferRenderbuffer;
          case 125: return glFramebufferRenderbufferOES;
          case 126: return glFramebufferTexture2D;
          case 127: return glFramebufferTexture2DMultisampleIMG;
          case 128: return glFramebufferTexture2DOES;
          case 129: return glFramebufferTexture3DOES;
          case 130: return glFrontFace;
          case 131: return glFrustumf;
          case 132: return glFrustumfOES;
          case 133: return glFrustumx;
          case 134: return glFrustumxOES;
          case 135: return glGenBuffers;
          case 136: return glGenerateMipmap;
          case 137: return glGenerateMipmapOES;
          case 138: return glGenFencesNV;
          case 139: return glGenFramebuffers;
          case 140: return glGenFramebuffersOES;
          case 141: return glGenPerfMonitorsAMD;
          case 142: return glGenRenderbuffers;
          case 143: return glGenRenderbuffersOES;
          case 144: return glGenTextures;
          case 145: return glGenVertexArraysOES;
          case 146: return glGetActiveAttrib;
          case 147: return glGetActiveUniform;
          case 148: return glGetAttachedShaders;
          case 149: return glGetAttribLocation;
          case 150: return glGetBooleanv;
          case 151: return glGetBufferParameteriv;
          case 152: return glGetBufferPointervOES;
          case 153: return glGetClipPlanef;
          case 154: return glGetClipPlanefOES;
          case 155: return glGetClipPlanex;
          case 156: return glGetClipPlanexOES;
          case 157: return glGetDriverControlsQCOM;
          case 158: return glGetDriverControlStringQCOM;
          case 159: return glGetError;
          case 160: return glGetFenceivNV;
          case 161: return glGetFixedv;
          case 162: return glGetFixedvOES;
          case 163: return glGetFloatv;
          case 164: return glGetFramebufferAttachmentParameteriv;
          case 165: return glGetFramebufferAttachmentParameterivOES;
          case 166: return glGetIntegerv;
          case 167: return glGetLightfv;
          case 168: return glGetLightxv;
          case 169: return glGetLightxvOES;
          case 170: return glGetMaterialfv;
          case 171: return glGetMaterialxv;
          case 172: return glGetMaterialxvOES;
          case 173: return glGetPerfMonitorCounterDataAMD;
          case 174: return glGetPerfMonitorCounterInfoAMD;
          case 175: return glGetPerfMonitorCountersAMD;
          case 176: return glGetPerfMonitorCounterStringAMD;
          case 177: return glGetPerfMonitorGroupsAMD;
          case 178: return glGetPerfMonitorGroupStringAMD;
          case 179: return glGetPointerv;
          case 180: return glGetProgramBinaryOES;
          case 181: return glGetProgramInfoLog;
          case 182: return glGetProgramiv;
          case 183: return glGetRenderbufferParameteriv;
          case 184: return glGetRenderbufferParameterivOES;
          case 185: return glGetShaderInfoLog;
          case 186: return glGetShaderiv;
          case 187: return glGetShaderPrecisionFormat;
          case 188: return glGetShaderSource;
          case 189: return glGetString;
          case 190: return glGetTexEnvfv;
          case 191: return glGetTexEnviv;
          case 192: return glGetTexEnvxv;
          case 193: return glGetTexEnvxvOES;
          case 194: return glGetTexGenfvOES;
          case 195: return glGetTexGenivOES;
          case 196: return glGetTexGenxvOES;
          case 197: return glGetTexParameterfv;
          case 198: return glGetTexParameteriv;
          case 199: return glGetTexParameterxv;
          case 200: return glGetTexParameterxvOES;
          case 201: return glGetUniformfv;
          case 202: return glGetUniformiv;
          case 203: return glGetUniformLocation;
          case 204: return glGetVertexAttribfv;
          case 205: return glGetVertexAttribiv;
          case 206: return glGetVertexAttribPointerv;
          case 207: return glHint;
          case 208: return glIsBuffer;
          case 209: return glIsEnabled;
          case 210: return glIsFenceNV;
          case 211: return glIsFramebuffer;
          case 212: return glIsFramebufferOES;
          case 213: return glIsProgram;
          case 214: return glIsRenderbuffer;
          case 215: return glIsRenderbufferOES;
          case 216: return glIsShader;
          case 217: return glIsTexture;
          case 218: return glIsVertexArrayOES;
          case 219: return glLightf;
          case 220: return glLightfv;
          case 221: return glLightModelf;
          case 222: return glLightModelfv;
          case 223: return glLightModelx;
          case 224: return glLightModelxOES;
          case 225: return glLightModelxv;
          case 226: return glLightModelxvOES;
          case 227: return glLightx;
          case 228: return glLightxOES;
          case 229: return glLightxv;
          case 230: return glLightxvOES;
          case 231: return glLineWidth;
          case 232: return glLineWidthx;
          case 233: return glLineWidthxOES;
          case 234: return glLinkProgram;
          case 235: return glLoadIdentity;
          case 236: return glLoadMatrixf;
          case 237: return glLoadMatrixx;
          case 238: return glLoadMatrixxOES;
          case 239: return glLoadPaletteFromModelViewMatrixOES;
          case 240: return glLogicOp;
          case 241: return glMapBufferOES;
          case 242: return glMaterialf;
          case 243: return glMaterialfv;
          case 244: return glMaterialx;
          case 245: return glMaterialxOES;
          case 246: return glMaterialxv;
          case 247: return glMaterialxvOES;
          case 248: return glMatrixIndexPointerOES;
          case 249: return glMatrixMode;
          case 250: return glMultiDrawArraysEXT;
          case 251: return glMultiDrawElementsEXT;
          case 252: return glMultiTexCoord4f;
          case 253: return glMultiTexCoord4x;
          case 254: return glMultiTexCoord4xOES;
          case 255: return glMultMatrixf;
          case 256: return glMultMatrixx;
          case 257: return glMultMatrixxOES;
          case 258: return glNormal3f;
          case 259: return glNormal3x;
          case 260: return glNormal3xOES;
          case 261: return glNormalPointer;
          case 262: return glOrthof;
          case 263: return glOrthofOES;
          case 264: return glOrthox;
          case 265: return glOrthoxOES;
          case 266: return glPixelStorei;
          case 267: return glPointParameterf;
          case 268: return glPointParameterfv;
          case 269: return glPointParameterx;
          case 270: return glPointParameterxOES;
          case 271: return glPointParameterxv;
          case 272: return glPointParameterxvOES;
          case 273: return glPointSize;
          case 274: return glPointSizePointerOES;
          case 275: return glPointSizex;
          case 276: return glPointSizexOES;
          case 277: return glPolygonOffset;
          case 278: return glPolygonOffsetx;
          case 279: return glPolygonOffsetxOES;
          case 280: return glPopMatrix;
          case 281: return glProgramBinaryOES;
          case 282: return glPushMatrix;
          case 283: return glQueryMatrixxOES;
          case 284: return glReadPixels;
          case 285: return glReleaseShaderCompiler;
          case 286: return glRenderbufferStorage;
          case 287: return glRenderbufferStorageMultisampleIMG;
          case 288: return glRenderbufferStorageOES;
          case 289: return glRotatef;
          case 290: return glRotatex;
          case 291: return glRotatexOES;
          case 292: return glSampleCoverage;
          case 293: return glSampleCoveragex;
          case 294: return glSampleCoveragexOES;
          case 295: return glScalef;
          case 296: return glScalex;
          case 297: return glScalexOES;
          case 298: return glScissor;
          case 299: return glSelectPerfMonitorCountersAMD;
          case 300: return glSetFenceNV;
          case 301: return glShadeModel;
          case 302: return glShaderBinary;
          case 303: return glShaderSource;
          case 304: return glStartTilingQCOM;
          case 305: return glStencilFunc;
          case 306: return glStencilFuncSeparate;
          case 307: return glStencilMask;
          case 308: return glStencilMaskSeparate;
          case 309: return glStencilOp;
          case 310: return glStencilOpSeparate;
          case 311: return glTestFenceNV;
          case 312: return glTexCoordPointer;
          case 313: return glTexEnvf;
          case 314: return glTexEnvfv;
          case 315: return glTexEnvi;
          case 316: return glTexEnviv;
          case 317: return glTexEnvx;
          case 318: return glTexEnvxOES;
          case 319: return glTexEnvxv;
          case 320: return glTexEnvxvOES;
          case 321: return glTexGenfOES;
          case 322: return glTexGenfvOES;
          case 323: return glTexGeniOES;
          case 324: return glTexGenivOES;
          case 325: return glTexGenxOES;
          case 326: return glTexGenxvOES;
          case 327: return glTexImage2D;
          case 328: return glTexImage3DOES;
          case 329: return glTexParameterf;
          case 330: return glTexParameterfv;
          case 331: return glTexParameteri;
          case 332: return glTexParameteriv;
          case 333: return glTexParameterx;
          case 334: return glTexParameterxOES;
          case 335: return glTexParameterxv;
          case 336: return glTexParameterxvOES;
          case 337: return glTexSubImage2D;
          case 338: return glTexSubImage3DOES;
          case 339: return glTranslatef;
          case 340: return glTranslatex;
          case 341: return glTranslatexOES;
          case 342: return glUniform1f;
          case 343: return glUniform1fv;
          case 344: return glUniform1i;
          case 345: return glUniform1iv;
          case 346: return glUniform2f;
          case 347: return glUniform2fv;
          case 348: return glUniform2i;
          case 349: return glUniform2iv;
          case 350: return glUniform3f;
          case 351: return glUniform3fv;
          case 352: return glUniform3i;
          case 353: return glUniform3iv;
          case 354: return glUniform4f;
          case 355: return glUniform4fv;
          case 356: return glUniform4i;
          case 357: return glUniform4iv;
          case 358: return glUniformMatrix2fv;
          case 359: return glUniformMatrix3fv;
          case 360: return glUniformMatrix4fv;
          case 361: return glUnmapBufferOES;
          case 362: return glUseProgram;
          case 363: return glValidateProgram;
          case 364: return glVertexAttrib1f;
          case 365: return glVertexAttrib1fv;
          case 366: return glVertexAttrib2f;
          case 367: return glVertexAttrib2fv;
          case 368: return glVertexAttrib3f;
          case 369: return glVertexAttrib3fv;
          case 370: return glVertexAttrib4f;
          case 371: return glVertexAttrib4fv;
          case 372: return glVertexAttribPointer;
          case 373: return glVertexPointer;
          case 374: return glViewport;
          case 375: return glWeightPointerOES;
          case 376: return glReadBuffer;
          case 377: return glDrawRangeElements;
          case 378: return glTexImage3D;
          case 379: return glTexSubImage3D;
          case 380: return glCopyTexSubImage3D;
          case 381: return glCompressedTexImage3D;
          case 382: return glCompressedTexSubImage3D;
          case 383: return glGenQueries;
          case 384: return glDeleteQueries;
          case 385: return glIsQuery;
          case 386: return glBeginQuery;
          case 387: return glEndQuery;
          case 388: return glGetQueryiv;
          case 389: return glGetQueryObjectuiv;
          case 390: return glUnmapBuffer;
          case 391: return glGetBufferPointerv;
          case 392: return glDrawBuffers;
          case 393: return glUniformMatrix2x3fv;
          case 394: return glUniformMatrix3x2fv;
          case 395: return glUniformMatrix2x4fv;
          case 396: return glUniformMatrix4x2fv;
          case 397: return glUniformMatrix3x4fv;
          case 398: return glUniformMatrix4x3fv;
          case 399: return glBlitFramebuffer;
          case 400: return glRenderbufferStorageMultisample;
          case 401: return glFramebufferTextureLayer;
          case 402: return glMapBufferRange;
          case 403: return glFlushMappedBufferRange;
          case 404: return glBindVertexArray;
          case 405: return glDeleteVertexArrays;
          case 406: return glGenVertexArrays;
          case 407: return glIsVertexArray;
          case 408: return glGetIntegeri_v;
          case 409: return glBeginTransformFeedback;
          case 410: return glEndTransformFeedback;
          case 411: return glBindBufferRange;
          case 412: return glBindBufferBase;
          case 413: return glTransformFeedbackVaryings;
          case 414: return glGetTransformFeedbackVarying;
          case 415: return glVertexAttribIPointer;
          case 416: return glGetVertexAttribIiv;
          case 417: return glGetVertexAttribIuiv;
          case 418: return glVertexAttribI4i;
          case 419: return glVertexAttribI4ui;
          case 420: return glVertexAttribI4iv;
          case 421: return glVertexAttribI4uiv;
          case 422: return glGetUniformuiv;
          case 423: return glGetFragDataLocation;
          case 424: return glUniform1ui;
          case 425: return glUniform2ui;
          case 426: return glUniform3ui;
          case 427: return glUniform4ui;
          case 428: return glUniform1uiv;
          case 429: return glUniform2uiv;
          case 430: return glUniform3uiv;
          case 431: return glUniform4uiv;
          case 432: return glClearBufferiv;
          case 433: return glClearBufferuiv;
          case 434: return glClearBufferfv;
          case 435: return glClearBufferfi;
          case 436: return glGetStringi;
          case 437: return glCopyBufferSubData;
          case 438: return glGetUniformIndices;
          case 439: return glGetActiveUniformsiv;
          case 440: return glGetUniformBlockIndex;
          case 441: return glGetActiveUniformBlockiv;
          case 442: return glGetActiveUniformBlockName;
          case 443: return glUniformBlockBinding;
          case 444: return glDrawArraysInstanced;
          case 445: return glDrawElementsInstanced;
          case 446: return glFenceSync;
          case 447: return glIsSync;
          case 448: return glDeleteSync;
          case 449: return glClientWaitSync;
          case 450: return glWaitSync;
          case 451: return glGetInteger64v;
          case 452: return glGetSynciv;
          case 453: return glGetInteger64i_v;
          case 454: return glGetBufferParameteri64v;
          case 455: return glGenSamplers;
          case 456: return glDeleteSamplers;
          case 457: return glIsSampler;
          case 458: return glBindSampler;
          case 459: return glSamplerParameteri;
          case 460: return glSamplerParameteriv;
          case 461: return glSamplerParameterf;
          case 462: return glSamplerParameterfv;
          case 463: return glGetSamplerParameteriv;
          case 464: return glGetSamplerParameterfv;
          case 465: return glVertexAttribDivisor;
          case 466: return glBindTransformFeedback;
          case 467: return glDeleteTransformFeedbacks;
          case 468: return glGenTransformFeedbacks;
          case 469: return glIsTransformFeedback;
          case 470: return glPauseTransformFeedback;
          case 471: return glResumeTransformFeedback;
          case 472: return glGetProgramBinary;
          case 473: return glProgramBinary;
          case 474: return glProgramParameteri;
          case 475: return glInvalidateFramebuffer;
          case 476: return glInvalidateSubFramebuffer;
          case 477: return glTexStorage2D;
          case 478: return glTexStorage3D;
          case 479: return glGetInternalformativ;
          case 502: return glActiveShaderProgramEXT;
          case 503: return glAlphaFuncQCOM;
          case 504: return glBeginQueryEXT;
          case 505: return glBindProgramPipelineEXT;
          case 506: return glBlitFramebufferANGLE;
          case 507: return glCreateShaderProgramvEXT;
          case 508: return glDeleteProgramPipelinesEXT;
          case 509: return glDeleteQueriesEXT;
          case 510: return glDrawBuffersNV;
          case 511: return glEndQueryEXT;
          case 512: return glFramebufferTexture2DMultisampleEXT;
          case 513: return glGenProgramPipelinesEXT;
          case 514: return glGenQueriesEXT;
          case 515: return glGetGraphicsResetStatusEXT;
          case 516: return glGetObjectLabelEXT;
          case 517: return glGetProgramPipelineInfoLogEXT;
          case 518: return glGetProgramPipelineivEXT;
          case 519: return glGetQueryObjectuivEXT;
          case 520: return glGetQueryivEXT;
          case 521: return glGetnUniformfvEXT;
          case 522: return glInsertEventMarkerEXT;
          case 523: return glIsProgramPipelineEXT;
          case 524: return glIsQueryEXT;
          case 525: return glLabelObjectEXT;
          case 526: return glPopGroupMarkerEXT;
          case 527: return glProgramParameteriEXT;
          case 528: return glProgramUniform1fEXT;
          case 529: return glProgramUniform1fvEXT;
          case 530: return glProgramUniform1iEXT;
          case 531: return glProgramUniform1ivEXT;
          case 532: return glProgramUniform2fEXT;
          case 533: return glProgramUniform2fvEXT;
          case 534: return glProgramUniform2iEXT;
          case 535: return glProgramUniform2ivEXT;
          case 536: return glProgramUniform3fEXT;
          case 537: return glProgramUniform3fvEXT;
          case 538: return glProgramUniform3iEXT;
          case 539: return glProgramUniform3ivEXT;
          case 540: return glProgramUniform4fEXT;
          case 541: return glProgramUniform4fvEXT;
          case 542: return glProgramUniform4iEXT;
          case 543: return glProgramUniform4ivEXT;
          case 544: return glProgramUniformMatrix2fvEXT;
          case 545: return glProgramUniformMatrix3fvEXT;
          case 546: return glProgramUniformMatrix4fvEXT;
          case 547: return glPushGroupMarkerEXT;
          case 548: return glReadBufferNV;
          case 549: return glReadnPixelsEXT;
          case 550: return glRenderbufferStorageMultisampleANGLE;
          case 551: return glRenderbufferStorageMultisampleAPPLE;
          case 552: return glRenderbufferStorageMultisampleEXT;
          case 553: return glResolveMultisampleFramebufferAPPLE;
          case 554: return glTexStorage1DEXT;
          case 555: return glTexStorage2DEXT;
          case 556: return glTexStorage3DEXT;
          case 557: return glTextureStorage1DEXT;
          case 558: return glTextureStorage2DEXT;
          case 559: return glTextureStorage3DEXT;
          case 560: return glUseProgramStagesEXT;
          case 561: return glValidateProgramPipelineEXT;
          case 2000: return eglGetDisplay;
          case 2001: return eglInitialize;
          case 2002: return eglTerminate;
          case 2003: return eglGetConfigs;
          case 2004: return eglChooseConfig;
          case 2005: return eglGetConfigAttrib;
          case 2006: return eglCreateWindowSurface;
          case 2007: return eglCreatePixmapSurface;
          case 2008: return eglCreatePbufferSurface;
          case 2009: return eglDestroySurface;
          case 2010: return eglQuerySurface;
          case 2011: return eglCreateContext;
          case 2012: return eglDestroyContext;
          case 2013: return eglMakeCurrent;
          case 2014: return eglGetCurrentContext;
          case 2015: return eglGetCurrentSurface;
          case 2016: return eglGetCurrentDisplay;
          case 2017: return eglQueryContext;
          case 2018: return eglWaitGL;
          case 2019: return eglWaitNative;
          case 2020: return eglSwapBuffers;
          case 2021: return eglCopyBuffers;
          case 2022: return eglGetError;
          case 2023: return eglQueryString;
          case 2024: return eglGetProcAddress;
          case 2025: return eglSurfaceAttrib;
          case 2026: return eglBindTexImage;
          case 2027: return eglReleaseTexImage;
          case 2028: return eglSwapInterval;
          case 2029: return eglBindAPI;
          case 2030: return eglQueryAPI;
          case 2031: return eglWaitClient;
          case 2032: return eglReleaseThread;
          case 2033: return eglCreatePbufferFromClientBuffer;
          case 2034: return eglLockSurfaceKHR;
          case 2035: return eglUnlockSurfaceKHR;
          case 2036: return eglCreateImageKHR;
          case 2037: return eglDestroyImageKHR;
          case 2038: return eglCreateSyncKHR;
          case 2039: return eglDestroySyncKHR;
          case 2040: return eglClientWaitSyncKHR;
          case 2041: return eglGetSyncAttribKHR;
          case 2042: return eglSetSwapRectangleANDROID;
          case 2043: return eglGetRenderBufferANDROID;
          case 2044: return eglGetSystemTimeFrequencyNV;
          case 2045: return eglGetSystemTimeNV;
          case 3000: return invalid;
          case 3001: return glVertexAttribPointerData;
          default: return null;
        }
      }
      
      public static com.google.protobuf.Internal.EnumLiteMap<Function>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static com.google.protobuf.Internal.EnumLiteMap<Function>
          internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<Function>() {
              @Override
            public Function findValueByNumber(int number) {
                return Function.valueOf(number)
      ;        }
            };
      
      private final int index;
      private final int value;
      private Function(int index, int value) {
        this.index = index;
        this.value = value;
      }
      
      // @@protoc_insertion_point(enum_scope:android.gltrace.GLMessage.Function)
    }
    
    public static final class DataType extends
        com.google.protobuf.GeneratedMessageLite {
      // Use DataType.newBuilder() to construct.
      private DataType() {
        initFields();
      }
      private DataType(boolean noInit) {}
      
      private static final DataType defaultInstance;
      public static DataType getDefaultInstance() {
        return defaultInstance;
      }
      
      @Override
    public DataType getDefaultInstanceForType() {
        return defaultInstance;
      }
      
      public enum Type
          implements com.google.protobuf.Internal.EnumLite {
        VOID(0, 1),
        CHAR(1, 2),
        BYTE(2, 3),
        INT(3, 4),
        FLOAT(4, 5),
        BOOL(5, 6),
        ENUM(6, 7),
        INT64(7, 8),
        ;
        
        
        @Override
        public final int getNumber() { return value; }
        
        public static Type valueOf(int value) {
          switch (value) {
            case 1: return VOID;
            case 2: return CHAR;
            case 3: return BYTE;
            case 4: return INT;
            case 5: return FLOAT;
            case 6: return BOOL;
            case 7: return ENUM;
            case 8: return INT64;
            default: return null;
          }
        }
        
        public static com.google.protobuf.Internal.EnumLiteMap<Type>
            internalGetValueMap() {
          return internalValueMap;
        }
        private static com.google.protobuf.Internal.EnumLiteMap<Type>
            internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<Type>() {
                @Override
                public Type findValueByNumber(int number) {
                  return Type.valueOf(number)
        ;        }
              };
        
        private final int index;
        private final int value;
        private Type(int index, int value) {
          this.index = index;
          this.value = value;
        }
        
        // @@protoc_insertion_point(enum_scope:android.gltrace.GLMessage.DataType.Type)
      }
      
      // required .android.gltrace.GLMessage.DataType.Type type = 1 [default = VOID];
      public static final int TYPE_FIELD_NUMBER = 1;
      private boolean hasType;
      private com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType.Type type_;
      public boolean hasType() { return hasType; }
      public com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType.Type getType() { return type_; }
      
      // required bool isArray = 2 [default = false];
      public static final int ISARRAY_FIELD_NUMBER = 2;
      private boolean hasIsArray;
      private boolean isArray_ = false;
      public boolean hasIsArray() { return hasIsArray; }
      public boolean getIsArray() { return isArray_; }
      
      // repeated int32 intValue = 3;
      public static final int INTVALUE_FIELD_NUMBER = 3;
      private java.util.List<java.lang.Integer> intValue_ =
        java.util.Collections.emptyList();
      public java.util.List<java.lang.Integer> getIntValueList() {
        return intValue_;
      }
      public int getIntValueCount() { return intValue_.size(); }
      public int getIntValue(int index) {
        return intValue_.get(index);
      }
      
      // repeated float floatValue = 4;
      public static final int FLOATVALUE_FIELD_NUMBER = 4;
      private java.util.List<java.lang.Float> floatValue_ =
        java.util.Collections.emptyList();
      public java.util.List<java.lang.Float> getFloatValueList() {
        return floatValue_;
      }
      public int getFloatValueCount() { return floatValue_.size(); }
      public float getFloatValue(int index) {
        return floatValue_.get(index);
      }
      
      // repeated bytes charValue = 5;
      public static final int CHARVALUE_FIELD_NUMBER = 5;
      private java.util.List<com.google.protobuf.ByteString> charValue_ =
        java.util.Collections.emptyList();
      public java.util.List<com.google.protobuf.ByteString> getCharValueList() {
        return charValue_;
      }
      public int getCharValueCount() { return charValue_.size(); }
      public com.google.protobuf.ByteString getCharValue(int index) {
        return charValue_.get(index);
      }
      
      // repeated bytes rawBytes = 6;
      public static final int RAWBYTES_FIELD_NUMBER = 6;
      private java.util.List<com.google.protobuf.ByteString> rawBytes_ =
        java.util.Collections.emptyList();
      public java.util.List<com.google.protobuf.ByteString> getRawBytesList() {
        return rawBytes_;
      }
      public int getRawBytesCount() { return rawBytes_.size(); }
      public com.google.protobuf.ByteString getRawBytes(int index) {
        return rawBytes_.get(index);
      }
      
      // repeated bool boolValue = 7;
      public static final int BOOLVALUE_FIELD_NUMBER = 7;
      private java.util.List<java.lang.Boolean> boolValue_ =
        java.util.Collections.emptyList();
      public java.util.List<java.lang.Boolean> getBoolValueList() {
        return boolValue_;
      }
      public int getBoolValueCount() { return boolValue_.size(); }
      public boolean getBoolValue(int index) {
        return boolValue_.get(index);
      }
      
      // repeated int64 int64Value = 8;
      public static final int INT64VALUE_FIELD_NUMBER = 8;
      private java.util.List<java.lang.Long> int64Value_ =
        java.util.Collections.emptyList();
      public java.util.List<java.lang.Long> getInt64ValueList() {
        return int64Value_;
      }
      public int getInt64ValueCount() { return int64Value_.size(); }
      public long getInt64Value(int index) {
        return int64Value_.get(index);
      }
      
      private void initFields() {
        type_ = com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType.Type.VOID;
      }
      @Override
    public final boolean isInitialized() {
        if (!hasType) return false;
        if (!hasIsArray) return false;
        return true;
      }
      
      @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        getSerializedSize();
        if (hasType()) {
          output.writeEnum(1, getType().getNumber());
        }
        if (hasIsArray()) {
          output.writeBool(2, getIsArray());
        }
        for (int element : getIntValueList()) {
          output.writeInt32(3, element);
        }
        for (float element : getFloatValueList()) {
          output.writeFloat(4, element);
        }
        for (com.google.protobuf.ByteString element : getCharValueList()) {
          output.writeBytes(5, element);
        }
        for (com.google.protobuf.ByteString element : getRawBytesList()) {
          output.writeBytes(6, element);
        }
        for (boolean element : getBoolValueList()) {
          output.writeBool(7, element);
        }
        for (long element : getInt64ValueList()) {
          output.writeInt64(8, element);
        }
      }
      
      private int memoizedSerializedSize = -1;
      @Override
    public int getSerializedSize() {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
      
        size = 0;
        if (hasType()) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(1, getType().getNumber());
        }
        if (hasIsArray()) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(2, getIsArray());
        }
        {
          int dataSize = 0;
          for (int element : getIntValueList()) {
            dataSize += com.google.protobuf.CodedOutputStream
              .computeInt32SizeNoTag(element);
          }
          size += dataSize;
          size += 1 * getIntValueList().size();
        }
        {
          int dataSize = 0;
          dataSize = 4 * getFloatValueList().size();
          size += dataSize;
          size += 1 * getFloatValueList().size();
        }
        {
          int dataSize = 0;
          for (com.google.protobuf.ByteString element : getCharValueList()) {
            dataSize += com.google.protobuf.CodedOutputStream
              .computeBytesSizeNoTag(element);
          }
          size += dataSize;
          size += 1 * getCharValueList().size();
        }
        {
          int dataSize = 0;
          for (com.google.protobuf.ByteString element : getRawBytesList()) {
            dataSize += com.google.protobuf.CodedOutputStream
              .computeBytesSizeNoTag(element);
          }
          size += dataSize;
          size += 1 * getRawBytesList().size();
        }
        {
          int dataSize = 0;
          dataSize = 1 * getBoolValueList().size();
          size += dataSize;
          size += 1 * getBoolValueList().size();
        }
        {
          int dataSize = 0;
          for (long element : getInt64ValueList()) {
            dataSize += com.google.protobuf.CodedOutputStream
              .computeInt64SizeNoTag(element);
          }
          size += dataSize;
          size += 1 * getInt64ValueList().size();
        }
        memoizedSerializedSize = size;
        return size;
      }
      
      public static com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return newBuilder().mergeFrom(data).buildParsed();
      }
      public static com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return newBuilder().mergeFrom(data, extensionRegistry)
                 .buildParsed();
      }
      public static com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return newBuilder().mergeFrom(data).buildParsed();
      }
      public static com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return newBuilder().mergeFrom(data, extensionRegistry)
                 .buildParsed();
      }
      public static com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return newBuilder().mergeFrom(input).buildParsed();
      }
      public static com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return newBuilder().mergeFrom(input, extensionRegistry)
                 .buildParsed();
      }
      public static com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        Builder builder = newBuilder();
        if (builder.mergeDelimitedFrom(input)) {
          return builder.buildParsed();
        } else {
          return null;
        }
      }
      public static com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        Builder builder = newBuilder();
        if (builder.mergeDelimitedFrom(input, extensionRegistry)) {
          return builder.buildParsed();
        } else {
          return null;
        }
      }
      public static com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return newBuilder().mergeFrom(input).buildParsed();
      }
      public static com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return newBuilder().mergeFrom(input, extensionRegistry)
                 .buildParsed();
      }
      
      public static Builder newBuilder() { return Builder.create(); }
      @Override
    public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder(com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType prototype) {
        return newBuilder().mergeFrom(prototype);
      }
      @Override
    public Builder toBuilder() { return newBuilder(this); }
      
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageLite.Builder<
            com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType, Builder> {
        private com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType result;
        
        // Construct using com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType.newBuilder()
        private Builder() {}
        
        private static Builder create() {
          Builder builder = new Builder();
          builder.result = new com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType();
          return builder;
        }
        
        @Override
        protected com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType internalGetResult() {
          return result;
        }
        
        @Override
        public Builder clear() {
          if (result == null) {
            throw new IllegalStateException(
              "Cannot call clear() after build().");
          }
          result = new com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType();
          return this;
        }
        
        @Override
        public Builder clone() {
          return create().mergeFrom(result);
        }
        
        @Override
        public com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType getDefaultInstanceForType() {
          return com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType.getDefaultInstance();
        }
        
        @Override
        public boolean isInitialized() {
          return result.isInitialized();
        }
        @Override
        public com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType build() {
          if (result != null && !isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return buildPartial();
        }
        
        private com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType buildParsed()
            throws com.google.protobuf.InvalidProtocolBufferException {
          if (!isInitialized()) {
            throw newUninitializedMessageException(
              result).asInvalidProtocolBufferException();
          }
          return buildPartial();
        }
        
        @Override
        public com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType buildPartial() {
          if (result == null) {
            throw new IllegalStateException(
              "build() has already been called on this Builder.");
          }
          if (result.intValue_ != java.util.Collections.EMPTY_LIST) {
            result.intValue_ =
              java.util.Collections.unmodifiableList(result.intValue_);
          }
          if (result.floatValue_ != java.util.Collections.EMPTY_LIST) {
            result.floatValue_ =
              java.util.Collections.unmodifiableList(result.floatValue_);
          }
          if (result.charValue_ != java.util.Collections.EMPTY_LIST) {
            result.charValue_ =
              java.util.Collections.unmodifiableList(result.charValue_);
          }
          if (result.rawBytes_ != java.util.Collections.EMPTY_LIST) {
            result.rawBytes_ =
              java.util.Collections.unmodifiableList(result.rawBytes_);
          }
          if (result.boolValue_ != java.util.Collections.EMPTY_LIST) {
            result.boolValue_ =
              java.util.Collections.unmodifiableList(result.boolValue_);
          }
          if (result.int64Value_ != java.util.Collections.EMPTY_LIST) {
            result.int64Value_ =
              java.util.Collections.unmodifiableList(result.int64Value_);
          }
          com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType returnMe = result;
          result = null;
          return returnMe;
        }
        
        @Override
        public Builder mergeFrom(com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType other) {
          if (other == com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType.getDefaultInstance()) return this;
          if (other.hasType()) {
            setType(other.getType());
          }
          if (other.hasIsArray()) {
            setIsArray(other.getIsArray());
          }
          if (!other.intValue_.isEmpty()) {
            if (result.intValue_.isEmpty()) {
              result.intValue_ = new java.util.ArrayList<java.lang.Integer>();
            }
            result.intValue_.addAll(other.intValue_);
          }
          if (!other.floatValue_.isEmpty()) {
            if (result.floatValue_.isEmpty()) {
              result.floatValue_ = new java.util.ArrayList<java.lang.Float>();
            }
            result.floatValue_.addAll(other.floatValue_);
          }
          if (!other.charValue_.isEmpty()) {
            if (result.charValue_.isEmpty()) {
              result.charValue_ = new java.util.ArrayList<com.google.protobuf.ByteString>();
            }
            result.charValue_.addAll(other.charValue_);
          }
          if (!other.rawBytes_.isEmpty()) {
            if (result.rawBytes_.isEmpty()) {
              result.rawBytes_ = new java.util.ArrayList<com.google.protobuf.ByteString>();
            }
            result.rawBytes_.addAll(other.rawBytes_);
          }
          if (!other.boolValue_.isEmpty()) {
            if (result.boolValue_.isEmpty()) {
              result.boolValue_ = new java.util.ArrayList<java.lang.Boolean>();
            }
            result.boolValue_.addAll(other.boolValue_);
          }
          if (!other.int64Value_.isEmpty()) {
            if (result.int64Value_.isEmpty()) {
              result.int64Value_ = new java.util.ArrayList<java.lang.Long>();
            }
            result.int64Value_.addAll(other.int64Value_);
          }
          return this;
        }
        
        @Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          while (true) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                return this;
              default: {
                if (!parseUnknownField(input, extensionRegistry, tag)) {
                  return this;
                }
                break;
              }
              case 8: {
                int rawValue = input.readEnum();
                com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType.Type value = com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType.Type.valueOf(rawValue);
                if (value != null) {
                  setType(value);
                }
                break;
              }
              case 16: {
                setIsArray(input.readBool());
                break;
              }
              case 24: {
                addIntValue(input.readInt32());
                break;
              }
              case 26: {
                int length = input.readRawVarint32();
                int limit = input.pushLimit(length);
                while (input.getBytesUntilLimit() > 0) {
                  addIntValue(input.readInt32());
                }
                input.popLimit(limit);
                break;
              }
              case 37: {
                addFloatValue(input.readFloat());
                break;
              }
              case 34: {
                int length = input.readRawVarint32();
                int limit = input.pushLimit(length);
                while (input.getBytesUntilLimit() > 0) {
                  addFloatValue(input.readFloat());
                }
                input.popLimit(limit);
                break;
              }
              case 42: {
                addCharValue(input.readBytes());
                break;
              }
              case 50: {
                addRawBytes(input.readBytes());
                break;
              }
              case 56: {
                addBoolValue(input.readBool());
                break;
              }
              case 58: {
                int length = input.readRawVarint32();
                int limit = input.pushLimit(length);
                while (input.getBytesUntilLimit() > 0) {
                  addBoolValue(input.readBool());
                }
                input.popLimit(limit);
                break;
              }
              case 64: {
                addInt64Value(input.readInt64());
                break;
              }
              case 66: {
                int length = input.readRawVarint32();
                int limit = input.pushLimit(length);
                while (input.getBytesUntilLimit() > 0) {
                  addInt64Value(input.readInt64());
                }
                input.popLimit(limit);
                break;
              }
            }
          }
        }
        
        
        // required .android.gltrace.GLMessage.DataType.Type type = 1 [default = VOID];
        public boolean hasType() {
          return result.hasType();
        }
        public com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType.Type getType() {
          return result.getType();
        }
        public Builder setType(com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType.Type value) {
          if (value == null) {
            throw new NullPointerException();
          }
          result.hasType = true;
          result.type_ = value;
          return this;
        }
        public Builder clearType() {
          result.hasType = false;
          result.type_ = com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType.Type.VOID;
          return this;
        }
        
        // required bool isArray = 2 [default = false];
        public boolean hasIsArray() {
          return result.hasIsArray();
        }
        public boolean getIsArray() {
          return result.getIsArray();
        }
        public Builder setIsArray(boolean value) {
          result.hasIsArray = true;
          result.isArray_ = value;
          return this;
        }
        public Builder clearIsArray() {
          result.hasIsArray = false;
          result.isArray_ = false;
          return this;
        }
        
        // repeated int32 intValue = 3;
        public java.util.List<java.lang.Integer> getIntValueList() {
          return java.util.Collections.unmodifiableList(result.intValue_);
        }
        public int getIntValueCount() {
          return result.getIntValueCount();
        }
        public int getIntValue(int index) {
          return result.getIntValue(index);
        }
        public Builder setIntValue(int index, int value) {
          result.intValue_.set(index, value);
          return this;
        }
        public Builder addIntValue(int value) {
          if (result.intValue_.isEmpty()) {
            result.intValue_ = new java.util.ArrayList<java.lang.Integer>();
          }
          result.intValue_.add(value);
          return this;
        }
        public Builder addAllIntValue(
            java.lang.Iterable<? extends java.lang.Integer> values) {
          if (result.intValue_.isEmpty()) {
            result.intValue_ = new java.util.ArrayList<java.lang.Integer>();
          }
          super.addAll(values, result.intValue_);
          return this;
        }
        public Builder clearIntValue() {
          result.intValue_ = java.util.Collections.emptyList();
          return this;
        }
        
        // repeated float floatValue = 4;
        public java.util.List<java.lang.Float> getFloatValueList() {
          return java.util.Collections.unmodifiableList(result.floatValue_);
        }
        public int getFloatValueCount() {
          return result.getFloatValueCount();
        }
        public float getFloatValue(int index) {
          return result.getFloatValue(index);
        }
        public Builder setFloatValue(int index, float value) {
          result.floatValue_.set(index, value);
          return this;
        }
        public Builder addFloatValue(float value) {
          if (result.floatValue_.isEmpty()) {
            result.floatValue_ = new java.util.ArrayList<java.lang.Float>();
          }
          result.floatValue_.add(value);
          return this;
        }
        public Builder addAllFloatValue(
            java.lang.Iterable<? extends java.lang.Float> values) {
          if (result.floatValue_.isEmpty()) {
            result.floatValue_ = new java.util.ArrayList<java.lang.Float>();
          }
          super.addAll(values, result.floatValue_);
          return this;
        }
        public Builder clearFloatValue() {
          result.floatValue_ = java.util.Collections.emptyList();
          return this;
        }
        
        // repeated bytes charValue = 5;
        public java.util.List<com.google.protobuf.ByteString> getCharValueList() {
          return java.util.Collections.unmodifiableList(result.charValue_);
        }
        public int getCharValueCount() {
          return result.getCharValueCount();
        }
        public com.google.protobuf.ByteString getCharValue(int index) {
          return result.getCharValue(index);
        }
        public Builder setCharValue(int index, com.google.protobuf.ByteString value) {
          if (value == null) {
    throw new NullPointerException();
  }
  result.charValue_.set(index, value);
          return this;
        }
        public Builder addCharValue(com.google.protobuf.ByteString value) {
          if (value == null) {
    throw new NullPointerException();
  }
  if (result.charValue_.isEmpty()) {
            result.charValue_ = new java.util.ArrayList<com.google.protobuf.ByteString>();
          }
          result.charValue_.add(value);
          return this;
        }
        public Builder addAllCharValue(
            java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {
          if (result.charValue_.isEmpty()) {
            result.charValue_ = new java.util.ArrayList<com.google.protobuf.ByteString>();
          }
          super.addAll(values, result.charValue_);
          return this;
        }
        public Builder clearCharValue() {
          result.charValue_ = java.util.Collections.emptyList();
          return this;
        }
        
        // repeated bytes rawBytes = 6;
        public java.util.List<com.google.protobuf.ByteString> getRawBytesList() {
          return java.util.Collections.unmodifiableList(result.rawBytes_);
        }
        public int getRawBytesCount() {
          return result.getRawBytesCount();
        }
        public com.google.protobuf.ByteString getRawBytes(int index) {
          return result.getRawBytes(index);
        }
        public Builder setRawBytes(int index, com.google.protobuf.ByteString value) {
          if (value == null) {
    throw new NullPointerException();
  }
  result.rawBytes_.set(index, value);
          return this;
        }
        public Builder addRawBytes(com.google.protobuf.ByteString value) {
          if (value == null) {
    throw new NullPointerException();
  }
  if (result.rawBytes_.isEmpty()) {
            result.rawBytes_ = new java.util.ArrayList<com.google.protobuf.ByteString>();
          }
          result.rawBytes_.add(value);
          return this;
        }
        public Builder addAllRawBytes(
            java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {
          if (result.rawBytes_.isEmpty()) {
            result.rawBytes_ = new java.util.ArrayList<com.google.protobuf.ByteString>();
          }
          super.addAll(values, result.rawBytes_);
          return this;
        }
        public Builder clearRawBytes() {
          result.rawBytes_ = java.util.Collections.emptyList();
          return this;
        }
        
        // repeated bool boolValue = 7;
        public java.util.List<java.lang.Boolean> getBoolValueList() {
          return java.util.Collections.unmodifiableList(result.boolValue_);
        }
        public int getBoolValueCount() {
          return result.getBoolValueCount();
        }
        public boolean getBoolValue(int index) {
          return result.getBoolValue(index);
        }
        public Builder setBoolValue(int index, boolean value) {
          result.boolValue_.set(index, value);
          return this;
        }
        public Builder addBoolValue(boolean value) {
          if (result.boolValue_.isEmpty()) {
            result.boolValue_ = new java.util.ArrayList<java.lang.Boolean>();
          }
          result.boolValue_.add(value);
          return this;
        }
        public Builder addAllBoolValue(
            java.lang.Iterable<? extends java.lang.Boolean> values) {
          if (result.boolValue_.isEmpty()) {
            result.boolValue_ = new java.util.ArrayList<java.lang.Boolean>();
          }
          super.addAll(values, result.boolValue_);
          return this;
        }
        public Builder clearBoolValue() {
          result.boolValue_ = java.util.Collections.emptyList();
          return this;
        }
        
        // repeated int64 int64Value = 8;
        public java.util.List<java.lang.Long> getInt64ValueList() {
          return java.util.Collections.unmodifiableList(result.int64Value_);
        }
        public int getInt64ValueCount() {
          return result.getInt64ValueCount();
        }
        public long getInt64Value(int index) {
          return result.getInt64Value(index);
        }
        public Builder setInt64Value(int index, long value) {
          result.int64Value_.set(index, value);
          return this;
        }
        public Builder addInt64Value(long value) {
          if (result.int64Value_.isEmpty()) {
            result.int64Value_ = new java.util.ArrayList<java.lang.Long>();
          }
          result.int64Value_.add(value);
          return this;
        }
        public Builder addAllInt64Value(
            java.lang.Iterable<? extends java.lang.Long> values) {
          if (result.int64Value_.isEmpty()) {
            result.int64Value_ = new java.util.ArrayList<java.lang.Long>();
          }
          super.addAll(values, result.int64Value_);
          return this;
        }
        public Builder clearInt64Value() {
          result.int64Value_ = java.util.Collections.emptyList();
          return this;
        }
        
        // @@protoc_insertion_point(builder_scope:android.gltrace.GLMessage.DataType)
      }
      
      static {
        defaultInstance = new DataType(true);
        com.android.ide.eclipse.gltrace.GLProtoBuf.internalForceInit();
        defaultInstance.initFields();
      }
      
      // @@protoc_insertion_point(class_scope:android.gltrace.GLMessage.DataType)
    }
    
    public static final class FrameBuffer extends
        com.google.protobuf.GeneratedMessageLite {
      // Use FrameBuffer.newBuilder() to construct.
      private FrameBuffer() {
        initFields();
      }
      private FrameBuffer(boolean noInit) {}
      
      private static final FrameBuffer defaultInstance;
      public static FrameBuffer getDefaultInstance() {
        return defaultInstance;
      }
      
      @Override
    public FrameBuffer getDefaultInstanceForType() {
        return defaultInstance;
      }
      
      // required int32 width = 1;
      public static final int WIDTH_FIELD_NUMBER = 1;
      private boolean hasWidth;
      private int width_ = 0;
      public boolean hasWidth() { return hasWidth; }
      public int getWidth() { return width_; }
      
      // required int32 height = 2;
      public static final int HEIGHT_FIELD_NUMBER = 2;
      private boolean hasHeight;
      private int height_ = 0;
      public boolean hasHeight() { return hasHeight; }
      public int getHeight() { return height_; }
      
      // repeated bytes contents = 3;
      public static final int CONTENTS_FIELD_NUMBER = 3;
      private java.util.List<com.google.protobuf.ByteString> contents_ =
        java.util.Collections.emptyList();
      public java.util.List<com.google.protobuf.ByteString> getContentsList() {
        return contents_;
      }
      public int getContentsCount() { return contents_.size(); }
      public com.google.protobuf.ByteString getContents(int index) {
        return contents_.get(index);
      }
      
      private void initFields() {
      }
      @Override
    public final boolean isInitialized() {
        if (!hasWidth) return false;
        if (!hasHeight) return false;
        return true;
      }
      
      @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        getSerializedSize();
        if (hasWidth()) {
          output.writeInt32(1, getWidth());
        }
        if (hasHeight()) {
          output.writeInt32(2, getHeight());
        }
        for (com.google.protobuf.ByteString element : getContentsList()) {
          output.writeBytes(3, element);
        }
      }
      
      private int memoizedSerializedSize = -1;
      @Override
    public int getSerializedSize() {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
      
        size = 0;
        if (hasWidth()) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt32Size(1, getWidth());
        }
        if (hasHeight()) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt32Size(2, getHeight());
        }
        {
          int dataSize = 0;
          for (com.google.protobuf.ByteString element : getContentsList()) {
            dataSize += com.google.protobuf.CodedOutputStream
              .computeBytesSizeNoTag(element);
          }
          size += dataSize;
          size += 1 * getContentsList().size();
        }
        memoizedSerializedSize = size;
        return size;
      }
      
      public static com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.FrameBuffer parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return newBuilder().mergeFrom(data).buildParsed();
      }
      public static com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.FrameBuffer parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return newBuilder().mergeFrom(data, extensionRegistry)
                 .buildParsed();
      }
      public static com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.FrameBuffer parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return newBuilder().mergeFrom(data).buildParsed();
      }
      public static com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.FrameBuffer parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return newBuilder().mergeFrom(data, extensionRegistry)
                 .buildParsed();
      }
      public static com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.FrameBuffer parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return newBuilder().mergeFrom(input).buildParsed();
      }
      public static com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.FrameBuffer parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return newBuilder().mergeFrom(input, extensionRegistry)
                 .buildParsed();
      }
      public static com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.FrameBuffer parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        Builder builder = newBuilder();
        if (builder.mergeDelimitedFrom(input)) {
          return builder.buildParsed();
        } else {
          return null;
        }
      }
      public static com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.FrameBuffer parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        Builder builder = newBuilder();
        if (builder.mergeDelimitedFrom(input, extensionRegistry)) {
          return builder.buildParsed();
        } else {
          return null;
        }
      }
      public static com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.FrameBuffer parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return newBuilder().mergeFrom(input).buildParsed();
      }
      public static com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.FrameBuffer parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return newBuilder().mergeFrom(input, extensionRegistry)
                 .buildParsed();
      }
      
      public static Builder newBuilder() { return Builder.create(); }
      @Override
    public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder(com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.FrameBuffer prototype) {
        return newBuilder().mergeFrom(prototype);
      }
      @Override
    public Builder toBuilder() { return newBuilder(this); }
      
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageLite.Builder<
            com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.FrameBuffer, Builder> {
        private com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.FrameBuffer result;
        
        // Construct using com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.FrameBuffer.newBuilder()
        private Builder() {}
        
        private static Builder create() {
          Builder builder = new Builder();
          builder.result = new com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.FrameBuffer();
          return builder;
        }
        
        @Override
        protected com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.FrameBuffer internalGetResult() {
          return result;
        }
        
        @Override
        public Builder clear() {
          if (result == null) {
            throw new IllegalStateException(
              "Cannot call clear() after build().");
          }
          result = new com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.FrameBuffer();
          return this;
        }
        
        @Override
        public Builder clone() {
          return create().mergeFrom(result);
        }
        
        @Override
        public com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.FrameBuffer getDefaultInstanceForType() {
          return com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.FrameBuffer.getDefaultInstance();
        }
        
        @Override
        public boolean isInitialized() {
          return result.isInitialized();
        }
        @Override
        public com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.FrameBuffer build() {
          if (result != null && !isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return buildPartial();
        }
        
        private com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.FrameBuffer buildParsed()
            throws com.google.protobuf.InvalidProtocolBufferException {
          if (!isInitialized()) {
            throw newUninitializedMessageException(
              result).asInvalidProtocolBufferException();
          }
          return buildPartial();
        }
        
        @Override
        public com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.FrameBuffer buildPartial() {
          if (result == null) {
            throw new IllegalStateException(
              "build() has already been called on this Builder.");
          }
          if (result.contents_ != java.util.Collections.EMPTY_LIST) {
            result.contents_ =
              java.util.Collections.unmodifiableList(result.contents_);
          }
          com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.FrameBuffer returnMe = result;
          result = null;
          return returnMe;
        }
        
        @Override
        public Builder mergeFrom(com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.FrameBuffer other) {
          if (other == com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.FrameBuffer.getDefaultInstance()) return this;
          if (other.hasWidth()) {
            setWidth(other.getWidth());
          }
          if (other.hasHeight()) {
            setHeight(other.getHeight());
          }
          if (!other.contents_.isEmpty()) {
            if (result.contents_.isEmpty()) {
              result.contents_ = new java.util.ArrayList<com.google.protobuf.ByteString>();
            }
            result.contents_.addAll(other.contents_);
          }
          return this;
        }
        
        @Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          while (true) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                return this;
              default: {
                if (!parseUnknownField(input, extensionRegistry, tag)) {
                  return this;
                }
                break;
              }
              case 8: {
                setWidth(input.readInt32());
                break;
              }
              case 16: {
                setHeight(input.readInt32());
                break;
              }
              case 26: {
                addContents(input.readBytes());
                break;
              }
            }
          }
        }
        
        
        // required int32 width = 1;
        public boolean hasWidth() {
          return result.hasWidth();
        }
        public int getWidth() {
          return result.getWidth();
        }
        public Builder setWidth(int value) {
          result.hasWidth = true;
          result.width_ = value;
          return this;
        }
        public Builder clearWidth() {
          result.hasWidth = false;
          result.width_ = 0;
          return this;
        }
        
        // required int32 height = 2;
        public boolean hasHeight() {
          return result.hasHeight();
        }
        public int getHeight() {
          return result.getHeight();
        }
        public Builder setHeight(int value) {
          result.hasHeight = true;
          result.height_ = value;
          return this;
        }
        public Builder clearHeight() {
          result.hasHeight = false;
          result.height_ = 0;
          return this;
        }
        
        // repeated bytes contents = 3;
        public java.util.List<com.google.protobuf.ByteString> getContentsList() {
          return java.util.Collections.unmodifiableList(result.contents_);
        }
        public int getContentsCount() {
          return result.getContentsCount();
        }
        public com.google.protobuf.ByteString getContents(int index) {
          return result.getContents(index);
        }
        public Builder setContents(int index, com.google.protobuf.ByteString value) {
          if (value == null) {
    throw new NullPointerException();
  }
  result.contents_.set(index, value);
          return this;
        }
        public Builder addContents(com.google.protobuf.ByteString value) {
          if (value == null) {
    throw new NullPointerException();
  }
  if (result.contents_.isEmpty()) {
            result.contents_ = new java.util.ArrayList<com.google.protobuf.ByteString>();
          }
          result.contents_.add(value);
          return this;
        }
        public Builder addAllContents(
            java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {
          if (result.contents_.isEmpty()) {
            result.contents_ = new java.util.ArrayList<com.google.protobuf.ByteString>();
          }
          super.addAll(values, result.contents_);
          return this;
        }
        public Builder clearContents() {
          result.contents_ = java.util.Collections.emptyList();
          return this;
        }
        
        // @@protoc_insertion_point(builder_scope:android.gltrace.GLMessage.FrameBuffer)
      }
      
      static {
        defaultInstance = new FrameBuffer(true);
        com.android.ide.eclipse.gltrace.GLProtoBuf.internalForceInit();
        defaultInstance.initFields();
      }
      
      // @@protoc_insertion_point(class_scope:android.gltrace.GLMessage.FrameBuffer)
    }
    
    // required int32 context_id = 1;
    public static final int CONTEXT_ID_FIELD_NUMBER = 1;
    private boolean hasContextId;
    private int contextId_ = 0;
    public boolean hasContextId() { return hasContextId; }
    public int getContextId() { return contextId_; }
    
    // required int64 start_time = 2;
    public static final int START_TIME_FIELD_NUMBER = 2;
    private boolean hasStartTime;
    private long startTime_ = 0L;
    public boolean hasStartTime() { return hasStartTime; }
    public long getStartTime() { return startTime_; }
    
    // required int32 duration = 3;
    public static final int DURATION_FIELD_NUMBER = 3;
    private boolean hasDuration;
    private int duration_ = 0;
    public boolean hasDuration() { return hasDuration; }
    public int getDuration() { return duration_; }
    
    // required .android.gltrace.GLMessage.Function function = 4 [default = invalid];
    public static final int FUNCTION_FIELD_NUMBER = 4;
    private boolean hasFunction;
    private com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.Function function_;
    public boolean hasFunction() { return hasFunction; }
    public com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.Function getFunction() { return function_; }
    
    // repeated .android.gltrace.GLMessage.DataType args = 5;
    public static final int ARGS_FIELD_NUMBER = 5;
    private java.util.List<com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType> args_ =
      java.util.Collections.emptyList();
    public java.util.List<com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType> getArgsList() {
      return args_;
    }
    public int getArgsCount() { return args_.size(); }
    public com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType getArgs(int index) {
      return args_.get(index);
    }
    
    // optional .android.gltrace.GLMessage.DataType returnValue = 6;
    public static final int RETURNVALUE_FIELD_NUMBER = 6;
    private boolean hasReturnValue;
    private com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType returnValue_;
    public boolean hasReturnValue() { return hasReturnValue; }
    public com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType getReturnValue() { return returnValue_; }
    
    // optional .android.gltrace.GLMessage.FrameBuffer fb = 7;
    public static final int FB_FIELD_NUMBER = 7;
    private boolean hasFb;
    private com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.FrameBuffer fb_;
    public boolean hasFb() { return hasFb; }
    public com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.FrameBuffer getFb() { return fb_; }
    
    // optional int32 threadtime = 8;
    public static final int THREADTIME_FIELD_NUMBER = 8;
    private boolean hasThreadtime;
    private int threadtime_ = 0;
    public boolean hasThreadtime() { return hasThreadtime; }
    public int getThreadtime() { return threadtime_; }
    
    private void initFields() {
      function_ = com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.Function.invalid;
      returnValue_ = com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType.getDefaultInstance();
      fb_ = com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.FrameBuffer.getDefaultInstance();
    }
    @Override
    public final boolean isInitialized() {
      if (!hasContextId) return false;
      if (!hasStartTime) return false;
      if (!hasDuration) return false;
      if (!hasFunction) return false;
      for (com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType element : getArgsList()) {
        if (!element.isInitialized()) return false;
      }
      if (hasReturnValue()) {
        if (!getReturnValue().isInitialized()) return false;
      }
      if (hasFb()) {
        if (!getFb().isInitialized()) return false;
      }
      return true;
    }
    
    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      if (hasContextId()) {
        output.writeInt32(1, getContextId());
      }
      if (hasStartTime()) {
        output.writeInt64(2, getStartTime());
      }
      if (hasDuration()) {
        output.writeInt32(3, getDuration());
      }
      if (hasFunction()) {
        output.writeEnum(4, getFunction().getNumber());
      }
      for (com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType element : getArgsList()) {
        output.writeMessage(5, element);
      }
      if (hasReturnValue()) {
        output.writeMessage(6, getReturnValue());
      }
      if (hasFb()) {
        output.writeMessage(7, getFb());
      }
      if (hasThreadtime()) {
        output.writeInt32(8, getThreadtime());
      }
    }
    
    private int memoizedSerializedSize = -1;
    @Override
    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
    
      size = 0;
      if (hasContextId()) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(1, getContextId());
      }
      if (hasStartTime()) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(2, getStartTime());
      }
      if (hasDuration()) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(3, getDuration());
      }
      if (hasFunction()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(4, getFunction().getNumber());
      }
      for (com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType element : getArgsList()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, element);
      }
      if (hasReturnValue()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, getReturnValue());
      }
      if (hasFb()) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, getFb());
      }
      if (hasThreadtime()) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(8, getThreadtime());
      }
      memoizedSerializedSize = size;
      return size;
    }
    
    public static com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return newBuilder().mergeFrom(data).buildParsed();
    }
    public static com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return newBuilder().mergeFrom(data, extensionRegistry)
               .buildParsed();
    }
    public static com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return newBuilder().mergeFrom(data).buildParsed();
    }
    public static com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return newBuilder().mergeFrom(data, extensionRegistry)
               .buildParsed();
    }
    public static com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return newBuilder().mergeFrom(input).buildParsed();
    }
    public static com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return newBuilder().mergeFrom(input, extensionRegistry)
               .buildParsed();
    }
    public static com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      Builder builder = newBuilder();
      if (builder.mergeDelimitedFrom(input)) {
        return builder.buildParsed();
      } else {
        return null;
      }
    }
    public static com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      Builder builder = newBuilder();
      if (builder.mergeDelimitedFrom(input, extensionRegistry)) {
        return builder.buildParsed();
      } else {
        return null;
      }
    }
    public static com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return newBuilder().mergeFrom(input).buildParsed();
    }
    public static com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return newBuilder().mergeFrom(input, extensionRegistry)
               .buildParsed();
    }
    
    public static Builder newBuilder() { return Builder.create(); }
    @Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder(com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage prototype) {
      return newBuilder().mergeFrom(prototype);
    }
    @Override
    public Builder toBuilder() { return newBuilder(this); }
    
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage, Builder> {
      private com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage result;
      
      // Construct using com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.newBuilder()
      private Builder() {}
      
      private static Builder create() {
        Builder builder = new Builder();
        builder.result = new com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage();
        return builder;
      }
      
      @Override
    protected com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage internalGetResult() {
        return result;
      }
      
      @Override
    public Builder clear() {
        if (result == null) {
          throw new IllegalStateException(
            "Cannot call clear() after build().");
        }
        result = new com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage();
        return this;
      }
      
      @Override
    public Builder clone() {
        return create().mergeFrom(result);
      }
      
      @Override
    public com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage getDefaultInstanceForType() {
        return com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.getDefaultInstance();
      }
      
      @Override
    public boolean isInitialized() {
        return result.isInitialized();
      }
      @Override
    public com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage build() {
        if (result != null && !isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return buildPartial();
      }
      
      private com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage buildParsed()
          throws com.google.protobuf.InvalidProtocolBufferException {
        if (!isInitialized()) {
          throw newUninitializedMessageException(
            result).asInvalidProtocolBufferException();
        }
        return buildPartial();
      }
      
      @Override
    public com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage buildPartial() {
        if (result == null) {
          throw new IllegalStateException(
            "build() has already been called on this Builder.");
        }
        if (result.args_ != java.util.Collections.EMPTY_LIST) {
          result.args_ =
            java.util.Collections.unmodifiableList(result.args_);
        }
        com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage returnMe = result;
        result = null;
        return returnMe;
      }
      
      @Override
    public Builder mergeFrom(com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage other) {
        if (other == com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.getDefaultInstance()) return this;
        if (other.hasContextId()) {
          setContextId(other.getContextId());
        }
        if (other.hasStartTime()) {
          setStartTime(other.getStartTime());
        }
        if (other.hasDuration()) {
          setDuration(other.getDuration());
        }
        if (other.hasFunction()) {
          setFunction(other.getFunction());
        }
        if (!other.args_.isEmpty()) {
          if (result.args_.isEmpty()) {
            result.args_ = new java.util.ArrayList<com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType>();
          }
          result.args_.addAll(other.args_);
        }
        if (other.hasReturnValue()) {
          mergeReturnValue(other.getReturnValue());
        }
        if (other.hasFb()) {
          mergeFb(other.getFb());
        }
        if (other.hasThreadtime()) {
          setThreadtime(other.getThreadtime());
        }
        return this;
      }
      
      @Override
    public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        while (true) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              return this;
            default: {
              if (!parseUnknownField(input, extensionRegistry, tag)) {
                return this;
              }
              break;
            }
            case 8: {
              setContextId(input.readInt32());
              break;
            }
            case 16: {
              setStartTime(input.readInt64());
              break;
            }
            case 24: {
              setDuration(input.readInt32());
              break;
            }
            case 32: {
              int rawValue = input.readEnum();
              com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.Function value = com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.Function.valueOf(rawValue);
              if (value != null) {
                setFunction(value);
              }
              break;
            }
            case 42: {
              com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType.Builder subBuilder = com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType.newBuilder();
              input.readMessage(subBuilder, extensionRegistry);
              addArgs(subBuilder.buildPartial());
              break;
            }
            case 50: {
              com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType.Builder subBuilder = com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType.newBuilder();
              if (hasReturnValue()) {
                subBuilder.mergeFrom(getReturnValue());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setReturnValue(subBuilder.buildPartial());
              break;
            }
            case 58: {
              com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.FrameBuffer.Builder subBuilder = com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.FrameBuffer.newBuilder();
              if (hasFb()) {
                subBuilder.mergeFrom(getFb());
              }
              input.readMessage(subBuilder, extensionRegistry);
              setFb(subBuilder.buildPartial());
              break;
            }
            case 64: {
              setThreadtime(input.readInt32());
              break;
            }
          }
        }
      }
      
      
      // required int32 context_id = 1;
      public boolean hasContextId() {
        return result.hasContextId();
      }
      public int getContextId() {
        return result.getContextId();
      }
      public Builder setContextId(int value) {
        result.hasContextId = true;
        result.contextId_ = value;
        return this;
      }
      public Builder clearContextId() {
        result.hasContextId = false;
        result.contextId_ = 0;
        return this;
      }
      
      // required int64 start_time = 2;
      public boolean hasStartTime() {
        return result.hasStartTime();
      }
      public long getStartTime() {
        return result.getStartTime();
      }
      public Builder setStartTime(long value) {
        result.hasStartTime = true;
        result.startTime_ = value;
        return this;
      }
      public Builder clearStartTime() {
        result.hasStartTime = false;
        result.startTime_ = 0L;
        return this;
      }
      
      // required int32 duration = 3;
      public boolean hasDuration() {
        return result.hasDuration();
      }
      public int getDuration() {
        return result.getDuration();
      }
      public Builder setDuration(int value) {
        result.hasDuration = true;
        result.duration_ = value;
        return this;
      }
      public Builder clearDuration() {
        result.hasDuration = false;
        result.duration_ = 0;
        return this;
      }
      
      // required .android.gltrace.GLMessage.Function function = 4 [default = invalid];
      public boolean hasFunction() {
        return result.hasFunction();
      }
      public com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.Function getFunction() {
        return result.getFunction();
      }
      public Builder setFunction(com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.Function value) {
        if (value == null) {
          throw new NullPointerException();
        }
        result.hasFunction = true;
        result.function_ = value;
        return this;
      }
      public Builder clearFunction() {
        result.hasFunction = false;
        result.function_ = com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.Function.invalid;
        return this;
      }
      
      // repeated .android.gltrace.GLMessage.DataType args = 5;
      public java.util.List<com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType> getArgsList() {
        return java.util.Collections.unmodifiableList(result.args_);
      }
      public int getArgsCount() {
        return result.getArgsCount();
      }
      public com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType getArgs(int index) {
        return result.getArgs(index);
      }
      public Builder setArgs(int index, com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType value) {
        if (value == null) {
          throw new NullPointerException();
        }
        result.args_.set(index, value);
        return this;
      }
      public Builder setArgs(int index, com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType.Builder builderForValue) {
        result.args_.set(index, builderForValue.build());
        return this;
      }
      public Builder addArgs(com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType value) {
        if (value == null) {
          throw new NullPointerException();
        }
        if (result.args_.isEmpty()) {
          result.args_ = new java.util.ArrayList<com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType>();
        }
        result.args_.add(value);
        return this;
      }
      public Builder addArgs(com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType.Builder builderForValue) {
        if (result.args_.isEmpty()) {
          result.args_ = new java.util.ArrayList<com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType>();
        }
        result.args_.add(builderForValue.build());
        return this;
      }
      public Builder addAllArgs(
          java.lang.Iterable<? extends com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType> values) {
        if (result.args_.isEmpty()) {
          result.args_ = new java.util.ArrayList<com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType>();
        }
        super.addAll(values, result.args_);
        return this;
      }
      public Builder clearArgs() {
        result.args_ = java.util.Collections.emptyList();
        return this;
      }
      
      // optional .android.gltrace.GLMessage.DataType returnValue = 6;
      public boolean hasReturnValue() {
        return result.hasReturnValue();
      }
      public com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType getReturnValue() {
        return result.getReturnValue();
      }
      public Builder setReturnValue(com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType value) {
        if (value == null) {
          throw new NullPointerException();
        }
        result.hasReturnValue = true;
        result.returnValue_ = value;
        return this;
      }
      public Builder setReturnValue(com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType.Builder builderForValue) {
        result.hasReturnValue = true;
        result.returnValue_ = builderForValue.build();
        return this;
      }
      public Builder mergeReturnValue(com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType value) {
        if (result.hasReturnValue() &&
            result.returnValue_ != com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType.getDefaultInstance()) {
          result.returnValue_ =
            com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType.newBuilder(result.returnValue_).mergeFrom(value).buildPartial();
        } else {
          result.returnValue_ = value;
        }
        result.hasReturnValue = true;
        return this;
      }
      public Builder clearReturnValue() {
        result.hasReturnValue = false;
        result.returnValue_ = com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.DataType.getDefaultInstance();
        return this;
      }
      
      // optional .android.gltrace.GLMessage.FrameBuffer fb = 7;
      public boolean hasFb() {
        return result.hasFb();
      }
      public com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.FrameBuffer getFb() {
        return result.getFb();
      }
      public Builder setFb(com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.FrameBuffer value) {
        if (value == null) {
          throw new NullPointerException();
        }
        result.hasFb = true;
        result.fb_ = value;
        return this;
      }
      public Builder setFb(com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.FrameBuffer.Builder builderForValue) {
        result.hasFb = true;
        result.fb_ = builderForValue.build();
        return this;
      }
      public Builder mergeFb(com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.FrameBuffer value) {
        if (result.hasFb() &&
            result.fb_ != com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.FrameBuffer.getDefaultInstance()) {
          result.fb_ =
            com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.FrameBuffer.newBuilder(result.fb_).mergeFrom(value).buildPartial();
        } else {
          result.fb_ = value;
        }
        result.hasFb = true;
        return this;
      }
      public Builder clearFb() {
        result.hasFb = false;
        result.fb_ = com.android.ide.eclipse.gltrace.GLProtoBuf.GLMessage.FrameBuffer.getDefaultInstance();
        return this;
      }
      
      // optional int32 threadtime = 8;
      public boolean hasThreadtime() {
        return result.hasThreadtime();
      }
      public int getThreadtime() {
        return result.getThreadtime();
      }
      public Builder setThreadtime(int value) {
        result.hasThreadtime = true;
        result.threadtime_ = value;
        return this;
      }
      public Builder clearThreadtime() {
        result.hasThreadtime = false;
        result.threadtime_ = 0;
        return this;
      }
      
      // @@protoc_insertion_point(builder_scope:android.gltrace.GLMessage)
    }
    
    static {
      defaultInstance = new GLMessage(true);
      com.android.ide.eclipse.gltrace.GLProtoBuf.internalForceInit();
      defaultInstance.initFields();
    }
    
    // @@protoc_insertion_point(class_scope:android.gltrace.GLMessage)
  }
  
  
  static {
  }
  
  public static void internalForceInit() {}
  
  // @@protoc_insertion_point(outer_class_scope)
}
